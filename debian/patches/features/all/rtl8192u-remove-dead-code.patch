From: Mauro Carvalho Chehab <mchehab@infradead.org>
Date: Tue, 3 Nov 2009 07:45:50 -0200
Subject: [PATCH 04/30] Staging: rtl8192u: remove dead code

commit 50a09b3b099ebc8326b85b4f508fb47655e1fed3 upstream.

Remove #ifse against older kernel versions;
Remove codes marked with #if 0;
Remove #if 1

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8192u/ieee80211.h               |  157 ---
 drivers/staging/rtl8192u/ieee80211/EndianFree.h    |    5 -
 drivers/staging/rtl8192u/ieee80211/crypto_compat.h |   30 -
 drivers/staging/rtl8192u/ieee80211/dot11d.c        |   16 -
 drivers/staging/rtl8192u/ieee80211/ieee80211.h     |  157 ---
 .../staging/rtl8192u/ieee80211/ieee80211_crypt.h   |    7 -
 .../staging/rtl8192u/ieee80211/ieee80211_module.c  |    2 -
 drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c  |  110 --
 .../staging/rtl8192u/ieee80211/ieee80211_softmac.c |  242 -----
 .../rtl8192u/ieee80211/ieee80211_softmac_wx.c      |   78 --
 drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c  |   17 -
 drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c  |  154 ---
 drivers/staging/rtl8192u/ieee80211/internal.h      |   16 -
 .../staging/rtl8192u/ieee80211/rtl819x_BAProc.c    |   42 -
 .../staging/rtl8192u/ieee80211/rtl819x_HTProc.c    |  259 +-----
 drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h   |  166 ---
 .../staging/rtl8192u/ieee80211/rtl819x_TSProc.c    |   26 -
 drivers/staging/rtl8192u/r8192U.h                  |  104 --
 drivers/staging/rtl8192u/r8192U_core.c             | 1083 --------------------
 drivers/staging/rtl8192u/r8192U_dm.c               |  288 ------
 drivers/staging/rtl8192u/r8192U_dm.h               |   55 -
 drivers/staging/rtl8192u/r8192U_hw.h               |  335 ------
 drivers/staging/rtl8192u/r8192U_wx.c               |   82 --
 drivers/staging/rtl8192u/r819xU_cmdpkt.c           |   31 -
 drivers/staging/rtl8192u/r819xU_cmdpkt.h           |   10 -
 drivers/staging/rtl8192u/r819xU_firmware.c         |  266 -----
 drivers/staging/rtl8192u/r819xU_firmware.h         |   41 -
 drivers/staging/rtl8192u/r819xU_phy.c              |   49 -
 drivers/staging/rtl8192u/r819xU_phy.h              |    4 -
 29 files changed, 1 insertions(+), 3831 deletions(-)

diff --git a/drivers/staging/rtl8192u/ieee80211.h b/drivers/staging/rtl8192u/ieee80211.h
index f579585..3a47f12 100644
--- a/drivers/staging/rtl8192u/ieee80211.h
+++ b/drivers/staging/rtl8192u/ieee80211.h
@@ -27,12 +27,7 @@
 #include <linux/kernel.h>   /* ARRAY_SIZE */
 #include <linux/version.h>
 #include <linux/module.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 #include <linux/jiffies.h>
-#else
-#include <linux/jffs.h>
-#include <linux/tqueue.h>
-#endif
 #include <linux/timer.h>
 #include <linux/sched.h>
 
@@ -43,11 +38,6 @@
 #include "ieee80211/rtl819x_BA.h"
 #include "ieee80211/rtl819x_TS.h"
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
-#ifndef bool
-typedef enum{false = 0, true} bool;
-#endif
-#endif
 
 #ifndef IW_MODE_MONITOR
 #define IW_MODE_MONITOR 6
@@ -57,24 +47,6 @@ typedef enum{false = 0, true} bool;
 #define IWEVCUSTOM 0x8c02
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-#ifndef __bitwise
-#define __bitwise __attribute__((bitwise))
-#endif
-typedef __u16  __le16;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27))
-struct iw_spy_data{
-	/* --- Standard spy support --- */
-	int 			spy_number;
-	u_char 			spy_address[IW_MAX_SPY][ETH_ALEN];
-	struct iw_quality	spy_stat[IW_MAX_SPY];
-	/* --- Enhanced spy support (event) */
-	struct iw_quality	spy_thr_low; /* Low threshold */
-	struct iw_quality	spy_thr_high; /* High threshold */
-	u_char			spy_thr_under[IW_MAX_SPY];
-};
-#endif
-#endif
 
 #ifndef container_of
 /**
@@ -425,46 +397,10 @@ typedef struct ieee_param {
 #define IW_QUAL_NOISE_UPDATED  0x4
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-static inline void tq_init(struct tq_struct * task, void(*func)(void *), void *data)
-{
-	task->routine = func;
-	task->data 	= data;
-	//task->next = NULL;
-	INIT_LIST_HEAD(&task->list);
-	task->sync = 0;
-}
-#endif
 
 // linux under 2.6.9 release may not support it, so modify it for common use
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9))
-//#define MSECS(t)	(1000 * ((t) / HZ) + 1000 * ((t) % HZ) / HZ)
-#define MSECS(t)	(HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
-static inline unsigned long msleep_interruptible_rsl(unsigned int msecs)
-{
-	 unsigned long timeout = MSECS(msecs) + 1;
-
-	 while (timeout) {
-		 set_current_state(TASK_INTERRUPTIBLE);
-		 timeout = schedule_timeout(timeout);
-	 }
-	 return timeout;
-}
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,31))
-static inline void msleep(unsigned int msecs)
-{
-	 unsigned long timeout = MSECS(msecs) + 1;
-
-	 while (timeout) {
-		 set_current_state(TASK_UNINTERRUPTIBLE);
-		 timeout = schedule_timeout(timeout);
-	 }
-}
-#endif
-#else
 #define MSECS(t) msecs_to_jiffies(t)
 #define msleep_interruptible_rsl  msleep_interruptible
-#endif
 
 #define IEEE80211_DATA_LEN		2304
 /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
@@ -926,7 +862,6 @@ struct ieee_ibss_seq {
  *       information for frames received.  Not setting these will not cause
  *       any adverse affects. */
 struct ieee80211_rx_stats {
-#if 1
 	u32 mac_time[2];
 	s8 rssi;
 	u8 signal;
@@ -988,7 +923,6 @@ struct ieee80211_rx_stats {
 	bool		  bToSelfBA;		//cosa add for rssi
 	char 	  cck_adc_pwdb[4];	//cosa add for rx path selection
 	u16		  Seq_Num;
-#endif
 
 };
 
@@ -1336,7 +1270,6 @@ typedef union _frameqos {
 #define QOS_OUI_PARAM_SUB_TYPE          1
 #define QOS_VERSION_1                   1
 #define QOS_AIFSN_MIN_VALUE             2
-#if 1
 struct ieee80211_qos_information_element {
 	u8 elementID;
 	u8 length;
@@ -1411,7 +1344,6 @@ struct ieee80211_wmm_tspec_elem {
 	u16 surp_band_allow;
 	u16 medium_time;
 }__attribute__((packed));
-#endif
 enum eap_type {
 	EAP_PACKET = 0,
 	EAPOL_START,
@@ -1534,14 +1466,12 @@ enum {WMM_all_frame, WMM_two_frame, WMM_four_frame, WMM_six_frame};
 
 //UP Mapping to AC, using in MgntQuery_SequenceNumber() and maybe for DSCP
 //#define UP2AC(up)	((up<3) ? ((up==0)?1:0) : (up>>1))
-#if 1
 #define UP2AC(up) (		   \
 	((up) < 1) ? WME_AC_BE : \
 	((up) < 3) ? WME_AC_BK : \
 	((up) < 4) ? WME_AC_BE : \
 	((up) < 6) ? WME_AC_VI : \
 	WME_AC_VO)
-#endif
 //AC Mapping to UP, using in Tx part for selecting the corresponding TX queue
 #define AC2UP(_ac)	(       \
 	((_ac) == WME_AC_VO) ? 6 : \
@@ -1597,12 +1527,7 @@ struct ieee80211_network {
 	/* Ensure null-terminated for any debug msgs */
 	u8 ssid[IW_ESSID_MAX_SIZE + 1];
 	u8 ssid_len;
-#if 1
 	struct ieee80211_qos_data qos_data;
-#else
-       // Qos related. Added by Annie, 2005-11-01.
-	BSS_QOS   BssQos;
-#endif
 	//added by amy for LEAP
 	bool	bWithAironetIE;
 	bool	bCkipSupported;
@@ -1667,7 +1592,6 @@ struct ieee80211_network {
 	struct list_head list;
 };
 
-#if 1
 enum ieee80211_state {
 
 	/* the card is not linked at all */
@@ -1706,17 +1630,6 @@ enum ieee80211_state {
 	IEEE80211_LINKED_SCANNING,
 
 };
-#else
-enum ieee80211_state {
-	IEEE80211_UNINITIALIZED = 0,
-	IEEE80211_INITIALIZED,
-	IEEE80211_ASSOCIATING,
-	IEEE80211_ASSOCIATED,
-	IEEE80211_AUTHENTICATING,
-	IEEE80211_AUTHENTICATED,
-	IEEE80211_SHUTDOWN
-};
-#endif
 
 #define DEFAULT_MAX_SCAN_AGE (15 * HZ)
 #define DEFAULT_FTS 2346
@@ -1735,20 +1648,7 @@ enum ieee80211_state {
 #define IEEE80211_52GHZ_CHANNELS (IEEE80211_52GHZ_MAX_CHANNEL - \
 				  IEEE80211_52GHZ_MIN_CHANNEL + 1)
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11))
-extern inline int is_multicast_ether_addr(const u8 *addr)
-{
-	return ((addr[0] != 0xff) && (0x01 & addr[0]));
-}
-#endif
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13))
-extern inline int is_broadcast_ether_addr(const u8 *addr)
-{
-	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
-		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
-}
-#endif
 
 typedef struct tx_pending_t{
 	int frag;
@@ -1826,11 +1726,7 @@ typedef struct _RT_POWER_SAVE_CONTROL
 	bool				bIPSModeBackup;
 	bool				bSwRfProcessing;
 	RT_RF_POWER_STATE	eInactivePowerState;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct 	InactivePsWorkItem;
-#else
-	struct tq_struct	InactivePsWorkItem;
-#endif
 	struct timer_list	InactivePsTimer;
 
 	// Return point for join action
@@ -2195,32 +2091,13 @@ struct ieee80211_device {
 
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct associate_complete_wq;
 	struct work_struct associate_procedure_wq;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	struct delayed_work softmac_scan_wq;
 	struct delayed_work associate_retry_wq;
 	 struct delayed_work start_ibss_wq;
-#else
-	struct work_struct softmac_scan_wq;
-	struct work_struct associate_retry_wq;
-	struct work_struct start_ibss_wq;
-#endif
 	struct work_struct wx_sync_scan_wq;
 	struct workqueue_struct *wq;
-#else
-	/* used for periodly scan */
-	struct timer_list scan_timer;
-
-	struct tq_struct associate_complete_wq;
-	struct tq_struct associate_retry_wq;
-	struct tq_struct start_ibss_wq;
-	struct tq_struct associate_procedure_wq;
-	struct tq_struct softmac_scan_wq;
-	struct tq_struct wx_sync_scan_wq;
-
-#endif
 	// Qos related. Added by Annie, 2005-11-01.
 	//STA_QOS  StaQos;
 
@@ -2320,35 +2197,9 @@ struct ieee80211_device {
 	void (*ps_request_tx_ack) (struct net_device *dev);
 	void (*enter_sleep_state) (struct net_device *dev, u32 th, u32 tl);
 	short (*ps_is_queue_empty) (struct net_device *dev);
-#if 0
-	/* Typical STA methods */
-	int (*handle_auth) (struct net_device * dev,
-			    struct ieee80211_auth * auth);
-	int (*handle_deauth) (struct net_device * dev,
-			      struct ieee80211_deauth * auth);
-	int (*handle_action) (struct net_device * dev,
-			      struct ieee80211_action * action,
-			      struct ieee80211_rx_stats * stats);
-	int (*handle_disassoc) (struct net_device * dev,
-				struct ieee80211_disassoc * assoc);
-#endif
 	int (*handle_beacon) (struct net_device * dev, struct ieee80211_beacon * beacon, struct ieee80211_network * network);
-#if 0
-	int (*handle_probe_response) (struct net_device * dev,
-				      struct ieee80211_probe_response * resp,
-				      struct ieee80211_network * network);
-	int (*handle_probe_request) (struct net_device * dev,
-				     struct ieee80211_probe_request * req,
-				     struct ieee80211_rx_stats * stats);
-#endif
 	int (*handle_assoc_response) (struct net_device * dev, struct ieee80211_assoc_response_frame * resp, struct ieee80211_network * network);
 
-#if 0
-	/* Typical AP methods */
-	int (*handle_assoc_request) (struct net_device * dev);
-	int (*handle_reassoc_request) (struct net_device * dev,
-				       struct ieee80211_reassoc_request * req);
-#endif
 
 	/* check whether Tx hw resouce available */
 	short (*check_nic_enough_desc)(struct net_device *dev, int queue_index);
@@ -2406,11 +2257,7 @@ struct ieee80211_device {
 
 static inline void *ieee80211_priv(struct net_device *dev)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
-#else
-	return ((struct ieee80211_device *)dev->priv)->priv;
-#endif
 }
 
 extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
@@ -2663,11 +2510,7 @@ extern int ieee80211_wx_get_freq(struct ieee80211_device *ieee, struct iw_reques
 			     union iwreq_data *wrqu, char *b);
 
 //extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern void ieee80211_wx_sync_scan_wq(struct work_struct *work);
-#else
- extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
-#endif
 
 
 extern int ieee80211_wx_set_rawtx(struct ieee80211_device *ieee,
diff --git a/drivers/staging/rtl8192u/ieee80211/EndianFree.h b/drivers/staging/rtl8192u/ieee80211/EndianFree.h
index 0c417a6..dc85fb9 100644
--- a/drivers/staging/rtl8192u/ieee80211/EndianFree.h
+++ b/drivers/staging/rtl8192u/ieee80211/EndianFree.h
@@ -7,11 +7,6 @@
  *		2. Before write integer to IO.
  *		3. After read integer from IO.
  */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
-#ifndef bool
-typedef enum{false = 0, true} bool;
-#endif
-#endif
 
 #define __MACHINE_LITTLE_ENDIAN 1234    /* LSB first: i386, vax */
 #define __MACHINE_BIG_ENDIAN    4321    /* MSB first: 68000, ibm, net, ppc */
diff --git a/drivers/staging/rtl8192u/ieee80211/crypto_compat.h b/drivers/staging/rtl8192u/ieee80211/crypto_compat.h
index c7f26ff..da48658 100644
--- a/drivers/staging/rtl8192u/ieee80211/crypto_compat.h
+++ b/drivers/staging/rtl8192u/ieee80211/crypto_compat.h
@@ -30,35 +30,6 @@ static inline int crypto_cipher_decrypt(struct crypto_tfm *tfm,
 	return tfm->crt_cipher.cit_decrypt(tfm, dst, src, nbytes);
 }
 
-#if 0
-/*
- *	crypto_free_tfm - Free crypto transform
- *	@tfm: Transform to free
- *
- *	crypto_free_tfm() frees up the transform and any associated resources,
- *	then drops the refcount on the associated algorithm.
- */
-void crypto_free_tfm(struct crypto_tfm *tfm)
-{
-	struct crypto_alg *alg;
-	int size;
-
-	if (unlikely(!tfm))
-		return;
-
-	alg = tfm->__crt_alg;
-	size = sizeof(*tfm) + alg->cra_ctxsize;
-
-	if (alg->cra_exit)
-		alg->cra_exit(tfm);
-	crypto_exit_ops(tfm);
-	crypto_mod_put(alg);
-	memset(tfm, 0, size);
-	kfree(tfm);
-}
-
-#endif
-#if 1
  struct crypto_tfm *crypto_alloc_tfm(const char *name, u32 flags)
 {
 	struct crypto_tfm *tfm = NULL;
@@ -83,7 +54,6 @@ void crypto_free_tfm(struct crypto_tfm *tfm)
 
 	return tfm;
 }
-#endif
 //EXPORT_SYMBOL_GPL(crypto_alloc_tfm);
 //EXPORT_SYMBOL_GPL(crypto_free_tfm);
 
diff --git a/drivers/staging/rtl8192u/ieee80211/dot11d.c b/drivers/staging/rtl8192u/ieee80211/dot11d.c
index e5f2ded..b91cbfc 100644
--- a/drivers/staging/rtl8192u/ieee80211/dot11d.c
+++ b/drivers/staging/rtl8192u/ieee80211/dot11d.c
@@ -35,10 +35,6 @@ Dot11d_Reset(struct ieee80211_device *ieee)
 {
 	u32 i;
 	PRT_DOT11D_INFO pDot11dInfo = GET_DOT11D_INFO(ieee);
-#if 0
-	if(!pDot11dInfo->bEnabled)
-		return;
-#endif
 	// Clear old channel map
 	memset(pDot11dInfo->channel_map, 0, MAX_CHANNEL_NUMBER+1);
 	memset(pDot11dInfo->MaxTxPwrDbmList, 0xFF, MAX_CHANNEL_NUMBER+1);
@@ -108,14 +104,12 @@ Dot11d_UpdateCountryIe(
 
 		pTriple = (PCHNL_TXPOWER_TRIPLE)((u8*)pTriple + 3);
 	}
-#if 1
 	//printk("Dot11d_UpdateCountryIe(): Channel List:\n");
 	printk("Channel List:");
 	for(i=1; i<= MAX_CHANNEL_NUMBER; i++)
 		if(pDot11dInfo->channel_map[i] > 0)
 			printk(" %d", i);
 	printk("\n");
-#endif
 
 	UPDATE_CIE_SRC(dev, pTaddr);
 
@@ -218,7 +212,6 @@ int ToLegalChannel(
 
 	return default_chn;
 }
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(Dot11d_Init);
 EXPORT_SYMBOL(Dot11d_Reset);
 EXPORT_SYMBOL(Dot11d_UpdateCountryIe);
@@ -226,14 +219,5 @@ EXPORT_SYMBOL(DOT11D_GetMaxTxPwrInDbm);
 EXPORT_SYMBOL(DOT11D_ScanComplete);
 EXPORT_SYMBOL(IsLegalChannel);
 EXPORT_SYMBOL(ToLegalChannel);
-#else
-EXPORT_SYMBOL_NOVERS(Dot11d_Init);
-EXPORT_SYMBOL_NOVERS(Dot11d_Reset);
-EXPORT_SYMBOL_NOVERS(Dot11d_UpdateCountryIe);
-EXPORT_SYMBOL_NOVERS(DOT11D_GetMaxTxPwrInDbm);
-EXPORT_SYMBOL_NOVERS(DOT11D_ScanComplete);
-EXPORT_SYMBOL_NOVERS(IsLegalChannel);
-EXPORT_SYMBOL_NOVERS(ToLegalChannel);
-#endif
 
 #endif
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211.h b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
index 0dd7737..10908e1 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
@@ -27,12 +27,7 @@
 #include <linux/kernel.h>   /* ARRAY_SIZE */
 #include <linux/version.h>
 #include <linux/module.h>
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 #include <linux/jiffies.h>
-#else
-#include <linux/jffs.h>
-#include <linux/tqueue.h>
-#endif
 #include <linux/timer.h>
 #include <linux/sched.h>
 
@@ -43,11 +38,6 @@
 #include "rtl819x_BA.h"
 #include "rtl819x_TS.h"
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
-#ifndef bool
-typedef enum{false = 0, true} bool;
-#endif
-#endif
 
 #ifndef IW_MODE_MONITOR
 #define IW_MODE_MONITOR 6
@@ -57,24 +47,6 @@ typedef enum{false = 0, true} bool;
 #define IWEVCUSTOM 0x8c02
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-#ifndef __bitwise
-#define __bitwise __attribute__((bitwise))
-#endif
-typedef __u16  __le16;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27))
-struct iw_spy_data{
-	/* --- Standard spy support --- */
-	int 			spy_number;
-	u_char 			spy_address[IW_MAX_SPY][ETH_ALEN];
-	struct iw_quality	spy_stat[IW_MAX_SPY];
-	/* --- Enhanced spy support (event) */
-	struct iw_quality	spy_thr_low; /* Low threshold */
-	struct iw_quality	spy_thr_high; /* High threshold */
-	u_char			spy_thr_under[IW_MAX_SPY];
-};
-#endif
-#endif
 
 #ifndef container_of
 /**
@@ -425,46 +397,10 @@ typedef struct ieee_param {
 #define IW_QUAL_NOISE_UPDATED  0x4
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-static inline void tq_init(struct tq_struct * task, void(*func)(void *), void *data)
-{
-	task->routine = func;
-	task->data 	= data;
-	//task->next = NULL;
-	INIT_LIST_HEAD(&task->list);
-	task->sync = 0;
-}
-#endif
 
 // linux under 2.6.9 release may not support it, so modify it for common use
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9))
-//#define MSECS(t)	(1000 * ((t) / HZ) + 1000 * ((t) % HZ) / HZ)
-#define MSECS(t)	(HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
-static inline unsigned long msleep_interruptible_rsl(unsigned int msecs)
-{
-	 unsigned long timeout = MSECS(msecs) + 1;
-
-	 while (timeout) {
-		 set_current_state(TASK_INTERRUPTIBLE);
-		 timeout = schedule_timeout(timeout);
-	 }
-	 return timeout;
-}
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,31))
-static inline void msleep(unsigned int msecs)
-{
-	 unsigned long timeout = MSECS(msecs) + 1;
-
-	 while (timeout) {
-		 set_current_state(TASK_UNINTERRUPTIBLE);
-		 timeout = schedule_timeout(timeout);
-	 }
-}
-#endif
-#else
 #define MSECS(t) msecs_to_jiffies(t)
 #define msleep_interruptible_rsl  msleep_interruptible
-#endif
 
 #define IEEE80211_DATA_LEN		2304
 /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
@@ -926,7 +862,6 @@ struct ieee_ibss_seq {
  *       information for frames received.  Not setting these will not cause
  *       any adverse affects. */
 struct ieee80211_rx_stats {
-#if 1
 	u32 mac_time[2];
 	s8 rssi;
 	u8 signal;
@@ -988,7 +923,6 @@ struct ieee80211_rx_stats {
 	bool		  bToSelfBA;		//cosa add for rssi
 	char 	  cck_adc_pwdb[4];	//cosa add for rx path selection
 	u16		  Seq_Num;
-#endif
 
 };
 
@@ -1336,7 +1270,6 @@ typedef union _frameqos {
 #define QOS_OUI_PARAM_SUB_TYPE          1
 #define QOS_VERSION_1                   1
 #define QOS_AIFSN_MIN_VALUE             2
-#if 1
 struct ieee80211_qos_information_element {
 	u8 elementID;
 	u8 length;
@@ -1411,7 +1344,6 @@ struct ieee80211_wmm_tspec_elem {
 	u16 surp_band_allow;
 	u16 medium_time;
 }__attribute__((packed));
-#endif
 enum eap_type {
 	EAP_PACKET = 0,
 	EAPOL_START,
@@ -1534,14 +1466,12 @@ enum {WMM_all_frame, WMM_two_frame, WMM_four_frame, WMM_six_frame};
 
 //UP Mapping to AC, using in MgntQuery_SequenceNumber() and maybe for DSCP
 //#define UP2AC(up)	((up<3) ? ((up==0)?1:0) : (up>>1))
-#if 1
 #define UP2AC(up) (		   \
 	((up) < 1) ? WME_AC_BE : \
 	((up) < 3) ? WME_AC_BK : \
 	((up) < 4) ? WME_AC_BE : \
 	((up) < 6) ? WME_AC_VI : \
 	WME_AC_VO)
-#endif
 //AC Mapping to UP, using in Tx part for selecting the corresponding TX queue
 #define AC2UP(_ac)	(       \
 	((_ac) == WME_AC_VO) ? 6 : \
@@ -1597,12 +1527,7 @@ struct ieee80211_network {
 	/* Ensure null-terminated for any debug msgs */
 	u8 ssid[IW_ESSID_MAX_SIZE + 1];
 	u8 ssid_len;
-#if 1
 	struct ieee80211_qos_data qos_data;
-#else
-       // Qos related. Added by Annie, 2005-11-01.
-	BSS_QOS   BssQos;
-#endif
 
 	//added by amy for LEAP
 	bool	bWithAironetIE;
@@ -1668,7 +1593,6 @@ struct ieee80211_network {
 	struct list_head list;
 };
 
-#if 1
 enum ieee80211_state {
 
 	/* the card is not linked at all */
@@ -1707,17 +1631,6 @@ enum ieee80211_state {
 	IEEE80211_LINKED_SCANNING,
 
 };
-#else
-enum ieee80211_state {
-	IEEE80211_UNINITIALIZED = 0,
-	IEEE80211_INITIALIZED,
-	IEEE80211_ASSOCIATING,
-	IEEE80211_ASSOCIATED,
-	IEEE80211_AUTHENTICATING,
-	IEEE80211_AUTHENTICATED,
-	IEEE80211_SHUTDOWN
-};
-#endif
 
 #define DEFAULT_MAX_SCAN_AGE (15 * HZ)
 #define DEFAULT_FTS 2346
@@ -1736,20 +1649,7 @@ enum ieee80211_state {
 #define IEEE80211_52GHZ_CHANNELS (IEEE80211_52GHZ_MAX_CHANNEL - \
 				  IEEE80211_52GHZ_MIN_CHANNEL + 1)
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11))
-extern inline int is_multicast_ether_addr(const u8 *addr)
-{
-	return ((addr[0] != 0xff) && (0x01 & addr[0]));
-}
-#endif
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13))
-extern inline int is_broadcast_ether_addr(const u8 *addr)
-{
-	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
-		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
-}
-#endif
 
 typedef struct tx_pending_t{
 	int frag;
@@ -1827,11 +1727,7 @@ typedef struct _RT_POWER_SAVE_CONTROL
 	bool				bIPSModeBackup;
 	bool				bSwRfProcessing;
 	RT_RF_POWER_STATE	eInactivePowerState;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct 	InactivePsWorkItem;
-#else
-	struct tq_struct	InactivePsWorkItem;
-#endif
 	struct timer_list	InactivePsTimer;
 
 	// Return point for join action
@@ -2196,32 +2092,13 @@ struct ieee80211_device {
 
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct associate_complete_wq;
 	struct work_struct associate_procedure_wq;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	struct delayed_work softmac_scan_wq;
 	struct delayed_work associate_retry_wq;
 	 struct delayed_work start_ibss_wq;
-#else
-	struct work_struct softmac_scan_wq;
-	struct work_struct associate_retry_wq;
-	struct work_struct start_ibss_wq;
-#endif
 	struct work_struct wx_sync_scan_wq;
 	struct workqueue_struct *wq;
-#else
-	/* used for periodly scan */
-	struct timer_list scan_timer;
-
-	struct tq_struct associate_complete_wq;
-	struct tq_struct associate_retry_wq;
-	struct tq_struct start_ibss_wq;
-	struct tq_struct associate_procedure_wq;
-	struct tq_struct softmac_scan_wq;
-	struct tq_struct wx_sync_scan_wq;
-
-#endif
         // Qos related. Added by Annie, 2005-11-01.
         //STA_QOS  StaQos;
 
@@ -2321,35 +2198,9 @@ struct ieee80211_device {
 	void (*ps_request_tx_ack) (struct net_device *dev);
 	void (*enter_sleep_state) (struct net_device *dev, u32 th, u32 tl);
 	short (*ps_is_queue_empty) (struct net_device *dev);
-#if 0
-	/* Typical STA methods */
-	int (*handle_auth) (struct net_device * dev,
-			    struct ieee80211_auth * auth);
-	int (*handle_deauth) (struct net_device * dev,
-			      struct ieee80211_deauth * auth);
-	int (*handle_action) (struct net_device * dev,
-			      struct ieee80211_action * action,
-			      struct ieee80211_rx_stats * stats);
-	int (*handle_disassoc) (struct net_device * dev,
-				struct ieee80211_disassoc * assoc);
-#endif
 	int (*handle_beacon) (struct net_device * dev, struct ieee80211_beacon * beacon, struct ieee80211_network * network);
-#if 0
-	int (*handle_probe_response) (struct net_device * dev,
-				      struct ieee80211_probe_response * resp,
-				      struct ieee80211_network * network);
-	int (*handle_probe_request) (struct net_device * dev,
-				     struct ieee80211_probe_request * req,
-				     struct ieee80211_rx_stats * stats);
-#endif
 	int (*handle_assoc_response) (struct net_device * dev, struct ieee80211_assoc_response_frame * resp, struct ieee80211_network * network);
 
-#if 0
-	/* Typical AP methods */
-	int (*handle_assoc_request) (struct net_device * dev);
-	int (*handle_reassoc_request) (struct net_device * dev,
-				       struct ieee80211_reassoc_request * req);
-#endif
 
 	/* check whether Tx hw resouce available */
 	short (*check_nic_enough_desc)(struct net_device *dev, int queue_index);
@@ -2407,11 +2258,7 @@ struct ieee80211_device {
 
 static inline void *ieee80211_priv(struct net_device *dev)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
-#else
-	return ((struct ieee80211_device *)dev->priv)->priv;
-#endif
 }
 
 extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
@@ -2664,11 +2511,7 @@ extern int ieee80211_wx_get_freq(struct ieee80211_device *ieee, struct iw_reques
 			     union iwreq_data *wrqu, char *b);
 
 //extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern void ieee80211_wx_sync_scan_wq(struct work_struct *work);
-#else
- extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
-#endif
 
 
 extern int ieee80211_wx_set_rawtx(struct ieee80211_device *ieee,
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt.h b/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt.h
index a84df4b..b58a3bc 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt.h
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt.h
@@ -82,12 +82,5 @@ void ieee80211_crypt_deinit_entries(struct ieee80211_device *, int);
 void ieee80211_crypt_deinit_handler(unsigned long);
 void ieee80211_crypt_delayed_deinit(struct ieee80211_device *ieee,
 				    struct ieee80211_crypt_data **crypt);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-#define offset_in_page(p) ((unsigned long)(p) & ~PAGE_MASK)
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,31))
-#define crypto_alloc_tfm crypto_alloc_tfm_rsl
-#define crypto_free_tfm crypto_free_tfm_rsl
-#endif
 
 #endif
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_module.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_module.c
index bbaec94..7a8690f 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_module.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_module.c
@@ -201,13 +201,11 @@ void free_ieee80211(struct net_device *dev)
 	int i;
 	//struct list_head *p, *q;
 //	del_timer_sync(&ieee->SwBwTimer);
-#if 1
 	if (ieee->pHTInfo != NULL)
 	{
 		kfree(ieee->pHTInfo);
 		ieee->pHTInfo = NULL;
 	}
-#endif
 	RemoveAllTS(ieee);
 	ieee80211_softmac_free(ieee);
 	del_timer_sync(&ieee->crypt_deinit_timer);
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
index 5b66e54..0e003c5 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c
@@ -55,11 +55,7 @@ static inline void ieee80211_monitor_rx(struct ieee80211_device *ieee,
 	u16 fc = le16_to_cpu(hdr->frame_ctl);
 
 	skb->dev = ieee->dev;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
         skb_reset_mac_header(skb);
-#else
-        skb->mac.raw = skb->data;
-#endif
 
 	skb_pull(skb, ieee80211_get_hdrlen(fc));
 	skb->pkt_type = PACKET_OTHERHOST;
@@ -351,13 +347,11 @@ ieee80211_rx_frame_decrypt(struct ieee80211_device* ieee, struct sk_buff *skb,
 
 	if (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)
 		return 0;
-#if 1
 	if (ieee->hwsec_active)
 	{
 		cb_desc *tcb_desc = (cb_desc *)(skb->cb+ MAX_DEV_ADDR_SIZE);
 		tcb_desc->bHwSec = 1;
 	}
-#endif
 	hdr = (struct ieee80211_hdr_4addr *) skb->data;
 	hdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
 
@@ -534,7 +528,6 @@ AddReorderEntry(
 	)
 {
 	struct list_head *pList = &pTS->RxPendingPktList;
-#if  1
 	while(pList->next != &pTS->RxPendingPktList)
 	{
 		if( SN_LESS(pReorderEntry->SeqNum, ((PRX_REORDER_ENTRY)list_entry(pList->next,RX_REORDER_ENTRY,List))->SeqNum) )
@@ -550,7 +543,6 @@ AddReorderEntry(
 			break;
 		}
 	}
-#endif
 	pReorderEntry->List.next = pList->next;
 	pReorderEntry->List.next->prev = &pReorderEntry->List;
 	pReorderEntry->List.prev = pList;
@@ -626,10 +618,6 @@ void RxReorderIndicatePacket( struct ieee80211_device *ieee,
 	u8			index = 0;
 	bool			bMatchWinStart = false, bPktInBuf = false;
 	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__FUNCTION__,SeqNum,pTS->RxIndicateSeq,WinSize);
-#if 0
-	if(!list_empty(&ieee->RxReorder_Unused_List))
-		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): ieee->RxReorder_Unused_List is nut NULL\n");
-#endif
 	/* Rx Reorder initialize condition.*/
 	if(pTS->RxIndicateSeq == 0xffff) {
 		pTS->RxIndicateSeq = SeqNum;
@@ -696,7 +684,6 @@ void RxReorderIndicatePacket( struct ieee80211_device *ieee,
 			pReorderEntry->prxb = prxb;
 	//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pREorderEntry->SeqNum is %d\n",__FUNCTION__,pReorderEntry->SeqNum);
 
-#if 1
 			if(!AddReorderEntry(pTS, pReorderEntry)) {
 				IEEE80211_DEBUG(IEEE80211_DL_REORDER, "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
 					__FUNCTION__, pTS->RxIndicateSeq, SeqNum);
@@ -713,7 +700,6 @@ void RxReorderIndicatePacket( struct ieee80211_device *ieee,
 				IEEE80211_DEBUG(IEEE80211_DL_REORDER,
 					 "Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
 			}
-#endif
 		}
 		else {
 			/*
@@ -736,7 +722,6 @@ void RxReorderIndicatePacket( struct ieee80211_device *ieee,
 	/* Check if there is any packet need indicate.*/
 	while(!list_empty(&pTS->RxPendingPktList)) {
 		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): start RREORDER indicate\n",__FUNCTION__);
-#if 1
 		pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
 		if( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
 				SN_EQUAL(pReorderEntry->SeqNum, pTS->RxIndicateSeq))
@@ -763,7 +748,6 @@ void RxReorderIndicatePacket( struct ieee80211_device *ieee,
 			bPktInBuf = true;
 			break;
 		}
-#endif
 	}
 
 	/* Handling pending timer. Set this timer to prevent from long time Rx buffering.*/
@@ -780,7 +764,6 @@ void RxReorderIndicatePacket( struct ieee80211_device *ieee,
 		ieee80211_indicate_packets(ieee, prxbIndicateArray, index);
 	}
 
-#if 1
 	if(bPktInBuf && pTS->RxTimeoutIndicateSeq==0xffff) {
 		// Set new pending timer.
 		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): SET rx timeout timer\n", __FUNCTION__);
@@ -790,7 +773,6 @@ void RxReorderIndicatePacket( struct ieee80211_device *ieee,
 		pTS->RxPktPendingTimer.expires = jiffies + MSECS(pHTInfo->RxReorderPendingTime);
 		add_timer(&pTS->RxPktPendingTimer);
 	}
-#endif
 }
 
 u8 parse_subframe(struct sk_buff *skb,
@@ -857,11 +839,6 @@ u8 parse_subframe(struct sk_buff *skb,
 			nSubframe_Length = (nSubframe_Length>>8) + (nSubframe_Length<<8);
 
 			if(skb->len<(ETHERNET_HEADER_SIZE + nSubframe_Length)) {
-#if 0//cosa
-				RT_ASSERT(
-						(nRemain_Length>=(ETHERNET_HEADER_SIZE + nSubframe_Length)),
-						("ParseSubframe(): A-MSDU subframe parse error!! Subframe Length: %d\n", nSubframe_Length) );
-#endif
 				printk("%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\
 						__FUNCTION__,rxb->nr_subframes);
 				printk("%s: A-MSDU parse error!! Subframe Length: %d\n",__FUNCTION__, nSubframe_Length);
@@ -1058,19 +1035,7 @@ int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 	else
 	{
 		PRX_TS_RECORD pRxTS = NULL;
-	#if 0
-		struct ieee80211_hdr_3addr *hdr;
-		u16 fc;
-		hdr = (struct ieee80211_hdr_3addr *)skb->data;
-		fc = le16_to_cpu(hdr->frame_ctl);
-		u8 tmp = (fc & IEEE80211_FCTL_FROMDS) && (fc & IEEE80211_FCTL_TODS);
-
-		u8 tid = (*((u8*)skb->data + (((fc& IEEE80211_FCTL_FROMDS) && (fc & IEEE80211_FCTL_TODS))?30:24)))&0xf;
-		printk("====================>fc:%x, tid:%d, tmp:%d\n", fc, tid, tmp);
-		//u8 tid =  (u8)((frameqos*)(buf + ((fc & IEEE80211_FCTL_TODS)&&(fc & IEEE80211_FCTL_FROMDS))? 30 : 24))->field.tid;
-	#endif
 			//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): QOS ENABLE AND RECEIVE QOS DATA , we will get Ts, tid:%d\n",__FUNCTION__, tid);
-#if 1
 		if(GetTs(
 				ieee,
 				(PTS_COMMON_INFO*) &pRxTS,
@@ -1099,22 +1064,8 @@ int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 			goto rx_dropped;
 		}
 	}
-#endif
 	if (type == IEEE80211_FTYPE_MGMT) {
 
-	#if 0
-		if ( stype == IEEE80211_STYPE_AUTH &&
-		    fc & IEEE80211_FCTL_WEP && ieee->host_decrypt &&
-		    (keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0)
-		{
-			printk(KERN_DEBUG "%s: failed to decrypt mgmt::auth "
-			       "from " MAC_FMT "\n", dev->name,
-			       MAC_ARG(hdr->addr2));
-			/* TODO: could inform hostapd about this so that it
-			 * could send auth failure report */
-			goto rx_dropped;
-		}
-	#endif
 
 	//IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
 		if (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))
@@ -1336,7 +1287,6 @@ int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 	}
 */
 //added by amy for reorder
-#if 1
 	if(ieee->current_network.qos_data.active && IsQoSDataFrame(skb->data)
 		&& !is_multicast_ether_addr(hdr->addr1) && !is_broadcast_ether_addr(hdr->addr1))
 	{
@@ -1348,7 +1298,6 @@ int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
 			ieee->bis_any_nonbepkts = true;
 		}
 	}
-#endif
 //added by amy for reorder
 	/* skb: hdr + (possible reassembled) full plaintext payload */
 	payload = skb->data + hdrlen;
@@ -1974,16 +1923,6 @@ int ieee80211_parse_info_param(struct ieee80211_device *ieee,
 
 				}
 			}
-#if 0
-			if (tmp_htcap_len !=0)
-				{
-					u16 cap_ext = ((PHT_CAPABILITY_ELE)&info_element->data[0])->ExtHTCapInfo;
-					if ((cap_ext & 0x0c00) == 0x0c00)
-						{
-							network->ralink_cap_exist = true;
-						}
-				}
-#endif
 			if(info_element->len >= 3 &&
 				info_element->data[0] == 0x00 &&
 				info_element->data[1] == 0x0c &&
@@ -2156,44 +2095,6 @@ int ieee80211_parse_info_param(struct ieee80211_device *ieee,
 			break;
 #endif
 /* TODO */
-#if 0
-			/* 802.11h */
-		case MFIE_TYPE_POWER_CONSTRAINT:
-			network->power_constraint = info_element->data[0];
-			network->flags |= NETWORK_HAS_POWER_CONSTRAINT;
-			break;
-
-		case MFIE_TYPE_CSA:
-			network->power_constraint = info_element->data[0];
-			network->flags |= NETWORK_HAS_CSA;
-			break;
-
-		case MFIE_TYPE_QUIET:
-			network->quiet.count = info_element->data[0];
-			network->quiet.period = info_element->data[1];
-			network->quiet.duration = info_element->data[2];
-			network->quiet.offset = info_element->data[3];
-			network->flags |= NETWORK_HAS_QUIET;
-			break;
-
-		case MFIE_TYPE_IBSS_DFS:
-			if (network->ibss_dfs)
-				break;
-			network->ibss_dfs = kmemdup(info_element->data,
-						    info_element->len,
-						    GFP_ATOMIC);
-			if (!network->ibss_dfs)
-				return 1;
-			network->flags |= NETWORK_HAS_IBSS_DFS;
-			break;
-
-		case MFIE_TYPE_TPC_REPORT:
-			network->tpc_report.transmit_power =
-			    info_element->data[0];
-			network->tpc_report.link_margin = info_element->data[1];
-			network->flags |= NETWORK_HAS_TPC_REPORT;
-			break;
-#endif
 		default:
 			IEEE80211_DEBUG_MGMT
 			    ("Unsupported info element: %s (%d)\n",
@@ -2376,11 +2277,9 @@ static inline int ieee80211_network_init(
 	if (ieee80211_is_empty_essid(network->ssid, network->ssid_len))
 		network->flags |= NETWORK_EMPTY_ESSID;
 
-#if 1
 	stats->signal = 30 + (stats->SignalStrength * 70) / 100;
 	//stats->signal = ieee80211_SignalStrengthTranslate(stats->signal);
 	stats->noise = ieee80211_translate_todbm((u8)(100-stats->signal)) -25;
-#endif
 
 	memcpy(&network->stats, stats, sizeof(network->stats));
 
@@ -2488,7 +2387,6 @@ static inline void update_network(struct ieee80211_network *dst,
 	dst->qos_data.old_param_count = old_param;
 
 	/* dst->last_associate is not overwritten */
-#if 1
 	dst->wmm_info = src->wmm_info; //sure to exist in beacon or probe response frame.
 	if(src->wmm_param[0].ac_aci_acm_aifsn|| \
 	   src->wmm_param[1].ac_aci_acm_aifsn|| \
@@ -2497,9 +2395,6 @@ static inline void update_network(struct ieee80211_network *dst,
 	  memcpy(dst->wmm_param, src->wmm_param, WME_AC_PRAM_LEN);
 	}
 	//dst->QoS_Enable = src->QoS_Enable;
-#else
-	dst->QoS_Enable = 1;//for Rtl8187 simulation
-#endif
 #ifdef THOMAS_TURBO
 	dst->Turbo_Enable = src->Turbo_Enable;
 #endif
@@ -2769,10 +2664,5 @@ void ieee80211_rx_mgt(struct ieee80211_device *ieee,
 	}
 }
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_rx_mgt);
 EXPORT_SYMBOL(ieee80211_rx);
-#else
-EXPORT_SYMBOL_NOVERS(ieee80211_rx_mgt);
-EXPORT_SYMBOL_NOVERS(ieee80211_rx);
-#endif
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
index 1629b0f..8a86e93 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac.c
@@ -503,34 +503,11 @@ out:
 }
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-/* called both by wq with ieee->lock held */
-void ieee80211_softmac_scan(struct ieee80211_device *ieee)
-{
-#if 0
-	short watchdog = 0;
-	do{
-		ieee->current_network.channel =
-			(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;
-		if (watchdog++ > MAX_CHANNEL_NUMBER)
-				return; /* no good chans */
-
-	}while(!ieee->channel_map[ieee->current_network.channel]);
-#endif
-
-	schedule_task(&ieee->softmac_scan_wq);
-}
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_softmac_scan_wq(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
 	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);
-#else
-void ieee80211_softmac_scan_wq(struct ieee80211_device *ieee)
-{
-#endif
 	static short watchdog = 0;
 #ifdef ENABLE_DOT11D
 	u8 channel_map[MAX_CHANNEL_NUMBER+1];
@@ -567,13 +544,7 @@ void ieee80211_softmac_scan_wq(struct ieee80211_device *ieee)
 	ieee80211_send_probe_requests(ieee);
 
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);
-#else
-	//ieee->scan_timer.expires = jiffies + MSECS(IEEE80211_SOFTMAC_SCAN_TIME);
-	if (ieee->scanning == 1)
-		mod_timer(&ieee->scan_timer,(jiffies + MSECS(IEEE80211_SOFTMAC_SCAN_TIME)));
-#endif
 
 	up(&ieee->scan_sem);
 	return;
@@ -588,17 +559,6 @@ out:
 	up(&ieee->scan_sem);
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-void ieee80211_softmac_scan_cb(unsigned long _dev)
-{
-	unsigned long flags;
-	struct ieee80211_device *ieee = (struct ieee80211_device *)_dev;
-
-	spin_lock_irqsave(&ieee->lock, flags);
-	ieee80211_softmac_scan(ieee);
-	spin_unlock_irqrestore(&ieee->lock, flags);
-}
-#endif
 
 
 void ieee80211_beacons_start(struct ieee80211_device *ieee)
@@ -656,11 +616,7 @@ void ieee80211_softmac_stop_scan(struct ieee80211_device *ieee)
 	if (ieee->scanning == 1){
 		ieee->scanning = 0;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		cancel_delayed_work(&ieee->softmac_scan_wq);
-#else
-		del_timer_sync(&ieee->scan_timer);
-#endif
 	}
 
 //	spin_unlock_irqrestore(&ieee->lock, flags);
@@ -690,16 +646,7 @@ void ieee80211_start_scan(struct ieee80211_device *ieee)
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
 		if (ieee->scanning == 0){
 			ieee->scanning = 1;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 			queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, 0);
-#else
-
-			queue_work(ieee->wq, &ieee->softmac_scan_wq);
-#endif
-#else
-			ieee80211_softmac_scan(ieee);
-#endif
 		}
 	}else
 		ieee->start_scan(ieee->dev);
@@ -800,22 +747,10 @@ static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *d
 	else
 		atim_len = 0;
 
-#if 1
 	if(ieee80211_is_54g(ieee->current_network))
 		erp_len = 3;
 	else
 		erp_len = 0;
-#else
-      if((ieee->current_network.mode == IEEE_G)
-		||( ieee->current_network.mode == IEEE_N_24G && ieee->pHTInfo->bCurSuppCCK)) {
-		erp_len = 3;
-		erpinfo_content = 0;
-		if(ieee->current_network.buseprotection)
-			erpinfo_content |= ERP_UseProtection;
-	}
-	else
-		erp_len = 0;
-#endif
 
 
 	crypt = ieee->crypt[ieee->tx_keyidx];
@@ -824,7 +759,6 @@ static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *d
 	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
 		((0 == strcmp(crypt->ops->name, "WEP") || wpa_ie_len));
 	//HT ralated element
-#if 1
 	tmp_ht_cap_buf =(u8*) &(ieee->pHTInfo->SelfHTCap);
 	tmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);
 	tmp_ht_info_buf =(u8*) &(ieee->pHTInfo->SelfHTInfo);
@@ -840,7 +774,6 @@ static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *d
 		HTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf, &tmp_generic_ie_len);
 	}
 //	printk("===============>tmp_ht_cap_len is %d,tmp_ht_info_len is %d, tmp_generic_ie_len is %d\n",tmp_ht_cap_len,tmp_ht_info_len,tmp_generic_ie_len);
-#endif
 	beacon_size = sizeof(struct ieee80211_probe_response)+2+
 		ssid_len
 		+3 //channel
@@ -875,10 +808,6 @@ static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *d
 		cpu_to_le16((beacon_buf->capability |= WLAN_CAPABILITY_SHORT_SLOT));
 
 	crypt = ieee->crypt[ieee->tx_keyidx];
-#if 0
-	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
-		(0 == strcmp(crypt->ops->name, "WEP"));
-#endif
 	if (encrypt)
 		beacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
 
@@ -917,14 +846,6 @@ static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *d
 		*(tag++) = 1;
 		*(tag++) = erpinfo_content;
 	}
-#if 0
-	//Include High Throuput capability
-
-	*(tag++) = MFIE_TYPE_HT_CAP;
-	*(tag++) = tmp_ht_cap_len - 2;
-	memcpy(tag, tmp_ht_cap_buf, tmp_ht_cap_len - 2);
-	tag += tmp_ht_cap_len - 2;
-#endif
 	if(rate_ex_len){
 		*(tag++) = MFIE_TYPE_RATES_EX;
 		*(tag++) = rate_ex_len-2;
@@ -932,14 +853,6 @@ static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *d
 		tag+=rate_ex_len-2;
 	}
 
-#if 0
-	//Include High Throuput info
-
-	*(tag++) = MFIE_TYPE_HT_INFO;
-	*(tag++) = tmp_ht_info_len - 2;
-	memcpy(tag, tmp_ht_info_buf, tmp_ht_info_len -2);
-	tag += tmp_ht_info_len - 2;
-#endif
 	if (wpa_ie_len)
 	{
 		if (ieee->iw_mode == IW_MODE_ADHOC)
@@ -950,28 +863,6 @@ static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *d
 		tag += wpa_ie_len;
 	}
 
-#if 0
-	//
-	// Construct Realtek Proprietary Aggregation mode (Set AMPDU Factor to 2, 32k)
-	//
-	if(pHTInfo->bRegRT2RTAggregation)
-	{
-		(*tag++) = 0xdd;
-		(*tag++) = tmp_generic_ie_len - 2;
-		memcpy(tag,tmp_generic_ie_buf,tmp_generic_ie_len -2);
-		tag += tmp_generic_ie_len -2;
-
-	}
-#endif
-#if 0
-	if(ieee->qos_support)
-	{
-		(*tag++) = 0xdd;
-		(*tag++) = wmm_len;
-		memcpy(tag,QosOui,wmm_len);
-		tag += wmm_len;
-	}
-#endif
 	//skb->dev = ieee->dev;
 	return skb;
 }
@@ -1380,12 +1271,8 @@ void ieee80211_associate_abort(struct ieee80211_device *ieee)
 
 	ieee->state = IEEE80211_ASSOCIATING_RETRY;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	queue_delayed_work(ieee->wq, &ieee->associate_retry_wq, \
 			   IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);
-#else
-	schedule_task(&ieee->associate_retry_wq);
-#endif
 
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
@@ -1447,10 +1334,6 @@ void ieee80211_auth_challenge(struct ieee80211_device *ieee, u8 *challenge, int
 
 		softmac_mgmt_xmit(skb, ieee);
 		mod_timer(&ieee->associate_timer, jiffies + (HZ/2));
-#if 0
-		ieee->associate_timer.expires = jiffies + (HZ / 2);
-		add_timer(&ieee->associate_timer);
-#endif
 		//dev_kfree_skb_any(skb);//edit by thomas
 	}
 	kfree(challenge);
@@ -1472,21 +1355,12 @@ void ieee80211_associate_step2(struct ieee80211_device *ieee)
 	else{
 		softmac_mgmt_xmit(skb, ieee);
 		mod_timer(&ieee->associate_timer, jiffies + (HZ/2));
-#if 0
-		ieee->associate_timer.expires = jiffies + (HZ / 2);
-		add_timer(&ieee->associate_timer);
-#endif
 		//dev_kfree_skb_any(skb);//edit by thomas
 	}
 }
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_associate_complete_wq(struct work_struct *work)
 {
 	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_complete_wq);
-#else
-void ieee80211_associate_complete_wq(struct ieee80211_device *ieee)
-{
-#endif
 	printk(KERN_INFO "Associated successfully\n");
 	if(ieee80211_is_54g(ieee->current_network) &&
 		(ieee->modulation & IEEE80211_OFDM_MODULATION)){
@@ -1537,41 +1411,14 @@ void ieee80211_associate_complete(struct ieee80211_device *ieee)
 //	struct net_device* dev = ieee->dev;
 	del_timer_sync(&ieee->associate_timer);
 
-#if 0
-	for(i = 0; i < 6; i++) {
-	  ieee->seq_ctrl[i] = 0;
-	}
-#endif
 	ieee->state = IEEE80211_LINKED;
-#if 0
-	if (ieee->pHTInfo->bCurrentHTSupport)
-	{
-		printk("Successfully associated, ht enabled\n");
-		queue_work(ieee->wq, &ieee->ht_onAssRsp);
-	}
-	else
-	{
-		printk("Successfully associated, ht not enabled\n");
-		memset(ieee->dot11HTOperationalRateSet, 0, 16);
-		HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
-	}
-#endif
 	//ieee->UpdateHalRATRTableHandler(dev, ieee->dot11HTOperationalRateSet);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	queue_work(ieee->wq, &ieee->associate_complete_wq);
-#else
-	schedule_task(&ieee->associate_complete_wq);
-#endif
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_associate_procedure_wq(struct work_struct *work)
 {
 	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_procedure_wq);
-#else
-void ieee80211_associate_procedure_wq(struct ieee80211_device *ieee)
-{
-#endif
 	ieee->sync_scan_hurryup = 1;
 	down(&ieee->wx_sem);
 
@@ -1669,11 +1516,7 @@ inline void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee
 					}
 
 					ieee->state = IEEE80211_ASSOCIATING;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 					queue_work(ieee->wq, &ieee->associate_procedure_wq);
-#else
-					schedule_task(&ieee->associate_procedure_wq);
-#endif
 				}else{
 					if(ieee80211_is_54g(ieee->current_network) &&
 						(ieee->modulation & IEEE80211_OFDM_MODULATION)){
@@ -1890,11 +1733,6 @@ ieee80211_rx_assoc_rq(struct ieee80211_device *ieee, struct sk_buff *skb)
 
 	printk(KERN_INFO"New client associated: "MAC_FMT"\n", MAC_ARG(dest));
 	//FIXME
-	#if 0
-	spin_lock_irqsave(&ieee->lock,flags);
-	add_associate(ieee,dest);
-	spin_unlock_irqrestore(&ieee->lock,flags);
-	#endif
 }
 
 
@@ -2179,11 +2017,7 @@ ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
 						"Association response status code 0x%x\n",
 						errcode);
 					if(ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT) {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 						queue_work(ieee->wq, &ieee->associate_procedure_wq);
-#else
-						schedule_task(&ieee->associate_procedure_wq);
-#endif
 					} else {
 						ieee80211_associate_abort(ieee);
 					}
@@ -2290,11 +2124,7 @@ ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
 				notify_wx_assoc_event(ieee);
 				//HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 				RemovePeerTS(ieee, header->addr2);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 				queue_work(ieee->wq, &ieee->associate_procedure_wq);
-#else
-				schedule_task(&ieee->associate_procedure_wq);
-#endif
 			}
 			break;
 		case IEEE80211_STYPE_MANAGE_ACT:
@@ -2347,7 +2177,6 @@ void ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *
 	if(tcb_desc->bMulticast) {
 		ieee->stats.multicast++;
 	}
-#if 1
 	/* if xmit available, just xmit it immediately, else just insert it to the wait queue */
 	for(i = 0; i < txb->nr_frags; i++) {
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
@@ -2377,7 +2206,6 @@ void ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *
 			//ieee->dev->trans_start = jiffies;
 		}
 	}
-#endif
 	ieee80211_txb_free(txb);
 
 //exit:
@@ -2531,16 +2359,11 @@ void ieee80211_start_monitor_mode(struct ieee80211_device *ieee)
 		netif_carrier_on(ieee->dev);
 	}
 }
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_start_ibss_wq(struct work_struct *work)
 {
 
 	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
 	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);
-#else
-void ieee80211_start_ibss_wq(struct ieee80211_device *ieee)
-{
-#endif
 	/* iwconfig mode ad-hoc will schedule this and return
 	 * on the other hand this will block further iwconfig SET
 	 * operations because of the wx_sem hold.
@@ -2650,11 +2473,7 @@ void ieee80211_start_ibss_wq(struct ieee80211_device *ieee)
 
 inline void ieee80211_start_ibss(struct ieee80211_device *ieee)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	queue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 150);
-#else
-	schedule_task(&ieee->start_ibss_wq);
-#endif
 }
 
 /* this is called only in user context, with wx_sem held */
@@ -2719,15 +2538,10 @@ void ieee80211_disassociate(struct ieee80211_device *ieee)
 	notify_wx_assoc_event(ieee);
 
 }
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void ieee80211_associate_retry_wq(struct work_struct *work)
 {
         struct delayed_work *dwork = container_of(work, struct delayed_work, work);
         struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, associate_retry_wq);
-#else
-void ieee80211_associate_retry_wq(struct ieee80211_device *ieee)
-{
-#endif
 	unsigned long flags;
 
 	down(&ieee->wx_sem);
@@ -2822,10 +2636,8 @@ void ieee80211_stop_protocol(struct ieee80211_device *ieee)
 
 	ieee80211_stop_send_beacons(ieee);
 	del_timer_sync(&ieee->associate_timer);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&ieee->associate_retry_wq);
 	cancel_delayed_work(&ieee->start_ibss_wq);
-#endif
 	ieee80211_stop_scan(ieee);
 
 	ieee80211_disassociate(ieee);
@@ -2943,11 +2755,6 @@ void ieee80211_softmac_init(struct ieee80211_device *ieee)
 	ieee->sta_edca_param[3] = 0x002F3262;
 	ieee->aggregation = true;
 	ieee->enable_rx_imm_BA = 1;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	init_timer(&ieee->scan_timer);
-	ieee->scan_timer.data = (unsigned long)ieee;
-	ieee->scan_timer.function = ieee80211_softmac_scan_cb;
-#endif
 	ieee->tx_pending.txb = NULL;
 
 	init_timer(&ieee->associate_timer);
@@ -2958,16 +2765,12 @@ void ieee80211_softmac_init(struct ieee80211_device *ieee)
 	ieee->beacon_timer.data = (unsigned long) ieee;
 	ieee->beacon_timer.function = ieee80211_send_beacon_cb;
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 #ifdef PF_SYNCTHREAD
 	ieee->wq = create_workqueue(DRV_NAME,0);
 #else
 	ieee->wq = create_workqueue(DRV_NAME);
 #endif
-#endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	INIT_DELAYED_WORK(&ieee->start_ibss_wq,ieee80211_start_ibss_wq);
 	INIT_WORK(&ieee->associate_complete_wq, ieee80211_associate_complete_wq);
 	INIT_WORK(&ieee->associate_procedure_wq, ieee80211_associate_procedure_wq);
@@ -2975,23 +2778,7 @@ void ieee80211_softmac_init(struct ieee80211_device *ieee)
 	INIT_DELAYED_WORK(&ieee->associate_retry_wq, ieee80211_associate_retry_wq);
 	INIT_WORK(&ieee->wx_sync_scan_wq,ieee80211_wx_sync_scan_wq);
 
-#else
-	INIT_WORK(&ieee->start_ibss_wq,(void(*)(void*)) ieee80211_start_ibss_wq,ieee);
-	INIT_WORK(&ieee->associate_retry_wq,(void(*)(void*)) ieee80211_associate_retry_wq,ieee);
-	INIT_WORK(&ieee->associate_complete_wq,(void(*)(void*)) ieee80211_associate_complete_wq,ieee);
-	INIT_WORK(&ieee->associate_procedure_wq,(void(*)(void*)) ieee80211_associate_procedure_wq,ieee);
-	INIT_WORK(&ieee->softmac_scan_wq,(void(*)(void*)) ieee80211_softmac_scan_wq,ieee);
-	INIT_WORK(&ieee->wx_sync_scan_wq,(void(*)(void*)) ieee80211_wx_sync_scan_wq,ieee);
-#endif
 
-#else
-	tq_init(&ieee->start_ibss_wq,(void(*)(void*)) ieee80211_start_ibss_wq,ieee);
-	tq_init(&ieee->associate_retry_wq,(void(*)(void*)) ieee80211_associate_retry_wq,ieee);
-	tq_init(&ieee->associate_complete_wq,(void(*)(void*)) ieee80211_associate_complete_wq,ieee);
-	tq_init(&ieee->associate_procedure_wq,(void(*)(void*)) ieee80211_associate_procedure_wq,ieee);
-	tq_init(&ieee->softmac_scan_wq,(void(*)(void*)) ieee80211_softmac_scan_wq,ieee);
-	tq_init(&ieee->wx_sync_scan_wq,(void(*)(void*)) ieee80211_wx_sync_scan_wq,ieee);
-#endif
 	sema_init(&ieee->wx_sem, 1);
 	sema_init(&ieee->scan_sem, 1);
 
@@ -3016,10 +2803,8 @@ void ieee80211_softmac_free(struct ieee80211_device *ieee)
 #endif
 	del_timer_sync(&ieee->associate_timer);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	cancel_delayed_work(&ieee->associate_retry_wq);
 	destroy_workqueue(ieee->wq);
-#endif
 
 	up(&ieee->wx_sem);
 }
@@ -3296,11 +3081,7 @@ static int ieee80211_wpa_set_encryption(struct ieee80211_device *ieee,
 		}
 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
 		new_crypt->ops = ops;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
-#else
-		if (new_crypt->ops && try_inc_mod_count(new_crypt->ops->owner))
-#endif
 			new_crypt->priv =
 				new_crypt->ops->init(param->u.crypt.idx);
 
@@ -3483,7 +3264,6 @@ void notify_wx_assoc_event(struct ieee80211_device *ieee)
 	wireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);
 }
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_get_beacon);
 EXPORT_SYMBOL(ieee80211_wake_queue);
 EXPORT_SYMBOL(ieee80211_stop_queue);
@@ -3504,26 +3284,4 @@ EXPORT_SYMBOL(ieee80211_stop_scan);
 EXPORT_SYMBOL(ieee80211_send_probe_requests);
 EXPORT_SYMBOL(ieee80211_softmac_scan_syncro);
 EXPORT_SYMBOL(ieee80211_start_scan_syncro);
-#else
-EXPORT_SYMBOL_NOVERS(ieee80211_get_beacon);
-EXPORT_SYMBOL_NOVERS(ieee80211_wake_queue);
-EXPORT_SYMBOL_NOVERS(ieee80211_stop_queue);
-EXPORT_SYMBOL_NOVERS(ieee80211_reset_queue);
-EXPORT_SYMBOL_NOVERS(ieee80211_softmac_stop_protocol);
-EXPORT_SYMBOL_NOVERS(ieee80211_softmac_start_protocol);
-EXPORT_SYMBOL_NOVERS(ieee80211_is_shortslot);
-EXPORT_SYMBOL_NOVERS(ieee80211_is_54g);
-EXPORT_SYMBOL_NOVERS(ieee80211_wpa_supplicant_ioctl);
-EXPORT_SYMBOL_NOVERS(ieee80211_ps_tx_ack);
-EXPORT_SYMBOL_NOVERS(ieee80211_softmac_xmit);
-EXPORT_SYMBOL_NOVERS(ieee80211_stop_send_beacons);
-EXPORT_SYMBOL_NOVERS(notify_wx_assoc_event);
-EXPORT_SYMBOL_NOVERS(SendDisassociation);
-EXPORT_SYMBOL_NOVERS(ieee80211_disassociate);
-EXPORT_SYMBOL_NOVERS(ieee80211_start_send_beacons);
-EXPORT_SYMBOL_NOVERS(ieee80211_stop_scan);
-EXPORT_SYMBOL_NOVERS(ieee80211_send_probe_requests);
-EXPORT_SYMBOL_NOVERS(ieee80211_softmac_scan_syncro);
-EXPORT_SYMBOL_NOVERS(ieee80211_start_scan_syncro);
-#endif
 //EXPORT_SYMBOL(ieee80211_sta_ps_send_null_frame);
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c
index d395fc6..f335c25 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_softmac_wx.c
@@ -234,23 +234,8 @@ int ieee80211_wx_get_rate(struct ieee80211_device *ieee,
 			     union iwreq_data *wrqu, char *extra)
 {
 	u32 tmp_rate;
-#if 0
-	printk("===>mode:%d, halfNmode:%d\n", ieee->mode, ieee->bHalfWirelessN24GMode);
-	if (ieee->mode & (IEEE_A | IEEE_B | IEEE_G))
-		tmp_rate = ieee->rate;
-	else if (ieee->mode & IEEE_N_5G)
-		tmp_rate = 580;
-	else if (ieee->mode & IEEE_N_24G)
-	{
-		if (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev))
-			tmp_rate = HTHalfMcsToDataRate(ieee, 15);
-		else
-			tmp_rate = HTMcsToDataRate(ieee, 15);
-	}
-#else
 	tmp_rate = TxCountToDataRate(ieee, ieee->softmac_stats.CurrentShowTxate);
 
-#endif
 	wrqu->bitrate.value = tmp_rate * 500000;
 
 	return 0;
@@ -313,14 +298,9 @@ out:
 	return 0;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 void ieee80211_wx_sync_scan_wq(struct work_struct *work)
 {
 	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, wx_sync_scan_wq);
-#else
-void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee)
-{
-#endif
 	short chan;
 	HT_EXTCHNL_OFFSET chan_offset=0;
 	HT_CHANNEL_WIDTH bandwidth=0;
@@ -392,11 +372,7 @@ int ieee80211_wx_set_scan(struct ieee80211_device *ieee, struct iw_request_info
 	}
 
 	if ( ieee->state == IEEE80211_LINKED){
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		queue_work(ieee->wq, &ieee->wx_sync_scan_wq);
-#else
-		schedule_task(&ieee->wx_sync_scan_wq);
-#endif
 		/* intentionally forget to up sem */
 		return 0;
 	}
@@ -442,29 +418,8 @@ int ieee80211_wx_set_essid(struct ieee80211_device *ieee,
 	if (wrqu->essid.flags && wrqu->essid.length) {
 		//first flush current network.ssid
 		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
-#if LINUX_VERSION_CODE <  KERNEL_VERSION(2,6,20)
-		strncpy(ieee->current_network.ssid, extra, len);
-		ieee->current_network.ssid_len = len;
-#if 0
-		{
-			int i;
-			for (i=0; i<len; i++)
-				printk("%c ", extra[i]);
-			printk("\n");
-		}
-#endif
-#else
 		strncpy(ieee->current_network.ssid, extra, len+1);
 		ieee->current_network.ssid_len = len+1;
-#if 0
-		{
-			int i;
-			for (i=0; i<len + 1; i++)
-				printk("%c ", extra[i]);
-			printk("\n");
-		}
-#endif
-#endif
 		ieee->ssid_set = 1;
 	}
 	else{
@@ -557,18 +512,6 @@ int ieee80211_wx_set_power(struct ieee80211_device *ieee,
 				 union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
-#if 0
-	if(
-		(!ieee->sta_wake_up) ||
-		(!ieee->ps_request_tx_ack) ||
-		(!ieee->enter_sleep_state) ||
-		(!ieee->ps_is_queue_empty)){
-
-	//	printk("ERROR. PS mode is tryied to be use but driver missed a callback\n\n");
-
-		return -1;
-	}
-#endif
 	down(&ieee->wx_sem);
 
 	if (wrqu->power.disabled){
@@ -652,7 +595,6 @@ exit:
 	return ret;
 
 }
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_wx_get_essid);
 EXPORT_SYMBOL(ieee80211_wx_set_essid);
 EXPORT_SYMBOL(ieee80211_wx_set_rate);
@@ -671,23 +613,3 @@ EXPORT_SYMBOL(ieee80211_wx_get_power);
 EXPORT_SYMBOL(ieee80211_wlan_frequencies);
 EXPORT_SYMBOL(ieee80211_wx_set_rts);
 EXPORT_SYMBOL(ieee80211_wx_get_rts);
-#else
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_essid);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_essid);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_rate);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_rate);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_wap);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_wap);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_mode);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_mode);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_scan);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_freq);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_freq);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_rawtx);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_name);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_power);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_power);
-EXPORT_SYMBOL_NOVERS(ieee80211_wlan_frequencies);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_rts);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_rts);
-#endif
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
index b64e4cb..b29c36b 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c
@@ -235,11 +235,6 @@ void ieee80211_txb_free(struct ieee80211_txb *txb) {
 	//int i;
 	if (unlikely(!txb))
 		return;
-#if 0
-	for (i = 0; i < txb->nr_frags; i++)
-		if (txb->fragments[i])
-			dev_kfree_skb_any(txb->fragments[i]);
-#endif
 	kfree(txb);
 }
 
@@ -287,11 +282,7 @@ ieee80211_classify(struct sk_buff *skb, struct ieee80211_network *network)
 		return 0;
 
 //	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
 	ip = ip_hdr(skb);
-#else
-	ip = (struct iphdr*)(skb->data + sizeof(struct ether_header));
-#endif
 	switch (ip->tos & 0xfc) {
 		case 0x20:
 			return 2;
@@ -334,12 +325,10 @@ void ieee80211_tx_query_agg_cap(struct ieee80211_device* ieee, struct sk_buff* s
 	if(!Adapter->HalFunc.GetNmodeSupportBySecCfgHandler(Adapter))
 		return;
 #endif
-#if 1
 	if(!ieee->GetNmodeSupportBySecCfg(ieee->dev))
 	{
 		return;
 	}
-#endif
 	if(pHTInfo->bCurrentAMPDUEnable)
 	{
 		if (!GetTs(ieee, (PTS_COMMON_INFO*)(&pTxTs), hdr->addr1, skb->priority, TX_DIR, true))
@@ -602,11 +591,7 @@ void ieee80211_query_seqnum(struct ieee80211_device*ieee, struct sk_buff* skb, u
 
 int ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
 	struct ieee80211_device *ieee = netdev_priv(dev);
-#else
-	struct ieee80211_device *ieee = (struct ieee80211_device *)dev->priv;
-#endif
 	struct ieee80211_txb *txb = NULL;
 	struct ieee80211_hdr_3addrqos *frag_hdr;
 	int i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;
@@ -878,7 +863,6 @@ int ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)
 //WB add to fill data tcb_desc here. only first fragment is considered, need to change, and you may remove to other place.
 	if (txb)
 	{
-#if 1
 		cb_desc *tcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);
 		tcb_desc->bTxEnableFwCalcDur = 1;
 		if (is_multicast_ether_addr(header.addr1))
@@ -899,7 +883,6 @@ int ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)
 		ieee80211_query_seqnum(ieee, txb->fragments[0], header.addr1);
 //		IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, txb->fragments[0]->data, txb->fragments[0]->len);
 		//IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, tcb_desc, sizeof(cb_desc));
-#endif
 	}
 	spin_unlock_irqrestore(&ieee->lock, flags);
 	dev_kfree_skb_any(skb);
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c b/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c
index 3b248cd..d397f1d 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211_wx.c
@@ -35,11 +35,6 @@
 #include <linux/module.h>
 
 #include "ieee80211.h"
-#if 0
-static const char *ieee80211_modes[] = {
-	"?", "a", "b", "ab", "g", "ag", "bg", "abg"
-};
-#endif
 struct modes_unit {
 	char *mode_string;
 	int mode_size;
@@ -53,25 +48,7 @@ struct modes_unit ieee80211_modes[] = {
 	{"N-5G",4},
 };
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-static inline char *
-iwe_stream_add_event_rsl(char *     stream,         /* Stream of events */
-		     char *     ends,           /* End of stream */
-		     struct iw_event *iwe,      /* Payload */
-		     int        event_len)      /* Real size of payload */
-{
-	/* Check if it's possible */
-	if((stream + event_len) < ends) {
-		iwe->len = event_len;
-		ndelay(1);   //new
-		memcpy(stream, (char *) iwe, event_len);
-		stream += event_len;
-	}
-	return stream;
-}
-#else
 #define iwe_stream_add_event_rsl iwe_stream_add_event
-#endif
 
 #define MAX_CUSTOM_LEN 64
 static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
@@ -92,11 +69,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 	iwe.cmd = SIOCGIWAP;
 	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
 	memcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_ADDR_LEN);
-#else
-	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_ADDR_LEN);
-#endif
 	/* Remaining entries will be displayed in the order we provide them */
 
 	/* Add the ESSID */
@@ -105,18 +78,10 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 //	if (network->flags & NETWORK_EMPTY_ESSID) {
 	if (network->ssid_len == 0) {
 		iwe.u.data.length = sizeof("<hidden>");
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 		start = iwe_stream_add_point(info, start, stop, &iwe, "<hidden>");
-#else
-		start = iwe_stream_add_point(start, stop, &iwe, "<hidden>");
-#endif
 	} else {
 		iwe.u.data.length = min(network->ssid_len, (u8)32);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 		start = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);
-#else
-		start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
-#endif
 	}
 	/* Add the protocol name */
 	iwe.cmd = SIOCGIWNAME;
@@ -128,11 +93,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 	}
 	*pname = '\0';
 	snprintf(iwe.u.name, IFNAMSIZ, "IEEE802.11%s", proto_name);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_CHAR_LEN);
-#else
-	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_CHAR_LEN);
-#endif
 	/* Add mode */
 	iwe.cmd = SIOCGIWMODE;
 	if (network->capability &
@@ -141,11 +102,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 			iwe.u.mode = IW_MODE_MASTER;
 		else
 			iwe.u.mode = IW_MODE_ADHOC;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 		start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_UINT_LEN);
-#else
-		start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_UINT_LEN);
-#endif
 	}
 
 	/* Add frequency/channel */
@@ -155,11 +112,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 	iwe.u.freq.m = network->channel;
 	iwe.u.freq.e = 0;
 	iwe.u.freq.i = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_FREQ_LEN);
-#else
-	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_FREQ_LEN);
-#endif
 	/* Add encryption capability */
 	iwe.cmd = SIOCGIWENCODE;
 	if (network->capability & WLAN_CAPABILITY_PRIVACY)
@@ -167,11 +120,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 	else
 		iwe.u.data.flags = IW_ENCODE_DISABLED;
 	iwe.u.data.length = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	start = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);
-#else
-	start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
-#endif
 	/* Add basic and extended rates */
 	max_rate = 0;
 	p = custom;
@@ -215,33 +164,15 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 		if (rate > max_rate)
 			max_rate = rate;
 	}
-#if 0
-	printk("max rate:%d ===basic rate:\n", max_rate);
-	for (i=0;i<network->rates_len;i++)
-		printk(" %x", network->rates[i]);
-	printk("\n=======extend rate\n");
-	for (i=0; i<network->rates_ex_len; i++)
-		printk(" %x", network->rates_ex[i]);
-	printk("\n");
-#endif
 	iwe.cmd = SIOCGIWRATE;
 	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
 	iwe.u.bitrate.value = max_rate * 500000;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	start = iwe_stream_add_event_rsl(info, start, stop, &iwe,
 				     IW_EV_PARAM_LEN);
-#else
-	start = iwe_stream_add_event_rsl(start, stop, &iwe,
-				     IW_EV_PARAM_LEN);
-#endif
 	iwe.cmd = IWEVCUSTOM;
 	iwe.u.data.length = p - custom;
 	if (iwe.u.data.length)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	start = iwe_stream_add_point(info, start, stop, &iwe, custom);
-#else
-	start = iwe_stream_add_point(start, stop, &iwe, custom);
-#endif
 	/* Add quality statistics */
 	/* TODO: Fix these values... */
 	iwe.cmd = IWEVQUAL;
@@ -256,21 +187,13 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 	if (!(network->stats.mask & IEEE80211_STATMASK_SIGNAL))
 		iwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;
 	iwe.u.qual.updated = 7;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	start = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_QUAL_LEN);
-#else
-	start = iwe_stream_add_event_rsl(start, stop, &iwe, IW_EV_QUAL_LEN);
-#endif
 	iwe.cmd = IWEVCUSTOM;
 	p = custom;
 
 	iwe.u.data.length = p - custom;
 	if (iwe.u.data.length)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	    start = iwe_stream_add_point(info, start, stop, &iwe, custom);
-#else
-	    start = iwe_stream_add_point(start, stop, &iwe, custom);
-#endif
 #if (WIRELESS_EXT < 18)
 	if (ieee->wpa_enabled && network->wpa_ie_len){
 		char buf[MAX_WPA_IE_LEN * 2 + 30];
@@ -284,11 +207,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = IWEVCUSTOM;
 		iwe.u.data.length = strlen(buf);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
-#else
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
-#endif
 	}
 
 	if (ieee->wpa_enabled && network->rsn_ie_len){
@@ -303,11 +222,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = IWEVCUSTOM;
 		iwe.u.data.length = strlen(buf);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
-#else
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
-#endif
 	}
 #else
 	memset(&iwe, 0, sizeof(iwe));
@@ -317,11 +232,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 		memcpy(buf, network->wpa_ie, network->wpa_ie_len);
 		iwe.cmd = IWEVGENIE;
 		iwe.u.data.length = network->wpa_ie_len;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
-#else
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
-#endif
 	}
 	memset(&iwe, 0, sizeof(iwe));
 	if (network->rsn_ie_len)
@@ -330,11 +241,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 		memcpy(buf, network->rsn_ie, network->rsn_ie_len);
 		iwe.cmd = IWEVGENIE;
 		iwe.u.data.length = network->rsn_ie_len;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
-#else
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
-#endif
 	}
 #endif
 
@@ -347,11 +254,7 @@ static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,
 		      " Last beacon: %lums ago", (jiffies - network->last_scanned) / (HZ / 100));
 	iwe.u.data.length = p - custom;
 	if (iwe.u.data.length)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
 	    start = iwe_stream_add_point(info, start, stop, &iwe, custom);
-#else
-	    start = iwe_stream_add_point(start, stop, &iwe, custom);
-#endif
 
 	return start;
 }
@@ -486,11 +389,7 @@ int ieee80211_wx_set_encode(struct ieee80211_device *ieee,
 			request_module("ieee80211_crypt_wep");
 			new_crypt->ops = ieee80211_get_crypto_ops("WEP");
 		}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
-#else
-		if (new_crypt->ops && try_inc_mod_count(new_crypt->ops->owner))
-#endif
 			new_crypt->priv = new_crypt->ops->init(key);
 
 		if (!new_crypt->ops || !new_crypt->priv) {
@@ -611,15 +510,6 @@ int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
 		erq->flags |= IW_ENCODE_DISABLED;
 		return 0;
 	}
-#if 0
-	if (strcmp(crypt->ops->name, "WEP") != 0) {
-		/* only WEP is supported with wireless extensions, so just
-		 * report that encryption is used */
-		erq->length = 0;
-		erq->flags |= IW_ENCODE_ENABLED;
-		return 0;
-	}
-#endif
 	len = crypt->ops->get_key(keybuf, SCM_KEY_LEN, NULL, crypt->priv);
 	erq->length = (len >= 0 ? len : 0);
 
@@ -638,7 +528,6 @@ int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
 			       union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct net_device *dev = ieee->dev;
 	struct iw_point *encoding = &wrqu->encoding;
 	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
@@ -702,12 +591,6 @@ int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
 
 	sec.enabled = 1;
     //    sec.encrypt = 1;
-#if 0
-	if (group_key ? !ieee->host_mc_decrypt :
-	    !(ieee->host_encrypt || ieee->host_decrypt ||
-	      ieee->host_encrypt_msdu))
-		goto skip_host_crypt;
-#endif
 	switch (ext->alg) {
 	case IW_ENCODE_ALG_WEP:
 		alg = "WEP";
@@ -747,12 +630,7 @@ int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
 
 		ieee80211_crypt_delayed_deinit(ieee, crypt);
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
 		new_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);
-#else
-		new_crypt = kmalloc(sizeof(*new_crypt), GFP_KERNEL);
-		memset(new_crypt,0,sizeof(*new_crypt));
-#endif
 		if (new_crypt == NULL) {
 			ret = -ENOMEM;
 			goto done;
@@ -777,7 +655,6 @@ int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
 		ret = -EINVAL;
 		goto done;
 	}
-#if 1
  //skip_host_crypt:
 	//printk("skip_host_crypt:ext_flags:%x\n", ext->ext_flags);
 	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
@@ -807,7 +684,6 @@ int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,
 		if (group_key)
 			sec.flags &= ~SEC_LEVEL;
 	}
-#endif
 done:
 	if (ieee->set_security)
 		ieee->set_security(ieee->dev, &sec);
@@ -818,7 +694,6 @@ done:
 		IEEE80211_DEBUG_WX("%s: reset_port failed\n", dev->name);
 		return -EINVAL;
 	}
-#endif
 	return ret;
 }
 
@@ -881,7 +756,6 @@ int ieee80211_wx_set_mlme(struct ieee80211_device *ieee,
 			       struct iw_request_info *info,
 			       union iwreq_data *wrqu, char *extra)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct iw_mlme *mlme = (struct iw_mlme *) extra;
 	switch (mlme->cmd) {
 	case IW_MLME_DEAUTH:
@@ -891,7 +765,6 @@ int ieee80211_wx_set_mlme(struct ieee80211_device *ieee,
 	 default:
 		return -EOPNOTSUPP;
 	}
-#endif
 	return 0;
 }
 
@@ -899,7 +772,6 @@ int ieee80211_wx_set_auth(struct ieee80211_device *ieee,
 			       struct iw_request_info *info,
 			       struct iw_param *data, char *extra)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	switch (data->flags & IW_AUTH_INDEX) {
 	case IW_AUTH_WPA_VERSION:
 	     /*need to support wpa2 here*/
@@ -941,13 +813,11 @@ int ieee80211_wx_set_auth(struct ieee80211_device *ieee,
 		//printk("open_wep:%d\n", ieee->open_wep);
 		break;
 
-#if 1
 	case IW_AUTH_WPA_ENABLED:
 		ieee->wpa_enabled = (data->value)?1:0;
 		//printk("enalbe wpa:%d\n", ieee->wpa_enabled);
 		break;
 
-#endif
 	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
 		ieee->ieee802_1x = data->value;
 		break;
@@ -957,23 +827,11 @@ int ieee80211_wx_set_auth(struct ieee80211_device *ieee,
 	default:
 		return -EOPNOTSUPP;
 	}
-#endif
 	return 0;
 }
 #endif
-#if 1
 int ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len)
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-#if 0
-	printk("====>%s()\n", __FUNCTION__);
-	{
-		int i;
-		for (i=0; i<len; i++)
-		printk("%2x ", ie[i]&0xff);
-		printk("\n");
-	}
-#endif
 	u8 *buf;
 
 	if (len>MAX_WPA_IE_LEN || (len && ie == NULL))
@@ -1004,13 +862,10 @@ int ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len)
 		ieee->wpa_ie = NULL;
 		ieee->wpa_ie_len = 0;
 	}
-#endif
 	return 0;
 
 }
-#endif
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 EXPORT_SYMBOL(ieee80211_wx_set_gen_ie);
 #if (WIRELESS_EXT >= 18)
 EXPORT_SYMBOL(ieee80211_wx_set_mlme);
@@ -1021,12 +876,3 @@ EXPORT_SYMBOL(ieee80211_wx_get_encode_ext);
 EXPORT_SYMBOL(ieee80211_wx_get_scan);
 EXPORT_SYMBOL(ieee80211_wx_set_encode);
 EXPORT_SYMBOL(ieee80211_wx_get_encode);
-#else
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_gen_ie);
-//EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_mlme);
-//EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_auth);
-//EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_encode_ext);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_scan);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_set_encode);
-EXPORT_SYMBOL_NOVERS(ieee80211_wx_get_encode);
-#endif
diff --git a/drivers/staging/rtl8192u/ieee80211/internal.h b/drivers/staging/rtl8192u/ieee80211/internal.h
index ddc2235..a7c096e 100644
--- a/drivers/staging/rtl8192u/ieee80211/internal.h
+++ b/drivers/staging/rtl8192u/ieee80211/internal.h
@@ -22,22 +22,6 @@
 #include <asm/softirq.h>
 #include <asm/kmap_types.h>
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20))
-#define list_for_each_entry(pos, head, member)				\
-	for (pos = list_entry((head)->next, typeof(*pos), member),	\
-		     prefetch(pos->member.next);			\
-	     &pos->member != (head); 					\
-	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
-		     prefetch(pos->member.next))
-
-static inline void cond_resched(void)
-{
-	if (need_resched()) {
-		set_current_state(TASK_RUNNING);
-		schedule();
-	}
-}
-#endif
 
 extern enum km_type crypto_km_types[];
 
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_BAProc.c b/drivers/staging/rtl8192u/ieee80211/rtl819x_BAProc.c
index 98b3bb6..26af43b 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_BAProc.c
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_BAProc.c
@@ -174,48 +174,6 @@ static struct sk_buff* ieee80211_ADDBA(struct ieee80211_device* ieee, u8* Dst, P
 	//return NULL;
 }
 
-#if 0 //I try to merge ADDBA_REQ and ADDBA_RSP frames together..
-/********************************************************************************************************************
- *function:  construct ADDBAREQ frame
- *   input:  u8* 		dst 	//ADDBARsp frame's destination
- *   	     PBA_RECORD 	pBA	//BA_RECORD entry which stores the necessary information for BA_RSP.
- *   	     u16 		StatusCode  //status code.
- *  output:  none
- *  return:  sk_buff* 		skb     //return constructed skb to xmit
-********************************************************************************************************************/
-static struct sk_buff* ieee80211_ADDBA_Rsp( IN	struct ieee80211_device* ieee, u8* dst, PBA_RECORD pBA, u16 StatusCode)
-{
-	OCTET_STRING	osADDBAFrame, tmp;
-
-	FillOctetString(osADDBAFrame, Buffer, 0);
-	*pLength = 0;
-
-	ConstructMaFrameHdr(
-					Adapter,
-					Addr,
-					ACT_CAT_BA,
-					ACT_ADDBARSP,
-					&osADDBAFrame	);
-
-	// Dialog Token
-	FillOctetString(tmp, &pBA->DialogToken, 1);
-	PacketAppendData(&osADDBAFrame, tmp);
-
-	// Status Code
-	FillOctetString(tmp, &StatusCode, 2);
-	PacketAppendData(&osADDBAFrame, tmp);
-
-	// BA Parameter Set
-	FillOctetString(tmp, &pBA->BaParamSet, 2);
-	PacketAppendData(&osADDBAFrame, tmp);
-
-	// BA Timeout Value
-	FillOctetString(tmp, &pBA->BaTimeoutValue, 2);
-	PacketAppendData(&osADDBAFrame, tmp);
-
-	*pLength = osADDBAFrame.Length;
-}
-#endif
 
 /********************************************************************************************************************
  *function:  construct DELBA frame
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c b/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
index 7c0e489..2c4eb38 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c
@@ -348,11 +348,6 @@ bool IsHTHalfNmodeAPs(struct ieee80211_device* ieee)
 {
 	bool			retValue = false;
 	struct ieee80211_network* net = &ieee->current_network;
-#if 0
-	if(pMgntInfo->bHalfNMode == false)
-		retValue = false;
-	else
-#endif
 	if((memcmp(net->bssid, BELKINF5D8233V1_RALINK, 3)==0) ||
 		     (memcmp(net->bssid, BELKINF5D82334V3_RALINK, 3)==0) ||
 		     (memcmp(net->bssid, PCI_RALINK, 3)==0) ||
@@ -421,24 +416,6 @@ void HTIOTPeerDetermine(struct ieee80211_device* ieee)
 u8 HTIOTActIsDisableMCS14(struct ieee80211_device* ieee, u8* PeerMacAddr)
 {
 	u8 ret = 0;
-#if 0
-	// Apply for 819u only
-#if (HAL_CODE_BASE==RTL8192 && DEV_BUS_TYPE==USB_INTERFACE)
-	if((memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0) ||
-		(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)
-	    )
-	{
-		ret = 1;
-	}
-
-
-	if(pHTInfo->bCurrentRT2RTAggregation)
-	{
-		// The parameter of pHTInfo->bCurrentRT2RTAggregation must be decided previously
-		ret = 1;
-	}
-#endif
-#endif
 	return ret;
  }
 
@@ -498,21 +475,6 @@ bool HTIOTActIsDisableMCSTwoSpatialStream(struct ieee80211_device* ieee, u8 *Pee
 
 #ifdef TODO
 	// Apply for 819u only
-//#if (HAL_CODE_BASE==RTL8192)
-
-	//This rule only apply to Belkin(Ralink) AP
-	if(IS_UNDER_11N_AES_MODE(Adapter))
-	{
-		if((PlatformCompareMemory(PeerMacAddr, BELKINF5D8233V1_RALINK, 3)==0) ||
-				(PlatformCompareMemory(PeerMacAddr, PCI_RALINK, 3)==0) ||
-				(PlatformCompareMemory(PeerMacAddr, EDIMAX_RALINK, 3)==0))
-		{
-			//Set True to disable this function. Disable by default, Emily, 2008.04.23
-			retValue = false;
-		}
-	}
-
-//#endif
 #endif
 	return retValue;
 }
@@ -530,18 +492,6 @@ u8 HTIOTActIsDisableEDCATurbo(struct ieee80211_device* 	ieee, u8* PeerMacAddr)
 	// Set specific EDCA parameter for different AP in DM handler.
 
 	return retValue;
-#if 0
-	if((memcmp(PeerMacAddr, UNKNOWN_BORADCOM, 3)==0)||
-		(memcmp(PeerMacAddr, LINKSYSWRT330_LINKSYSWRT300_BROADCOM, 3)==0)||
-		(memcmp(PeerMacAddr, LINKSYSWRT350_LINKSYSWRT150_BROADCOM, 3)==0)||
-		(memcmp(PeerMacAddr, NETGEAR834Bv2_BROADCOM, 3)==0))
-
-	{
-		retValue = 1;	//Linksys disable EDCA turbo mode
-	}
-
-	return retValue;
-#endif
 }
 
 /********************************************************************************************************************
@@ -809,7 +759,7 @@ void HTConstructRT2RTAggElement(struct ieee80211_device* ieee, u8* posRT2RTAgg,
 	*len = 6 + 2;
 	return;
 #ifdef TODO
-#if(HAL_CODE_BASE == RTL8192 && DEV_BUS_TYPE == USB_INTERFACE)
+#if (HAL_CODE_BASE == RTL8192 && DEV_BUS_TYPE == USB_INTERFACE)
 	/*
 	//Emily. If it is required to Ask Realtek AP to send AMPDU during AES mode, enable this
 	   section of code.
@@ -988,17 +938,6 @@ u8 HTFilterMCSRate( struct ieee80211_device* ieee, u8* pSupportMCS, u8* pOperate
 	return true;
 }
 void HTSetConnectBwMode(struct ieee80211_device* ieee, HT_CHANNEL_WIDTH	Bandwidth, HT_EXTCHNL_OFFSET	Offset);
-#if 0
-//I need move this function to other places, such as rx?
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-void HTOnAssocRsp_wq(struct work_struct *work)
-{
-	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, ht_onAssRsp);
-#else
-void HTOnAssocRsp_wq(struct ieee80211_device *ieee)
-{
-#endif
-#endif
 void HTOnAssocRsp(struct ieee80211_device *ieee)
 {
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
@@ -1100,10 +1039,6 @@ void HTOnAssocRsp(struct ieee80211_device *ieee)
 	{
 		// Set MPDU density to 2 to Realtek AP, and set it to 0 for others
 		// Replace MPDU factor declared in original association response frame format. 2007.08.20 by Emily
-#if 0
-		osTmp= PacketGetElement( asocpdu, EID_Vendor, OUI_SUB_REALTEK_AGG, OUI_SUBTYPE_DONT_CARE);
-		if(osTmp.Length >= 5)	//00:e0:4c:02:00
-#endif
 		if (ieee->current_network.bssht.bdRT2RTAggregation)
 		{
 			if( ieee->pairwise_key_type != KEY_TYPE_NA)
@@ -1122,19 +1057,12 @@ void HTOnAssocRsp(struct ieee80211_device *ieee)
 
 	// <2> Set AMPDU Minimum MPDU Start Spacing
 	// 802.11n 3.0 section 9.7d.3
-#if 1
 	if(pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)
 		pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
 	else
 		pHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;
 	if(ieee->pairwise_key_type != KEY_TYPE_NA )
 		pHTInfo->CurrentMPDUDensity 	= 7; // 8us
-#else
-	if(pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)
-		pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
-	else
-		pHTInfo->CurrentMPDUDensity = pPeerHTCap->MPDUDensity;
-#endif
 	// Force TX AMSDU
 
 	// Lanhsin: mark for tmp to avoid deauth by ap from  s3
@@ -1278,187 +1206,6 @@ void HTInitializeBssDesc(PBSS_HT pBssHT)
 	pBssHT->bdRT2RTAggregation = false;
 	pBssHT->bdRT2RTLongSlotTime = false;
 }
-#if 0
-//below function has merged into ieee80211_network_init() in ieee80211_rx.c
-void
-HTParsingHTCapElement(
-	IN	PADAPTER		Adapter,
-	IN	OCTET_STRING	HTCapIE,
-	OUT	PRT_WLAN_BSS	pBssDesc
-)
-{
-	PMGNT_INFO      			pMgntInfo = &Adapter->MgntInfo;
-
-	if( HTCapIE.Length > sizeof(pBssDesc->BssHT.bdHTCapBuf) )
-	{
-		RT_TRACE( COMP_HT, DBG_LOUD, ("HTParsingHTCapElement(): HT Capability Element length is too long!\n") );
-		return;
-	}
-
-	// TODO: Check the correctness of HT Cap
-	//Print each field in detail. Driver should not print out this message by default
-	if(!pMgntInfo->mActingAsAp && !pMgntInfo->mAssoc)
-		HTDebugHTCapability(DBG_TRACE, Adapter, &HTCapIE, (pu8)"HTParsingHTCapElement()");
-
-	HTCapIE.Length = HTCapIE.Length > sizeof(pBssDesc->BssHT.bdHTCapBuf)?\
-		sizeof(pBssDesc->BssHT.bdHTCapBuf):HTCapIE.Length;	//prevent from overflow
-
-	CopyMem(pBssDesc->BssHT.bdHTCapBuf, HTCapIE.Octet, HTCapIE.Length);
-	pBssDesc->BssHT.bdHTCapLen = HTCapIE.Length;
-
-}
-
-
-void
-HTParsingHTInfoElement(
-	PADAPTER		Adapter,
-	OCTET_STRING	HTInfoIE,
-	PRT_WLAN_BSS	pBssDesc
-)
-{
-	PMGNT_INFO      			pMgntInfo = &Adapter->MgntInfo;
-
-	if( HTInfoIE.Length > sizeof(pBssDesc->BssHT.bdHTInfoBuf))
-	{
-		RT_TRACE( COMP_HT, DBG_LOUD, ("HTParsingHTInfoElement(): HT Information Element length is too long!\n") );
-		return;
-	}
-
-	// TODO: Check the correctness of HT Info
-	//Print each field in detail. Driver should not print out this message by default
-	if(!pMgntInfo->mActingAsAp && !pMgntInfo->mAssoc)
-		HTDebugHTInfo(DBG_TRACE, Adapter, &HTInfoIE, (pu8)"HTParsingHTInfoElement()");
-
-	HTInfoIE.Length = HTInfoIE.Length > sizeof(pBssDesc->BssHT.bdHTInfoBuf)?\
-		sizeof(pBssDesc->BssHT.bdHTInfoBuf):HTInfoIE.Length;	//prevent from overflow
-
-	CopyMem( pBssDesc->BssHT.bdHTInfoBuf, HTInfoIE.Octet, HTInfoIE.Length);
-	pBssDesc->BssHT.bdHTInfoLen = HTInfoIE.Length;
-}
-
-/*
-  * Get HT related information from beacon and save it in BssDesc
-  *
-  * (1) Parse HTCap, and HTInfo, and record whether it is 11n AP
-  * (2) If peer is HT, but not WMM, call QosSetLegacyWMMParamWithHT()
-  * (3) Check whether peer is Realtek AP (for Realtek proprietary aggregation mode).
-  * Input:
-  * 		PADAPTER	Adapter
-  *
-  * Output:
-  *		PRT_TCB		BssDesc
-  *
-*/
-void HTGetValueFromBeaconOrProbeRsp(
-	PADAPTER			Adapter,
-	POCTET_STRING		pSRCmmpdu,
-	PRT_WLAN_BSS		bssDesc
-)
-{
-	PMGNT_INFO      			pMgntInfo = &Adapter->MgntInfo;
-	PRT_HIGH_THROUGHPUT		pHTInfo = GET_HT_INFO(pMgntInfo);
-	OCTET_STRING				HTCapIE, HTInfoIE, HTRealtekAgg, mmpdu;
-	OCTET_STRING				BroadcomElement, CiscoElement;
-
-	mmpdu.Octet = pSRCmmpdu->Octet;
-	mmpdu.Length = pSRCmmpdu->Length;
-
-	//2Note:
-	//   Mark for IOT testing using  Linksys WRT350N, This AP does not contain WMM IE  when
-	//   it is configured at pure-N mode.
-	//	if(bssDesc->BssQos.bdQoSMode & QOS_WMM)
-	//
-
-	HTInitializeBssDesc (&bssDesc->BssHT);
-
-	//2<1> Parse HTCap, and HTInfo
-	// Get HT Capability IE: (1) Get IEEE Draft N IE or (2) Get EWC IE
-	HTCapIE = PacketGetElement(mmpdu, EID_HTCapability, OUI_SUB_DONT_CARE, OUI_SUBTYPE_DONT_CARE);
-	if(HTCapIE.Length == 0)
-	{
-		HTCapIE = PacketGetElement(mmpdu, EID_Vendor, OUI_SUB_11N_EWC_HT_CAP, OUI_SUBTYPE_DONT_CARE);
-		if(HTCapIE.Length != 0)
-			bssDesc->BssHT.bdHTSpecVer= HT_SPEC_VER_EWC;
-	}
-	if(HTCapIE.Length != 0)
-		HTParsingHTCapElement(Adapter, HTCapIE, bssDesc);
-
-	// Get HT Information IE: (1) Get IEEE Draft N IE or (2) Get EWC IE
-	HTInfoIE = PacketGetElement(mmpdu, EID_HTInfo, OUI_SUB_DONT_CARE, OUI_SUBTYPE_DONT_CARE);
-	if(HTInfoIE.Length == 0)
-	{
-		HTInfoIE = PacketGetElement(mmpdu, EID_Vendor, OUI_SUB_11N_EWC_HT_INFO, OUI_SUBTYPE_DONT_CARE);
-		if(HTInfoIE.Length != 0)
-				bssDesc->BssHT.bdHTSpecVer  = HT_SPEC_VER_EWC;
-	}
-	if(HTInfoIE.Length != 0)
-		HTParsingHTInfoElement(Adapter, HTInfoIE, bssDesc);
-
-	//2<2>If peer is HT, but not WMM, call QosSetLegacyWMMParamWithHT()
-	if(HTCapIE.Length != 0)
-	{
-		bssDesc->BssHT.bdSupportHT = true;
-		if(bssDesc->BssQos.bdQoSMode == QOS_DISABLE)
-			QosSetLegacyWMMParamWithHT(Adapter, bssDesc);
-	}
-	else
-	{
-		bssDesc->BssHT.bdSupportHT = false;
-	}
-
-	//2<3>Check whether the peer is Realtek AP/STA
-	if(pHTInfo->bRegRT2RTAggregation)
-	{
-		if(bssDesc->BssHT.bdSupportHT)
-		{
-			HTRealtekAgg = PacketGetElement(mmpdu, EID_Vendor, OUI_SUB_REALTEK_AGG, OUI_SUBTYPE_DONT_CARE);
-			if(HTRealtekAgg.Length >=5 )
-			{
-				bssDesc->BssHT.bdRT2RTAggregation = true;
-
-				if((HTRealtekAgg.Octet[4]==1) && (HTRealtekAgg.Octet[5] & 0x02))
-					bssDesc->BssHT.bdRT2RTLongSlotTime = true;
-			}
-		}
-	}
-
-	//
-	// 2008/01/25 MH Get Broadcom AP IE for manamgent frame CCK rate problem.
-	// AP can not receive CCK managemtn from from 92E.
-	//
-
-	// Initialize every new bss broadcom cap exist as false..
-	bssDesc->bBroadcomCapExist= false;
-
-	if(HTCapIE.Length != 0 || HTInfoIE.Length != 0)
-	{
-		u4Byte	Length = 0;
-
-		FillOctetString(BroadcomElement, NULL, 0);
-
-		BroadcomElement = PacketGetElement( mmpdu, EID_Vendor, OUI_SUB_BROADCOM_IE_1, OUI_SUBTYPE_DONT_CARE);
-		Length += BroadcomElement.Length;
-		BroadcomElement = PacketGetElement( mmpdu, EID_Vendor, OUI_SUB_BROADCOM_IE_2, OUI_SUBTYPE_DONT_CARE);
-		Length += BroadcomElement.Length;
-		BroadcomElement = PacketGetElement( mmpdu, EID_Vendor, OUI_SUB_BROADCOM_IE_3, OUI_SUBTYPE_DONT_CARE);
-		Length += BroadcomElement.Length;
-
-		if(Length > 0)
-			bssDesc->bBroadcomCapExist = true;
-	}
-
-
-	// For Cisco IOT issue
-	CiscoElement = PacketGetElement( mmpdu, EID_Vendor, OUI_SUB_CISCO_IE, OUI_SUBTYPE_DONT_CARE);
-	if(CiscoElement.Length != 0){ // 3: 0x00, 0x40, 0x96 ....
-		bssDesc->bCiscoCapExist = true;
-	}else{
-		bssDesc->bCiscoCapExist = false;
-	}
-}
-
-
-#endif
 /********************************************************************************************************************
  *function:  initialize Bss HT structure(struct PBSS_HT)
  *   input:  struct ieee80211_device 	*ieee
@@ -1712,8 +1459,4 @@ void HTSetConnectBwModeCallback(struct ieee80211_device* ieee)
 	pHTInfo->bSwBwInProgress = false;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-EXPORT_SYMBOL_NOVERS(HTUpdateSelfAndPeerSetting);
-#else
 EXPORT_SYMBOL(HTUpdateSelfAndPeerSetting);
-#endif
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h b/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
index 7ecfe68..13b1e5c 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
@@ -70,147 +70,6 @@ typedef	enum _ACK_POLICY{
 }ACK_POLICY,*PACK_POLICY;
 
 #define WMM_PARAM_ELEMENT_SIZE	(8+(4*AC_PARAM_SIZE))
-#if 0
-#define GET_QOS_CTRL(_pStart)	ReadEF2Byte((u8 *)(_pStart) + 24)
-#define SET_QOS_CTRL(_pStart, _value)	WriteEF2Byte((u8 *)(_pStart) + 24, _value)
-
-// WMM control field.
-#define GET_QOS_CTRL_WMM_UP(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 0, 3))
-#define SET_QOS_CTRL_WMM_UP(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 0, 3, (u8)(_value))
-
-#define GET_QOS_CTRL_WMM_EOSP(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 4, 1))
-#define SET_QOS_CTRL_WMM_EOSP(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 4, 1, (u8)(_value))
-
-#define GET_QOS_CTRL_WMM_ACK_POLICY(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 5, 2))
-#define SET_QOS_CTRL_WMM_ACK_POLICY(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 5, 2, (u8)(_value))
-
-// 802.11e control field (by STA, data)
-#define GET_QOS_CTRL_STA_DATA_TID(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 0, 4))
-#define SET_QOS_CTRL_STA_DATA_TID(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 0, 4, (u8)(_value))
-
-#define GET_QOS_CTRL_STA_DATA_QSIZE_FLAG(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 4, 1))
-#define SET_QOS_CTRL_STA_DATA_QSIZE_FLAG(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 4, 1, (u8)(_value))
-
-#define GET_QOS_CTRL_STA_DATA_ACK_POLICY(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 5, 2))
-#define SET_QOS_CTRL_STA_DATA_ACK_POLICY(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 5, 2, (u8)(_value))
-
-#define GET_QOS_CTRL_STA_DATA_TXOP(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 8, 8))
-#define SET_QOS_CTRL_STA_DATA_TXOP(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 8, 8, (u8)(_value))
-
-#define GET_QOS_CTRL_STA_DATA_QSIZE(_pStart)	GET_QOS_CTRL_STA_DATA_TXOP(_pStart)
-#define SET_QOS_CTRL_STA_DATA_QSIZE(_pStart, _value)	SET_QOS_CTRL_STA_DATA_TXOP(_pStart)
-
-// 802.11e control field (by HC, data)
-#define GET_QOS_CTRL_HC_DATA_TID(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 0, 4))
-#define SET_QOS_CTRL_HC_DATA_TID(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 0, 4, (u8)(_value))
-
-#define GET_QOS_CTRL_HC_DATA_EOSP(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 4, 1))
-#define SET_QOS_CTRL_HC_DATA_EOSP(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 4, 1, (u8)(_value))
-
-#define GET_QOS_CTRL_HC_DATA_ACK_POLICY(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 5, 2))
-#define SET_QOS_CTRL_HC_DATA_ACK_POLICY(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 5, 2, (u8)(_value))
-
-#define GET_QOS_CTRL_HC_DATA_PS_BUFSTATE(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 8, 8))
-#define SET_QOS_CTRL_HC_DATA_PS_BUFSTATE(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 8, 8, (u8)(_value))
-
-// 802.11e control field (by HC, CFP)
-#define GET_QOS_CTRL_HC_CFP_TID(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 0, 4))
-#define SET_QOS_CTRL_HC_CFP_TID(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 0, 4, (u8)(_value))
-
-#define GET_QOS_CTRL_HC_CFP_EOSP(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 4, 1))
-#define SET_QOS_CTRL_HC_CFP_EOSP(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 4, 1, (u8)(_value))
-
-#define GET_QOS_CTRL_HC_CFP_ACK_POLICY(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 5, 2))
-#define SET_QOS_CTRL_HC_CFP_ACK_POLICY(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 5, 2, (u8)(_value))
-
-#define GET_QOS_CTRL_HC_CFP_TXOP_LIMIT(_pStart)	((u8)LE_BITS_TO_2BYTE((u8 *)(_pStart)+24, 8, 8))
-#define SET_QOS_CTRL_HC_CFP_TXOP_LIMIT(_pStart, _value)	SET_BITS_TO_LE_2BYTE((u8 *)(_pStart)+24, 8, 8, (u8)(_value))
-
-#define SET_WMM_QOS_INFO_FIELD(_pStart, _val)	WriteEF1Byte(_pStart, _val)
-
-#define GET_WMM_QOS_INFO_FIELD_PARAMETERSET_COUNT(_pStart)	LE_BITS_TO_1BYTE(_pStart, 0, 4)
-#define SET_WMM_QOS_INFO_FIELD_PARAMETERSET_COUNT(_pStart, _val)	SET_BITS_TO_LE_1BYTE(_pStart, 0, 4, _val)
-
-#define GET_WMM_QOS_INFO_FIELD_AP_UAPSD(_pStart)	LE_BITS_TO_1BYTE(_pStart, 7, 1)
-#define SET_WMM_QOS_INFO_FIELD_AP_UAPSD(_pStart, _val)	SET_BITS_TO_LE_1BYTE(_pStart, 7, 1, _val)
-
-#define GET_WMM_QOS_INFO_FIELD_STA_AC_VO_UAPSD(_pStart)	LE_BITS_TO_1BYTE(_pStart, 0, 1)
-#define SET_WMM_QOS_INFO_FIELD_STA_AC_VO_UAPSD(_pStart, _val)	SET_BITS_TO_LE_1BYTE(_pStart, 0, 1, _val)
-
-#define GET_WMM_QOS_INFO_FIELD_STA_AC_VI_UAPSD(_pStart)	LE_BITS_TO_1BYTE(_pStart, 1, 1)
-#define SET_WMM_QOS_INFO_FIELD_STA_AC_VI_UAPSD(_pStart, _val)	SET_BITS_TO_LE_1BYTE(_pStart, 1, 1, _val)
-
-#define GET_WMM_QOS_INFO_FIELD_STA_AC_BE_UAPSD(_pStart)	LE_BITS_TO_1BYTE(_pStart, 2, 1)
-#define SET_WMM_QOS_INFO_FIELD_STA_AC_BE_UAPSD(_pStart, _val)	SET_BITS_TO_LE_1BYTE(_pStart, 2, 1, _val)
-
-#define GET_WMM_QOS_INFO_FIELD_STA_AC_BK_UAPSD(_pStart)	LE_BITS_TO_1BYTE(_pStart, 3, 1)
-#define SET_WMM_QOS_INFO_FIELD_STA_AC_BK_UAPSD(_pStart, _val)	SET_BITS_TO_LE_1BYTE(_pStart, 3, 1, _val)
-
-#define GET_WMM_QOS_INFO_FIELD_STA_MAX_SP_LEN(_pStart)	LE_BITS_TO_1BYTE(_pStart, 5, 2)
-#define SET_WMM_QOS_INFO_FIELD_STA_MAX_SP_LEN(_pStart, _val)	SET_BITS_TO_LE_1BYTE(_pStart, 5, 2, _val)
-
-
-#define WMM_INFO_ELEMENT_SIZE	7
-
-#define GET_WMM_INFO_ELE_OUI(_pStart)	((u8 *)(_pStart))
-#define SET_WMM_INFO_ELE_OUI(_pStart, _pVal)	PlatformMoveMemory(_pStart, _pVal, 3);
-
-#define GET_WMM_INFO_ELE_OUI_TYPE(_pStart)	( EF1Byte( *((u8 *)(_pStart)+3) ) )
-#define SET_WMM_INFO_ELE_OUI_TYPE(_pStart, _val)	( *((u8 *)(_pStart)+3) = EF1Byte(_val) )
-
-#define GET_WMM_INFO_ELE_OUI_SUBTYPE(_pStart)	( EF1Byte( *((u8 *)(_pStart)+4) ) )
-#define SET_WMM_INFO_ELE_OUI_SUBTYPE(_pStart, _val)	( *((u8 *)(_pStart)+4) = EF1Byte(_val) )
-
-#define GET_WMM_INFO_ELE_VERSION(_pStart)	( EF1Byte( *((u8 *)(_pStart)+5) ) )
-#define SET_WMM_INFO_ELE_VERSION(_pStart, _val)	( *((u8 *)(_pStart)+5) = EF1Byte(_val) )
-
-#define GET_WMM_INFO_ELE_QOS_INFO_FIELD(_pStart)	( EF1Byte( *((u8 *)(_pStart)+6) ) )
-#define SET_WMM_INFO_ELE_QOS_INFO_FIELD(_pStart, _val)	( *((u8 *)(_pStart)+6) = EF1Byte(_val) )
-
-
-
-#define GET_WMM_AC_PARAM_AIFSN(_pStart)	( (u8)LE_BITS_TO_4BYTE(_pStart, 0, 4) )
-#define SET_WMM_AC_PARAM_AIFSN(_pStart, _val)	SET_BITS_TO_LE_4BYTE(_pStart, 0, 4, _val)
-
-#define GET_WMM_AC_PARAM_ACM(_pStart)	( (u8)LE_BITS_TO_4BYTE(_pStart, 4, 1) )
-#define SET_WMM_AC_PARAM_ACM(_pStart, _val)	SET_BITS_TO_LE_4BYTE(_pStart, 4, 1, _val)
-
-#define GET_WMM_AC_PARAM_ACI(_pStart)		( (u8)LE_BITS_TO_4BYTE(_pStart, 5, 2) )
-#define SET_WMM_AC_PARAM_ACI(_pStart, _val)	SET_BITS_TO_LE_4BYTE(_pStart, 5, 2, _val)
-
-#define GET_WMM_AC_PARAM_ACI_AIFSN(_pStart)	( (u8)LE_BITS_TO_4BYTE(_pStart, 0, 8) )
-#define SET_WMM_AC_PARAM_ACI_AIFSN(_pStart, _val)	SET_BTIS_TO_LE_4BYTE(_pStart, 0, 8, _val)
-
-#define GET_WMM_AC_PARAM_ECWMIN(_pStart)	( (u8)LE_BITS_TO_4BYTE(_pStart, 8, 4) )
-#define SET_WMM_AC_PARAM_ECWMIN(_pStart, _val)	SET_BITS_TO_LE_4BYTE(_pStart, 8, 4, _val)
-
-#define GET_WMM_AC_PARAM_ECWMAX(_pStart)	( (u8)LE_BITS_TO_4BYTE(_pStart, 12, 4) )
-#define SET_WMM_AC_PARAM_ECWMAX(_pStart, _val)	SET_BITS_TO_LE_4BYTE(_pStart, 12, 4, _val)
-
-#define GET_WMM_AC_PARAM_TXOP_LIMIT(_pStart)		( (u16)LE_BITS_TO_4BYTE(_pStart, 16, 16) )
-#define SET_WMM_AC_PARAM_TXOP_LIMIT(_pStart, _val)	SET_BITS_TO_LE_4BYTE(_pStart, 16, 16, _val)
-
-
-
-
-#define GET_WMM_PARAM_ELE_OUI(_pStart)	((u8 *)(_pStart))
-#define SET_WMM_PARAM_ELE_OUI(_pStart, _pVal)	PlatformMoveMemory(_pStart, _pVal, 3)
-
-#define GET_WMM_PARAM_ELE_OUI_TYPE(_pStart)	( EF1Byte( *((u8 *)(_pStart)+3) ) )
-#define SET_WMM_PARAM_ELE_OUI_TYPE(_pStart, _val)	( *((u8 *)(_pStart)+3) = EF1Byte(_val) )
-
-#define GET_WMM_PARAM_ELE_OUI_SUBTYPE(_pStart)	( EF1Byte( *((u8 *)(_pStart)+4) ) )
-#define SET_WMM_PARAM_ELE_OUI_SUBTYPE(_pStart, _val)	( *((u8 *)(_pStart)+4) = EF1Byte(_val) )
-
-#define GET_WMM_PARAM_ELE_VERSION(_pStart)	( EF1Byte( *((u8 *)(_pStart)+5) ) )
-#define SET_WMM_PARAM_ELE_VERSION(_pStart, _val)	( *((u8 *)(_pStart)+5) = EF1Byte(_val) )
-
-#define GET_WMM_PARAM_ELE_QOS_INFO_FIELD(_pStart)	( EF1Byte( *((u8 *)(_pStart)+6) ) )
-#define SET_WMM_PARAM_ELE_QOS_INFO_FIELD(_pStart, _val)	( *((u8 *)(_pStart)+6) = EF1Byte(_val) )
-
-#define GET_WMM_PARAM_ELE_AC_PARAM(_pStart)	( (u8 *)(_pStart)+8 )
-#define SET_WMM_PARAM_ELE_AC_PARAM(_pStart, _pVal) PlatformMoveMemory((_pStart)+8, _pVal, 16)
-#endif
 
 //
 // QoS Control Field
@@ -361,21 +220,6 @@ typedef	union _QOS_INFO_FIELD{
 
 }QOS_INFO_FIELD, *PQOS_INFO_FIELD;
 
-#if 0
-//
-// WMM Information Element
-// Ref: WMM spec 2.2.1: WME Information Element, p.10.
-//
-typedef struct _WMM_INFO_ELEMENT{
-//	u8			ElementID;
-//	u8			Length;
-	u8			OUI[3];
-	u8			OUI_Type;
-	u8			OUI_SubType;
-	u8			Version;
-	QOS_INFO_FIELD	QosInfo;
-}WMM_INFO_ELEMENT, *PWMM_INFO_ELEMENT;
-#endif
 
 //
 // ACI to AC coding.
@@ -650,16 +494,6 @@ typedef struct _OCTET_STRING{
 	u8        	*Octet;
 	u16             Length;
 }OCTET_STRING, *POCTET_STRING;
-#if 0
-#define FillOctetString(_os,_octet,_len)             \
-	(_os).Octet=(u8 *)(_octet);                  \
-	(_os).Length=(_len);
-
-#define WMM_ELEM_HDR_LEN        		     6
-#define WMMElemSkipHdr(_osWMMElem)                   \
-	(_osWMMElem).Octet += WMM_ELEM_HDR_LEN;      \
-	(_osWMMElem).Length -= WMM_ELEM_HDR_LEN;
-#endif
 //
 // STA QoS data.
 // Ref: DOT11_QOS in 8185 code. [def. in QoS_mp.h]
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c b/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
index ecf24b9..5373d56 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_TSProc.c
@@ -2,13 +2,6 @@
 #include <linux/etherdevice.h>
 #include "rtl819x_TS.h"
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#define list_for_each_entry_safe(pos, n, head, member) \
-	for (pos = list_entry((head)->next, typeof(*pos), member), \
-		n = list_entry(pos->member.next, typeof(*pos), member); \
-		&pos->member != (head); \
-		pos = n, n = list_entry(n->member.next, typeof(*n), member))
-#endif
 void TsSetupTimeOut(unsigned long data)
 {
 	// Not implement yet
@@ -28,7 +21,6 @@ void TsInactTimeout(unsigned long data)
  *  return:  NULL
  *  notice:
 ********************************************************************************************************************/
-#if 1
 void RxPktPendingTimeout(unsigned long data)
 {
 	PRX_TS_RECORD	pRxTs = (PRX_TS_RECORD)data;
@@ -102,7 +94,6 @@ void RxPktPendingTimeout(unsigned long data)
 	spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
 	//PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
 }
-#endif
 
 /********************************************************************************************************************
  *function:  Add BA timer function
@@ -366,17 +357,10 @@ bool GetTs(
 		IEEE80211_DEBUG(IEEE80211_DL_ERR, "get TS for Broadcast or Multicast\n");
 		return false;
 	}
-#if 0
-	if(ieee->pStaQos->CurrentQosMode == QOS_DISABLE)
-	{	UP = 0; } //only use one TS
-	else if(ieee->pStaQos->CurrentQosMode & QOS_WMM)
-	{
-#else
 	if (ieee->current_network.qos_data.supported == 0)
 		UP = 0;
 	else
 	{
-#endif
 		// In WMM case: we use 4 TID only
 		if (!IsACValid(TID))
 		{
@@ -548,7 +532,6 @@ void RemovePeerTS(struct ieee80211_device* ieee, u8* Addr)
 {
 	PTS_COMMON_INFO	pTS, pTmpTS;
 	printk("===========>RemovePeerTS,"MAC_FMT"\n", MAC_ARG(Addr));
-#if 1
 	list_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, List)
 	{
 		if (memcmp(pTS->Addr, Addr, 6) == 0)
@@ -589,13 +572,11 @@ void RemovePeerTS(struct ieee80211_device* ieee, u8* Addr)
 			list_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);
 		}
 	}
-#endif
 }
 
 void RemoveAllTS(struct ieee80211_device* ieee)
 {
 	PTS_COMMON_INFO pTS, pTmpTS;
-#if 1
 	list_for_each_entry_safe(pTS, pTmpTS, &ieee->Tx_TS_Pending_List, List)
 	{
 		RemoveTsEntry(ieee, pTS, TX_DIR);
@@ -623,7 +604,6 @@ void RemoveAllTS(struct ieee80211_device* ieee)
 		list_del_init(&pTS->List);
 		list_add_tail(&pTS->List, &ieee->Rx_TS_Unused_List);
 	}
-#endif
 }
 
 void TsStartAddBaProcess(struct ieee80211_device* ieee, PTX_TS_RECORD	pTxTS)
@@ -631,7 +611,6 @@ void TsStartAddBaProcess(struct ieee80211_device* ieee, PTX_TS_RECORD	pTxTS)
 	if(pTxTS->bAddBaReqInProgress == false)
 	{
 		pTxTS->bAddBaReqInProgress = true;
-#if 1
 		if(pTxTS->bAddBaReqDelayed)
 		{
 			IEEE80211_DEBUG(IEEE80211_DL_BA, "TsStartAddBaProcess(): Delayed Start ADDBA after 60 sec!!\n");
@@ -642,13 +621,8 @@ void TsStartAddBaProcess(struct ieee80211_device* ieee, PTX_TS_RECORD	pTxTS)
 			IEEE80211_DEBUG(IEEE80211_DL_BA,"TsStartAddBaProcess(): Immediately Start ADDBA now!!\n");
 			mod_timer(&pTxTS->TsAddBaTimer, jiffies+10); //set 10 ticks
 		}
-#endif
 	}
 	else
 		IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s()==>BA timer is already added\n", __FUNCTION__);
 }
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-EXPORT_SYMBOL_NOVERS(RemovePeerTS);
-#else
 EXPORT_SYMBOL(RemovePeerTS);
-#endif
diff --git a/drivers/staging/rtl8192u/r8192U.h b/drivers/staging/rtl8192u/r8192U.h
index 8f62f45..69a2721 100644
--- a/drivers/staging/rtl8192u/r8192U.h
+++ b/drivers/staging/rtl8192u/r8192U.h
@@ -39,9 +39,6 @@
 #include <linux/random.h>
 #include <linux/version.h>
 #include <asm/io.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
-#include <asm/semaphore.h>
-#endif
 #include "ieee80211.h"
 
 #define RTL8192U
@@ -87,11 +84,6 @@
 
 // Rx smooth factor
 #define	Rx_Smooth_Factor		20
-#if 0 //we need to use RT_TRACE instead DMESG as RT_TRACE will clearly show debug level wb.
-#define DMESG(x,a...) printk(KERN_INFO RTL819xU_MODULE_NAME ": " x "\n", ## a)
-#define DMESGW(x,a...) printk(KERN_WARNING RTL819xU_MODULE_NAME ": WW:" x "\n", ## a)
-#define DMESGE(x,a...) printk(KERN_WARNING RTL819xU_MODULE_NAME ": EE:" x "\n", ## a)
-#else
 #define DMESG(x,a...)
 #define DMESGW(x,a...)
 #define DMESGE(x,a...)
@@ -141,7 +133,6 @@ do { if(rt_global_debug_component & component) \
 #define COMP_DOWN				BIT29  //for rm driver module
 #define COMP_RESET				BIT30  //for silent reset
 #define COMP_ERR				BIT31 //for error out, always on
-#endif
 
 #define RTL819x_DEBUG
 #ifdef RTL819x_DEBUG
@@ -596,16 +587,6 @@ typedef struct rtl_reg_debug{
 
 
 
-#if 0
-
-typedef struct tx_pendingbuf
-{
-	struct ieee80211_txb *txb;
-	short ispending;
-	short descfrag;
-} tx_pendigbuf;
-
-#endif
 
 typedef struct _rt_9x_tx_rate_history {
 	u32             cck[4];
@@ -933,11 +914,7 @@ typedef struct r8192_priv
 	spinlock_t irq_lock;
 //	spinlock_t irq_th_lock;
 	spinlock_t tx_lock;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	struct semaphore mutex;
-#else
         struct mutex mutex;
-#endif
 	//spinlock_t rf_lock; //used to lock rf write operation added by wb
 
 	u16 irq_mask;
@@ -1007,11 +984,7 @@ typedef struct r8192_priv
 /* modified by davad for Rx process */
        struct sk_buff_head rx_queue;
        struct sk_buff_head skb_queue;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-	struct tq_struct qos_activate;
-#else
        struct work_struct qos_activate;
-#endif
 	short  tx_urb_index;
 	atomic_t tx_pending[0x10];//UART_PRIORITY+1
 
@@ -1041,11 +1014,7 @@ typedef struct r8192_priv
 	u16 rts;
 
 	struct 	ChnlAccessSetting  ChannelAccessSetting;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct reset_wq;
-#else
-	struct tq_struct reset_wq;
-#endif
 
 /**********************************************************/
 	//for rtl819xUsb
@@ -1194,33 +1163,14 @@ typedef struct r8192_priv
 	u16		SifsTime;
 
 	//define work item by amy 080526
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	struct delayed_work update_beacon_wq;
 	struct delayed_work watch_dog_wq;
 	struct delayed_work txpower_tracking_wq;
 	struct delayed_work rfpath_check_wq;
 	struct delayed_work gpio_change_rf_wq;
 	struct delayed_work initialgain_operate_wq;
-#else
-	struct work_struct update_beacon_wq;
-	struct work_struct watch_dog_wq;
-	struct work_struct txpower_tracking_wq;
-	struct work_struct rfpath_check_wq;
-	struct work_struct gpio_change_rf_wq;
-	struct work_struct initialgain_operate_wq;
-#endif
 	struct workqueue_struct *priv_wq;
-#else
-	/* used for periodly scan */
-	struct tq_struct update_beacon_wq;
-	struct tq_struct txpower_tracking_wq;
-	struct tq_struct rfpath_check_wq;
-	struct tq_struct watch_dog_wq;
-	struct tq_struct gpio_change_rf_wq;
-	struct tq_struct initialgain_operate_wq;
-#endif
 }r8192_priv;
 
 // for rtl8187
@@ -1259,60 +1209,6 @@ typedef enum{
 	} nic_t;
 
 
-#if 0 //defined in Qos.h
-//typedef u32 AC_CODING;
-#define AC0_BE	0		// ACI: 0x00	// Best Effort
-#define AC1_BK	1		// ACI: 0x01	// Background
-#define AC2_VI	2		// ACI: 0x10	// Video
-#define AC3_VO	3		// ACI: 0x11	// Voice
-#define AC_MAX	4		// Max: define total number; Should not to be used as a real enum.
-
-//
-// ECWmin/ECWmax field.
-// Ref: WMM spec 2.2.2: WME Parameter Element, p.13.
-//
-typedef	union _ECW{
-	u8	charData;
-	struct
-	{
-		u8	ECWmin:4;
-		u8	ECWmax:4;
-	}f;	// Field
-}ECW, *PECW;
-
-//
-// ACI/AIFSN Field.
-// Ref: WMM spec 2.2.2: WME Parameter Element, p.12.
-//
-typedef	union _ACI_AIFSN{
-	u8	charData;
-
-	struct
-	{
-		u8	AIFSN:4;
-		u8	ACM:1;
-		u8	ACI:2;
-		u8	Reserved:1;
-	}f;	// Field
-}ACI_AIFSN, *PACI_AIFSN;
-
-//
-// AC Parameters Record Format.
-// Ref: WMM spec 2.2.2: WME Parameter Element, p.12.
-//
-typedef	union _AC_PARAM{
-	u32	longData;
-	u8	charData[4];
-
-	struct
-	{
-		ACI_AIFSN	AciAifsn;
-		ECW		Ecw;
-		u16		TXOPLimit;
-	}f;	// Field
-}AC_PARAM, *PAC_PARAM;
-
-#endif
 #ifdef JOHN_HWSEC
 struct ssid_thread {
 	struct net_device *dev;
diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index 7aa4642..adade13 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -71,9 +71,6 @@ double __extendsfdf2(float a) {return a;}
 //#include "r8192xU_phyreg.h"
 #include <linux/usb.h>
 // FIXME: check if 2.6.7 is ok
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7))
-#define usb_kill_urb usb_unlink_urb
-#endif
 
 #ifdef CONFIG_RTL8192_PM
 #include "r8192_pm.h"
@@ -127,59 +124,36 @@ static struct usb_device_id rtl8192_usb_id_tbl[] = {
 };
 
 MODULE_LICENSE("GPL");
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 MODULE_VERSION("V 1.1");
-#endif
 MODULE_DEVICE_TABLE(usb, rtl8192_usb_id_tbl);
 MODULE_DESCRIPTION("Linux driver for Realtek RTL8192 USB WiFi cards");
 
 static char* ifname = "wlan%d";
-#if 0
-static int hwseqnum = 0;
-static int hwwep = 0;
-#endif
 static int hwwep = 1;  //default use hw. set 0 to use software security
 static int channels = 0x3fff;
 
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
 module_param(ifname, charp, S_IRUGO|S_IWUSR );
 //module_param(hwseqnum,int, S_IRUGO|S_IWUSR);
 module_param(hwwep,int, S_IRUGO|S_IWUSR);
 module_param(channels,int, S_IRUGO|S_IWUSR);
-#else
-MODULE_PARM(ifname, "s");
-//MODULE_PARM(hwseqnum,"i");
-MODULE_PARM(hwwep,"i");
-MODULE_PARM(channels,"i");
-#endif
 
 MODULE_PARM_DESC(ifname," Net interface name, wlan%d=default");
 //MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
 MODULE_PARM_DESC(hwwep," Try to use hardware security support. ");
 MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static int __devinit rtl8192_usb_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id);
 static void __devexit rtl8192_usb_disconnect(struct usb_interface *intf);
-#else
-static void *__devinit rtl8192_usb_probe(struct usb_device *udev,unsigned int ifnum,
-			 const struct usb_device_id *id);
-static void __devexit rtl8192_usb_disconnect(struct usb_device *udev, void *ptr);
-#endif
 
 
 static struct usb_driver rtl8192_usb_driver = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
-	.owner		= THIS_MODULE,
-#endif
 	.name		= RTL819xU_MODULE_NAME,		  /* Driver name   */
 	.id_table	= rtl8192_usb_id_tbl,		  /* PCI_ID table  */
 	.probe		= rtl8192_usb_probe,		  /* probe fn      */
 	.disconnect	= rtl8192_usb_disconnect,	  /* remove fn     */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0)
 #ifdef CONFIG_RTL8192_PM
 	.suspend	= rtl8192_suspend,		  /* PM suspend fn */
 	.resume		= rtl8192_resume,                 /* PM resume fn  */
@@ -187,7 +161,6 @@ static struct usb_driver rtl8192_usb_driver = {
 	.suspend	= NULL,				  /* PM suspend fn */
 	.resume      	= NULL,				  /* PM resume fn  */
 #endif
-#endif
 };
 
 #ifdef ENABLE_DOT11D
@@ -280,7 +253,6 @@ static void rtl819x_set_channel_map(u8 channel_plan, struct r8192_priv* priv)
 
 void CamResetAllEntry(struct net_device *dev)
 {
-#if 1
 	u32 ulcommand = 0;
 	//2004/02/11  In static WEP, OID_ADD_KEY or OID_ADD_WEP are set before STA associate to AP.
 	// However, ResetKey is called on OID_802_11_INFRASTRUCTURE_MODE and MlmeAssociateRequest
@@ -293,12 +265,6 @@ void CamResetAllEntry(struct net_device *dev)
 	//DbgPrint("========================================\n\n");
 	ulcommand |= BIT31|BIT30;
 	write_nic_dword(dev, RWCAM, ulcommand);
-#else
-	for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
-		CAM_mark_invalid(dev, ucIndex);
-	for(ucIndex=0;ucIndex<TOTAL_CAM_ENTRY;ucIndex++)
-		CAM_empty_entry(dev, ucIndex);
-#endif
 
 }
 
@@ -513,13 +479,8 @@ inline void force_pci_posting(struct net_device *dev)
 static struct net_device_stats *rtl8192_stats(struct net_device *dev);
 void rtl8192_commit(struct net_device *dev);
 //void rtl8192_restart(struct net_device *dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_restart(struct work_struct *work);
 //void rtl8192_rq_tx_ack(struct work_struct *work);
-#else
- void rtl8192_restart(struct net_device *dev);
-// //void rtl8192_rq_tx_ack(struct net_device *dev);
- #endif
 
 void watch_dog_timer_callback(unsigned long data);
 
@@ -590,7 +551,6 @@ len += snprintf(page + len, count - len,
 
 		//	printk("%2x ",read_nic_byte(dev,n));
 	}
-#if 1
 len += snprintf(page + len, count - len,
 			"\n####################page 1##################\n ");
 	for(n=0;n<=max;)
@@ -620,7 +580,6 @@ len += snprintf(page + len, count - len,
 		//      printk("%2x ",read_nic_byte(dev,n));
 	}
 
-#endif
 
 	len += snprintf(page + len, count - len,"\n");
 	*eof = 1;
@@ -629,98 +588,8 @@ len += snprintf(page + len, count - len,
 }
 
 
-#if 0
-static int proc_get_cck_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-//	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	int len = 0;
-	int i,n;
 
-	int max = 0x5F;
 
-	/* This dump the current register page */
-	for(n=0;n<=max;)
-	{
-		//printk( "\nD: %2x> ", n);
-		len += snprintf(page + len, count - len,
-			"\nD:  %2x > ",n);
-
-		for(i=0;i<16 && n<=max;i++,n++)
-		len += snprintf(page + len, count - len,
-			"%2x ",read_phy_cck(dev,n));
-
-		//	printk("%2x ",read_nic_byte(dev,n));
-	}
-	len += snprintf(page + len, count - len,"\n");
-
-
-	*eof = 1;
-	return len;
-}
-
-#endif
-
-#if 0
-static int proc_get_ofdm_reg(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-//	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	int len = 0;
-	int i,n;
-
-	//int max=0xff;
-	int max = 0x40;
-
-	/* This dump the current register page */
-	for(n=0;n<=max;)
-	{
-		//printk( "\nD: %2x> ", n);
-		len += snprintf(page + len, count - len,
-			"\nD:  %2x > ",n);
-
-		for(i=0;i<16 && n<=max;i++,n++)
-		len += snprintf(page + len, count - len,
-			"%2x ",read_phy_ofdm(dev,n));
-
-		//	printk("%2x ",read_nic_byte(dev,n));
-	}
-	len += snprintf(page + len, count - len,"\n");
-
-
-
-	*eof = 1;
-	return len;
-}
-
-#endif
-
-#if 0
-static int proc_get_stats_hw(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	int len = 0;
-
-	len += snprintf(page + len, count - len,
-		"NIC int: %lu\n"
-		"Total int: %lu\n",
-		priv->stats.ints,
-		priv->stats.shints);
-
-	*eof = 1;
-	return len;
-}
-#endif
 
 static int proc_get_stats_tx(char *page, char **start,
 			  off_t offset, int count,
@@ -818,35 +687,16 @@ static int proc_get_stats_rx(char *page, char **start,
 	*eof = 1;
 	return len;
 }
-#if 0
-#if WIRELESS_EXT >= 12 && WIRELESS_EXT < 17
-
-static struct iw_statistics *r8192_get_wireless_stats(struct net_device *dev)
-{
-       struct r8192_priv *priv = ieee80211_priv(dev);
-
-       return &priv->wstats;
-}
-#endif
-#endif
 void rtl8192_proc_module_init(void)
 {
 	RT_TRACE(COMP_INIT, "Initializing proc filesystem");
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-	rtl8192_proc=create_proc_entry(RTL819xU_MODULE_NAME, S_IFDIR, proc_net);
-#else
 	rtl8192_proc=create_proc_entry(RTL819xU_MODULE_NAME, S_IFDIR, init_net.proc_net);
-#endif
 }
 
 
 void rtl8192_proc_module_remove(void)
 {
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-	remove_proc_entry(RTL819xU_MODULE_NAME, proc_net);
-#else
 	remove_proc_entry(RTL819xU_MODULE_NAME, init_net.proc_net);
-#endif
 }
 
 
@@ -883,16 +733,6 @@ void rtl8192_proc_init_one(struct net_device *dev)
 		      dev->name);
 		return;
 	}
-	#if 0
-	e = create_proc_read_entry("stats-hw", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_hw, dev);
-
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8192/%s/stats-hw\n",
-		      dev->name);
-	}
-	#endif
 	e = create_proc_read_entry("stats-rx", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_rx, dev);
 
@@ -911,17 +751,6 @@ void rtl8192_proc_init_one(struct net_device *dev)
 		      "/proc/net/rtl8192/%s/stats-tx\n",
 		      dev->name);
 	}
-	#if 0
-	e = create_proc_read_entry("stats-ieee", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_ieee, dev);
-
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8192/%s/stats-ieee\n",
-		      dev->name);
-	}
-
-	#endif
 
 	e = create_proc_read_entry("stats-ap", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_ap, dev);
@@ -939,23 +768,6 @@ void rtl8192_proc_init_one(struct net_device *dev)
 		      "/proc/net/rtl8192/%s/registers\n",
 		      dev->name);
 	}
-#if 0
-	e = create_proc_read_entry("cck-registers", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_cck_reg, dev);
-	if (!e) {
-		RT_TRACE(COMP_ERR, "Unable to initialize "
-		      "/proc/net/rtl8192/%s/cck-registers\n",
-		      dev->name);
-	}
-
-	e = create_proc_read_entry("ofdm-registers", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_ofdm_reg, dev);
-	if (!e) {
-		RT_TRACE(COMP_ERR, "Unable to initialize "
-		      "/proc/net/rtl8192/%s/ofdm-registers\n",
-		      dev->name);
-	}
-#endif
 }
 /****************************************************************************
    -----------------------------MISC STUFF-------------------------
@@ -994,11 +806,7 @@ void tx_timeout(struct net_device *dev)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	//rtl8192_commit(dev);
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 	schedule_work(&priv->reset_wq);
-#else
-	schedule_task(&priv->reset_wq);
-#endif
 	//DMESG("TXTIMEOUT");
 }
 
@@ -1033,30 +841,6 @@ void rtl8192_dump_reg(struct net_device *dev)
       ------------------------------HW STUFF---------------------------
 *****************************************************************************/
 
-#if 0
-void rtl8192_irq_enable(struct net_device *dev)
-{
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	//priv->irq_enabled = 1;
-/*
-	write_nic_word(dev,INTA_MASK,INTA_RXOK | INTA_RXDESCERR | INTA_RXOVERFLOW |\
-	INTA_TXOVERFLOW | INTA_HIPRIORITYDESCERR | INTA_HIPRIORITYDESCOK |\
-	INTA_NORMPRIORITYDESCERR | INTA_NORMPRIORITYDESCOK |\
-	INTA_LOWPRIORITYDESCERR | INTA_LOWPRIORITYDESCOK | INTA_TIMEOUT);
-*/
-	write_nic_word(dev,INTA_MASK, priv->irq_mask);
-}
-
-
-void rtl8192_irq_disable(struct net_device *dev)
-{
-//	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	write_nic_word(dev,INTA_MASK,0);
-	force_pci_posting(dev);
-//	priv->irq_enabled = 0;
-}
-#endif
 
 void rtl8192_set_mode(struct net_device *dev,int mode)
 {
@@ -1104,15 +888,6 @@ void rtl8192_set_chan(struct net_device *dev,short ch)
 //	u32 tx;
 	RT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __FUNCTION__, ch);
 	priv->chan=ch;
-	#if 0
-	if(priv->ieee80211->iw_mode == IW_MODE_ADHOC ||
-		priv->ieee80211->iw_mode == IW_MODE_MASTER){
-
-			priv->ieee80211->link_state = WLAN_LINK_ASSOCIATED;
-			priv->ieee80211->master_chan = ch;
-			rtl8192_update_beacon_ch(dev);
-		}
-	#endif
 
 	/* this hack should avoid frame TX during channel setting*/
 
@@ -1132,11 +907,7 @@ void rtl8192_set_chan(struct net_device *dev,short ch)
 #endif
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static void rtl8192_rx_isr(struct urb *urb, struct pt_regs *regs);
-#else
 static void rtl8192_rx_isr(struct urb *urb);
-#endif
 //static void rtl8192_rx_isr(struct urb *rx_urb);
 
 u32 get_rxpacket_shiftbytes_819xusb(struct ieee80211_rx_stats *pstats)
@@ -1164,11 +935,7 @@ static int rtl8192_rx_initiate(struct net_device*dev)
 		skb = __dev_alloc_skb(RX_URB_SIZE, GFP_KERNEL);
 		if (!skb)
 			break;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		entry = usb_alloc_urb(0, GFP_KERNEL);
-#else
-		entry = usb_alloc_urb(0);
-#endif
 		if (!entry) {
 			kfree_skb(skb);
 			break;
@@ -1191,11 +958,7 @@ static int rtl8192_rx_initiate(struct net_device*dev)
 		skb = __dev_alloc_skb(RX_URB_SIZE ,GFP_KERNEL);
 		if (!skb)
 			break;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		entry = usb_alloc_urb(0, GFP_KERNEL);
-#else
-		entry = usb_alloc_urb(0);
-#endif
 		if (!entry) {
 			kfree_skb(skb);
 			break;
@@ -1277,106 +1040,14 @@ void rtl8192_rx_enable(struct net_device *dev)
 	rtl8192_rx_initiate(dev);
 
 //	rtl8192_set_rxconf(dev);
-#if 0
-	if(NIC_8187 == priv->card_8187) {
-		cmd=read_nic_byte(dev,CMD);
-		write_nic_byte(dev,CMD,cmd | (1<<CMD_RX_ENABLE_SHIFT));
-	}
-	else {
-		//write_nic_dword(dev, RX_CONF, priv->ReceiveConfig);
-	}
-#endif
 }
 
 
 void rtl8192_tx_enable(struct net_device *dev)
 {
-#if 0
-	u8 cmd;
-	u8 byte;
-	u32 txconf;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	//test loopback
-	//	priv->TransmitConfig |= (TX_LOOPBACK_BASEBAND<<TX_LOOPBACK_SHIFT);
-	if(NIC_8187B == priv->card_8187){
-		write_nic_dword(dev, TX_CONF, priv->TransmitConfig);
-		byte = read_nic_byte(dev, MSR);
-		byte |= MSR_LINK_ENEDCA;
-		write_nic_byte(dev, MSR, byte);
-	} else {
-		byte = read_nic_byte(dev,CW_CONF);
-		byte &= ~(1<<CW_CONF_PERPACKET_CW_SHIFT);
-		byte &= ~(1<<CW_CONF_PERPACKET_RETRY_SHIFT);
-		write_nic_byte(dev, CW_CONF, byte);
-
-		byte = read_nic_byte(dev, TX_AGC_CTL);
-		byte &= ~(1<<TX_AGC_CTL_PERPACKET_GAIN_SHIFT);
-		byte &= ~(1<<TX_AGC_CTL_PERPACKET_ANTSEL_SHIFT);
-		byte &= ~(1<<TX_AGC_CTL_FEEDBACK_ANT);
-		write_nic_byte(dev, TX_AGC_CTL, byte);
-
-		txconf= read_nic_dword(dev,TX_CONF);
-
-
-		txconf = txconf &~ TX_LOOPBACK_MASK;
-
-#ifndef LOOP_TEST
-		txconf = txconf | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT);
-#else
-		txconf = txconf | (TX_LOOPBACK_BASEBAND<<TX_LOOPBACK_SHIFT);
-#endif
-		txconf = txconf &~ TCR_SRL_MASK;
-		txconf = txconf &~ TCR_LRL_MASK;
-
-		txconf = txconf | (priv->retry_data<<TX_LRLRETRY_SHIFT); // long
-		txconf = txconf | (priv->retry_rts<<TX_SRLRETRY_SHIFT); // short
-
-		txconf = txconf &~ (1<<TX_NOCRC_SHIFT);
-
-		txconf = txconf &~ TCR_MXDMA_MASK;
-		txconf = txconf | (TCR_MXDMA_2048<<TCR_MXDMA_SHIFT);
-
-		txconf = txconf | TCR_DISReqQsize;
-		txconf = txconf | TCR_DISCW;
-		txconf = txconf &~ TCR_SWPLCPLEN;
-
-		txconf=txconf | (1<<TX_NOICV_SHIFT);
-
-		write_nic_dword(dev,TX_CONF,txconf);
-
-#ifdef DEBUG_TX
-		DMESG("txconf: %x %x",txconf,read_nic_dword(dev,TX_CONF));
-#endif
-
-		cmd=read_nic_byte(dev,CMD);
-		write_nic_byte(dev,CMD,cmd | (1<<CMD_TX_ENABLE_SHIFT));
-	}
-#endif
-}
-
-#if 0
-void rtl8192_beacon_tx_enable(struct net_device *dev)
-{
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask &=~(1<<TX_DMA_STOP_BEACON_SHIFT);
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-	rtl8192_set_mode(dev,EPROM_CMD_NORMAL);
 }
 
 
-void rtl8192_
-_disable(struct net_device *dev)
-{
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask |= (1<<TX_DMA_STOP_BEACON_SHIFT);
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-	rtl8192_set_mode(dev,EPROM_CMD_NORMAL);
-}
-
-#endif
-
 
 void rtl8192_rtx_disable(struct net_device *dev)
 {
@@ -1411,91 +1082,9 @@ void rtl8192_rtx_disable(struct net_device *dev)
 
 int alloc_tx_beacon_desc_ring(struct net_device *dev, int count)
 {
-	#if 0
-	int i;
-	u32 *tmp;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-
-	priv->txbeaconring = (u32*)pci_alloc_consistent(priv->pdev,
-					  sizeof(u32)*8*count,
-					  &priv->txbeaconringdma);
-	if (!priv->txbeaconring) return -1;
-	for (tmp=priv->txbeaconring,i=0;i<count;i++){
-		*tmp = *tmp &~ (1<<31); // descriptor empty, owned by the drv
-		/*
-		*(tmp+2) = (u32)dma_tmp;
-		*(tmp+3) = bufsize;
-		*/
-		if(i+1<count)
-			*(tmp+4) = (u32)priv->txbeaconringdma+((i+1)*8*4);
-		else
-			*(tmp+4) = (u32)priv->txbeaconringdma;
-
-		tmp=tmp+8;
-	}
-	#endif
 	return 0;
 }
 
-#if 0
-void rtl8192_reset(struct net_device *dev)
-{
-
-	//struct r8192_priv *priv = ieee80211_priv(dev);
-	//u8 cr;
-
-
-	/* make sure the analog power is on before
-	 * reset, otherwise reset may fail
-	 */
-#if 0
-	if(NIC_8187 == priv->card_8187) {
-		rtl8192_set_anaparam(dev, RTL8225_ANAPARAM_ON);
-		rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
-		rtl8192_irq_disable(dev);
-		mdelay(200);
-		write_nic_byte_E(dev,0x18,0x10);
-		write_nic_byte_E(dev,0x18,0x11);
-		write_nic_byte_E(dev,0x18,0x00);
-		mdelay(200);
-	}
-#endif
-	printk("=====>reset?\n");
-#if 0
-	cr=read_nic_byte(dev,CMD);
-	cr = cr & 2;
-	cr = cr | (1<<CMD_RST_SHIFT);
-	write_nic_byte(dev,CMD,cr);
-
-	force_pci_posting(dev);
-
-	mdelay(200);
-
-	if(read_nic_byte(dev,CMD) & (1<<CMD_RST_SHIFT))
-		RT_TRACE(COMP_ERR, "Card reset timeout!\n");
-	else
-		RT_TRACE(COMP_DOWN, "Card successfully reset\n");
-#endif
-#if 0
-	if(NIC_8187 == priv->card_8187) {
-
-		printk("This is RTL8187 Reset procedure\n");
-		rtl8192_set_mode(dev,EPROM_CMD_LOAD);
-		force_pci_posting(dev);
-		mdelay(200);
-
-		/* after the eeprom load cycle, make sure we have
-		 * correct anaparams
-		 */
-		rtl8192_set_anaparam(dev, RTL8225_ANAPARAM_ON);
-		rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
-	}
-	else
-#endif
-		printk("This is RTL8187B Reset procedure\n");
-
-}
-#endif
 inline u16 ieeerate2rtlrate(int rate)
 {
 	switch(rate){
@@ -1537,11 +1126,7 @@ inline u16 rtl8192_rate2rate(short rate)
 
 
 /* The protype of rx_isr has changed since one verion of Linux Kernel */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static void rtl8192_rx_isr(struct urb *urb, struct pt_regs *regs)
-#else
 static void rtl8192_rx_isr(struct urb *urb)
-#endif
 {
 	struct sk_buff *skb = (struct sk_buff *) urb->context;
 	struct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;
@@ -1559,11 +1144,7 @@ static void rtl8192_rx_isr(struct urb *urb)
 	//	printk("%s():rx status err\n",__FUNCTION__);
 		return;
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
 	skb_unlink(skb, &priv->rx_queue);
-#else
-	__skb_unlink(skb,&priv->rx_queue);
-#endif
 	skb_put(skb, urb->actual_length);
 
 	skb_queue_tail(&priv->skb_queue, skb);
@@ -1618,44 +1199,16 @@ rtl819xusb_rx_command_packet(
 	return status;
 }
 
-#if 0
-void rtl8192_tx_queues_stop(struct net_device *dev)
-{
-	//struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	u8 dma_poll_mask = (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_HIPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_NORMPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_BEACON_SHIFT);
-
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,dma_poll_mask);
-	rtl8192_set_mode(dev,EPROM_CMD_NORMAL);
-}
-#endif
 
 void rtl8192_data_hard_stop(struct net_device *dev)
 {
 	//FIXME !!
-	#if 0
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask |= (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-	rtl8192_set_mode(dev,EPROM_CMD_NORMAL);
-	#endif
 }
 
 
 void rtl8192_data_hard_resume(struct net_device *dev)
 {
 	// FIXME !!
-	#if 0
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask &= ~(1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-	rtl8192_set_mode(dev,EPROM_CMD_NORMAL);
-	#endif
 }
 
 /* this function TX data frames when the ieee80211 stack requires this.
@@ -1739,11 +1292,7 @@ u8 QueryIsShort(u8 TxHT, u8 TxRate, cb_desc *tcb_desc);
 u8 MapHwQueueToFirmwareQueue(u8 QueueID);
 struct sk_buff *DrvAggr_Aggregation(struct net_device *dev, struct ieee80211_drv_agg_txb *pSendList)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	struct ieee80211_device *ieee = netdev_priv(dev);
-#else
-	struct ieee80211_device *ieee = (struct ieee80211_device *)dev->priv;
-#endif
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	cb_desc 	*tcb_desc = NULL;
 	u8 		i;
@@ -1854,53 +1403,11 @@ struct sk_buff *DrvAggr_Aggregation(struct net_device *dev, struct ieee80211_drv
 		/*DWORD 1*/
 		tx_agg_desc->SecCAMID= 0;
 		tx_agg_desc->RATid = tcb_desc->RATRIndex;
-#if 0
-		/* Fill security related */
-		if( pTcb->bEncrypt && !Adapter->MgntInfo.SecurityInfo.SWTxEncryptFlag)
-		{
-			EncAlg = SecGetEncryptionOverhead(
-					Adapter,
-					&EncryptionMPDUHeadOverhead,
-					&EncryptionMPDUTailOverhead,
-					NULL,
-					NULL,
-					FALSE,
-					FALSE);
-			//2004/07/22, kcwu, EncryptionMPDUHeadOverhead has been added in previous code
-			//MPDUOverhead = EncryptionMPDUHeadOverhead + EncryptionMPDUTailOverhead;
-			MPDUOverhead = EncryptionMPDUTailOverhead;
-			tx_agg_desc->NoEnc = 0;
-			RT_TRACE(COMP_SEC, DBG_LOUD, ("******We in the loop SecCAMID is %d SecDescAssign is %d The Sec is %d********\n",tx_agg_desc->SecCAMID,tx_agg_desc->SecDescAssign,EncAlg));
-			//CamDumpAll(Adapter);
-		}
-		else
-#endif
 		{
 			//MPDUOverhead = 0;
 			tx_agg_desc->NoEnc = 1;
 		}
-#if 0
-		switch(EncAlg){
-			case NO_Encryption:
-				tx_agg_desc->SecType = 0x0;
-				break;
-			case WEP40_Encryption:
-			case WEP104_Encryption:
-				tx_agg_desc->SecType = 0x1;
-				break;
-			case TKIP_Encryption:
-				tx_agg_desc->SecType = 0x2;
-				break;
-			case AESCCMP_Encryption:
-				tx_agg_desc->SecType = 0x3;
-				break;
-			default:
-				tx_agg_desc->SecType = 0x0;
-				break;
-		}
-#else
 		tx_agg_desc->SecType = 0x0;
-#endif
 
 		if (tcb_desc->bHwSec) {
 			switch (priv->ieee80211->pairwise_key_type)
@@ -1956,11 +1463,7 @@ struct sk_buff *DrvAggr_Aggregation(struct net_device *dev, struct ieee80211_drv
 u8 DrvAggr_GetAggregatibleList(struct net_device *dev, struct sk_buff *skb,
 		struct ieee80211_drv_agg_txb *pSendList)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	struct ieee80211_device *ieee = netdev_priv(dev);
-#else
-	struct ieee80211_device *ieee = (struct ieee80211_device *)dev->priv;
-#endif
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	u16		nMaxAggrNum = pHTInfo->UsbTxAggrNum;
 	cb_desc 	*tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
@@ -1979,11 +1482,7 @@ u8 DrvAggr_GetAggregatibleList(struct net_device *dev, struct sk_buff *skb,
 }
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static void rtl8192_tx_isr(struct urb *tx_urb, struct pt_regs *reg)
-#else
 static void rtl8192_tx_isr(struct urb *tx_urb)
-#endif
 {
 	struct sk_buff *skb = (struct sk_buff*)tx_urb->context;
 	struct net_device *dev = NULL;
@@ -2019,29 +1518,11 @@ static void rtl8192_tx_isr(struct urb *tx_urb)
 		atomic_dec(&priv->tx_pending[queue_index]);
 	}
 
-#if 0  //we need to send zero byte packet just after 512 byte(64 byte)packet is transmitted, or we will halt. It will greatly reduced available page in FW, and ruin our throughput. WB 2008.08.27
-	if(BufLen > 0 && ((BufLen % 512 == 0)||(BufLen % 64 == 0))) {
-		bToSend0Byte = true;
-	}
-
-	bToSend0Byte = false;
-	//
-	// Note that, we at most handle 1 MPDU to send here, either
-	// fragment or MPDU in wait queue.
-	//
-	if(!bToSend0Byte)
-#endif
 	{
 		//
 		// Handle HW Beacon:
 		// We had transfer our beacon frame to host controler at this moment.
 		//
-#if 0
-		if(tcb_desc->tx_queue == BEACON_QUEUE)
-		{
-			priv->bSendingBeacon = FALSE;
-		}
-#endif
 		//
 		// Caution:
 		// Handling the wait queue of command packets.
@@ -2095,12 +1576,6 @@ static void rtl8192_tx_isr(struct urb *tx_urb)
 						if(DrvAggr_GetAggregatibleList(dev, skb, &SendList) > 1) {
 							skb = DrvAggr_Aggregation(dev, &SendList);
 
-#if 0
-						printk("=============>to send aggregated packet!\n");
-						RT_DEBUG_DATA(COMP_SEND, skb->cb, sizeof(skb->cb));
-						printk("\n=================skb->len = %d\n", skb->len);
-						RT_DEBUG_DATA(COMP_SEND, skb->data, skb->len);
-#endif
 						}
 					}
 					priv->ieee80211->softmac_hard_start_xmit(skb, dev);
@@ -2110,23 +1585,6 @@ static void rtl8192_tx_isr(struct urb *tx_urb)
 		}
 	}
 
-#if 0
-	else
-	{
-		RT_TRACE( COMP_SEND,"HalUsbOutComplete(%d): bToSend0Byte.\n", PipeIndex);
-
-		//
-		// In this case, we don't return skb now.
-		// It will be returned when the 0-byte request completed.
-		//
-
-		//
-		// Bulk out an 0-byte padding transfer.
-		//
-		HalUsbOut0Byte(pAdapter, PipeIndex, skb);
-	}
-
-#endif
 }
 
 void rtl8192_beacon_stop(struct net_device *dev)
@@ -2264,46 +1722,10 @@ void rtl8192_net_update(struct net_device *dev)
 
 //temporary hw beacon is not used any more.
 //open it when necessary
-#if 1
 void rtl819xusb_beacon_tx(struct net_device *dev,u16  tx_rate)
 {
 
-#if 0
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	struct sk_buff *skb;
-	int i = 0;
-	//u8 cr;
-
-	rtl8192_net_update(dev);
-
-	skb = ieee80211_get_beacon(priv->ieee80211);
-		if(!skb){
-			DMESG("not enought memory for allocating beacon");
-			return;
-		}
-
-
-		write_nic_byte(dev, BQREQ, read_nic_byte(dev, BQREQ) | (1<<7));
-
-		i=0;
-		//while(!read_nic_byte(dev,BQREQ & (1<<7)))
-		while( (read_nic_byte(dev, BQREQ) & (1<<7)) == 0 )
-		{
-			msleep_interruptible_rtl(HZ/2);
-			if(i++ > 10){
-				DMESGW("get stuck to wait HW beacon to be ready");
-				return ;
-			}
-		}
-	skb->cb[0] = NORM_PRIORITY;
-	skb->cb[1] = 0; //morefragment = 0
-	skb->cb[2] = ieeerate2rtlrate(tx_rate);
-
-	rtl8192_tx(dev,skb);
-
-#endif
 }
-#endif
 inline u8 rtl8192_IsWirelessBMode(u16 rate)
 {
 	if( ((rate <= 110) && (rate != 60) && (rate != 90)) || (rate == 220) )
@@ -2392,38 +1814,6 @@ u16 N_DBPSOfRate(u16 DataRate)
 
 void rtl819xU_cmd_isr(struct urb *tx_cmd_urb, struct pt_regs *regs)
 {
-#if 0
-	struct net_device *dev = (struct net_device*)tx_cmd_urb->context;
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	int		   last_init_packet = 0;
-	u8		   *ptr_cmd_buf;
-	u16		    cmd_buf_len;
-
-	if(tx_cmd_urb->status != 0) {
-		priv->pFirmware.firmware_seg_index = 0; //only begin transter, should it can be set to 1
-	}
-
-	/* Free the urb and the corresponding buf for common Tx cmd packet, or
-	 * last segment of each firmware img.
-	 */
-	if((priv->pFirmware.firmware_seg_index == 0) ||(priv->pFirmware.firmware_seg_index == priv->pFirmware.firmware_seg_maxnum)) {
-		priv->pFirmware.firmware_seg_index = 0;//only begin transter, should it can be set to 1
-	} else {
-		/* prepare for last transfer */
-		/* update some infomation for */
-		/* last segment of the firmware img need indicate to device */
-		priv->pFirmware.firmware_seg_index++;
-		if(priv->pFirmware.firmware_seg_index == priv->pFirmware.firmware_seg_maxnum) {
-			last_init_packet = 1;
-		}
-
-		cmd_buf_len = priv->pFirmware.firmware_seg_container[priv->pFirmware.firmware_seg_index-1].seg_size;
-		ptr_cmd_buf = priv->pFfirmware.firmware_seg_container[priv->pFfirmware.firmware_seg_index-1].seg_ptr;
-		rtl819xU_tx_cmd(dev, ptr_cmd_buf, cmd_buf_len, last_init_packet, DESC_PACKET_TYPE_INIT);
-	}
-
-	kfree(tx_cmd_urb->transfer_buffer);
-#endif
 	usb_free_urb(tx_cmd_urb);
 }
 
@@ -2451,11 +1841,7 @@ short rtl819xU_tx_cmd(struct net_device *dev, struct sk_buff *skb)
 
 	//printk("\n %s::queue_index = %d\n",__FUNCTION__, queue_index);
 	atomic_inc(&priv->tx_pending[queue_index]);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
-#else
-	tx_urb = usb_alloc_urb(0);
-#endif
 	if(!tx_urb){
 		dev_kfree_skb(skb);
 		return -ENOMEM;
@@ -2489,11 +1875,7 @@ short rtl819xU_tx_cmd(struct net_device *dev, struct sk_buff *skb)
 	usb_fill_bulk_urb(tx_urb,priv->udev, usb_sndbulkpipe(priv->udev,idx_pipe), \
 			skb->data, skb->len, rtl8192_tx_isr, skb);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	status = usb_submit_urb(tx_urb, GFP_ATOMIC);
-#else
-	status = usb_submit_urb(tx_urb);
-#endif
 
 	if (!status){
 		return 0;
@@ -2612,11 +1994,7 @@ u8 QueryIsShort(u8 TxHT, u8 TxRate, cb_desc *tcb_desc)
 	return tmp_Short;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static void tx_zero_isr(struct urb *tx_urb, struct pt_regs *reg)
-#else
 static void tx_zero_isr(struct urb *tx_urb)
-#endif
 {
 	return;
 }
@@ -2639,10 +2017,6 @@ short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
 	//int urb_len;
 	unsigned int idx_pipe;
 //	RT_DEBUG_DATA(COMP_SEND, tcb_desc, sizeof(cb_desc));
-#if 0
-	/* Added by Annie for filling Len_Adjust field. 2005-12-14. */
-	RT_ENC_ALG  EncAlg = NO_Encryption;
-#endif
 //	printk("=============> %s\n", __FUNCTION__);
 	pend = atomic_read(&priv->tx_pending[tcb_desc->queue_index]);
 	/* we are locked here so the two atomic_read and inc are executed
@@ -2650,32 +2024,12 @@ short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
 	 * !!! For debug purpose
 	 */
 	if( pend > MAX_TX_URB){
-#if 0
-		switch (tcb_desc->queue_index) {
-			case VO_PRIORITY:
-				priv->stats.txvodrop++;
-				break;
-			case VI_PRIORITY:
-				priv->stats.txvidrop++;
-				break;
-			case BE_PRIORITY:
-				priv->stats.txbedrop++;
-				break;
-			default://BK_PRIORITY
-				priv->stats.txbkdrop++;
-				break;
-		}
-#endif
 		printk("To discard skb packet!\n");
 		dev_kfree_skb_any(skb);
 		return -1;
 	}
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
-#else
-	tx_urb = usb_alloc_urb(0);
-#endif
 	if(!tx_urb){
 		dev_kfree_skb_any(skb);
 		return -ENOMEM;
@@ -2751,53 +2105,11 @@ short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
 	/*DWORD 1*/
 	tx_desc->SecCAMID= 0;
 	tx_desc->RATid = tcb_desc->RATRIndex;
-#if 0
-	/* Fill security related */
-	if( pTcb->bEncrypt && !Adapter->MgntInfo.SecurityInfo.SWTxEncryptFlag)
-	{
-		EncAlg = SecGetEncryptionOverhead(
-				Adapter,
-				&EncryptionMPDUHeadOverhead,
-				&EncryptionMPDUTailOverhead,
-				NULL,
-				NULL,
-				FALSE,
-				FALSE);
-		//2004/07/22, kcwu, EncryptionMPDUHeadOverhead has been added in previous code
-		//MPDUOverhead = EncryptionMPDUHeadOverhead + EncryptionMPDUTailOverhead;
-		MPDUOverhead = EncryptionMPDUTailOverhead;
-		tx_desc->NoEnc = 0;
-		RT_TRACE(COMP_SEC, DBG_LOUD, ("******We in the loop SecCAMID is %d SecDescAssign is %d The Sec is %d********\n",tx_desc->SecCAMID,tx_desc->SecDescAssign,EncAlg));
-		//CamDumpAll(Adapter);
-	}
-	else
-#endif
 	{
 		//MPDUOverhead = 0;
 		tx_desc->NoEnc = 1;
 	}
-#if 0
-	switch(EncAlg){
-		case NO_Encryption:
-			tx_desc->SecType = 0x0;
-			break;
-		case WEP40_Encryption:
-		case WEP104_Encryption:
-			tx_desc->SecType = 0x1;
-			break;
-		case TKIP_Encryption:
-			tx_desc->SecType = 0x2;
-			break;
-		case AESCCMP_Encryption:
-			tx_desc->SecType = 0x3;
-			break;
-		default:
-			tx_desc->SecType = 0x0;
-			break;
-	}
-#else
 	tx_desc->SecType = 0x0;
-#endif
 		if (tcb_desc->bHwSec)
 			{
 				switch (priv->ieee80211->pairwise_key_type)
@@ -2830,13 +2142,8 @@ short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
 
 	/* Fill fields that are required to be initialized in all of the descriptors */
 	//DWORD 0
-#if 0
-	tx_desc->FirstSeg = (tcb_desc->bFirstSeg)? 1:0;
-	tx_desc->LastSeg = (tcb_desc->bLastSeg)?1:0;
-#else
 	tx_desc->FirstSeg = 1;
 	tx_desc->LastSeg = 1;
-#endif
 	tx_desc->OWN = 1;
 
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
@@ -2863,11 +2170,7 @@ short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
 			usb_sndbulkpipe(udev,idx_pipe), skb->data,
 			skb->len, rtl8192_tx_isr, skb);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	status = usb_submit_urb(tx_urb, GFP_ATOMIC);
-#else
-	status = usb_submit_urb(tx_urb);
-#endif
 	if (!status){
 //we need to send 0 byte packet whenever 512N bytes/64N(HIGN SPEED/NORMAL SPEED) bytes packet has been transmitted. Otherwise, it will be halt to wait for another packet. WB. 2008.08.27
 		bool bSend0Byte = false;
@@ -2884,12 +2187,7 @@ short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
 		}
 		if (bSend0Byte)
 		{
-#if 1
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			tx_urb_zero = usb_alloc_urb(0,GFP_ATOMIC);
-#else
-			tx_urb_zero = usb_alloc_urb(0);
-#endif
 			if(!tx_urb_zero){
 				RT_TRACE(COMP_ERR, "can't alloc urb for zero byte\n");
 				return -ENOMEM;
@@ -2897,16 +2195,11 @@ short rtl8192_tx(struct net_device *dev, struct sk_buff* skb)
 			usb_fill_bulk_urb(tx_urb_zero,udev,
 					usb_sndbulkpipe(udev,idx_pipe), &zero,
 					0, tx_zero_isr, dev);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			status = usb_submit_urb(tx_urb_zero, GFP_ATOMIC);
-#else
-			status = usb_submit_urb(tx_urb_zero);
-#endif
 			if (status){
 			RT_TRACE(COMP_ERR, "Error TX URB for zero byte %d, error %d", atomic_read(&priv->tx_pending[tcb_desc->queue_index]), status);
 			return -1;
 			}
-#endif
 		}
 		dev->trans_start = jiffies;
 		atomic_inc(&priv->tx_pending[tcb_desc->queue_index]);
@@ -2927,11 +2220,7 @@ short rtl8192_usb_initendpoints(struct net_device *dev)
 #ifndef JACKSON_NEW_RX
 	for(i=0;i<(MAX_RX_URB+1);i++){
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		priv->rx_urb[i] = usb_alloc_urb(0,GFP_KERNEL);
-#else
-		priv->rx_urb[i] = usb_alloc_urb(0);
-#endif
 
 		priv->rx_urb[i]->transfer_buffer = kmalloc(RX_URB_SIZE, GFP_KERNEL);
 
@@ -3050,44 +2339,6 @@ void rtl8192_usb_deleteendpoints(struct net_device *dev)
 }
 #endif
 
-#if 0
-void rtl8192_set_rate(struct net_device *dev)
-{
-	int i;
-	u16 word;
-	int basic_rate,min_rr_rate,max_rr_rate;
-
-//	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	//if (ieee80211_is_54g(priv->ieee80211->current_network) &&
-//		priv->ieee80211->state == IEEE80211_LINKED){
-	basic_rate = ieeerate2rtlrate(240);
-	min_rr_rate = ieeerate2rtlrate(60);
-	max_rr_rate = ieeerate2rtlrate(240);
-
-//
-//	}else{
-//		basic_rate = ieeerate2rtlrate(20);
-//		min_rr_rate = ieeerate2rtlrate(10);
-//		max_rr_rate = ieeerate2rtlrate(110);
-//	}
-
-	write_nic_byte(dev, RESP_RATE,
-			max_rr_rate<<MAX_RESP_RATE_SHIFT| min_rr_rate<<MIN_RESP_RATE_SHIFT);
-
-	//word  = read_nic_word(dev, BRSR);
-	word  = read_nic_word(dev, BRSR_8187);
-	word &= ~BRSR_MBR_8185;
-
-
-	for(i=0;i<=basic_rate;i++)
-		word |= (1<<i);
-
-	//write_nic_word(dev, BRSR, word);
-	write_nic_word(dev, BRSR_8187, word);
-	//DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE), read_nic_word(dev,BRSR));
-}
-#endif
 extern void rtl8192_update_ratr_table(struct net_device* dev);
 void rtl8192_link_change(struct net_device *dev)
 {
@@ -3100,11 +2351,9 @@ void rtl8192_link_change(struct net_device *dev)
 	{
 		rtl8192_net_update(dev);
 		rtl8192_update_ratr_table(dev);
-#if 1
 		//add this as in pure N mode, wep encryption will use software way, but there is no chance to set this as wep will not set group key in wext. WB.2008.07.08
 		if ((KEY_TYPE_WEP40 == ieee->pairwise_key_type) || (KEY_TYPE_WEP104 == ieee->pairwise_key_type))
 		EnableHWSecurityConfig8192(dev);
-#endif
 	}
 	/*update timing params*/
 //	RT_TRACE(COMP_CH, "========>%s(), chan:%d\n", __FUNCTION__, priv->chan);
@@ -3132,16 +2381,10 @@ static struct ieee80211_qos_parameters def_qos_parameters = {
 };
 
 
-#if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 void rtl8192_update_beacon(struct work_struct * work)
 {
         struct r8192_priv *priv = container_of(work, struct r8192_priv, update_beacon_wq.work);
         struct net_device *dev = priv->ieee80211->dev;
-#else
-void rtl8192_update_beacon(struct net_device *dev)
-{
-        struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
  	struct ieee80211_device* ieee = priv->ieee80211;
 	struct ieee80211_network* net = &ieee->current_network;
 
@@ -3154,16 +2397,10 @@ void rtl8192_update_beacon(struct net_device *dev)
 * background support to run QoS activate functionality
 */
 int WDCAPARA_ADD[] = {EDCAPARA_BE,EDCAPARA_BK,EDCAPARA_VI,EDCAPARA_VO};
-#if LINUX_VERSION_CODE >=KERNEL_VERSION(2,6,20)
 void rtl8192_qos_activate(struct work_struct * work)
 {
 	struct r8192_priv *priv = container_of(work, struct r8192_priv, qos_activate);
 	struct net_device *dev = priv->ieee80211->dev;
-#else
-void rtl8192_qos_activate(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 	struct ieee80211_qos_parameters *qos_parameters = &priv->ieee80211->current_network.qos_data.parameters;
 	u8 mode = priv->ieee80211->current_network.mode;
 	//u32 size = sizeof(struct ieee80211_qos_parameters);
@@ -3174,11 +2411,7 @@ void rtl8192_qos_activate(struct net_device *dev)
 	if (priv == NULL)
 		return;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	down(&priv->mutex);
-#else
        mutex_lock(&priv->mutex);
-#endif
 	if(priv->ieee80211->state != IEEE80211_LINKED)
 		goto success;
 	RT_TRACE(COMP_QOS,"qos active process with associate response received\n");
@@ -3198,11 +2431,7 @@ void rtl8192_qos_activate(struct net_device *dev)
 	}
 
 success:
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	up(&priv->mutex);
-#else
        mutex_unlock(&priv->mutex);
-#endif
 }
 
 static int rtl8192_qos_handle_probe_response(struct r8192_priv *priv,
@@ -3229,11 +2458,7 @@ static int rtl8192_qos_handle_probe_response(struct r8192_priv *priv,
 				 network->qos_data.param_count)) {
 			network->qos_data.old_param_count =
 				network->qos_data.param_count;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			queue_work(priv->priv_wq, &priv->qos_activate);
-#else
-			schedule_task(&priv->qos_activate);
-#endif
 			RT_TRACE (COMP_QOS, "QoS parameters change call "
 					"qos_activate\n");
 		}
@@ -3242,11 +2467,7 @@ static int rtl8192_qos_handle_probe_response(struct r8192_priv *priv,
 		       &def_qos_parameters, size);
 
 		if ((network->qos_data.active == 1) && (active_network == 1)) {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			queue_work(priv->priv_wq, &priv->qos_activate);
-#else
-			schedule_task(&priv->qos_activate);
-#endif
 			RT_TRACE(COMP_QOS, "QoS was disabled call qos_activate \n");
 		}
 		network->qos_data.active = 0;
@@ -3264,16 +2485,7 @@ static int rtl8192_handle_beacon(struct net_device * dev,
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 	rtl8192_qos_handle_probe_response(priv,1,network);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	queue_delayed_work(priv->priv_wq, &priv->update_beacon_wq, 0);
-#else
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	schedule_task(&priv->update_beacon_wq);
-#else
-	queue_work(priv->priv_wq, &priv->update_beacon_wq);
-#endif
-
-#endif
 	return 0;
 
 }
@@ -3306,10 +2518,6 @@ static int rtl8192_qos_association_resp(struct r8192_priv *priv,
 			 &network->qos_data.parameters,\
 			sizeof(struct ieee80211_qos_parameters));
 		priv->ieee80211->current_network.qos_data.active = 1;
-#if 0
-		if((priv->ieee80211->current_network.qos_data.param_count != \
-					network->qos_data.param_count))
-#endif
 		 {
 			set_qos_param = 1;
 			/* update qos parameter for current network */
@@ -3330,11 +2538,7 @@ static int rtl8192_qos_association_resp(struct r8192_priv *priv,
 
 	RT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n",__FUNCTION__,network->flags ,priv->ieee80211->current_network.qos_data.active);
 	if (set_qos_param == 1)
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		queue_work(priv->priv_wq, &priv->qos_activate);
-#else
-		schedule_task(&priv->qos_activate);
-#endif
 
 
 	return ret;
@@ -3404,7 +2608,6 @@ static u8 ccmp_ie[4] = {0x00,0x50,0xf2,0x04};
 static u8 ccmp_rsn_ie[4] = {0x00, 0x0f, 0xac, 0x04};
 bool GetNmodeSupportBySecCfg8192(struct net_device*dev)
 {
-#if 1
 	struct r8192_priv* priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
 	struct ieee80211_network * network = &ieee->current_network;
@@ -3432,20 +2635,7 @@ bool GetNmodeSupportBySecCfg8192(struct net_device*dev)
 		return true;
 	}
 
-#if 0
-	//In here we discuss with SD4 David. He think we still can send TKIP in broadcast group key in MCS rate.
-	//We can't force in G mode if Pairwie key is AES and group key is TKIP
-	if((pSecInfo->GroupEncAlgorithm == WEP104_Encryption) || (pSecInfo->GroupEncAlgorithm == WEP40_Encryption)  ||
-	   (pSecInfo->PairwiseEncAlgorithm == WEP104_Encryption) ||
-	   (pSecInfo->PairwiseEncAlgorithm == WEP40_Encryption) || (pSecInfo->PairwiseEncAlgorithm == TKIP_Encryption))
-	{
-		return  false;
-	}
-	else
-		return true;
-#endif
 	return true;
-#endif
 }
 
 bool GetHalfNmodeSupportByAPs819xUsb(struct net_device* dev)
@@ -3502,7 +2692,6 @@ void rtl8192_SetWirelessMode(struct net_device* dev, u8 wireless_mode)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 bSupportMode = rtl8192_getSupportedWireleeMode(dev);
 
-#if 1
 	if ((wireless_mode == WIRELESS_MODE_AUTO) || ((wireless_mode&bSupportMode)==0))
 	{
 		if(bSupportMode & WIRELESS_MODE_N_24G)
@@ -3541,7 +2730,6 @@ void rtl8192_SetWirelessMode(struct net_device* dev, u8 wireless_mode)
 		priv->ieee80211->pHTInfo->bEnableHT = 0;
 	RT_TRACE(COMP_INIT, "Current Wireless Mode is %x\n", wireless_mode);
 	rtl8192_refresh_supportrate(priv);
-#endif
 
 }
 //init priv variables here. only non_zero value should be initialized here.
@@ -3679,18 +2867,10 @@ static void rtl8192_init_priv_lock(struct r8192_priv* priv)
 	//spin_lock_init(&priv->rf_lock);
 	sema_init(&priv->wx_sem,1);
 	sema_init(&priv->rf_sem,1);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16))
-	sema_init(&priv->mutex, 1);
-#else
 	mutex_init(&priv->mutex);
-#endif
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern  void    rtl819x_watchdog_wqcallback(struct work_struct *work);
-#else
-extern  void    rtl819x_watchdog_wqcallback(struct net_device *dev);
-#endif
 
 void rtl8192_irq_rx_tasklet(struct r8192_priv *priv);
 //init tasklet and wait_queue here. only 2.6 above kernel is considered
@@ -3699,15 +2879,12 @@ static void rtl8192_init_priv_task(struct net_device* dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 #ifdef PF_SYNCTHREAD
 	priv->priv_wq = create_workqueue(DRV_NAME,0);
 #else
 	priv->priv_wq = create_workqueue(DRV_NAME);
 #endif
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 	INIT_WORK(&priv->reset_wq, rtl8192_restart);
 
 	//INIT_DELAYED_WORK(&priv->watch_dog_wq, hal_dm_watchdog);
@@ -3720,30 +2897,6 @@ static void rtl8192_init_priv_task(struct net_device* dev)
 	//INIT_WORK(&priv->SwChnlWorkItem,  rtl8192_SwChnl_WorkItem);
 	//INIT_WORK(&priv->SetBWModeWorkItem,  rtl8192_SetBWModeWorkItem);
 	INIT_WORK(&priv->qos_activate, rtl8192_qos_activate);
-#else
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-	tq_init(&priv->reset_wq, (void*)rtl8192_restart, dev);
-	tq_init(&priv->watch_dog_wq, (void*)rtl819x_watchdog_wqcallback, dev);
-	tq_init(&priv->txpower_tracking_wq, (void*)dm_txpower_trackingcallback, dev);
-	tq_init(&priv->rfpath_check_wq, (void*)dm_rf_pathcheck_workitemcallback, dev);
-	tq_init(&priv->update_beacon_wq, (void*)rtl8192_update_beacon, dev);
-	//tq_init(&priv->SwChnlWorkItem, (void*) rtl8192_SwChnl_WorkItem, dev);
-	//tq_init(&priv->SetBWModeWorkItem, (void*)rtl8192_SetBWModeWorkItem, dev);
-	tq_init(&priv->qos_activate, (void *)rtl8192_qos_activate, dev);
-#else
-	INIT_WORK(&priv->reset_wq,(void(*)(void*)) rtl8192_restart,dev);
-	//INIT_WORK(&priv->watch_dog_wq, (void(*)(void*)) hal_dm_watchdog,dev);
-	INIT_WORK(&priv->watch_dog_wq, (void(*)(void*)) rtl819x_watchdog_wqcallback,dev);
-	INIT_WORK(&priv->txpower_tracking_wq, (void(*)(void*)) dm_txpower_trackingcallback,dev);
-//	INIT_WORK(&priv->gpio_change_rf_wq, (void(*)(void*)) dm_gpio_change_rf_callback,dev);
-	INIT_WORK(&priv->rfpath_check_wq, (void(*)(void*)) dm_rf_pathcheck_workitemcallback,dev);
-	INIT_WORK(&priv->update_beacon_wq, (void(*)(void*))rtl8192_update_beacon,dev);
-	INIT_WORK(&priv->initialgain_operate_wq, (void(*)(void*))InitialGainOperateWorkItemCallBack,dev);
-	//INIT_WORK(&priv->SwChnlWorkItem, (void(*)(void*)) rtl8192_SwChnl_WorkItem, dev);
-	//INIT_WORK(&priv->SetBWModeWorkItem, (void(*)(void*)) rtl8192_SetBWModeWorkItem, dev);
-	INIT_WORK(&priv->qos_activate, (void(*)(void *))rtl8192_qos_activate, dev);
-#endif
-#endif
 
 	tasklet_init(&priv->irq_rx_tasklet,
 	     (void(*)(unsigned long))rtl8192_irq_rx_tasklet,
@@ -4218,7 +3371,6 @@ bool rtl8192_adapter_start(struct net_device *dev)
 	//config BB.
 	rtl8192_BBConfig(dev);
 
-#if 1
 	//Loopback mode or not
 	priv->LoopbackMode = RTL819xU_NO_LOOPBACK;
 //	priv->LoopbackMode = RTL819xU_MAC_LOOPBACK;
@@ -4434,7 +3586,6 @@ if(Adapter->ResetProgress == RESET_TYPE_NORESET)
 	write_nic_byte(dev, 0x87, 0x0);
 
 
-#endif
 	return init_status;
 }
 
@@ -4442,63 +3593,6 @@ if(Adapter->ResetProgress == RESET_TYPE_NORESET)
  * rtl8192_beacon_tx_enable(). rtl8192_beacon_tx_disable() might
  * be used to stop beacon transmission
  */
-#if 0
-void rtl8192_start_tx_beacon(struct net_device *dev)
-{
-	int i;
-	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-	u16 word;
-	DMESG("Enabling beacon TX");
-	//write_nic_byte(dev, TX_CONF,0xe6);// TX_CONF
-	//rtl8192_init_beacon(dev);
-	//set_nic_txring(dev);
-//	rtl8192_prepare_beacon(dev);
-	rtl8192_irq_disable(dev);
-//	rtl8192_beacon_tx_enable(dev);
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	//write_nic_byte(dev,0x9d,0x20); //DMA Poll
-	//write_nic_word(dev,0x7a,0);
-	//write_nic_word(dev,0x7a,0x8000);
-
-
-	word  = read_nic_word(dev, BcnItv);
-	word &= ~BcnItv_BcnItv; // clear Bcn_Itv
-	write_nic_word(dev, BcnItv, word);
-
-	write_nic_word(dev, AtimWnd,
-		       read_nic_word(dev, AtimWnd) &~ AtimWnd_AtimWnd);
-
-	word  = read_nic_word(dev, BCN_INTR_ITV);
-	word &= ~BCN_INTR_ITV_MASK;
-
-	//word |= priv->ieee80211->beacon_interval *
-	//	((priv->txbeaconcount > 1)?(priv->txbeaconcount-1):1);
-	// FIXME:FIXME check if correct ^^ worked with 0x3e8;
-
-	write_nic_word(dev, BCN_INTR_ITV, word);
-
-	//write_nic_word(dev,0x2e,0xe002);
-	//write_nic_dword(dev,0x30,0xb8c7832e);
-	for(i=0; i<ETH_ALEN; i++)
-		write_nic_byte(dev, BSSID+i, priv->ieee80211->beacon_cell_ssid[i]);
-
-//	rtl8192_update_msr(dev);
-
-
-	//write_nic_byte(dev,CONFIG4,3); /* !!!!!!!!!! */
-
-	rtl8192_set_mode(dev, EPROM_CMD_NORMAL);
-
-	rtl8192_irq_enable(dev);
-
-	/* VV !!!!!!!!!! VV*/
-	/*
-	rtl8192_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,0x9d,0x00);
-	rtl8192_set_mode(dev,EPROM_CMD_NORMAL);
-*/
-}
-#endif
 /***************************************************************************
     -------------------------------NET STUFF---------------------------
 ***************************************************************************/
@@ -4552,21 +3646,18 @@ TxCheckStuck(struct net_device *dev)
 	     {
 	     		if(QueueID == TXCMD_QUEUE)
 		         continue;
-#if 1
 #ifdef USB_TX_DRIVER_AGGREGATION_ENABLE
 			if((skb_queue_len(&priv->ieee80211->skb_waitQ[QueueID]) == 0) && (skb_queue_len(&priv->ieee80211->skb_aggQ[QueueID]) == 0) && (skb_queue_len(&priv->ieee80211->skb_drv_aggQ[QueueID]) == 0))
 #else
 		     	if((skb_queue_len(&priv->ieee80211->skb_waitQ[QueueID]) == 0)  && (skb_queue_len(&priv->ieee80211->skb_aggQ[QueueID]) == 0))
 #endif
 			 	continue;
-#endif
 
 	             bCheckFwTxCnt = true;
 	     }
 //	     PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
 //	spin_unlock_irqrestore(&priv->ieee80211->lock,flags);
 //	RT_TRACE(COMP_RESET,"bCheckFwTxCnt is %d\n",bCheckFwTxCnt);
-#if 1
 	if(bCheckFwTxCnt)
 	{
 		if(HalTxCheckStuck819xUsb(dev))
@@ -4575,7 +3666,6 @@ TxCheckStuck(struct net_device *dev)
 			return RESET_TYPE_SILENT;
 		}
 	}
-#endif
 	return RESET_TYPE_NORESET;
 }
 
@@ -4694,7 +3784,6 @@ rtl819x_ifcheck_resetornot(struct net_device *dev)
 	rfState = priv->ieee80211->eRFPowerState;
 
 	TxResetType = TxCheckStuck(dev);
-#if 1
 	if( rfState != eRfOff ||
 		/*ADAPTER_TEST_STATUS_FLAG(Adapter, ADAPTER_STATUS_FW_DOWNLOAD_FAILURE)) &&*/
 		(priv->ieee80211->iw_mode != IW_MODE_ADHOC))
@@ -4709,7 +3798,6 @@ rtl819x_ifcheck_resetornot(struct net_device *dev)
 		// set, STA cannot hear any packet a all. Emily, 2008.04.12
 		RxResetType = RxCheckStuck(dev);
 	}
-#endif
 	if(TxResetType==RESET_TYPE_NORMAL || RxResetType==RESET_TYPE_NORMAL)
 		return RESET_TYPE_NORMAL;
 	else if(TxResetType==RESET_TYPE_SILENT || RxResetType==RESET_TYPE_SILENT){
@@ -4889,7 +3977,6 @@ RESET_START:
 		// Set the variable for reset.
 		priv->ResetProgress = RESET_TYPE_SILENT;
 //		rtl8192_close(dev);
-#if 1
 		down(&priv->wx_sem);
 		if(priv->up == 0)
 		{
@@ -4914,9 +4001,7 @@ RESET_START:
 			printk("ieee->state is IEEE80211_LINKED\n");
 			ieee80211_stop_send_beacons(priv->ieee80211);
 			del_timer_sync(&ieee->associate_timer);
-			#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			cancel_delayed_work(&ieee->associate_retry_wq);
-			#endif
 			ieee80211_stop_scan(ieee);
 			netif_carrier_off(dev);
 			up(&ieee->wx_sem);
@@ -4943,22 +4028,13 @@ RESET_START:
 				RT_TRACE(COMP_ERR," ERR!!! %s():  Reset Failed!!\n", __FUNCTION__);
 			}
 		}
-#endif
 		ieee->is_silent_reset = 1;
-#if 1
 		EnableHWSecurityConfig8192(dev);
-#if 1
 		if(ieee->state == IEEE80211_LINKED && ieee->iw_mode == IW_MODE_INFRA)
 		{
 			ieee->set_chan(ieee->dev, ieee->current_network.channel);
 
-#if 1
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 			queue_work(ieee->wq, &ieee->associate_complete_wq);
-#else
-			schedule_task(&ieee->associate_complete_wq);
-#endif
-#endif
 
 		}
 		else if(ieee->state == IEEE80211_LINKED && ieee->iw_mode == IW_MODE_ADHOC)
@@ -4974,7 +4050,6 @@ RESET_START:
 				ieee->data_hard_resume(ieee->dev);
 			netif_carrier_on(ieee->dev);
 		}
-#endif
 
 		CamRestoreAllEntry(dev);
 
@@ -4987,7 +4062,6 @@ RESET_START:
 		// For test --> force write UFWP.
 		write_nic_byte(dev, UFWP, 1);
 		RT_TRACE(COMP_RESET, "Reset finished!! ====>[%d]\n", priv->reset_count);
-#endif
 	}
 }
 
@@ -5010,7 +4084,6 @@ void CAM_read_entry(
 
 	//Check polling bit is clear
 //	mdelay(1);
-#if 1
 		while((i--)>=0)
 		{
 			ulStatus = read_nic_dword(dev, RWCAM);
@@ -5021,7 +4094,6 @@ void CAM_read_entry(
 				break;
 			}
 		}
-#endif
 		write_nic_dword(dev, RWCAM, target_command);
 		RT_TRACE(COMP_SEC,"CAM_read_entry(): WRITE A0: %x \n",target_command);
 	 //	printk("CAM_read_entry(): WRITE A0: %lx \n",target_command);
@@ -5054,17 +4126,11 @@ void rtl819x_update_rxcounts(
 }
 
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	rtl819x_watchdog_wqcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,watch_dog_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern	void	rtl819x_watchdog_wqcallback(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 	struct ieee80211_device* ieee = priv->ieee80211;
 	RESET_TYPE	ResetType = RESET_TYPE_NORESET;
 	static u8	check_reset_cnt=0;
@@ -5106,11 +4172,7 @@ extern	void	rtl819x_watchdog_wqcallback(struct net_device *dev)
 				notify_wx_assoc_event(priv->ieee80211);
 				RemovePeerTS(priv->ieee80211,priv->ieee80211->current_network.bssid);
 				priv->ieee80211->link_change(dev);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
                                 queue_work(priv->ieee80211->wq, &priv->ieee80211->associate_procedure_wq);
-#else
-                                schedule_task(&priv->ieee80211->associate_procedure_wq);
-#endif
 
 			}
 		}
@@ -5126,7 +4188,6 @@ extern	void	rtl819x_watchdog_wqcallback(struct net_device *dev)
 		//DbgPrint("Start to check silent reset\n");
 	}
 	//	RT_TRACE(COMP_RESET,"%s():priv->force_reset is %d,priv->ResetProgress is %d, priv->bForcedSilentReset is %d,priv->bDisableNormalResetCheck is %d,ResetType is %d\n",__FUNCTION__,priv->force_reset,priv->ResetProgress,priv->bForcedSilentReset,priv->bDisableNormalResetCheck,ResetType);
-#if 1
 	if( (priv->force_reset) || (priv->ResetProgress==RESET_TYPE_NORESET &&
 		(priv->bForcedSilentReset ||
 		(!priv->bDisableNormalResetCheck && ResetType==RESET_TYPE_SILENT)))) // This is control by OID set in Pomelo
@@ -5134,7 +4195,6 @@ extern	void	rtl819x_watchdog_wqcallback(struct net_device *dev)
 		RT_TRACE(COMP_RESET,"%s():priv->force_reset is %d,priv->ResetProgress is %d, priv->bForcedSilentReset is %d,priv->bDisableNormalResetCheck is %d,ResetType is %d\n",__FUNCTION__,priv->force_reset,priv->ResetProgress,priv->bForcedSilentReset,priv->bDisableNormalResetCheck,ResetType);
 		rtl819x_ifsilentreset(dev);
 	}
-#endif
 	priv->force_reset = false;
 	priv->bForcedSilentReset = false;
 	priv->bResetInProgress = false;
@@ -5146,20 +4206,8 @@ void watch_dog_timer_callback(unsigned long data)
 {
 	struct r8192_priv *priv = ieee80211_priv((struct net_device *) data);
 	//printk("===============>watch_dog  timer\n");
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	queue_delayed_work(priv->priv_wq,&priv->watch_dog_wq, 0);
-#else
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	schedule_task(&priv->watch_dog_wq);
-#else
-	queue_work(priv->priv_wq,&priv->watch_dog_wq);
-#endif
-#endif
 	mod_timer(&priv->watch_dog_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));
-#if 0
-	priv->watch_dog_timer.expires = jiffies + MSECS(IEEE80211_WATCH_DOG_TIME);
-	add_timer(&priv->watch_dog_timer);
-#endif
 }
 int _rtl8192_up(struct net_device *dev)
 {
@@ -5298,17 +4346,10 @@ void rtl8192_restart(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 void rtl8192_restart(struct work_struct *work)
 {
 	struct r8192_priv *priv = container_of(work, struct r8192_priv, reset_wq);
 	struct net_device *dev = priv->ieee80211->dev;
-#else
-void rtl8192_restart(struct net_device *dev)
-{
-
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 
 	down(&priv->wx_sem);
 
@@ -5347,11 +4388,7 @@ int r8192_set_mac_adr(struct net_device *dev, void *mac)
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 	schedule_work(&priv->reset_wq);
-#else
-	schedule_task(&priv->reset_wq);
-#endif
 	up(&priv->wx_sem);
 
 	return 0;
@@ -5604,14 +4641,6 @@ void rtl8192_process_phyinfo(struct r8192_priv * priv,u8* buffer, struct ieee802
 		bcheck = true;
 	}else
 	{
-	#if 0
-		// if previous packet is aggregated packet, and current packet
-		//  (1) is not AMPDU
-		//  (2) is the first packet of one AMPDU
-		// that means the previous packet is the last one aggregated packet
-		if( !pcurrent_stats->bIsAMPDU || pcurrent_stats->bFirstMPDU)
-			bcheck = true;
-	#endif
 	}
 
 
@@ -5728,7 +4757,6 @@ void rtl8192_process_phyinfo(struct r8192_priv * priv,u8* buffer, struct ieee802
 			priv->undecorated_smoothed_pwdb = pprevious_stats->RxPWDBAll;
 			//DbgPrint("First pwdb initialize \n");
 		}
-#if 1
 		if(pprevious_stats->RxPWDBAll > (u32)priv->undecorated_smoothed_pwdb)
 		{
 			priv->undecorated_smoothed_pwdb =
@@ -5742,20 +4770,6 @@ void rtl8192_process_phyinfo(struct r8192_priv * priv,u8* buffer, struct ieee802
 					( ((priv->undecorated_smoothed_pwdb)*(Rx_Smooth_Factor-1)) +
 					(pprevious_stats->RxPWDBAll)) /(Rx_Smooth_Factor);
 		}
-#else
-		//Fixed by Jacken 2008-03-20
-		if(pPreviousRfd->Status.RxPWDBAll > (u32)pHalData->UndecoratedSmoothedPWDB)
-		{
-			pHalData->UndecoratedSmoothedPWDB =
-					( ((pHalData->UndecoratedSmoothedPWDB)* 5) + (pPreviousRfd->Status.RxPWDBAll)) / 6;
-			pHalData->UndecoratedSmoothedPWDB = pHalData->UndecoratedSmoothedPWDB + 1;
-		}
-		else
-		{
-			pHalData->UndecoratedSmoothedPWDB =
-					( ((pHalData->UndecoratedSmoothedPWDB)* 5) + (pPreviousRfd->Status.RxPWDBAll)) / 6;
-		}
-#endif
 
 	}
 
@@ -6133,9 +5147,6 @@ static void rtl8192_query_rxphystatus(
 			rx_evmX /= 2;	//dbm
 
 			evm = rtl819x_evm_dbtopercentage(rx_evmX);
-#if 0
-			EVM = SignalScaleMapping(EVM);//make it good looking, from 0~100
-#endif
 			//if(bpacket_match_bssid)
 			{
 				if(i==0) // Fill value in RFD, Get the first spatial stream only
@@ -6216,7 +5227,6 @@ void TranslateRxSignalStuff819xUsb(struct sk_buff *skb,
 								 && (!pstats->bHwError) && (!pstats->bCRC)&& (!pstats->bICV));
 	bpacket_toself =  bpacket_match_bssid & (eqMacAddr(praddr, priv->ieee80211->dev->dev_addr));
 
-#if 1//cosa
 		if(WLAN_FC_GET_FRAMETYPE(fc)== IEEE80211_STYPE_BEACON)
 		{
 			bPacketBeacon = true;
@@ -6229,7 +5239,6 @@ void TranslateRxSignalStuff819xUsb(struct sk_buff *skb,
 				//DbgPrint("BlockAck, MatchBSSID = %d, ToSelf = %d \n", bPacketMatchBSSID, bPacketToSelf);
 		}
 
-#endif
 
 
 	if(bpacket_match_bssid)
@@ -6416,10 +5425,6 @@ void query_rxdesc_status(struct sk_buff *skb, struct ieee80211_rx_stats *stats,
 
 		stats->bIsAMPDU = (driver_info->PartAggr==1);
 		stats->bFirstMPDU = (driver_info->PartAggr==1) && (driver_info->FirstAGGR==1);
-#if 0
-		// TODO: it is debug only. It should be disabled in released driver. 2007.1.12 by Joseph
-		UpdateRxAMPDUHistogramStatistics8190(Adapter, pRfd);
-#endif
 		stats->TimeStampLow = driver_info->TSFL;
 		// xiong mask it, 070514
 		//pRfd->Status.TimeStampHigh = PlatformEFIORead4Byte(Adapter, TSFR+4);
@@ -6452,17 +5457,6 @@ void query_rxdesc_status(struct sk_buff *skb, struct ieee80211_rx_stats *stats,
 	}
 #endif
 	/* for debug 2008.5.29 */
-#if 0
-	{
-		int i;
-		printk("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
-		for(i = 0; i < skb->len; i++) {
-			if(i % 10 == 0) printk("\n");
-			printk("%02x ", skb->data[i]);
-		}
-		printk("\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n");
-	}
-#endif
 
 	//added by vivi, for MP, 20080108
 	stats->RxIs40MHzPacket = driver_info->BW;
@@ -6753,33 +5747,6 @@ void rtl8192_rx_cmd(struct sk_buff *skb)
 		;
 
 
-#if 0
-	desc = (u32*)(skb->data);
-	cmd = (desc[0] >> 30) & 0x03;
-
-	if(cmd == 0x00) {//beacon interrupt
-		//send beacon packet
-		skb = ieee80211_get_beacon(priv->ieee80211);
-
-		if(!skb){
-			DMESG("not enought memory for allocating beacon");
-			return;
-		}
-		skb->cb[0] = BEACON_PRIORITY;
-		skb->cb[1] = 0;
-		skb->cb[2] = ieeerate2rtlrate(priv->ieee80211->basic_rate);
-		ret = rtl8192_tx(dev, skb);
-
-		if( ret != 0 ){
-			printk(KERN_ALERT "tx beacon packet error : %d !\n", ret);
-		}
-		dev_kfree_skb_any(skb);
-	} else {//0x00
-		//{ log the device information
-		// At present, It is not implemented just now.
-		//}
-	}
-#endif
 }
 
 void rtl8192_irq_rx_tasklet(struct r8192_priv *priv)
@@ -6833,39 +5800,22 @@ static const struct net_device_ops rtl8192_netdev_ops = {
      ---------------------------- USB_STUFF---------------------------
 *****************************************************************************/
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static int __devinit rtl8192_usb_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id)
-#else
-static void * __devinit rtl8192_usb_probe(struct usb_device *udev,
-					unsigned int ifnum,
-				  const struct usb_device_id *id)
-#endif
 {
 //	unsigned long ioaddr = 0;
 	struct net_device *dev = NULL;
 	struct r8192_priv *priv= NULL;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct usb_device *udev = interface_to_usbdev(intf);
-#endif
 	RT_TRACE(COMP_INIT, "Oops: i'm coming\n");
 
 	dev = alloc_ieee80211(sizeof(struct r8192_priv));
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-	SET_MODULE_OWNER(dev);
-#endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	usb_set_intfdata(intf, dev);
 	SET_NETDEV_DEV(dev, &intf->dev);
-#endif
 	priv = ieee80211_priv(dev);
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	priv->ieee80211 = netdev_priv(dev);
-#else
-	priv->ieee80211 = (struct net_device *)dev->priv;
-#endif
 	priv->udev=udev;
 
 	dev->netdev_ops = &rtl8192_netdev_ops;
@@ -6888,12 +5838,10 @@ static void * __devinit rtl8192_usb_probe(struct usb_device *udev,
 	}
 
 	RT_TRACE(COMP_INIT, "Driver probe completed1\n");
-#if 1
 	if(rtl8192_init(dev)!=0){
 		RT_TRACE(COMP_ERR, "Initialization failed");
 		goto fail;
 	}
-#endif
 	netif_carrier_off(dev);
 	netif_stop_queue(dev);
 
@@ -6903,22 +5851,14 @@ static void * __devinit rtl8192_usb_probe(struct usb_device *udev,
 
 
 	RT_TRACE(COMP_INIT, "Driver probe completed\n");
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	return dev;
-#else
 	return 0;
-#endif
 
 
 fail:
 	free_ieee80211(dev);
 
 	RT_TRACE(COMP_ERR, "wlan driver load failed\n");
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	return NULL;
-#else
 	return -ENODEV;
-#endif
 
 }
 
@@ -6926,38 +5866,19 @@ fail:
 void rtl8192_cancel_deferred_work(struct r8192_priv* priv)
 {
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
 	cancel_work_sync(&priv->reset_wq);
 	cancel_delayed_work(&priv->watch_dog_wq);
 	cancel_delayed_work(&priv->update_beacon_wq);
 	cancel_work_sync(&priv->qos_activate);
 	//cancel_work_sync(&priv->SetBWModeWorkItem);
 	//cancel_work_sync(&priv->SwChnlWorkItem);
-#else
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-//	cancel_delayed_work(&priv->reset_wq);
-	cancel_delayed_work(&priv->watch_dog_wq);
-	cancel_delayed_work(&priv->update_beacon_wq);
-//	cancel_delayed_work(&priv->qos_activate);
-	//cancel_delayed_work(&priv->SetBWModeWorkItem);
-	//cancel_delayed_work(&priv->SwChnlWorkItem);
-#endif
-#endif
 
 }
 
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 static void __devexit rtl8192_usb_disconnect(struct usb_interface *intf)
-#else
-static void __devexit rtl8192_usb_disconnect(struct usb_device *udev, void *ptr)
-#endif
 {
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct net_device *dev = usb_get_intfdata(intf);
-#else
-	struct net_device *dev = (struct net_device *)ptr;
-#endif
 
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	if(dev){
@@ -6976,9 +5897,7 @@ static void __devexit rtl8192_usb_disconnect(struct usb_device *udev, void *ptr)
 	//	priv->rf_close(dev);
 //		rtl8192_SetRFPowerState(dev, eRfOff);
 		rtl8192_usb_deleteendpoints(dev);
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 		destroy_workqueue(priv->priv_wq);
-#endif
 		//rtl8192_irq_disable(dev);
 		//rtl8192_reset(dev);
 		mdelay(10);
@@ -7075,7 +5994,6 @@ void EnableHWSecurityConfig8192(struct net_device *dev)
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 	 struct ieee80211_device* ieee = priv->ieee80211;
 	SECR_value = SCR_TxEncEnable | SCR_RxDecEnable;
-#if 1
 	if (((KEY_TYPE_WEP40 == ieee->pairwise_key_type) || (KEY_TYPE_WEP104 == ieee->pairwise_key_type)) && (priv->ieee80211->auth_mode != 2))
 	{
 		SECR_value |= SCR_RxUseDK;
@@ -7086,7 +6004,6 @@ void EnableHWSecurityConfig8192(struct net_device *dev)
 		SECR_value |= SCR_RxUseDK;
 		SECR_value |= SCR_TxUseDK;
 	}
-#endif
 	//add HWSec active enable here.
 //default using hwsec. when peer AP is in N mode only and pairwise_key_type is none_aes(which HT_IOT_ACT_PURE_N_MODE indicates it), use software security. when peer AP is in b,g,n mode mixed and pairwise_key_type is none_aes, use g mode hw security. WB on 2008.7.4
 
diff --git a/drivers/staging/rtl8192u/r8192U_dm.c b/drivers/staging/rtl8192u/r8192U_dm.c
index 9c2505a..2dde9fa 100644
--- a/drivers/staging/rtl8192u/r8192U_dm.c
+++ b/drivers/staging/rtl8192u/r8192U_dm.c
@@ -24,25 +24,11 @@ Major Change History:
 //
 // Indicate different AP vendor for IOT issue.
 //
-#if 0
-typedef enum _HT_IOT_PEER
-{
-	HT_IOT_PEER_UNKNOWN = 0,
-	HT_IOT_PEER_REALTEK = 1,
-	HT_IOT_PEER_BROADCOM = 2,
-	HT_IOT_PEER_RALINK = 3,
-	HT_IOT_PEER_ATHEROS = 4,
-	HT_IOT_PEER_CISCO = 5,
-	HT_IOT_PEER_MAX = 6
-}HT_IOT_PEER_E, *PHTIOT_PEER_E;
-#endif
-#if 1
 static u32 edca_setting_DL[HT_IOT_PEER_MAX] =
 		{ 0x5e4322, 	0x5e4322, 	0x5e4322, 	0x604322, 	0xa44f, 	0x5ea44f};
 static u32 edca_setting_UL[HT_IOT_PEER_MAX] =
 		{ 0x5e4322, 	0xa44f, 	0x5e4322, 	0x604322, 	0x5ea44f, 	0x5ea44f};
 
-#endif
 
 #define RTK_UL_EDCA 0xa44f
 #define RTK_DL_EDCA 0x5e4322
@@ -71,11 +57,7 @@ extern void hal_dm_watchdog(struct net_device *dev);
 
 
 extern	void	init_rate_adaptive(struct net_device *dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	dm_txpower_trackingcallback(struct work_struct *work);
-#else
-extern	void	dm_txpower_trackingcallback(struct net_device *dev);
-#endif
 
 extern	void	dm_cck_txpower_adjust(struct net_device *dev,bool  binch14);
 extern	void	dm_restore_dynamic_mechanism_state(struct net_device *dev);
@@ -91,15 +73,8 @@ extern	void dm_force_tx_fw_info(struct net_device *dev,
 										u32		force_value);
 extern	void	dm_init_edca_turbo(struct net_device *dev);
 extern	void	dm_rf_operation_test_callback(unsigned long data);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	dm_rf_pathcheck_workitemcallback(struct work_struct *work);
-#else
-extern	void	dm_rf_pathcheck_workitemcallback(struct net_device *dev);
-#endif
 extern	void dm_fsync_timer_callback(unsigned long data);
-#if 0
-extern	bool	dm_check_lbus_status(struct net_device *dev);
-#endif
 extern	void dm_check_fsync(struct net_device *dev);
 extern	void	dm_shadow_init(struct net_device *dev);
 
@@ -498,11 +473,9 @@ static void dm_check_rate_adaptive(struct net_device * dev)
 		}
 
 		// 2008.04.01
-#if 1
 		// For RTL819X, if pairwisekey = wep/tkip, we support only MCS0~7.
 		if(priv->ieee80211->GetHalfNmodeSupportByAPsHandler(dev))
 			targetRATR &=  0xf00fffff;
-#endif
 
 		//
 		// Check whether updating of RATR0 is required
@@ -884,29 +857,6 @@ static void dm_TXPowerTrackingCallback_ThermalMeter(struct net_device * dev)
 
 	//==========================
 	// this is only for test, should be masked
-#if 0
-{
-	//UINT32	eRFPath;
-	//UINT32	start_rf, end_rf;
-	UINT32	curr_addr;
-	//UINT32	reg_addr;
-	//UINT32	reg_addr_end;
-	UINT32	reg_value;
-	//start_rf 		= RF90_PATH_A;
-	//end_rf 			= RF90_PATH_B;//RF90_PATH_MAX;
-	//reg_addr 		= 0x0;
-	//reg_addr_end 	= 0x2F;
-
-		for (curr_addr = 0; curr_addr < 0x2d; curr_addr++)
-		{
-			reg_value = PHY_QueryRFReg(	Adapter, (RF90_RADIO_PATH_E)RF90_PATH_A,
-										curr_addr, bMaskDWord);
-		}
-
-	pHalData->TXPowercount = 0;
-	return;
-}
-#endif
 	//==========================
 
 	// read and filter out unreasonable value
@@ -981,17 +931,11 @@ static void dm_TXPowerTrackingCallback_ThermalMeter(struct net_device * dev)
 	priv->txpower_count = 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	dm_txpower_trackingcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,txpower_tracking_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern	void	dm_txpower_trackingcallback(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 
 #ifdef RTL8190P
 	dm_TXPowerTrackingCallback_TSSI(dev);
@@ -1550,15 +1494,7 @@ static void dm_CheckTXPowerTracking_TSSI(struct net_device *dev)
 	{
 		if((tx_power_track_counter % 30 == 0)&&(tx_power_track_counter != 0))
 		{
-			#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 				queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
-			#else
-				#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-				schedule_task(&priv->txpower_tracking_wq);
-				#else
-				queue_work(priv->priv_wq,&priv->txpower_tracking_wq);
-				#endif
-			#endif
 		}
 		tx_power_track_counter++;
 	}
@@ -1570,19 +1506,6 @@ static void dm_CheckTXPowerTracking_ThermalMeter(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	static u8 	TM_Trigger=0;
-#if 0
-	u1Byte					i;
-	u4Byte tmpRegA;
-	for(i=0; i<50; i++)
-	{
-		tmpRegA = PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x12, 0x078);	// 0x12: RF Reg[10:7]
-		PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
-		//delay_us(100);
-		PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);
-		//delay_us(100);
-	}
-	DbgPrint("Trigger and readback ThermalMeter, write RF reg0x2 = 0x4d to 0x4f for 50 times\n");
-#else
 	//DbgPrint("dm_CheckTXPowerTracking() \n");
 	if(!priv->btxpower_tracking)
 		return;
@@ -1610,18 +1533,9 @@ static void dm_CheckTXPowerTracking_ThermalMeter(struct net_device *dev)
 	else
 	{
 		//DbgPrint("Schedule TxPowerTrackingWorkItem\n");
-		#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 			queue_delayed_work(priv->priv_wq,&priv->txpower_tracking_wq,0);
-		#else
-			#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			schedule_task(&priv->txpower_tracking_wq);
-			#else
-			queue_work(priv->priv_wq,&priv->txpower_tracking_wq);
-			#endif
-		#endif
 		TM_Trigger = 0;
 	}
-#endif
 }
 
 
@@ -1829,14 +1743,6 @@ extern void dm_restore_dynamic_mechanism_state(struct net_device *dev)
 			//cosa PlatformEFIOWrite4Byte(Adapter, RATR0, ((pu4Byte)(val))[0]);
 			write_nic_dword(dev, RATR0, ratr_value);
 			write_nic_byte(dev, UFWP, 1);
-#if 0		// Disable old code.
-			u1Byte index;
-			u4Byte input_value;
-			index = (u1Byte)((((pu4Byte)(val))[0]) >> 28);
-			input_value = (((pu4Byte)(val))[0]) & 0x0fffffff;
-			// TODO: Correct it. Emily 2007.01.11
-			PlatformEFIOWrite4Byte(Adapter, RATR0+index*4, input_value);
-#endif
 	}
 	//Resore TX Power Tracking Index
 	if(priv->btxpower_trackingInit && priv->btxpower_tracking){
@@ -2099,28 +2005,6 @@ dm_change_rxpath_selection_setting(
 	}
 }
 
-#if 0
-extern void dm_force_tx_fw_info(struct net_device *dev,
-										u32		force_type,
-										u32		force_value)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	if (force_type == 0)	// don't force TxSC
-	{
-		//DbgPrint("Set Force SubCarrier Off\n");
-		priv->tx_fwinfo_force_subcarriermode = 0;
-	}
-	else if(force_type == 1) //force
-	{
-		//DbgPrint("Set Force SubCarrier On\n");
-		priv->tx_fwinfo_force_subcarriermode = 1;
-		if(force_value > 3)
-			force_value = 3;
-		priv->tx_fwinfo_force_subcarrierval = (u8)force_value;
-	}
-}
-#endif
 
 /*-----------------------------------------------------------------------------
  * Function:	dm_dig_init()
@@ -2759,7 +2643,6 @@ extern void dm_init_edca_turbo(struct net_device * dev)
 	priv->bis_cur_rdlstate = false;
 }	// dm_init_edca_turbo
 
-#if 1
 static void dm_check_edca_turbo(
 	struct net_device * dev)
 {
@@ -2777,10 +2660,8 @@ static void dm_check_edca_turbo(
 	// Do not be Turbo if it's under WiFi config and Qos Enabled, because the EDCA parameters
 	// should follow the settings from QAP. By Bruce, 2007-12-07.
 	//
-	#if 1
 	if(priv->ieee80211->state != IEEE80211_LINKED)
 		goto dm_CheckEdcaTurbo_EXIT;
-	#endif
 	// We do not turn on EDCA turbo mode for some AP that has IOT issue
 	if(priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO)
 		goto dm_CheckEdcaTurbo_EXIT;
@@ -2871,7 +2752,6 @@ dm_CheckEdcaTurbo_EXIT:
 	lastTxOkCnt = priv->stats.txbytesunicast;
 	lastRxOkCnt = priv->stats.rxbytesunicast;
 }	// dm_CheckEdcaTurbo
-#endif
 
 extern void DM_CTSToSelfSetting(struct net_device * dev,u32 DM_Type, u32 DM_Value)
 {
@@ -2932,20 +2812,7 @@ static void dm_ctstoself(struct net_device *dev)
 		}
 		else	//uplink
 		{
-		#if 1
 			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_CTS2SELF;
-		#else
-			if(priv->undecorated_smoothed_pwdb < priv->ieee80211->CTSToSelfTH)	// disable CTS to self
-			{
-				pHTInfo->IOTAction &= ~HT_IOT_ACT_FORCED_CTS2SELF;
-				//DbgPrint("dm_CTSToSelf() ==> CTS to self disabled\n");
-			}
-			else if(priv->undecorated_smoothed_pwdb >= (priv->ieee80211->CTSToSelfTH+5))	// enable CTS to self
-			{
-				pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_CTS2SELF;
-				//DbgPrint("dm_CTSToSelf() ==> CTS to self enabled\n");
-			}
-		#endif
 		}
 
 		lastTxOkCnt = priv->stats.txbytesunicast;
@@ -2954,79 +2821,6 @@ static void dm_ctstoself(struct net_device *dev)
 }
 
 
-#if 0
-/*-----------------------------------------------------------------------------
- * Function:	dm_rf_operation_test_callback()
- *
- * Overview:	Only for RF operation test now.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	05/29/2008	amy		Create Version 0 porting from windows code.
- *
- *---------------------------------------------------------------------------*/
-extern void dm_rf_operation_test_callback(unsigned long dev)
-{
-//	struct r8192_priv *priv = ieee80211_priv((struct net_device *)dev);
-	u8 erfpath;
-
-
-	for(erfpath=0; erfpath<4; erfpath++)
-	{
-		//DbgPrint("Set RF-%d\n\r", eRFPath);
-		//PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x2c, bMask12Bits, 0x3d7);
-		udelay(100);
-	}
-
-	{
-		//PlatformSetPeriodicTimer(Adapter, &pHalData->RfTest1Timer, 500);
-	}
-
-	// For test
-	{
-		//u8 i;
-		//PlatformSetPeriodicTimer(Adapter, &pHalData->RfTest1Timer, 500);
-#if 0
-		for(i=0; i<50; i++)
-		{
-			// Write Test
-			PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4d);
-			//delay_us(100);
-			PHY_SetRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits, 0x4f);
-			//delay_us(100);
-			PHY_SetRFReg(Adapter, RF90_PATH_C, 0x02, bMask12Bits, 0x4d);
-			//delay_us(100);
-			PHY_SetRFReg(Adapter, RF90_PATH_C, 0x02, bMask12Bits, 0x4f);
-			//delay_us(100);
-
-#if 0
-			// Read test
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x02, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x12, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x12, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x21, bMask12Bits);
-			//delay_us(100);
-			PHY_QueryRFReg(Adapter, RF90_PATH_A, 0x21, bMask12Bits);
-			//delay_us(100);
-#endif
-		}
-#endif
-	}
-
-}	/* DM_RfOperationTestCallBack */
-#endif
-
 /*-----------------------------------------------------------------------------
  * Function:	dm_check_rfctrl_gpio()
  *
@@ -3043,7 +2837,6 @@ extern void dm_rf_operation_test_callback(unsigned long dev)
  *	05/28/2008	amy		Create Version 0 porting from windows code.
  *
  *---------------------------------------------------------------------------*/
-#if 1
 static void dm_check_rfctrl_gpio(struct net_device * dev)
 {
 	//struct r8192_priv *priv = ieee80211_priv(dev);
@@ -3060,20 +2853,11 @@ static void dm_check_rfctrl_gpio(struct net_device * dev)
 	return;
 #endif
 #ifdef RTL8192E
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 		queue_delayed_work(priv->priv_wq,&priv->gpio_change_rf_wq,0);
-	#else
-		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		schedule_task(&priv->gpio_change_rf_wq);
-	     #else
-		queue_work(priv->priv_wq,&priv->gpio_change_rf_wq);
-		#endif
-	#endif
 #endif
 
 }	/* dm_CheckRfCtrlGPIO */
 
-#endif
 /*-----------------------------------------------------------------------------
  * Function:	dm_check_pbc_gpio()
  *
@@ -3129,17 +2913,11 @@ static	void	dm_check_pbc_gpio(struct net_device *dev)
  *	02/21/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
- #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	dm_gpio_change_rf_callback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,gpio_change_rf_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern	void	dm_gpio_change_rf_callback(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 	u8 tmp1byte;
 	RT_RF_POWER_STATE	eRfPowerStateToSet;
 	bool bActuallySet = false;
@@ -3207,17 +2985,11 @@ extern	void	dm_gpio_change_rf_callback(struct net_device *dev)
  *	01/30/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern	void	dm_rf_pathcheck_workitemcallback(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,rfpath_check_wq);
        struct net_device *dev =priv->ieee80211->dev;
-#else
-extern	void	dm_rf_pathcheck_workitemcallback(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 	//bool bactually_set = false;
 	u8 rfpath = 0, i;
 
@@ -3542,15 +3314,7 @@ static void dm_rxpath_sel_byrssi(struct net_device * dev)
 static	void	dm_check_rx_path_selection(struct net_device *dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 	queue_delayed_work(priv->priv_wq,&priv->rfpath_check_wq,0);
-#else
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	schedule_task(&priv->rfpath_check_wq);
-#else
-	queue_work(priv->priv_wq,&priv->rfpath_check_wq);
-#endif
-#endif
 }	/* dm_CheckRxRFPath */
 
 
@@ -3898,12 +3662,6 @@ void dm_check_fsync(struct net_device *dev)
 						#endif
 
 						reg_c38_State = RegC38_NonFsync_Other_AP;
-					#if 0//cosa
-						if (Adapter->HardwareType == HARDWARE_TYPE_RTL8190P)
-							DbgPrint("Fsync is idle, rssi<=35, write 0xc38 = 0x%x \n", 0x10);
-						else
-							DbgPrint("Fsync is idle, rssi<=35, write 0xc38 = 0x%x \n", 0x90);
-					#endif
 					}
 				}
 				else if(priv->undecorated_smoothed_pwdb >= (RegC38_TH+5))
@@ -3948,50 +3706,6 @@ void dm_check_fsync(struct net_device *dev)
 	}
 }
 
-#if 0
-/*-----------------------------------------------------------------------------
- * Function:	DM_CheckLBusStatus()
- *
- * Overview:	For 9x series, we must make sure LBUS is active for IO.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	02/22/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-extern	s1Byte	DM_CheckLBusStatus(IN	PADAPTER	Adapter)
-{
-	PMGNT_INFO	pMgntInfo=&Adapter->MgntInfo;
-
-#if (HAL_CODE_BASE & RTL819X)
-
-#if (HAL_CODE_BASE == RTL8192)
-
-#if( DEV_BUS_TYPE==PCI_INTERFACE)
-	//return (pMgntInfo->bLbusEnable);	// For debug only
-	return TRUE;
-#endif
-
-#if( DEV_BUS_TYPE==USB_INTERFACE)
-	return TRUE;
-#endif
-
-#endif	// #if (HAL_CODE_BASE == RTL8192)
-
-#if (HAL_CODE_BASE == RTL8190)
-	return TRUE;
-#endif	// #if (HAL_CODE_BASE == RTL8190)
-
-#endif	// #if (HAL_CODE_BASE & RTL819X)
-}	/* DM_CheckLBusStatus */
-
-#endif
 
 /*-----------------------------------------------------------------------------
  * Function:	dm_shadow_init()
@@ -4164,14 +3878,12 @@ static void dm_send_rssi_tofw(struct net_device *dev)
 	// 0x1e0(byte) to botify driver.
 	write_nic_byte(dev, DRIVER_RSSI, (u8)priv->undecorated_smoothed_pwdb);
 	return;
-#if 1
 	tx_cmd.Op		= TXCMD_SET_RX_RSSI;
 	tx_cmd.Length	= 4;
 	tx_cmd.Value		= priv->undecorated_smoothed_pwdb;
 
 	cmpk_message_handle_tx(dev, (u8*)&tx_cmd,
 								DESC_PACKET_TYPE_INIT, sizeof(DCMD_TXCMD_T));
-#endif
 }
 
 /*---------------------------Define function prototype------------------------*/
diff --git a/drivers/staging/rtl8192u/r8192U_dm.h b/drivers/staging/rtl8192u/r8192U_dm.h
index 1a619d2..3ceb59b 100644
--- a/drivers/staging/rtl8192u/r8192U_dm.h
+++ b/drivers/staging/rtl8192u/r8192U_dm.h
@@ -62,50 +62,6 @@
 #define 		Initial_Tx_Rate_Reg         	  0x1b9
 #define 		Tx_Retry_Count_Reg         0x1ac
 #define		RegC38_TH				 20
-#if 0
-//----------------------------------------------------------------------------
-//       8190 Rate Adaptive Table Register	(offset 0x320, 4 byte)
-//----------------------------------------------------------------------------
-
-//CCK
-#define	RATR_1M					0x00000001
-#define	RATR_2M					0x00000002
-#define	RATR_55M					0x00000004
-#define	RATR_11M					0x00000008
-//OFDM
-#define	RATR_6M					0x00000010
-#define	RATR_9M					0x00000020
-#define	RATR_12M					0x00000040
-#define	RATR_18M					0x00000080
-#define	RATR_24M					0x00000100
-#define	RATR_36M					0x00000200
-#define	RATR_48M					0x00000400
-#define	RATR_54M					0x00000800
-//MCS 1 Spatial Stream
-#define	RATR_MCS0					0x00001000
-#define	RATR_MCS1					0x00002000
-#define	RATR_MCS2					0x00004000
-#define	RATR_MCS3					0x00008000
-#define	RATR_MCS4					0x00010000
-#define	RATR_MCS5					0x00020000
-#define	RATR_MCS6					0x00040000
-#define	RATR_MCS7					0x00080000
-//MCS 2 Spatial Stream
-#define	RATR_MCS8					0x00100000
-#define	RATR_MCS9					0x00200000
-#define	RATR_MCS10					0x00400000
-#define	RATR_MCS11					0x00800000
-#define	RATR_MCS12					0x01000000
-#define	RATR_MCS13					0x02000000
-#define	RATR_MCS14					0x04000000
-#define	RATR_MCS15					0x08000000
-// ALL CCK Rate
-#define RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
-#define RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M\
-									|RATR_36M|RATR_48M|RATR_54M
-#define RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11| \
-									RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
-#endif
 /*--------------------------Define Parameters-------------------------------*/
 
 
@@ -275,11 +231,7 @@ extern  void deinit_hal_dm(struct net_device *dev);
 extern void hal_dm_watchdog(struct net_device *dev);
 
 extern  void    init_rate_adaptive(struct net_device *dev);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern  void    dm_txpower_trackingcallback(struct work_struct *work);
-#else
-extern  void    dm_txpower_trackingcallback(struct net_device *dev);
-#endif
 extern  void    dm_restore_dynamic_mechanism_state(struct net_device *dev);
 extern  void    dm_backup_dynamic_mechanism_state(struct net_device *dev);
 extern  void    dm_change_dynamic_initgain_thresh(struct net_device *dev,
@@ -287,16 +239,9 @@ extern  void    dm_change_dynamic_initgain_thresh(struct net_device *dev,
 extern  void    dm_force_tx_fw_info(struct net_device *dev,u32 force_type, u32 force_value);
 extern  void    dm_init_edca_turbo(struct net_device *dev);
 extern  void    dm_rf_operation_test_callback(unsigned long data);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern  void    dm_rf_pathcheck_workitemcallback(struct work_struct *work);
-#else
-extern  void    dm_rf_pathcheck_workitemcallback(struct net_device *dev);
-#endif
 extern  void dm_fsync_timer_callback(unsigned long data);
 extern	void	dm_cck_txpower_adjust(struct net_device *dev,bool  binch14);
-#if 0
-extern  char    dm_check_lbus_status(IN PADAPTER        Adapter);
-#endif
 extern  void    dm_shadow_init(struct net_device *dev);
 extern void dm_initialize_txpower_tracking(struct net_device *dev);
 /*--------------------------Exported Function prototype---------------------*/
diff --git a/drivers/staging/rtl8192u/r8192U_hw.h b/drivers/staging/rtl8192u/r8192U_hw.h
index 0f959ed..e89aaf7 100644
--- a/drivers/staging/rtl8192u/r8192U_hw.h
+++ b/drivers/staging/rtl8192u/r8192U_hw.h
@@ -39,15 +39,6 @@ typedef enum _BaseBand_Config_Type{
 	BaseBand_Config_PHY_REG = 0,			//Radio Path A
 	BaseBand_Config_AGC_TAB = 1,			//Radio Path B
 }BaseBand_Config_Type, *PBaseBand_Config_Type;
-#if 0
-typedef enum _RT_RF_TYPE_819xU{
-	RF_TYPE_MIN = 0,
-	RF_8225,
-	RF_8256,
-	RF_8258,
-	RF_PSEUDO_11N = 4,
-}RT_RF_TYPE_819xU, *PRT_RF_TYPE_819xU;
-#endif
 #define	RTL8187_REQT_READ	0xc0
 #define	RTL8187_REQT_WRITE	0x40
 #define	RTL8187_REQ_GET_REGS	0x05
@@ -408,332 +399,6 @@ enum _RTL8192Usb_HW {
 	MAC4 			= 0x004,
 	MAC5 			= 0x005,
 
-#if 0
-/* 0x0006 - 0x0007 - reserved */
-	RXFIFOCOUNT 		= 0x010,
-	TXFIFOCOUNT 		= 0x012,
-	BQREQ 			= 0x013,
-/* 0x0010 - 0x0017 - reserved */
-	TSFTR 			= 0x018,
-	TLPDA 			= 0x020,
-	TNPDA 			= 0x024,
-	THPDA 			= 0x028,
-	BSSID 			= 0x02E,
-	RESP_RATE 		= 0x034,
-	CMD 			= 0x037,
-#define CMD_RST_SHIFT 4
-#define CMD_RESERVED_MASK ((1<<1) | (1<<5) | (1<<6) | (1<<7))
-#define CMD_RX_ENABLE_SHIFT 3
-#define CMD_TX_ENABLE_SHIFT 2
-#define CR_RST      ((1<< 4))
-#define CR_RE       ((1<< 3))
-#define CR_TE       ((1<< 2))
-#define CR_MulRW    ((1<< 0))
-
-	INTA_MASK 		= 0x03c,
-	INTA 			= 0x03e,
-#define INTA_TXOVERFLOW (1<<15)
-#define INTA_TIMEOUT (1<<14)
-#define INTA_BEACONTIMEOUT (1<<13)
-#define INTA_ATIM (1<<12)
-#define INTA_BEACONDESCERR (1<<11)
-#define INTA_BEACONDESCOK (1<<10)
-#define INTA_HIPRIORITYDESCERR (1<<9)
-#define INTA_HIPRIORITYDESCOK (1<<8)
-#define INTA_NORMPRIORITYDESCERR (1<<7)
-#define INTA_NORMPRIORITYDESCOK (1<<6)
-#define INTA_RXOVERFLOW (1<<5)
-#define INTA_RXDESCERR (1<<4)
-#define INTA_LOWPRIORITYDESCERR (1<<3)
-#define INTA_LOWPRIORITYDESCOK (1<<2)
-#define INTA_RXCRCERR (1<<1)
-#define INTA_RXOK (1)
-	TX_CONF 		= 0x040,
-#define TX_CONF_HEADER_AUTOICREMENT_SHIFT 30
-#define TX_LOOPBACK_SHIFT 17
-#define TX_LOOPBACK_MAC 1
-#define TX_LOOPBACK_BASEBAND 2
-#define TX_LOOPBACK_NONE 0
-#define TX_LOOPBACK_CONTINUE 3
-#define TX_LOOPBACK_MASK ((1<<17)|(1<<18))
-#define TX_LRLRETRY_SHIFT 0
-#define TX_SRLRETRY_SHIFT 8
-#define TX_NOICV_SHIFT 19
-#define TX_NOCRC_SHIFT 16
-#define TCR_DurProcMode  ((1<<30))
-#define TCR_DISReqQsize  ((1<<28))
-#define TCR_HWVERID_MASK ((1<<27)|(1<<26)|(1<<25))
-#define TCR_HWVERID_SHIFT 25
-#define TCR_SWPLCPLEN     ((1<<24))
-#define TCR_PLCP_LEN TCR_SAT // rtl8180
-#define TCR_MXDMA_MASK   ((1<<23)|(1<<22)|(1<<21))
-#define TCR_MXDMA_1024 6
-#define TCR_MXDMA_2048 7
-#define TCR_MXDMA_SHIFT  21
-#define TCR_DISCW   ((1<<20))
-#define TCR_ICV     ((1<<19))
-#define TCR_LBK     ((1<<18)|(1<<17))
-#define TCR_LBK1    ((1<<18))
-#define TCR_LBK0    ((1<<17))
-#define TCR_CRC     ((1<<16))
-#define TCR_SRL_MASK   ((1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8))
-#define TCR_LRL_MASK   ((1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6)|(1<<7))
-#define TCR_PROBE_NOTIMESTAMP_SHIFT 29 //rtl8185
-	RX_CONF 		= 0x044,
-#define MAC_FILTER_MASK ((1<<0) | (1<<1) | (1<<2) | (1<<3) | (1<<5) | \
-(1<<12) | (1<<18) | (1<<19) | (1<<20) | (1<<21) | (1<<22) | (1<<23))
-#define RX_CHECK_BSSID_SHIFT 23
-#define ACCEPT_PWR_FRAME_SHIFT 22
-#define ACCEPT_MNG_FRAME_SHIFT 20
-#define ACCEPT_CTL_FRAME_SHIFT 19
-#define ACCEPT_DATA_FRAME_SHIFT 18
-#define ACCEPT_ICVERR_FRAME_SHIFT 12
-#define ACCEPT_CRCERR_FRAME_SHIFT 5
-#define ACCEPT_BCAST_FRAME_SHIFT 3
-#define ACCEPT_MCAST_FRAME_SHIFT 2
-#define ACCEPT_ALLMAC_FRAME_SHIFT 0
-#define ACCEPT_NICMAC_FRAME_SHIFT 1
-#define RX_FIFO_THRESHOLD_MASK ((1<<13) | (1<<14) | (1<<15))
-#define RX_FIFO_THRESHOLD_SHIFT 13
-#define RX_FIFO_THRESHOLD_128 3
-#define RX_FIFO_THRESHOLD_256 4
-#define RX_FIFO_THRESHOLD_512 5
-#define RX_FIFO_THRESHOLD_1024 6
-#define RX_FIFO_THRESHOLD_NONE 7
-#define RX_AUTORESETPHY_SHIFT 28
-#define MAX_RX_DMA_MASK ((1<<8) | (1<<9) | (1<<10))
-#define MAX_RX_DMA_2048 7
-#define MAX_RX_DMA_1024	6
-#define MAX_RX_DMA_SHIFT 10
-#define RCR_ONLYERLPKT ((1<<31))
-#define RCR_CS_SHIFT   29
-#define RCR_CS_MASK    ((1<<30) | (1<<29))
-#define RCR_ENMARP     ((1<<28))
-#define RCR_CBSSID     ((1<<23))
-#define RCR_APWRMGT    ((1<<22))
-#define RCR_ADD3       ((1<<21))
-#define RCR_AMF        ((1<<20))
-#define RCR_ACF        ((1<<19))
-#define RCR_ADF        ((1<<18))
-#define RCR_RXFTH      ((1<<15)|(1<<14)|(1<<13))
-#define RCR_RXFTH2     ((1<<15))
-#define RCR_RXFTH1     ((1<<14))
-#define RCR_RXFTH0     ((1<<13))
-#define RCR_AICV       ((1<<12))
-#define RCR_MXDMA      ((1<<10)|(1<< 9)|(1<< 8))
-#define RCR_MXDMA2     ((1<<10))
-#define RCR_MXDMA1     ((1<< 9))
-#define RCR_MXDMA0     ((1<< 8))
-#define RCR_9356SEL    ((1<< 6))
-#define RCR_ACRC32     ((1<< 5))
-#define RCR_AB         ((1<< 3))
-#define RCR_AM         ((1<< 2))
-#define RCR_APM        ((1<< 1))
-#define RCR_AAP        ((1<< 0))
-	INT_TIMEOUT 		= 0x048,
-	TX_BEACON_RING_ADDR 	= 0x04c,
-	EPROM_CMD 		= 0x58,
-#define EPROM_CMD_RESERVED_MASK ((1<<5)|(1<<4))
-#define EPROM_CMD_OPERATING_MODE_SHIFT 6
-#define EPROM_CMD_OPERATING_MODE_MASK ((1<<7)|(1<<6))
-#define EPROM_CMD_CONFIG 0x3
-#define EPROM_CMD_NORMAL 0
-#define EPROM_CMD_LOAD 1
-#define EPROM_CMD_PROGRAM 2
-#define EPROM_CS_SHIFT 3
-#define EPROM_CK_SHIFT 2
-#define EPROM_W_SHIFT 1
-#define EPROM_R_SHIFT 0
-	CONFIG0 		= 0x051,
-#define CONFIG0_WEP104     ((1<<6))
-#define CONFIG0_LEDGPO_En  ((1<<4))
-#define CONFIG0_Aux_Status ((1<<3))
-#define CONFIG0_GL         ((1<<1)|(1<<0))
-#define CONFIG0_GL1        ((1<<1))
-#define CONFIG0_GL0        ((1<<0))
-	CONFIG1 		= 0x052,
-#define CONFIG1_LEDS       ((1<<7)|(1<<6))
-#define CONFIG1_LEDS1      ((1<<7))
-#define CONFIG1_LEDS0      ((1<<6))
-#define CONFIG1_LWACT      ((1<<4))
-#define CONFIG1_MEMMAP     ((1<<3))
-#define CONFIG1_IOMAP      ((1<<2))
-#define CONFIG1_VPD        ((1<<1))
-#define CONFIG1_PMEn       ((1<<0))
-	CONFIG2 		= 0x053,
-#define CONFIG2_LCK        ((1<<7))
-#define CONFIG2_ANT        ((1<<6))
-#define CONFIG2_DPS        ((1<<3))
-#define CONFIG2_PAPE_sign  ((1<<2))
-#define CONFIG2_PAPE_time  ((1<<1)|(1<<0))
-#define CONFIG2_PAPE_time1 ((1<<1))
-#define CONFIG2_PAPE_time0 ((1<<0))
-	ANA_PARAM 		= 0x054,
-	CONFIG3 		= 0x059,
-#define CONFIG3_GNTSel     ((1<<7))
-#define CONFIG3_PARM_En    ((1<<6))
-#define CONFIG3_Magic      ((1<<5))
-#define CONFIG3_CardB_En   ((1<<3))
-#define CONFIG3_CLKRUN_En  ((1<<2))
-#define CONFIG3_FuncRegEn  ((1<<1))
-#define CONFIG3_FBtbEn     ((1<<0))
-#define CONFIG3_CLKRUN_SHIFT 2
-#define CONFIG3_ANAPARAM_W_SHIFT 6
-	CONFIG4 		= 0x05a,
-#define CONFIG4_VCOPDN     ((1<<7))
-#define CONFIG4_PWROFF     ((1<<6))
-#define CONFIG4_PWRMGT     ((1<<5))
-#define CONFIG4_LWPME      ((1<<4))
-#define CONFIG4_LWPTN      ((1<<2))
-#define CONFIG4_RFTYPE     ((1<<1)|(1<<0))
-#define CONFIG4_RFTYPE1    ((1<<1))
-#define CONFIG4_RFTYPE0    ((1<<0))
-	TESTR 			= 0x05b,
-#define TFPC_AC  0x05C
-
-#define SCR 0x05F
-	PGSELECT 		= 0x05e,
-#define PGSELECT_PG_SHIFT 0
-	SECURITY 		= 0x05f,
-#define SECURITY_WEP_TX_ENABLE_SHIFT 1
-#define SECURITY_WEP_RX_ENABLE_SHIFT 0
-#define SECURITY_ENCRYP_104 1
-#define SECURITY_ENCRYP_SHIFT 4
-#define SECURITY_ENCRYP_MASK ((1<<4)|(1<<5))
-	ANA_PARAM2 		= 0x060,
-	BEACON_INTERVAL 	= 0x070,
-#define BEACON_INTERVAL_MASK ((1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5)| \
-(1<<6)|(1<<7)|(1<<8)|(1<<9))
-	ATIM_WND 		= 0x072,
-#define ATIM_WND_MASK      (0x01FF)
-	BCN_INTR_ITV 		= 0x074,
-#define BCN_INTR_ITV_MASK  (0x01FF)
-	ATIM_INTR_ITV		= 0x076,
-#define ATIM_INTR_ITV_MASK  (0x01FF)
-	AckTimeOutReg      	= 0x079, //ACK timeout register, in unit of 4 us.
-	PHY_ADR 		= 0x07c,
-	PHY_READ 		= 0x07e,
-	RFPinsOutput 		= 0x080,
-	RFPinsEnable 		= 0x082,
-
-//Page 0
-	RFPinsSelect 		= 0x084,
-#define SW_CONTROL_GPIO 0x400
-	RFPinsInput 		= 0x086,
-	RF_PARA 		= 0x088,
-	RF_TIMING 		= 0x08c,
-	GP_ENABLE 		= 0x090,
-	GPIO 			= 0x091,
-	TX_AGC_CTL 		= 0x09c,
-#define TX_AGC_CTL_PER_PACKET_TXAGC	0x01
-#define TX_AGC_CTL_PERPACKET_GAIN_SHIFT 0
-#define TX_AGC_CTL_PERPACKET_ANTSEL_SHIFT 1
-#define TX_AGC_CTL_FEEDBACK_ANT 2
-#define TXAGC_CTL_PER_PACKET_ANT_SEL 0x02
-	OFDM_TXAGC 		= 0x09e,
-	ANTSEL 			= 0x09f,
-	WPA_CONFIG 		= 0x0b0,
-	SIFS 			= 0x0b4,
-	DIFS 			= 0x0b5,
-	SLOT 			= 0x0b6,
-	CW_CONF 		= 0x0bc,
-#define CW_CONF_PERPACKET_RETRY_LIMIT 0x02
-#define CW_CONF_PERPACKET_CW 0x01
-#define CW_CONF_PERPACKET_RETRY_SHIFT 1
-#define CW_CONF_PERPACKET_CW_SHIFT 0
-	CW_VAL 			= 0x0bd,
-	RATE_FALLBACK 		= 0x0be,
-#define MAX_RESP_RATE_SHIFT 4
-#define MIN_RESP_RATE_SHIFT 0
-#define RATE_FALLBACK_CTL_ENABLE  0x80
-#define RATE_FALLBACK_CTL_AUTO_STEP0 0x00
-	ACM_CONTROL             = 0x0BF,      // ACM Control Registe
-//----------------------------------------------------------------------------
-//       8187B ACM_CONTROL bits						(Offset 0xBF, 1 Byte)
-//----------------------------------------------------------------------------
-#define VOQ_ACM_EN				(0x01 << 7) //BIT7
-#define VIQ_ACM_EN				(0x01 << 6) //BIT6
-#define BEQ_ACM_EN				(0x01 << 5) //BIT5
-#define ACM_HW_EN				(0x01 << 4) //BIT4
-#define TXOPSEL					(0x01 << 3) //BIT3
-#define VOQ_ACM_CTL				(0x01 << 2) //BIT2 // Set to 1 when AC_VO used time reaches or exceeds the admitted time
-#define VIQ_ACM_CTL				(0x01 << 1) //BIT1 // Set to 1 when AC_VI used time reaches or exceeds the admitted time
-#define BEQ_ACM_CTL				(0x01 << 0) //BIT0 // Set to 1 when AC_BE used time reaches or exceeds the admitted time
-	CONFIG5 		= 0x0D8,
-#define CONFIG5_TX_FIFO_OK ((1<<7))
-#define CONFIG5_RX_FIFO_OK ((1<<6))
-#define CONFIG5_CALON      ((1<<5))
-#define CONFIG5_EACPI      ((1<<2))
-#define CONFIG5_LANWake    ((1<<1))
-#define CONFIG5_PME_STS    ((1<<0))
-	TX_DMA_POLLING 		= 0x0d9,
-#define TX_DMA_POLLING_BEACON_SHIFT 7
-#define TX_DMA_POLLING_HIPRIORITY_SHIFT 6
-#define TX_DMA_POLLING_NORMPRIORITY_SHIFT 5
-#define TX_DMA_POLLING_LOWPRIORITY_SHIFT 4
-#define TX_DMA_STOP_BEACON_SHIFT 3
-#define TX_DMA_STOP_HIPRIORITY_SHIFT 2
-#define TX_DMA_STOP_NORMPRIORITY_SHIFT 1
-#define TX_DMA_STOP_LOWPRIORITY_SHIFT 0
-	CWR 			= 0x0DC,
-	RetryCTR 		= 0x0DE,
-	INT_MIG                 = 0x0E2,      // Interrupt Migration (0xE2 ~ 0xE3)
-	TID_AC_MAP         	= 0x0E8,     // TID to AC Mapping Register
-	ANA_PARAM3 		= 0x0EE,
-
-
-//page 1
-	Wakeup0 		= 0x084,
-	Wakeup1 		= 0x08C,
-	Wakeup2LD 		= 0x094,
-	Wakeup2HD 		= 0x09C,
-	Wakeup3LD 		= 0x0A4,
-	Wakeup3HD 		= 0x0AC,
-	Wakeup4LD 		= 0x0B4,
-	Wakeup4HD 		= 0x0BC,
-	CRC0 			= 0x0C4,
-	CRC1 			= 0x0C6,
-	CRC2 			= 0x0C8,
-	CRC3 			= 0x0CA,
-	CRC4 			= 0x0CC,
-/* 0x00CE - 0x00D3 - reserved */
-
-	RFSW_CTRL               = 0x272,   // 0x272-0x273.
-
-//Reg Diff between rtl8187 and rtl8187B
-/**************************************************************************/
-	BRSR_8187 		= 0x02C,
-	BRSR_8187B 		= 0x034,
-#define BRSR_BPLCP  ((1<< 8))
-#define BRSR_MBR    ((1<< 1)|(1<< 0))
-#define BRSR_MBR_8185 ((1<< 11)|(1<< 10)|(1<< 9)|(1<< 8)|(1<< 7)|(1<< 6)|(1<< 5)|(1<< 4)|(1<< 3)|(1<< 2)|(1<< 1)|(1<< 0))
-#define BRSR_MBR0   ((1<< 0))
-#define BRSR_MBR1   ((1<< 1))
-
-/**************************************************************************/
-	EIFS_8187  		= 0x035,
-	EIFS_8187B 		= 0x02D,
-
-/**************************************************************************/
-	FER 			= 0x0F0,
-	FEMR 			= 0x0F4,
-	FPSR 			= 0x0F8,
-	FFER 			= 0x0FC,
-
-	AC_VO_PARAM             = 0x0F0,      // AC_VO Parameters Record
-	AC_VI_PARAM             = 0x0F4,      // AC_VI Parameters Record
-	AC_BE_PARAM             = 0x0F8,      // AC_BE Parameters Record
-	AC_BK_PARAM             = 0x0FC,      // AC_BK Parameters Record
-	TALLY_SEL 		= 0x0fc,
-//----------------------------------------------------------------------------
-//       8187B AC_XX_PARAM bits
-//----------------------------------------------------------------------------
-#define AC_PARAM_TXOP_LIMIT_OFFSET		16
-#define AC_PARAM_ECW_MAX_OFFSET			12
-#define AC_PARAM_ECW_MIN_OFFSET			8
-#define AC_PARAM_AIFS_OFFSET			0
-
-#endif
 };
 //----------------------------------------------------------------------------
 //       818xB AnaParm & AnaParm2 Register
diff --git a/drivers/staging/rtl8192u/r8192U_wx.c b/drivers/staging/rtl8192u/r8192U_wx.c
index 1c953c7..25d5c87 100644
--- a/drivers/staging/rtl8192u/r8192U_wx.c
+++ b/drivers/staging/rtl8192u/r8192U_wx.c
@@ -44,40 +44,6 @@ static int r8192_wx_get_freq(struct net_device *dev,
 }
 
 
-#if 0
-
-static int r8192_wx_set_beaconinterval(struct net_device *dev, struct iw_request_info *aa,
-			  union iwreq_data *wrqu, char *b)
-{
-	int *parms = (int *)b;
-	int bi = parms[0];
-
-	struct r8192_priv *priv = ieee80211_priv(dev);
-
-	down(&priv->wx_sem);
-	DMESG("setting beacon interval to %x",bi);
-
-	priv->ieee80211->beacon_interval=bi;
-	rtl8180_commit(dev);
-	up(&priv->wx_sem);
-
-	return 0;
-}
-
-
-static int r8192_wx_set_forceassociate(struct net_device *dev, struct iw_request_info *aa,
-			  union iwreq_data *wrqu, char *extra)
-{
-	struct r8192_priv *priv=ieee80211_priv(dev);
-	int *parms = (int *)extra;
-
-	priv->ieee80211->force_associate = (parms[0] > 0);
-
-
-	return 0;
-}
-
-#endif
 static int r8192_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
@@ -215,10 +181,6 @@ static int r8192_wx_read_bb(struct net_device *dev,
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u8 databb;
-#if 0
-	int i;
-	for(i=0;i<12;i++) printk("%8x\n", read_cam(dev, i) );
-#endif
 
 	down(&priv->wx_sem);
 
@@ -317,14 +279,6 @@ static int r8192_wx_get_ap_status(struct net_device *dev,
 
 
 #endif
-#if 0
-static int r8192_wx_null(struct net_device *dev,
-		struct iw_request_info *info,
-		union iwreq_data *wrqu, char *extra)
-{
-	return 0;
-}
-#endif
 static int r8192_wx_force_reset(struct net_device *dev,
 		struct iw_request_info *info,
 		union iwreq_data *wrqu, char *extra)
@@ -937,24 +891,12 @@ exit:
 }
 
 #if (WIRELESS_EXT >= 18)
-#if 0
-static int r8192_wx_get_enc_ext(struct net_device *dev,
-					struct iw_request_info *info,
-					union iwreq_data *wrqu, char *extra)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	int ret = 0;
-	ret = ieee80211_wx_get_encode_ext(priv->ieee80211, info, wrqu, extra);
-	return ret;
-}
-#endif
 //hw security need to reorganized.
 static int r8192_wx_set_enc_ext(struct net_device *dev,
 					struct iw_request_info *info,
 					union iwreq_data *wrqu, char *extra)
 {
 	int ret=0;
-	#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
 	//printk("===>%s()\n", __FUNCTION__);
@@ -969,13 +911,6 @@ static int r8192_wx_set_enc_ext(struct net_device *dev,
 		u32 key[4] = {0};
 		struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
 		struct iw_point *encoding = &wrqu->encoding;
-#if 0
-		static u8 CAM_CONST_ADDR[4][6] = {
-			{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-			{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
-			{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
-			{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}};
-#endif
 		u8 idx = 0, alg = 0, group = 0;
 		if ((encoding->flags & IW_ENCODE_DISABLED) ||
 		ext->alg == IW_ENCODE_ALG_NONE) //none is not allowed to use hwsec WB 2008.07.01
@@ -1035,7 +970,6 @@ static int r8192_wx_set_enc_ext(struct net_device *dev,
 end_hw_sec:
 
 	up(&priv->wx_sem);
-#endif
 	return ret;
 
 }
@@ -1044,13 +978,11 @@ static int r8192_wx_set_auth(struct net_device *dev,
 					union iwreq_data *data, char *extra)
 {
 	int ret=0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	//printk("====>%s()\n", __FUNCTION__);
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
 	ret = ieee80211_wx_set_auth(priv->ieee80211, info, &(data->param), extra);
 	up(&priv->wx_sem);
-#endif
 	return ret;
 }
 
@@ -1061,13 +993,11 @@ static int r8192_wx_set_mlme(struct net_device *dev,
 	//printk("====>%s()\n", __FUNCTION__);
 
 	int ret=0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
 	ret = ieee80211_wx_set_mlme(priv->ieee80211, info, wrqu, extra);
 
 	up(&priv->wx_sem);
-#endif
 	return ret;
 }
 #endif
@@ -1077,15 +1007,11 @@ static int r8192_wx_set_gen_ie(struct net_device *dev,
 {
 	   //printk("====>%s(), len:%d\n", __FUNCTION__, data->length);
 	int ret=0;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
-#if 1
 	ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
-#endif
 	up(&priv->wx_sem);
 	//printk("<======%s(), ret:%d\n", __FUNCTION__, ret);
-#endif
 	return ret;
 
 
@@ -1271,11 +1197,7 @@ struct iw_statistics *r8192_get_wireless_stats(struct net_device *dev)
 		wstats->qual.qual = 0;
 		wstats->qual.level = 0;
 		wstats->qual.noise = 0;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
 		wstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
-#else
-		wstats->qual.updated = 0x0f;
-#endif
 		return wstats;
 	}
 
@@ -1287,11 +1209,7 @@ struct iw_statistics *r8192_get_wireless_stats(struct net_device *dev)
 	wstats->qual.level = tmp_level;
 	wstats->qual.qual = tmp_qual;
 	wstats->qual.noise = tmp_noise;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
 	wstats->qual.updated = IW_QUAL_ALL_UPDATED| IW_QUAL_DBM;
-#else
-	wstats->qual.updated = 0x0f;
-#endif
 	return wstats;
 }
 //#endif
diff --git a/drivers/staging/rtl8192u/r819xU_cmdpkt.c b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
index e9a0eb8..fd19a85 100644
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.c
@@ -318,42 +318,11 @@ cmpk_handle_tx_feedback(
 	/* It seems that FW use big endian(MIPS) and DRV use little endian in
 	   windows OS. So we have to read the content byte by byte or transfer
 	   endian type before copy the message copy. */
-#if 0		// The TX FEEDBACK packet element address
-	//rx_tx_fb.Element_ID 	= pMsg[0];
-	//rx_tx_fb.Length 		= pMsg[1];
-	rx_tx_fb.TOK 			= pMsg[2]>>7;
-	rx_tx_fb.Fail_Reason 	= (pMsg[2] & 0x70) >> 4;
-	rx_tx_fb.TID 			= (pMsg[2] & 0x0F);
-	rx_tx_fb.Qos_Pkt 		= pMsg[3] >> 7;
-	rx_tx_fb.Bandwidth 		= (pMsg[3] & 0x40) >> 6;
-	rx_tx_fb.Retry_Cnt 		= pMsg[5];
-	rx_tx_fb.Pkt_ID 		= (pMsg[6] << 8) | pMsg[7];
-	rx_tx_fb.Seq_Num 		= (pMsg[8] << 8) | pMsg[9];
-	rx_tx_fb.S_Rate 		= pMsg[10];
-	rx_tx_fb.F_Rate 		= pMsg[11];
-	rx_tx_fb.S_RTS_Rate 	= pMsg[12];
-	rx_tx_fb.F_RTS_Rate 	= pMsg[13];
-	rx_tx_fb.pkt_length	= (pMsg[14] << 8) | pMsg[15];
-#endif
 	/* 2007/07/05 MH Use pointer to transfer structure memory. */
 	//memcpy((UINT8 *)&rx_tx_fb, pMsg, sizeof(CMPK_TXFB_T));
 	memcpy((u8*)&rx_tx_fb, pmsg, sizeof(cmpk_txfb_t));
 	/* 2. Use tx feedback info to count TX statistics. */
 	cmpk_count_txstatistic(dev, &rx_tx_fb);
-#if 0
-	/* 2007/07/11 MH Assign current operate rate.  */
-	if (pAdapter->RegWirelessMode == WIRELESS_MODE_A ||
-		pAdapter->RegWirelessMode == WIRELESS_MODE_B ||
-		pAdapter->RegWirelessMode == WIRELESS_MODE_G)
-	{
-		pMgntInfo->CurrentOperaRate = (rx_tx_fb.F_Rate & 0x7F);
-	}
-	else if (pAdapter->RegWirelessMode == WIRELESS_MODE_N_24G ||
-			 pAdapter->RegWirelessMode == WIRELESS_MODE_N_5G)
-	{
-		pMgntInfo->HTCurrentOperaRate = (rx_tx_fb.F_Rate & 0x8F);
-	}
-#endif
 	/* 2007/01/17 MH Comment previous method for TX statistic function. */
 	/* Collect info TX feedback packet to fill TCB. */
 	/* We can not know the packet length and transmit type: broadcast or uni
diff --git a/drivers/staging/rtl8192u/r819xU_cmdpkt.h b/drivers/staging/rtl8192u/r819xU_cmdpkt.h
index 34fbdcf..a8855e6 100644
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.h
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.h
@@ -13,16 +13,6 @@
 #define ISR_TxBcnErr				BIT26			// Transmit Beacon Error
 #define ISR_BcnTimerIntr			BIT13			// Beacon Timer Interrupt
 
-#if 0
-/* Define packet type. */
-typedef enum tag_packet_type
-{
-    PACKET_BROADCAST,
-    PACKET_MULTICAST,
-    PACKET_UNICAST,
-    PACKET_TYPE_MAX
-}cmpk_pkt_type_e;
-#endif
 
 /* Define element ID of command packet. */
 
diff --git a/drivers/staging/rtl8192u/r819xU_firmware.c b/drivers/staging/rtl8192u/r819xU_firmware.c
index 20d78f4..3cc2d57 100644
--- a/drivers/staging/rtl8192u/r819xU_firmware.c
+++ b/drivers/staging/rtl8192u/r819xU_firmware.c
@@ -16,9 +16,7 @@
 #include "r8192U_hw.h"
 #include "r819xU_firmware_img.h"
 #include "r819xU_firmware.h"
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 #include <linux/firmware.h>
-#endif
 void firmware_init_param(struct net_device *dev)
 {
 	struct r8192_priv 	*priv = ieee80211_priv(dev);
@@ -107,12 +105,6 @@ bool fw_download_code(struct net_device *dev, u8 *code_virtual_address, u32 buff
 
 	return rt_status;
 
-#if 0
-cmdsend_downloadcode_fail:
-	rt_status = false;
-	RT_TRACE(COMP_ERR, "CmdSendDownloadCode fail !!\n");
-	return rt_status;
-#endif
 }
 
 bool
@@ -154,52 +146,6 @@ fwSendNullPacket(
 	return rtStatus;
 }
 
-#if 0
-/*
- * Procedure  :   Download code into IMEM or DMEM
- * Description:   This routine will intialize firmware. If any error occurs during the initialization
- *				process, the routine shall terminate immediately and return fail.
- *				The routine copy virtual address get from opening of file into shared memory
- *				allocated during initialization. If code size larger than a conitneous shared
- *				memory may contain, the code should be divided into several section.
- *				!!!NOTES This finction should only be called during MPInitialization because
- *				A NIC driver should call NdisOpenFile only from MiniportInitialize.
- * Arguments :    The pointer of the adapter
- *			   Code address (Virtual address, should fill descriptor with physical address)
- *			   Code size
- * Returns  :
- *        RT_STATUS_FAILURE - the following initialization process should be terminated
- *        RT_STATUS_SUCCESS - if firmware initialization process success
- */
-bool fwsend_download_code(struct net_device *dev)
-{
-	struct r8192_priv 	*priv = ieee80211_priv(dev);
-	rt_firmware		*pfirmware = (rt_firmware*)(&priv->firmware);
-
-	bool			rt_status = true;
-	u16			length = 0;
-	u16			offset = 0;
-	u16			frag_threhold;
-	bool			last_init_packet = false;
-	u32			check_txcmdwait_queueemptytime = 100000;
-	u16			cmd_buf_len;
-	u8			*ptr_cmd_buf;
-
-	/* reset to 0 for first segment of img download */
-	pfirmware->firmware_seg_index = 1;
-
-	if(pfirmware->firmware_seg_index == pfirmware->firmware_seg_maxnum) {
-		last_init_packet = 1;
-	}
-
-	cmd_buf_len = pfirmware->firmware_seg_container[pfirmware->firmware_seg_index-1].seg_size;
-	ptr_cmd_buf = pfirmware->firmware_seg_container[pfirmware->firmware_seg_index-1].seg_ptr;
-	rtl819xU_tx_cmd(dev, ptr_cmd_buf, cmd_buf_len, last_init_packet, DESC_PACKET_TYPE_INIT);
-
-	rt_status = true;
-	return rt_status;
-}
-#endif
 
 //-----------------------------------------------------------------------------
 // Procedure:    Check whether main code is download OK. If OK, turn on CPU
@@ -338,11 +284,7 @@ bool init_firmware(struct net_device *dev)
 	 * Download boot, main, and data image for System reset.
 	 * Download data image for firmware reseta
 	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	priv->firmware_source = FW_SOURCE_HEADER_FILE;
-#else
 	priv->firmware_source = FW_SOURCE_IMG_FILE;
-#endif
 	for(init_step = starting_state; init_step <= FW_INIT_STEP2_DATA; init_step++) {
 		/*
 		 * Open Image file, and map file to contineous memory if open file success.
@@ -351,7 +293,6 @@ bool init_firmware(struct net_device *dev)
 		if(rst_opt == OPT_SYSTEM_RESET) {
 			switch(priv->firmware_source) {
 				case FW_SOURCE_IMG_FILE:
-				#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 					rc = request_firmware(&fw_entry, fw_name[init_step],&priv->udev->dev);
 					if(rc < 0 ) {
 						RT_TRACE(COMP_ERR, "request firmware fail!\n");
@@ -380,7 +321,6 @@ bool init_firmware(struct net_device *dev)
 					#endif
 					}
 					pfirmware->firmware_buf_size = file_length;
-					#endif
 					break;
 
 				case FW_SOURCE_HEADER_FILE:
@@ -411,11 +351,9 @@ bool init_firmware(struct net_device *dev)
 		 *   and Tx descriptor info
 		 * */
 		rt_status = fw_download_code(dev,mapped_file,file_length);
-		#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 		if(rst_opt == OPT_SYSTEM_RESET) {
 			release_firmware(fw_entry);
 		}
-		#endif
 
 		if(rt_status != TRUE) {
 			goto download_firmware_fail;
@@ -487,214 +425,10 @@ download_firmware_fail:
 
 }
 
-#if 0
-/*
- * Procedure:   (1)  Transform firmware code from little endian to big endian if required.
- *		(2)  Number of bytes in Firmware downloading should be multiple
- *		     of 4 bytes. If length is not multiple of 4 bytes, appending of zeros is required
- *
- */
-void CmdAppendZeroAndEndianTransform(
-	u1Byte	*pDst,
-	u1Byte	*pSrc,
-	u2Byte   	*pLength)
-{
 
-	u2Byte	ulAppendBytes = 0, i;
-	u2Byte	ulLength = *pLength;
 
-//test only
-	//memset(pDst, 0xcc, 12);
 
 
-	/* Transform from little endian to big endian */
-//#if DEV_BUS_TYPE==PCI_INTERFACE
-#if 0
-	for( i=0 ; i<(*pLength) ; i+=4)
-	{
-		if((i+3) < (*pLength))	pDst[i+0] = pSrc[i+3];
-		if((i+2) < (*pLength))	pDst[i+1] = pSrc[i+2];
-		if((i+1) < (*pLength))	pDst[i+2] = pSrc[i+1];
-		if((i+0) < (*pLength))	pDst[i+3] = pSrc[i+0];
-	}
-#else
-	pDst += USB_HWDESC_HEADER_LEN;
-	ulLength -= USB_HWDESC_HEADER_LEN;
-
-	for( i=0 ; i<ulLength ; i+=4) {
-		if((i+3) < ulLength)	pDst[i+0] = pSrc[i+3];
-		if((i+2) < ulLength)	pDst[i+1] = pSrc[i+2];
-		if((i+1) < ulLength)	pDst[i+2] = pSrc[i+1];
-		if((i+0) < ulLength)	pDst[i+3] = pSrc[i+0];
-
-	}
-#endif
-
-	//1(2) Append Zero
-	if(  ((*pLength) % 4)  >0)
-	{
-		ulAppendBytes = 4-((*pLength) % 4);
-
-		for(i=0 ; i<ulAppendBytes; i++)
-			pDst[  4*((*pLength)/4)  + i ] = 0x0;
-
-		*pLength += ulAppendBytes;
-	}
-}
-#endif
-
-#if 0
-RT_STATUS
-CmdSendPacket(
-	PADAPTER				Adapter,
-	PRT_TCB					pTcb,
-	PRT_TX_LOCAL_BUFFER 			pBuf,
-	u4Byte					BufferLen,
-	u4Byte					PacketType,
-	BOOLEAN					bLastInitPacket
-	)
-{
-	s2Byte		i;
-	u1Byte		QueueID;
-	u2Byte		firstDesc,curDesc = 0;
-	u2Byte		FragIndex=0, FragBufferIndex=0;
-
-	RT_STATUS	rtStatus = RT_STATUS_SUCCESS;
-
-	CmdInitTCB(Adapter, pTcb, pBuf, BufferLen);
-
-
-	if(CmdCheckFragment(Adapter, pTcb, pBuf))
-		CmdFragmentTCB(Adapter, pTcb);
-	else
-		pTcb->FragLength[0] = (u2Byte)pTcb->BufferList[0].Length;
-
-	QueueID=pTcb->SpecifiedQueueID;
-#if DEV_BUS_TYPE!=USB_INTERFACE
-	firstDesc=curDesc=Adapter->NextTxDescToFill[QueueID];
-#endif
 
-#if DEV_BUS_TYPE!=USB_INTERFACE
-	if(VacancyTxDescNum(Adapter, QueueID) > pTcb->BufferCount)
-#else
-	if(PlatformIsTxQueueAvailable(Adapter, QueueID, pTcb->BufferCount) &&
-		RTIsListEmpty(&Adapter->TcbWaitQueue[QueueID]))
-#endif
-	{
-		pTcb->nDescUsed=0;
-
-		for(i=0 ; i<pTcb->BufferCount ; i++)
-		{
-			Adapter->HalFunc.TxFillCmdDescHandler(
-				Adapter,
-				pTcb,
-				QueueID,							//QueueIndex
-				curDesc,							//index
-				FragBufferIndex==0,						//bFirstSeg
-				FragBufferIndex==(pTcb->FragBufCount[FragIndex]-1),		//bLastSeg
-				pTcb->BufferList[i].VirtualAddress,				//VirtualAddress
-				pTcb->BufferList[i].PhysicalAddressLow,				//PhyAddressLow
-				pTcb->BufferList[i].Length,					//BufferLen
-				i!=0,								//bSetOwnBit
-				(i==(pTcb->BufferCount-1)) && bLastInitPacket,			//bLastInitPacket
-				PacketType,							//DescPacketType
-				pTcb->FragLength[FragIndex]					//PktLen
-				);
-
-			if(FragBufferIndex==(pTcb->FragBufCount[FragIndex]-1))
-			{ // Last segment of the fragment.
-				pTcb->nFragSent++;
-			}
-
-			FragBufferIndex++;
-			if(FragBufferIndex==pTcb->FragBufCount[FragIndex])
-			{
-				FragIndex++;
-				FragBufferIndex=0;
-			}
-
-#if DEV_BUS_TYPE!=USB_INTERFACE
-			curDesc=(curDesc+1)%Adapter->NumTxDesc[QueueID];
-#endif
-			pTcb->nDescUsed++;
-		}
-
-#if DEV_BUS_TYPE!=USB_INTERFACE
-		RTInsertTailList(&Adapter->TcbBusyQueue[QueueID], &pTcb->List);
-		IncrementTxDescToFill(Adapter, QueueID, pTcb->nDescUsed);
-		Adapter->HalFunc.SetTxDescOWNHandler(Adapter, QueueID, firstDesc);
-		// TODO: should call poll use QueueID
-		Adapter->HalFunc.TxPollingHandler(Adapter, TXCMD_QUEUE);
-#endif
-	}
-	else
-#if DEV_BUS_TYPE!=USB_INTERFACE
-		goto CmdSendPacket_Fail;
-#else
-	{
-		pTcb->bLastInitPacket = bLastInitPacket;
-		RTInsertTailList(&Adapter->TcbWaitQueue[pTcb->SpecifiedQueueID], &pTcb->List);
-	}
-#endif
-
-	return rtStatus;
-
-#if DEV_BUS_TYPE!=USB_INTERFACE
-CmdSendPacket_Fail:
-	rtStatus = RT_STATUS_FAILURE;
-	return rtStatus;
-#endif
-
-}
-#endif
-
-
-
-
-#if 0
-RT_STATUS
-FWSendNullPacket(
-	IN	PADAPTER		Adapter,
-	IN	u4Byte			Length
-)
-{
-	RT_STATUS	rtStatus = RT_STATUS_SUCCESS;
-
-
-	PRT_TCB					pTcb;
-	PRT_TX_LOCAL_BUFFER 	pBuf;
-	BOOLEAN					bLastInitPacket = FALSE;
-
-	PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK);
-
-#if DEV_BUS_TYPE==USB_INTERFACE
-	Length += USB_HWDESC_HEADER_LEN;
-#endif
-
-	//Get TCB and local buffer from common pool. (It is shared by CmdQ, MgntQ, and USB coalesce DataQ)
-	if(MgntGetBuffer(Adapter, &pTcb, &pBuf))
-	{
-		PlatformZeroMemory(pBuf->Buffer.VirtualAddress, Length);
-		rtStatus = CmdSendPacket(Adapter, pTcb, pBuf, Length, DESC_PACKET_TYPE_INIT, bLastInitPacket);	//0 : always set LastInitPacket to zero
-//#if HAL_CODE_BASE != RTL8190HW
-//		// TODO: for test only
-//		ReturnTCB(Adapter, pTcb, RT_STATUS_SUCCESS);
-//#endif
-		if(rtStatus == RT_STATUS_FAILURE)
-			goto CmdSendNullPacket_Fail;
-	}else
-		goto CmdSendNullPacket_Fail;
-
-	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
-	return rtStatus;
-
-
-CmdSendNullPacket_Fail:
-	PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
-	rtStatus = RT_STATUS_FAILURE;
-	RT_ASSERT(rtStatus == RT_STATUS_SUCCESS, ("CmdSendDownloadCode fail !!\n"));
-	return rtStatus;
-}
-#endif
 
 
diff --git a/drivers/staging/rtl8192u/r819xU_firmware.h b/drivers/staging/rtl8192u/r819xU_firmware.h
index 5e56108..a4bceee 100644
--- a/drivers/staging/rtl8192u/r819xU_firmware.h
+++ b/drivers/staging/rtl8192u/r819xU_firmware.h
@@ -23,46 +23,5 @@ typedef enum _opt_rst_type{
 	OPT_FIRMWARE_RESET = 1,
 }opt_rst_type_e;
 
-#if 0
-/* CPU related */
-RT_STATUS
-CPUCheckMainCodeOKAndTurnOnCPU(
-	IN	PADAPTER			Adapter
-	);
-
-RT_STATUS
-CPUCheckFirmwareReady(
-	IN	PADAPTER			Adapter
-	);
-
-/* Firmware related */
-VOID
-FWInitializeParameters(
-	IN	PADAPTER		Adapter
-	);
-
-RT_STATUS
-FWSendDownloadCode(
-	IN	PADAPTER		Adapter,
-	IN	pu1Byte			CodeVirtualAddrress,
-	IN	u4Byte			BufferLen
-	);
-
-RT_STATUS
-FWSendNullPacket(
-	IN	PADAPTER		Adapter,
-	IN	u4Byte			Length
-	);
-
-RT_STATUS
-CmdSendPacket(
-	PADAPTER				Adapter,
-	PRT_TCB					pTcb,
-	PRT_TX_LOCAL_BUFFER 	pBuf,
-	u4Byte					BufferLen,
-	u4Byte					PacketType,
-	BOOLEAN					bLastInitPacket
-	);
-#endif
 #endif
 
diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index beeab51..a3adaed 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1079,18 +1079,6 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 		switch( eRFPowerState )
 		{
 			case eRfOn:
-#if 0
-						rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);		// 0x860[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x3);		// 0x88c[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x3); 		// 0x880[6:5]
-						rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x3);			// 0xc04[3:0]
-						rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x3);			// 0xd04[3:0]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter2, 0x7000, 0x3);	// 0x884[14:12]
-	//					for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-		//					PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x2);
-
-						//SwChnl(Adapter->ChannelID);
-#endif
 	//RF-A, RF-B
 					//enable RF-Chip A/B
 					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x1);	// 0x860[4]
@@ -1112,16 +1100,6 @@ bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eRFPowerS
 				break;
 
 			case eRfOff:
-#if 0
-						rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);		// 0x860[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300, 0x0);		// 0x88c[4]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60, 0x0); 		// 0x880[6:5]
-						rtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0);			// 0xc04[3:0]
-						rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0);			// 0xd04[3:0]
-						rtl8192_setBBreg(dev, rFPGA0_AnalogParameter2, 0x7000, 0x0);	// 0x884[14:12]
-	//					for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-		//					PHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
-#endif
 					//RF-A, RF-B
 					//disable RF-Chip A/B
 					rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4, 0x0);	// 0x860[4]
@@ -1582,11 +1560,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 1);
 
 			// Correct the tx power for CCK rate in 20M. Suggest by YN, 20071207
-#if 0
-			write_nic_dword(dev, rCCK0_TxFilter1, 0x1a1b0000);
-			write_nic_dword(dev, rCCK0_TxFilter2, 0x090e1317);
-			write_nic_dword(dev, rCCK0_DebugPort, 0x00000204);
-#endif
 			priv->cck_present_attentuation =
 				priv->cck_present_attentuation_20Mdefault + priv->cck_present_attentuation_difference;
 
@@ -1617,12 +1590,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			rtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand, (priv->nCur40MhzPrimeSC>>1));
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);
 			rtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00, priv->nCur40MhzPrimeSC);
-#if 0
-			// Correct the tx power for CCK rate in 40M. Suggest by YN, 20071207
-			write_nic_dword(dev, rCCK0_TxFilter1, 0x35360000);
-			write_nic_dword(dev, rCCK0_TxFilter2, 0x121c252e);
-			write_nic_dword(dev, rCCK0_DebugPort, 0x00000409);
-#endif
 			priv->cck_present_attentuation =
 				priv->cck_present_attentuation_40Mdefault + priv->cck_present_attentuation_difference;
 
@@ -1653,7 +1620,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 	}
 	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
 
-#if 1
 	//<3>Set RF related register
 	switch( priv->rf_chip )
 	{
@@ -1679,7 +1645,6 @@ void rtl8192_SetBWModeWorkItem(struct net_device *dev)
 			RT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);
 			break;
 	}
-#endif
 	priv->SetBWModeInProgress= false;
 
 	RT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d", atomic_read(&(priv->ieee80211->atm_swbw)) );
@@ -1726,29 +1691,15 @@ void InitialGain819xUsb(struct net_device *dev,	u8 Operation)
 
 	if(priv->up)
 	{
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 		queue_delayed_work(priv->priv_wq,&priv->initialgain_operate_wq,0);
-	#else
-		#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		schedule_task(&priv->initialgain_operate_wq);
-		#else
-		queue_work(priv->priv_wq,&priv->initialgain_operate_wq);
-		#endif
-	#endif
 	}
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern void InitialGainOperateWorkItemCallBack(struct work_struct *work)
 {
 	struct delayed_work *dwork = container_of(work,struct delayed_work,work);
        struct r8192_priv *priv = container_of(dwork,struct r8192_priv,initialgain_operate_wq);
        struct net_device *dev = priv->ieee80211->dev;
-#else
-extern void InitialGainOperateWorkItemCallBack(struct net_device *dev)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-#endif
 #define SCAN_RX_INITIAL_GAIN	0x17
 #define POWER_DETECTION_TH	0x08
 	u32	BitMask;
diff --git a/drivers/staging/rtl8192u/r819xU_phy.h b/drivers/staging/rtl8192u/r819xU_phy.h
index c165ac1..3e3bc57 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.h
+++ b/drivers/staging/rtl8192u/r819xU_phy.h
@@ -85,10 +85,6 @@ extern bool rtl8192_SetRFPowerState(struct net_device *dev, RT_RF_POWER_STATE eR
 //added by amy
 extern void InitialGain819xUsb(struct net_device *dev,	u8 Operation);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 extern void InitialGainOperateWorkItemCallBack(struct work_struct *work);
-#else
-extern void InitialGainOperateWorkItemCallBack(struct net_device *dev);
-#endif
 
 #endif
-- 
1.7.1

