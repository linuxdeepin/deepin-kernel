From 49b65765aca2696d20ba76ebde49f27c6ba3518e Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Fri, 11 Dec 2009 12:23:15 -0800
Subject: [PATCH 23/42] Staging: rt28x0: fix comments in common/*.c files

commit ec278fa259e48c89b206ccd9e1bee06277077263 upstream.

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2860/common/action.c       |   68 +-
 drivers/staging/rt2860/common/ba_action.c    |  340 ++++----
 drivers/staging/rt2860/common/cmm_aes.c      |   66 +-
 drivers/staging/rt2860/common/cmm_asic.c     |  700 ++++++++--------
 drivers/staging/rt2860/common/cmm_cfg.c      |   20 +-
 drivers/staging/rt2860/common/cmm_data.c     |  581 +++++++-------
 drivers/staging/rt2860/common/cmm_data_pci.c |  302 ++++----
 drivers/staging/rt2860/common/cmm_data_usb.c |  270 +++---
 drivers/staging/rt2860/common/cmm_info.c     |  314 ++++----
 drivers/staging/rt2860/common/cmm_mac_pci.c  |  378 +++++-----
 drivers/staging/rt2860/common/cmm_mac_usb.c  |  252 +++---
 drivers/staging/rt2860/common/cmm_sanity.c   |  278 +++---
 drivers/staging/rt2860/common/cmm_sync.c     |   90 +-
 drivers/staging/rt2860/common/cmm_tkip.c     |   96 ++--
 drivers/staging/rt2860/common/cmm_wep.c      |   26 +-
 drivers/staging/rt2860/common/cmm_wpa.c      |  608 +++++++-------
 drivers/staging/rt2860/common/ee_efuse.c     |   68 +-
 drivers/staging/rt2860/common/ee_prom.c      |   38 +-
 drivers/staging/rt2860/common/eeprom.c       |    8 +-
 drivers/staging/rt2860/common/mlme.c         | 1169 +++++++++++++-------------
 drivers/staging/rt2860/common/rt_channel.c   |  828 +++++++++---------
 drivers/staging/rt2860/common/rt_rf.c        |    8 +-
 drivers/staging/rt2860/common/rtmp_init.c    | 1032 ++++++++++++------------
 drivers/staging/rt2860/common/rtmp_mcu.c     |   52 +-
 drivers/staging/rt2860/common/rtmp_timer.c   |   22 +-
 drivers/staging/rt2860/common/spectrum.c     |  124 ++--
 26 files changed, 3866 insertions(+), 3872 deletions(-)

diff --git a/drivers/staging/rt2860/common/action.c b/drivers/staging/rt2860/common/action.c
index f6efdb6..f69681d 100644
--- a/drivers/staging/rt2860/common/action.c
+++ b/drivers/staging/rt2860/common/action.c
@@ -113,13 +113,13 @@ VOID MlmeADDBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	NdisZeroMemory(&Frame, sizeof(FRAME_ADDBA_REQ));
 
 	if (MlmeAddBAReqSanity(pAd, Elem->Msg, Elem->MsgLen, Addr)) {
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 		if (NStatus != NDIS_STATUS_SUCCESS) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("BA - MlmeADDBAAction() allocate memory failed \n"));
 			return;
 		}
-		// 1. find entry
+		/* 1. find entry */
 		Idx =
 		    pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
 		if (Idx == 0) {
@@ -200,27 +200,27 @@ VOID MlmeDELBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	FRAME_BAR FrameBar;
 
 	pInfo = (MLME_DELBA_REQ_STRUCT *) Elem->Msg;
-	// must send back DELBA
+	/* must send back DELBA */
 	NdisZeroMemory(&Frame, sizeof(FRAME_DELBA_REQ));
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("==> MlmeDELBAAction(), Initiator(%d) \n", pInfo->Initiator));
 
 	if (MlmeDelBAReqSanity(pAd, Elem->Msg, Elem->MsgLen)) {
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 		if (NStatus != NDIS_STATUS_SUCCESS) {
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("BA - MlmeDELBAAction() allocate memory failed 1. \n"));
 			return;
 		}
 
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	//Get an unused nonpaged memory
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	/*Get an unused nonpaged memory */
 		if (NStatus != NDIS_STATUS_SUCCESS) {
 			MlmeFreeMemory(pAd, pOutBuffer);
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("BA - MlmeDELBAAction() allocate memory failed 2. \n"));
 			return;
 		}
-		// SEND BAR (Send BAR to refresh peer reordering buffer.)
+		/* SEND BAR (Send BAR to refresh peer reordering buffer.) */
 		Idx =
 		    pAd->MacTab.Content[pInfo->Wcid].BAOriWcidArray[pInfo->TID];
 
@@ -228,12 +228,12 @@ VOID MlmeDELBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			      pAd->MacTab.Content[pInfo->Wcid].Addr,
 			      pAd->CurrentAddress);
 
-		FrameBar.StartingSeq.field.FragNum = 0;	// make sure sequence not clear in DEL funciton.
-		FrameBar.StartingSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];	// make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.TID = pInfo->TID;	// make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.ACKPolicy = IMMED_BA;	// make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.Compressed = 1;	// make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.MTID = 0;	// make sure sequence not clear in DEL funciton.
+		FrameBar.StartingSeq.field.FragNum = 0;	/* make sure sequence not clear in DEL funciton. */
+		FrameBar.StartingSeq.field.StartSeq = pAd->MacTab.Content[pInfo->Wcid].TxSeq[pInfo->TID];	/* make sure sequence not clear in DEL funciton. */
+		FrameBar.BarControl.TID = pInfo->TID;	/* make sure sequence not clear in DEL funciton. */
+		FrameBar.BarControl.ACKPolicy = IMMED_BA;	/* make sure sequence not clear in DEL funciton. */
+		FrameBar.BarControl.Compressed = 1;	/* make sure sequence not clear in DEL funciton. */
+		FrameBar.BarControl.MTID = 0;	/* make sure sequence not clear in DEL funciton. */
 
 		MakeOutgoingFrame(pOutBuffer2, &FrameLen,
 				  sizeof(FRAME_BAR), &FrameBar, END_OF_ARGS);
@@ -242,7 +242,7 @@ VOID MlmeDELBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("BA - MlmeDELBAAction() . Send BAR to refresh peer reordering buffer \n"));
 
-		// SEND DELBA FRAME
+		/* SEND DELBA FRAME */
 		FrameLen = 0;
 
 		{
@@ -263,7 +263,7 @@ VOID MlmeDELBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		Frame.Action = DELBA;
 		Frame.DelbaParm.Initiator = pInfo->Initiator;
 		Frame.DelbaParm.TID = pInfo->TID;
-		Frame.ReasonCode = 39;	// Time Out
+		Frame.ReasonCode = 39;	/* Time Out */
 		*(USHORT *) (&Frame.DelbaParm) =
 		    cpu2le16(*(USHORT *) (&Frame.DelbaParm));
 		Frame.ReasonCode = cpu2le16(Frame.ReasonCode);
@@ -288,8 +288,8 @@ VOID MlmeDLSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 VOID MlmeInvalidAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//PUCHAR                   pOutBuffer = NULL;
-	//Return the receiving frame except the MSB of category filed set to 1.  7.3.1.11
+	/*PUCHAR                   pOutBuffer = NULL; */
+	/*Return the receiving frame except the MSB of category filed set to 1.  7.3.1.11 */
 }
 
 VOID PeerQOSAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
@@ -347,20 +347,20 @@ static VOID respond_ht_information_exchange_action(IN PRTMP_ADAPTER pAd,
 	FRAME_HT_INFO HTINFOframe, *pFrame;
 	UCHAR *pAddr;
 
-	// 2. Always send back ADDBA Response
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	/* 2. Always send back ADDBA Response */
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("ACTION - respond_ht_information_exchange_action() allocate memory failed \n"));
 		return;
 	}
-	// get RA
+	/* get RA */
 	pFrame = (FRAME_HT_INFO *) & Elem->Msg[0];
 	pAddr = pFrame->Hdr.Addr2;
 
 	NdisZeroMemory(&HTINFOframe, sizeof(FRAME_HT_INFO));
-	// 2-1. Prepare ADDBA Response frame.
+	/* 2-1. Prepare ADDBA Response frame. */
 	{
 		if (ADHOC_ON(pAd))
 			ActHeaderInit(pAd, &HTINFOframe.Hdr, pAddr,
@@ -400,21 +400,21 @@ VOID PeerHTAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			 ("ACTION - HT Notify Channel bandwidth action----> \n"));
 
 		if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) {
-			// Note, this is to patch DIR-1353 AP. When the AP set to Wep, it will use legacy mode. But AP still keeps
-			// sending BW_Notify Action frame, and cause us to linkup and linkdown.
-			// In legacy mode, don't need to parse HT action frame.
+			/* Note, this is to patch DIR-1353 AP. When the AP set to Wep, it will use legacy mode. But AP still keeps */
+			/* sending BW_Notify Action frame, and cause us to linkup and linkdown. */
+			/* In legacy mode, don't need to parse HT action frame. */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("ACTION -Ignore HT Notify Channel BW when link as legacy mode. BW = %d---> \n",
 				  Elem->Msg[LENGTH_802_11 + 2]));
 			break;
 		}
 
-		if (Elem->Msg[LENGTH_802_11 + 2] == 0)	// 7.4.8.2. if value is 1, keep the same as supported channel bandwidth.
+		if (Elem->Msg[LENGTH_802_11 + 2] == 0)	/* 7.4.8.2. if value is 1, keep the same as supported channel bandwidth. */
 			pAd->MacTab.Content[Elem->Wcid].HTPhyMode.field.BW = 0;
 
 		break;
 	case SMPS_ACTION:
-		// 7.3.1.25
+		/* 7.3.1.25 */
 		DBGPRINT(RT_DEBUG_TRACE, ("ACTION - SMPS action----> \n"));
 		if (((Elem->Msg[LENGTH_802_11 + 2] & 0x1) == 0)) {
 			pAd->MacTab.Content[Elem->Wcid].MmpsMode = MMPS_ENABLE;
@@ -427,7 +427,7 @@ VOID PeerHTAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("Aid(%d) MIMO PS = %d\n", Elem->Wcid,
 			  pAd->MacTab.Content[Elem->Wcid].MmpsMode));
-		// rt2860c : add something for smps change.
+		/* rt2860c : add something for smps change. */
 		break;
 
 	case SETPCO_ACTION:
@@ -441,7 +441,7 @@ VOID PeerHTAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			pHT_info =
 			    (HT_INFORMATION_OCTET *) & Elem->Msg[LENGTH_802_11 +
 								 2];
-			// 7.4.8.10
+			/* 7.4.8.10 */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("ACTION - HT Information Exchange action----> \n"));
 			if (pHT_info->Request) {
@@ -512,7 +512,7 @@ VOID SendRefreshBAR(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry)
 
 			ASSERT(pBAEntry->Wcid < MAX_LEN_OF_MAC_TABLE);
 
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 			if (NStatus != NDIS_STATUS_SUCCESS) {
 				DBGPRINT(RT_DEBUG_ERROR,
 					 ("BA - MlmeADDBAAction() allocate memory failed \n"));
@@ -524,17 +524,17 @@ VOID SendRefreshBAR(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry)
 			BarHeaderInit(pAd, &FrameBar, pEntry->Addr,
 				      pAd->CurrentAddress);
 
-			FrameBar.StartingSeq.field.FragNum = 0;	// make sure sequence not clear in DEL function.
-			FrameBar.StartingSeq.field.StartSeq = Sequence;	// make sure sequence not clear in DEL funciton.
-			FrameBar.BarControl.TID = TID;	// make sure sequence not clear in DEL funciton.
+			FrameBar.StartingSeq.field.FragNum = 0;	/* make sure sequence not clear in DEL function. */
+			FrameBar.StartingSeq.field.StartSeq = Sequence;	/* make sure sequence not clear in DEL funciton. */
+			FrameBar.BarControl.TID = TID;	/* make sure sequence not clear in DEL funciton. */
 
 			MakeOutgoingFrame(pOutBuffer, &FrameLen,
 					  sizeof(FRAME_BAR), &FrameBar,
 					  END_OF_ARGS);
-			//if (!(CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET)))
-			if (1)	// Now we always send BAR.
+			/*if (!(CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET))) */
+			if (1)	/* Now we always send BAR. */
 			{
-				//MiniportMMRequestUnlock(pAd, 0, pOutBuffer, FrameLen);
+				/*MiniportMMRequestUnlock(pAd, 0, pOutBuffer, FrameLen); */
 				MiniportMMRequest(pAd,
 						  (MGMT_USE_QUEUE_FLAG |
 						   MapUserPriorityToAccessCategory
diff --git a/drivers/staging/rt2860/common/ba_action.c b/drivers/staging/rt2860/common/ba_action.c
index dedbe52..97cb40a 100644
--- a/drivers/staging/rt2860/common/ba_action.c
+++ b/drivers/staging/rt2860/common/ba_action.c
@@ -27,14 +27,14 @@
 
 #include "../rt_config.h"
 
-#define BA_ORI_INIT_SEQ		(pEntry->TxSeq[TID])	//1                        // inital sequence number of BA session
+#define BA_ORI_INIT_SEQ		(pEntry->TxSeq[TID])	/*1                        // inital sequence number of BA session */
 
 #define ORI_SESSION_MAX_RETRY	8
-#define ORI_BA_SESSION_TIMEOUT	(2000)	// ms
-#define REC_BA_SESSION_IDLE_TIMEOUT	(1000)	// ms
+#define ORI_BA_SESSION_TIMEOUT	(2000)	/* ms */
+#define REC_BA_SESSION_IDLE_TIMEOUT	(1000)	/* ms */
 
-#define REORDERING_PACKET_TIMEOUT		((100 * OS_HZ)/1000)	// system ticks -- 100 ms
-#define MAX_REORDERING_PACKET_TIMEOUT	((3000 * OS_HZ)/1000)	// system ticks -- 100 ms
+#define REORDERING_PACKET_TIMEOUT		((100 * OS_HZ)/1000)	/* system ticks -- 100 ms */
+#define MAX_REORDERING_PACKET_TIMEOUT	((3000 * OS_HZ)/1000)	/* system ticks -- 100 ms */
 
 #define RESET_RCV_SEQ		(0xFFFF)
 
@@ -66,20 +66,20 @@ VOID BA_MaxWinSizeReasign(IN PRTMP_ADAPTER pAd,
 {
 	UCHAR MaxSize;
 
-	if (pAd->MACVersion >= RALINK_2883_VERSION)	// 3*3
+	if (pAd->MACVersion >= RALINK_2883_VERSION)	/* 3*3 */
 	{
 		if (pAd->MACVersion >= RALINK_3070_VERSION) {
 			if (pEntryPeer->WepStatus !=
 			    Ndis802_11EncryptionDisabled)
-				MaxSize = 7;	// for non-open mode
+				MaxSize = 7;	/* for non-open mode */
 			else
 				MaxSize = 13;
 		} else
 			MaxSize = 31;
-	} else if (pAd->MACVersion >= RALINK_2880E_VERSION)	// 2880 e
+	} else if (pAd->MACVersion >= RALINK_2880E_VERSION)	/* 2880 e */
 	{
 		if (pEntryPeer->WepStatus != Ndis802_11EncryptionDisabled)
-			MaxSize = 7;	// for non-open mode
+			MaxSize = 7;	/* for non-open mode */
 		else
 			MaxSize = 13;
 	} else
@@ -108,9 +108,9 @@ void Announce_Reordering_Packet(IN PRTMP_ADAPTER pAd,
 		ASSERT(0);
 		BA_Reorder_AMSDU_Annnounce(pAd, pPacket);
 	} else {
-		//
-		// pass this 802.3 packet to upper layer or forward this packet to WM directly
-		//
+		/* */
+		/* pass this 802.3 packet to upper layer or forward this packet to WM directly */
+		/* */
 
 		ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pPacket,
 						 RTMP_GET_PACKET_IF(pPacket));
@@ -275,7 +275,7 @@ BOOLEAN ba_reordering_resource_init(PRTMP_ADAPTER pAd, int num)
 	return (TRUE);
 }
 
-//static int blk_count=0; // sample take off, no use
+/*static int blk_count=0; // sample take off, no use */
 
 static struct reordering_mpdu *ba_mpdu_blk_alloc(PRTMP_ADAPTER pAd)
 {
@@ -284,7 +284,7 @@ static struct reordering_mpdu *ba_mpdu_blk_alloc(PRTMP_ADAPTER pAd)
 	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
 	mpdu_blk = ba_dequeue(&pAd->mpdu_blk_pool.freelist);
 	if (mpdu_blk) {
-//              blk_count++;
+/*              blk_count++; */
 		/* reset mpdu_blk */
 		NdisZeroMemory(mpdu_blk, sizeof(struct reordering_mpdu));
 	}
@@ -298,7 +298,7 @@ static void ba_mpdu_blk_free(PRTMP_ADAPTER pAd,
 	ASSERT(mpdu_blk);
 
 	NdisAcquireSpinLock(&pAd->mpdu_blk_pool.lock);
-//      blk_count--;
+/*      blk_count--; */
 	ba_enqueue(&pAd->mpdu_blk_pool.freelist, mpdu_blk);
 	NdisReleaseSpinLock(&pAd->mpdu_blk_pool.lock);
 }
@@ -380,17 +380,17 @@ static void ba_refresh_reordering_mpdus(IN PRTMP_ADAPTER pAd,
 	NdisReleaseSpinLock(&pBAEntry->RxReRingLock);
 }
 
-//static
+/*static */
 void ba_flush_reordering_timeout_mpdus(IN PRTMP_ADAPTER pAd,
 				       IN PBA_REC_ENTRY pBAEntry,
 				       IN ULONG Now32)
 {
 	USHORT Sequence;
 
-//      if ((RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+REORDERING_PACKET_TIMEOUT)) &&
-//               (pBAEntry->list.qlen > ((pBAEntry->BAWinSize*7)/8))) //||
-//              (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(10*REORDERING_PACKET_TIMEOUT))) &&
-//               (pBAEntry->list.qlen > (pBAEntry->BAWinSize/8)))
+/*      if ((RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+REORDERING_PACKET_TIMEOUT)) && */
+/*               (pBAEntry->list.qlen > ((pBAEntry->BAWinSize*7)/8))) //|| */
+/*              (RTMP_TIME_AFTER((unsigned long)Now32, (unsigned long)(pBAEntry->LastIndSeqAtTimer+(10*REORDERING_PACKET_TIMEOUT))) && */
+/*               (pBAEntry->list.qlen > (pBAEntry->BAWinSize/8))) */
 	if (RTMP_TIME_AFTER
 	    ((unsigned long)Now32,
 	     (unsigned long)(pBAEntry->LastIndSeqAtTimer +
@@ -413,16 +413,16 @@ void ba_flush_reordering_timeout_mpdus(IN PRTMP_ADAPTER pAd,
 				 (REORDERING_PACKET_TIMEOUT)))
 		&& (pBAEntry->list.qlen > 0)
 	    ) {
-		//
-		// force LastIndSeq to shift to LastIndSeq+1
-		//
+		/* */
+		/* force LastIndSeq to shift to LastIndSeq+1 */
+		/* */
 		Sequence = (pBAEntry->LastIndSeq + 1) & MAXSEQ;
 		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, Sequence);
 		pBAEntry->LastIndSeqAtTimer = Now32;
 		pBAEntry->LastIndSeq = Sequence;
-		//
-		// indicate in-order mpdus
-		//
+		/* */
+		/* indicate in-order mpdus */
+		/* */
 		Sequence =
 		    ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry,
 							  Sequence);
@@ -446,7 +446,7 @@ VOID BAOriSessionSetUp(IN PRTMP_ADAPTER pAd,
 		       IN USHORT TimeOut,
 		       IN ULONG DelayTime, IN BOOLEAN isForced)
 {
-	//MLME_ADDBA_REQ_STRUCT AddbaReq;
+	/*MLME_ADDBA_REQ_STRUCT AddbaReq; */
 	BA_ORI_ENTRY *pBAEntry = NULL;
 	USHORT Idx;
 	BOOLEAN Cancelled;
@@ -455,20 +455,20 @@ VOID BAOriSessionSetUp(IN PRTMP_ADAPTER pAd,
 	    && (isForced == FALSE))
 		return;
 
-	// if this entry is limited to use legacy tx mode, it doesn't generate BA.
+	/* if this entry is limited to use legacy tx mode, it doesn't generate BA. */
 	if (RTMPStaFixedTxMode(pAd, pEntry) != FIXED_TXMODE_HT)
 		return;
 
 	if ((pEntry->BADeclineBitmap & (1 << TID)) && (isForced == FALSE)) {
-		// try again after 3 secs
+		/* try again after 3 secs */
 		DelayTime = 3000;
-//              DBGPRINT(RT_DEBUG_TRACE, ("DeCline BA from Peer\n"));
-//              return;
+/*              DBGPRINT(RT_DEBUG_TRACE, ("DeCline BA from Peer\n")); */
+/*              return; */
 	}
 
 	Idx = pEntry->BAOriWcidArray[TID];
 	if (Idx == 0) {
-		// allocate a BA session
+		/* allocate a BA session */
 		pBAEntry = BATableAllocOriEntry(pAd, &Idx);
 		if (pBAEntry == NULL) {
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -485,12 +485,12 @@ VOID BAOriSessionSetUp(IN PRTMP_ADAPTER pAd,
 
 	pEntry->BAOriWcidArray[TID] = Idx;
 
-	// Initialize BA session
+	/* Initialize BA session */
 	pBAEntry->ORI_BA_Status = Originator_WaitRes;
 	pBAEntry->Wcid = pEntry->Aid;
 	pBAEntry->BAWinSize = pAd->CommonCfg.BACapability.field.RxBAWinLimit;
 	pBAEntry->Sequence = BA_ORI_INIT_SEQ;
-	pBAEntry->Token = 1;	// (2008-01-21) Jan Lee recommends it - this token can't be 0
+	pBAEntry->Token = 1;	/* (2008-01-21) Jan Lee recommends it - this token can't be 0 */
 	pBAEntry->TID = TID;
 	pBAEntry->TimeOutValue = TimeOut;
 	pBAEntry->pAdapter = pAd;
@@ -502,7 +502,7 @@ VOID BAOriSessionSetUp(IN PRTMP_ADAPTER pAd,
 	} else
 		RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
 
-	// set timer to send ADDBA request
+	/* set timer to send ADDBA request */
 	RTMPSetTimer(&pBAEntry->ORIBATimer, DelayTime);
 }
 
@@ -522,7 +522,7 @@ VOID BAOriSessionAdd(IN PRTMP_ADAPTER pAd,
 	Idx = pEntry->BAOriWcidArray[TID];
 	pBAEntry = &pAd->BATable.BAOriEntry[Idx];
 
-	// Start fill in parameters.
+	/* Start fill in parameters. */
 	if ((Idx != 0) && (pBAEntry->TID == TID)
 	    && (pBAEntry->ORI_BA_Status == Originator_WaitRes)) {
 		pBAEntry->BAWinSize =
@@ -533,21 +533,21 @@ VOID BAOriSessionAdd(IN PRTMP_ADAPTER pAd,
 		pBAEntry->ORI_BA_Status = Originator_Done;
 		pAd->BATable.numDoneOriginator++;
 
-		// reset sequence number
+		/* reset sequence number */
 		pBAEntry->Sequence = BA_ORI_INIT_SEQ;
-		// Set Bitmap flag.
+		/* Set Bitmap flag. */
 		pEntry->TXBAbitmap |= (1 << TID);
 		RTMPCancelTimer(&pBAEntry->ORIBATimer, &Cancelled);
 
-		pBAEntry->ORIBATimer.TimerValue = 0;	//pFrame->TimeOutValue;
+		pBAEntry->ORIBATimer.TimerValue = 0;	/*pFrame->TimeOutValue; */
 
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("%s : TXBAbitmap = %x, BAWinSize = %d, TimeOut = %ld\n",
 			  __func__, pEntry->TXBAbitmap, pBAEntry->BAWinSize,
 			  pBAEntry->ORIBATimer.TimerValue));
 
-		// SEND BAR ;
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	//Get an unused nonpaged memory
+		/* SEND BAR ; */
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer2);	/*Get an unused nonpaged memory */
 		if (NStatus != NDIS_STATUS_SUCCESS) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("BA - BAOriSessionAdd() allocate memory failed \n"));
@@ -558,16 +558,16 @@ VOID BAOriSessionAdd(IN PRTMP_ADAPTER pAd,
 			      pAd->MacTab.Content[pBAEntry->Wcid].Addr,
 			      pAd->CurrentAddress);
 
-		FrameBar.StartingSeq.field.FragNum = 0;	// make sure sequence not clear in DEL function.
-		FrameBar.StartingSeq.field.StartSeq = pBAEntry->Sequence;	// make sure sequence not clear in DEL funciton.
-		FrameBar.BarControl.TID = pBAEntry->TID;	// make sure sequence not clear in DEL funciton.
+		FrameBar.StartingSeq.field.FragNum = 0;	/* make sure sequence not clear in DEL function. */
+		FrameBar.StartingSeq.field.StartSeq = pBAEntry->Sequence;	/* make sure sequence not clear in DEL funciton. */
+		FrameBar.BarControl.TID = pBAEntry->TID;	/* make sure sequence not clear in DEL funciton. */
 		MakeOutgoingFrame(pOutBuffer2, &FrameLen,
 				  sizeof(FRAME_BAR), &FrameBar, END_OF_ARGS);
 		MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer2, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer2);
 
 		if (pBAEntry->ORIBATimer.TimerValue)
-			RTMPSetTimer(&pBAEntry->ORIBATimer, pBAEntry->ORIBATimer.TimerValue);	// in mSec
+			RTMPSetTimer(&pBAEntry->ORIBATimer, pBAEntry->ORIBATimer.TimerValue);	/* in mSec */
 	}
 }
 
@@ -580,19 +580,19 @@ BOOLEAN BARecSessionAdd(IN PRTMP_ADAPTER pAd,
 	USHORT Idx;
 	UCHAR TID;
 	UCHAR BAWinSize;
-	//UINT32                  Value;
-	//UINT                    offset;
+	/*UINT32                  Value; */
+	/*UINT                    offset; */
 
 	ASSERT(pEntry);
 
-	// find TID
+	/* find TID */
 	TID = pFrame->BaParm.TID;
 
 	BAWinSize =
 	    min(((UCHAR) pFrame->BaParm.BufSize),
 		(UCHAR) pAd->CommonCfg.BACapability.field.RxBAWinLimit);
 
-	// Intel patch
+	/* Intel patch */
 	if (BAWinSize == 0) {
 		BAWinSize = 64;
 	}
@@ -603,7 +603,7 @@ BOOLEAN BARecSessionAdd(IN PRTMP_ADAPTER pAd,
 		pBAEntry = BATableAllocRecEntry(pAd, &Idx);
 	} else {
 		pBAEntry = &pAd->BATable.BARecEntry[Idx];
-		// flush all pending reordering mpdus
+		/* flush all pending reordering mpdus */
 		ba_refresh_reordering_mpdus(pAd, pBAEntry);
 	}
 
@@ -612,7 +612,7 @@ BOOLEAN BARecSessionAdd(IN PRTMP_ADAPTER pAd,
 		  pAd->BATable.numAsRecipient, Idx, pFrame->BaParm.BufSize,
 		  BAWinSize));
 
-	// Start fill in parameters.
+	/* Start fill in parameters. */
 	if (pBAEntry != NULL) {
 		ASSERT(pBAEntry->list.qlen == 0);
 
@@ -622,8 +622,8 @@ BOOLEAN BARecSessionAdd(IN PRTMP_ADAPTER pAd,
 		pBAEntry->TID = TID;
 		pBAEntry->TimeOutValue = pFrame->TimeOutValue;
 		pBAEntry->REC_BA_Status = Recipient_Accept;
-		// initial sequence number
-		pBAEntry->LastIndSeq = RESET_RCV_SEQ;	//pFrame->BaStartSeq.field.StartSeq;
+		/* initial sequence number */
+		pBAEntry->LastIndSeq = RESET_RCV_SEQ;	/*pFrame->BaStartSeq.field.StartSeq; */
 
 		DBGPRINT(RT_DEBUG_OFF,
 			 ("Start Seq = %08x\n",
@@ -638,13 +638,13 @@ BOOLEAN BARecSessionAdd(IN PRTMP_ADAPTER pAd,
 				      TRUE);
 		}
 
-		// Set Bitmap flag.
+		/* Set Bitmap flag. */
 		pEntry->RXBAbitmap |= (1 << TID);
 		pEntry->BARecWcidArray[TID] = Idx;
 
 		pEntry->BADeclineBitmap &= ~(1 << TID);
 
-		// Set BA session mask in WCID table.
+		/* Set BA session mask in WCID table. */
 		RTMP_ADD_BA_SESSION_TO_ASIC(pAd, pEntry->Aid, TID);
 
 		DBGPRINT(RT_DEBUG_TRACE,
@@ -673,11 +673,11 @@ BA_REC_ENTRY *BATableAllocRecEntry(IN PRTMP_ADAPTER pAd, OUT USHORT * Idx)
 					MAX_BARECI_SESSION));
 		goto done;
 	}
-	// reserve idx 0 to identify BAWcidArray[TID] as empty
+	/* reserve idx 0 to identify BAWcidArray[TID] as empty */
 	for (i = 1; i < MAX_LEN_OF_BA_REC_TABLE; i++) {
 		pBAEntry = &pAd->BATable.BARecEntry[i];
 		if ((pBAEntry->REC_BA_Status == Recipient_NONE)) {
-			// get one
+			/* get one */
 			pAd->BATable.numAsRecipient++;
 			pBAEntry->REC_BA_Status = Recipient_USED;
 			*Idx = i;
@@ -700,11 +700,11 @@ BA_ORI_ENTRY *BATableAllocOriEntry(IN PRTMP_ADAPTER pAd, OUT USHORT * Idx)
 	if (pAd->BATable.numAsOriginator >= (MAX_LEN_OF_BA_ORI_TABLE)) {
 		goto done;
 	}
-	// reserve idx 0 to identify BAWcidArray[TID] as empty
+	/* reserve idx 0 to identify BAWcidArray[TID] as empty */
 	for (i = 1; i < MAX_LEN_OF_BA_ORI_TABLE; i++) {
 		pBAEntry = &pAd->BATable.BAOriEntry[i];
 		if ((pBAEntry->ORI_BA_Status == Originator_NONE)) {
-			// get one
+			/* get one */
 			pAd->BATable.numAsOriginator++;
 			pBAEntry->ORI_BA_Status = Originator_USED;
 			pBAEntry->pAdapter = pAd;
@@ -739,7 +739,7 @@ VOID BATableFreeOriEntry(IN PRTMP_ADAPTER pAd, IN ULONG Idx)
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("BATableFreeOriEntry numAsOriginator= %ld\n",
 				  pAd->BATable.numAsRecipient));
-			// Erase Bitmap flag.
+			/* Erase Bitmap flag. */
 		}
 
 		ASSERT(pAd->BATable.numAsOriginator != 0);
@@ -789,13 +789,13 @@ VOID BAOriSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
 	if (Wcid >= MAX_LEN_OF_MAC_TABLE) {
 		return;
 	}
-	//
-	// Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID).
-	//
+	/* */
+	/* Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID). */
+	/* */
 	Idx = pAd->MacTab.Content[Wcid].BAOriWcidArray[TID];
 	if ((Idx == 0) || (Idx >= MAX_LEN_OF_BA_ORI_TABLE)) {
 		if (bForceSend == TRUE) {
-			// force send specified TID DelBA
+			/* force send specified TID DelBA */
 			MLME_DELBA_REQ_STRUCT DelbaReq;
 			MLME_QUEUE_ELEM *Elem =
 			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
@@ -831,9 +831,9 @@ VOID BAOriSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("\t===>Idx = %ld, Wcid=%d.TID=%d, ORI_BA_Status = %d \n", Idx,
 		  Wcid, TID, pBAEntry->ORI_BA_Status));
-	//
-	// Prepare DelBA action frame and send to the peer.
-	//
+	/* */
+	/* Prepare DelBA action frame and send to the peer. */
+	/* */
 	if ((bPassive == FALSE) && (TID == pBAEntry->TID)
 	    && (pBAEntry->ORI_BA_Status == Originator_Done)) {
 		MLME_DELBA_REQ_STRUCT DelbaReq;
@@ -863,7 +863,7 @@ VOID BAOriSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
 	BATableFreeOriEntry(pAd, Idx);
 
 	if (bPassive) {
-		//BAOriSessionSetUp(pAd, &pAd->MacTab.Content[Wcid], TID, 0, 10000, TRUE);
+		/*BAOriSessionSetUp(pAd, &pAd->MacTab.Content[Wcid], TID, 0, 10000, TRUE); */
 	}
 }
 
@@ -876,9 +876,9 @@ VOID BARecSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
 	if (Wcid >= MAX_LEN_OF_MAC_TABLE) {
 		return;
 	}
-	//
-	//  Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID).
-	//
+	/* */
+	/*  Locate corresponding BA Originator Entry in BA Table with the (pAddr,TID). */
+	/* */
 	Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
 	if (Idx == 0)
 		return;
@@ -890,21 +890,21 @@ VOID BARecSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("\t===>Idx = %ld, Wcid=%d.TID=%d, REC_BA_Status = %d \n", Idx,
 		  Wcid, TID, pBAEntry->REC_BA_Status));
-	//
-	// Prepare DelBA action frame and send to the peer.
-	//
+	/* */
+	/* Prepare DelBA action frame and send to the peer. */
+	/* */
 	if ((TID == pBAEntry->TID)
 	    && (pBAEntry->REC_BA_Status == Recipient_Accept)) {
 		MLME_DELBA_REQ_STRUCT DelbaReq;
 		BOOLEAN Cancelled;
-		//ULONG   offset;
-		//UINT32  VALUE;
+		/*ULONG   offset; */
+		/*UINT32  VALUE; */
 
 		RTMPCancelTimer(&pBAEntry->RECBATimer, &Cancelled);
 
-		//
-		// 1. Send DELBA Action Frame
-		//
+		/* */
+		/* 1. Send DELBA Action Frame */
+		/* */
 		if (bPassive == FALSE) {
 			MLME_QUEUE_ELEM *Elem =
 			    (MLME_QUEUE_ELEM *) kmalloc(sizeof(MLME_QUEUE_ELEM),
@@ -931,18 +931,18 @@ VOID BARecSessionTearDown(IN OUT PRTMP_ADAPTER pAd,
 			}
 		}
 
-		//
-		// 2. Free resource of BA session
-		//
-		// flush all pending reordering mpdus
+		/* */
+		/* 2. Free resource of BA session */
+		/* */
+		/* flush all pending reordering mpdus */
 		ba_refresh_reordering_mpdus(pAd, pBAEntry);
 
 		NdisAcquireSpinLock(&pAd->BATabLock);
 
-		// Erase Bitmap flag.
+		/* Erase Bitmap flag. */
 		pBAEntry->LastIndSeq = RESET_RCV_SEQ;
 		pBAEntry->BAWinSize = 0;
-		// Erase Bitmap flag at software mactable
+		/* Erase Bitmap flag at software mactable */
 		pAd->MacTab.Content[Wcid].RXBAbitmap &=
 		    (~(1 << (pBAEntry->TID)));
 		pAd->MacTab.Content[Wcid].BARecWcidArray[TID] = 0;
@@ -995,7 +995,7 @@ VOID BAOriSessionSetupTimeout(IN PVOID SystemSpecific1,
 	pAd = pBAEntry->pAdapter;
 
 	{
-		// Do nothing if monitor mode is on
+		/* Do nothing if monitor mode is on */
 		if (MONITOR_ON(pAd))
 			return;
 	}
@@ -1062,7 +1062,7 @@ VOID BARecSessionIdleTimeout(IN PVOID SystemSpecific1,
 		     (unsigned long)(pBAEntry->LastIndSeqAtTimer +
 				     REC_BA_SESSION_IDLE_TIMEOUT))) {
 			pAd = pBAEntry->pAdapter;
-			// flush all pending reordering mpdus
+			/* flush all pending reordering mpdus */
 			ba_refresh_reordering_mpdus(pAd, pBAEntry);
 			DBGPRINT(RT_DEBUG_OFF,
 				 ("%ld: REC BA session Timeout\n", Now32));
@@ -1072,15 +1072,15 @@ VOID BARecSessionIdleTimeout(IN PVOID SystemSpecific1,
 
 VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//      7.4.4.1
-	//ULONG Idx;
+	/*      7.4.4.1 */
+	/*ULONG Idx; */
 	UCHAR Status = 1;
 	UCHAR pAddr[6];
 	FRAME_ADDBA_RSP ADDframe;
 	PUCHAR pOutBuffer = NULL;
 	NDIS_STATUS NStatus;
 	PFRAME_ADDBA_REQ pAddreqFrame = NULL;
-	//UCHAR         BufSize;
+	/*UCHAR         BufSize; */
 	ULONG FrameLen;
 	PULONG ptemp;
 	PMAC_TABLE_ENTRY pMacEntry;
@@ -1088,16 +1088,16 @@ VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("%s ==> (Wcid = %d)\n", __func__, Elem->Wcid));
 
-	//hex_dump("AddBAReq", Elem->Msg, Elem->MsgLen);
+	/*hex_dump("AddBAReq", Elem->Msg, Elem->MsgLen); */
 
-	//ADDBA Request from unknown peer, ignore this.
+	/*ADDBA Request from unknown peer, ignore this. */
 	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
 		return;
 
 	pMacEntry = &pAd->MacTab.Content[Elem->Wcid];
 	DBGPRINT(RT_DEBUG_TRACE, ("BA - PeerAddBAReqAction----> \n"));
 	ptemp = (PULONG) Elem->Msg;
-	//DBGPRINT_RAW(RT_DEBUG_EMU, ("%08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x\n", *(ptemp), *(ptemp+1), *(ptemp+2), *(ptemp+3), *(ptemp+4), *(ptemp+5), *(ptemp+6), *(ptemp+7), *(ptemp+8)));
+	/*DBGPRINT_RAW(RT_DEBUG_EMU, ("%08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x:: %08x\n", *(ptemp), *(ptemp+1), *(ptemp+2), *(ptemp+3), *(ptemp+4), *(ptemp+5), *(ptemp+6), *(ptemp+7), *(ptemp+8))); */
 
 	if (PeerAddBAReqActionSanity(pAd, Elem->Msg, Elem->MsgLen, pAddr)) {
 
@@ -1111,9 +1111,9 @@ VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			     pAddreqFrame))
 				Status = 0;
 			else
-				Status = 38;	// more parameters have invalid values
+				Status = 38;	/* more parameters have invalid values */
 		} else {
-			Status = 37;	// the request has been declined.
+			Status = 37;	/* the request has been declined. */
 		}
 	}
 
@@ -1121,8 +1121,8 @@ VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		ASSERT(pAd->MacTab.Content[Elem->Wcid].Sst == SST_ASSOC);
 
 	pAddreqFrame = (PFRAME_ADDBA_REQ) (&Elem->Msg[0]);
-	// 2. Always send back ADDBA Response
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	/* 2. Always send back ADDBA Response */
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("ACTION - PeerBAAction() allocate memory failed \n"));
@@ -1131,7 +1131,7 @@ VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	NdisZeroMemory(&ADDframe, sizeof(FRAME_ADDBA_RSP));
 
-	// 2-1. Prepare ADDBA Response frame.
+	/* 2-1. Prepare ADDBA Response frame. */
 	{
 		if (ADHOC_ON(pAd))
 			ActHeaderInit(pAd, &ADDframe.Hdr, pAddr,
@@ -1145,7 +1145,7 @@ VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	ADDframe.Category = CATEGORY_BA;
 	ADDframe.Action = ADDBA_RESP;
 	ADDframe.Token = pAddreqFrame->Token;
-	// What is the Status code??  need to check.
+	/* What is the Status code??  need to check. */
 	ADDframe.StatusCode = Status;
 	ADDframe.BaParm.BAPolicy = IMMED_BA;
 	ADDframe.BaParm.AMSDUSupported = 0;
@@ -1156,7 +1156,7 @@ VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	if (ADDframe.BaParm.BufSize == 0) {
 		ADDframe.BaParm.BufSize = 64;
 	}
-	ADDframe.TimeOutValue = 0;	//pAddreqFrame->TimeOutValue;
+	ADDframe.TimeOutValue = 0;	/*pAddreqFrame->TimeOutValue; */
 
 	*(USHORT *) (&ADDframe.BaParm) =
 	    cpu2le16(*(USHORT *) (&ADDframe.BaParm));
@@ -1175,18 +1175,18 @@ VOID PeerAddBAReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 VOID PeerAddBARspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//UCHAR         Idx, i;
-	//PUCHAR                   pOutBuffer = NULL;
+	/*UCHAR         Idx, i; */
+	/*PUCHAR                   pOutBuffer = NULL; */
 	PFRAME_ADDBA_RSP pFrame = NULL;
-	//PBA_ORI_ENTRY         pBAEntry;
+	/*PBA_ORI_ENTRY         pBAEntry; */
 
-	//ADDBA Response from unknown peer, ignore this.
+	/*ADDBA Response from unknown peer, ignore this. */
 	if (Elem->Wcid >= MAX_LEN_OF_MAC_TABLE)
 		return;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("%s ==> Wcid(%d)\n", __func__, Elem->Wcid));
 
-	//hex_dump("PeerAddBARspAction()", Elem->Msg, Elem->MsgLen);
+	/*hex_dump("PeerAddBARspAction()", Elem->Msg, Elem->MsgLen); */
 
 	if (PeerAddBARspActionSanity(pAd, Elem->Msg, Elem->MsgLen)) {
 		pFrame = (PFRAME_ADDBA_RSP) (&Elem->Msg[0]);
@@ -1195,17 +1195,17 @@ VOID PeerAddBARspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			 ("\t\t StatusCode = %d\n", pFrame->StatusCode));
 		switch (pFrame->StatusCode) {
 		case 0:
-			// I want a BAsession with this peer as an originator.
+			/* I want a BAsession with this peer as an originator. */
 			BAOriSessionAdd(pAd, &pAd->MacTab.Content[Elem->Wcid],
 					pFrame);
 			break;
 		default:
-			// check status == USED ???
+			/* check status == USED ??? */
 			BAOriSessionTearDown(pAd, Elem->Wcid,
 					     pFrame->BaParm.TID, TRUE, FALSE);
 			break;
 		}
-		// Rcv Decline StatusCode
+		/* Rcv Decline StatusCode */
 		if ((pFrame->StatusCode == 37)
 		    || ((pAd->OpMode == OPMODE_STA) && STA_TGN_WIFI_ON(pAd)
 			&& (pFrame->StatusCode != 0))
@@ -1218,12 +1218,12 @@ VOID PeerAddBARspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 VOID PeerDelBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	//UCHAR                         Idx;
-	//PUCHAR                                pOutBuffer = NULL;
+	/*UCHAR                         Idx; */
+	/*PUCHAR                                pOutBuffer = NULL; */
 	PFRAME_DELBA_REQ pDelFrame = NULL;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("%s ==>\n", __func__));
-	//DELBA Request from unknown peer, ignore this.
+	/*DELBA Request from unknown peer, ignore this. */
 	if (PeerDelBAActionSanity(pAd, Elem->Wcid, Elem->Msg, Elem->MsgLen)) {
 		pDelFrame = (PFRAME_DELBA_REQ) (&Elem->Msg[0]);
 		if (pDelFrame->DelbaParm.Initiator == ORIGINATOR) {
@@ -1235,7 +1235,7 @@ VOID PeerDelBAAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("BA - PeerDelBAAction----> RECIPIENT, Reason = %d\n",
 				  pDelFrame->ReasonCode));
-			//hex_dump("DelBA Frame", pDelFrame, Elem->MsgLen);
+			/*hex_dump("DelBA Frame", pDelFrame, Elem->MsgLen); */
 			BAOriSessionTearDown(pAd, Elem->Wcid,
 					     pDelFrame->DelbaParm.TID, TRUE,
 					     FALSE);
@@ -1248,26 +1248,26 @@ BOOLEAN CntlEnqueueForRecv(IN PRTMP_ADAPTER pAd,
 			   IN ULONG MsgLen, IN PFRAME_BA_REQ pMsg)
 {
 	PFRAME_BA_REQ pFrame = pMsg;
-	//PRTMP_REORDERBUF      pBuffer;
-	//PRTMP_REORDERBUF      pDmaBuf;
+	/*PRTMP_REORDERBUF      pBuffer; */
+	/*PRTMP_REORDERBUF      pDmaBuf; */
 	PBA_REC_ENTRY pBAEntry;
-	//BOOLEAN       Result;
+	/*BOOLEAN       Result; */
 	ULONG Idx;
-	//UCHAR NumRxPkt;
-	UCHAR TID;		//, i;
+	/*UCHAR NumRxPkt; */
+	UCHAR TID;		/*, i; */
 
 	TID = (UCHAR) pFrame->BARControl.TID;
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("%s(): BAR-Wcid(%ld), Tid (%d)\n", __func__, Wcid, TID));
-	//hex_dump("BAR", (PCHAR) pFrame, MsgLen);
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/*hex_dump("BAR", (PCHAR) pFrame, MsgLen); */
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return FALSE;
 
-	// First check the size, it MUST not exceed the mlme queue size
+	/* First check the size, it MUST not exceed the mlme queue size */
 	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
 		DBGPRINT_ERR(("CntlEnqueueForRecv: frame too large, size = %ld \n", MsgLen));
 		return FALSE;
@@ -1280,7 +1280,7 @@ BOOLEAN CntlEnqueueForRecv(IN PRTMP_ADAPTER pAd,
 	}
 
 	if ((Wcid < MAX_LEN_OF_MAC_TABLE) && (TID < 8)) {
-		// if this receiving packet is from SA that is in our OriEntry. Since WCID <9 has direct mapping. no need search.
+		/* if this receiving packet is from SA that is in our OriEntry. Since WCID <9 has direct mapping. no need search. */
 		Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
 		pBAEntry = &pAd->BATable.BARecEntry[Idx];
 	} else {
@@ -1294,7 +1294,7 @@ BOOLEAN CntlEnqueueForRecv(IN PRTMP_ADAPTER pAd,
 	if (SEQ_SMALLER
 	    (pBAEntry->LastIndSeq, pFrame->BAStartingSeq.field.StartSeq,
 	     MAXSEQ)) {
-		//DBGPRINT(RT_DEBUG_TRACE, ("BAR Seq = %x, LastIndSeq = %x\n", pFrame->BAStartingSeq.field.StartSeq, pBAEntry->LastIndSeq));
+		/*DBGPRINT(RT_DEBUG_TRACE, ("BAR Seq = %x, LastIndSeq = %x\n", pFrame->BAStartingSeq.field.StartSeq, pBAEntry->LastIndSeq)); */
 		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry,
 						    pFrame->BAStartingSeq.field.
 						    StartSeq);
@@ -1302,7 +1302,7 @@ BOOLEAN CntlEnqueueForRecv(IN PRTMP_ADAPTER pAd,
 		    (pFrame->BAStartingSeq.field.StartSeq ==
 		     0) ? MAXSEQ : (pFrame->BAStartingSeq.field.StartSeq - 1);
 	}
-	//ba_refresh_reordering_mpdus(pAd, pBAEntry);
+	/*ba_refresh_reordering_mpdus(pAd, pBAEntry); */
 	return TRUE;
 }
 
@@ -1313,11 +1313,11 @@ VOID SendPSMPAction(IN PRTMP_ADAPTER pAd, IN UCHAR Wcid, IN UCHAR Psmp)
 {
 	PUCHAR pOutBuffer = NULL;
 	NDIS_STATUS NStatus;
-	//ULONG           Idx;
+	/*ULONG           Idx; */
 	FRAME_PSMP_ACTION Frame;
 	ULONG FrameLen;
 
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("BA - MlmeADDBAAction() allocate memory failed \n"));
@@ -1337,7 +1337,7 @@ VOID SendPSMPAction(IN PRTMP_ADAPTER pAd, IN UCHAR Wcid, IN UCHAR Psmp)
 			|| pAd->Antenna.field.TxPath > 1)) {
 			RTMP_ASIC_MMPS_DISABLE(pAd);
 		}
-#endif // RT30xx //
+#endif /* RT30xx // */
 		Frame.Psmp = 0;
 		break;
 	case MMPS_DYNAMIC:
@@ -1350,7 +1350,7 @@ VOID SendPSMPAction(IN PRTMP_ADAPTER pAd, IN UCHAR Wcid, IN UCHAR Psmp)
 			|| pAd->Antenna.field.TxPath > 1)) {
 			RTMP_ASIC_MMPS_ENABLE(pAd);
 		}
-#endif // RT30xx //
+#endif /* RT30xx // */
 		Frame.Psmp = 1;
 		break;
 	}
@@ -1372,7 +1372,7 @@ typedef struct PACKED {
 	UCHAR BSSID[MAC_ADDR_LEN];
 	UCHAR ReportingCondition;
 	UCHAR Threshold;
-	UCHAR SSIDIE[2];	// 2 byte
+	UCHAR SSIDIE[2];	/* 2 byte */
 } BEACON_REQUEST;
 
 typedef struct PACKED {
@@ -1391,10 +1391,10 @@ void convert_reordering_packet_to_preAMSDU_or_802_3_packet(IN PRTMP_ADAPTER pAd,
 	PNDIS_PACKET pRxPkt;
 	UCHAR Header802_3[LENGTH_802_3];
 
-	// 1. get 802.3 Header
-	// 2. remove LLC
-	//              a. pointer pRxBlk->pData to payload
-	//      b. modify pRxBlk->DataSize
+	/* 1. get 802.3 Header */
+	/* 2. remove LLC */
+	/*              a. pointer pRxBlk->pData to payload */
+	/*      b. modify pRxBlk->DataSize */
 
 	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
 
@@ -1406,9 +1406,9 @@ void convert_reordering_packet_to_preAMSDU_or_802_3_packet(IN PRTMP_ADAPTER pAd,
 	SET_OS_PKT_LEN(pRxPkt, pRxBlk->DataSize);
 	SET_OS_PKT_DATATAIL(pRxPkt, pRxBlk->pData, pRxBlk->DataSize);
 
-	//
-	// copy 802.3 header, if necessary
-	//
+	/* */
+	/* copy 802.3 header, if necessary */
+	/* */
 	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)) {
 		{
 #ifdef LINUX
@@ -1446,7 +1446,7 @@ static VOID ba_enqueue_reordering_packet(IN PRTMP_ADAPTER pAd,
 
 	mpdu_blk = ba_mpdu_blk_alloc(pAd);
 	if ((mpdu_blk != NULL) && (!RX_BLK_TEST_FLAG(pRxBlk, fRX_EAP))) {
-		// Write RxD buffer address & allocated buffer length
+		/* Write RxD buffer address & allocated buffer length */
 		NdisAcquireSpinLock(&pBAEntry->RxReRingLock);
 
 		mpdu_blk->Sequence = Sequence;
@@ -1459,18 +1459,18 @@ static VOID ba_enqueue_reordering_packet(IN PRTMP_ADAPTER pAd,
 
 		STATS_INC_RX_PACKETS(pAd, FromWhichBSSID);
 
-		//
-		// it is necessary for reordering packet to record
-		// which BSS it come from
-		//
+		/* */
+		/* it is necessary for reordering packet to record */
+		/* which BSS it come from */
+		/* */
 		RTMP_SET_PACKET_IF(pRxBlk->pRxPacket, FromWhichBSSID);
 
 		mpdu_blk->pPacket = pRxBlk->pRxPacket;
 
 		if (ba_reordering_mpdu_insertsorted(&pBAEntry->list, mpdu_blk)
 		    == FALSE) {
-			// had been already within reordering list
-			// don't indicate
+			/* had been already within reordering list */
+			/* don't indicate */
 			RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 					    NDIS_STATUS_SUCCESS);
 			ba_mpdu_blk_free(pAd, mpdu_blk);
@@ -1489,7 +1489,7 @@ static VOID ba_enqueue_reordering_packet(IN PRTMP_ADAPTER pAd,
 		 * and receving mpdu to upper layer
 		 * make tcp/ip to take care reordering mechanism
 		 */
-		//ba_refresh_reordering_mpdus(pAd, pBAEntry);
+		/*ba_refresh_reordering_mpdus(pAd, pBAEntry); */
 		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, Sequence);
 
 		pBAEntry->LastIndSeq = Sequence;
@@ -1527,7 +1527,7 @@ VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
 
 	if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)
 	    && (pRxBlk->DataSize > MAX_RX_PKT_LEN)) {
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 		return;
@@ -1542,9 +1542,9 @@ VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
 		}
 		pBAEntry = &pAd->BATable.BARecEntry[Idx];
 	} else {
-		// impossible !!!
+		/* impossible !!! */
 		ASSERT(0);
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 		return;
@@ -1552,7 +1552,7 @@ VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
 
 	ASSERT(pBAEntry);
 
-	// update last rx time
+	/* update last rx time */
 	NdisGetSystemUpTime(&Now32);
 
 	pBAEntry->rcvSeq = Sequence;
@@ -1560,23 +1560,23 @@ VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
 	ba_flush_reordering_timeout_mpdus(pAd, pBAEntry, Now32);
 	pBAEntry->LastIndSeqAtTimer = Now32;
 
-	//
-	// Reset Last Indicate Sequence
-	//
+	/* */
+	/* Reset Last Indicate Sequence */
+	/* */
 	if (pBAEntry->LastIndSeq == RESET_RCV_SEQ) {
 		ASSERT((pBAEntry->list.qlen == 0)
 		       && (pBAEntry->list.next == NULL));
 
-		// reset rcv sequence of BA session
+		/* reset rcv sequence of BA session */
 		pBAEntry->LastIndSeq = Sequence;
 		pBAEntry->LastIndSeqAtTimer = Now32;
 		INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, FromWhichBSSID);
 		return;
 	}
 
-	//
-	// I. Check if in order.
-	//
+	/* */
+	/* I. Check if in order. */
+	/* */
 	if (SEQ_STEPONE(Sequence, pBAEntry->LastIndSeq, MAXSEQ)) {
 		USHORT LastIndSeq;
 
@@ -1590,29 +1590,29 @@ VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
 		}
 		pBAEntry->LastIndSeqAtTimer = Now32;
 	}
-	//
-	// II. Drop Duplicated Packet
-	//
+	/* */
+	/* II. Drop Duplicated Packet */
+	/* */
 	else if (Sequence == pBAEntry->LastIndSeq) {
 
-		// drop and release packet
+		/* drop and release packet */
 		pBAEntry->nDropPacket++;
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 	}
-	//
-	// III. Drop Old Received Packet
-	//
+	/* */
+	/* III. Drop Old Received Packet */
+	/* */
 	else if (SEQ_SMALLER(Sequence, pBAEntry->LastIndSeq, MAXSEQ)) {
 
-		// drop and release packet
+		/* drop and release packet */
 		pBAEntry->nDropPacket++;
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 	}
-	//
-	// IV. Receive Sequence within Window Size
-	//
+	/* */
+	/* IV. Receive Sequence within Window Size */
+	/* */
 	else if (SEQ_SMALLER
 		 (Sequence,
 		  (((pBAEntry->LastIndSeq + pBAEntry->BAWinSize + 1)) & MAXSEQ),
@@ -1620,9 +1620,9 @@ VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
 		ba_enqueue_reordering_packet(pAd, pBAEntry, pRxBlk,
 					     FromWhichBSSID);
 	}
-	//
-	// V. Receive seq surpasses Win(lastseq + nMSDU). So refresh all reorder buffer
-	//
+	/* */
+	/* V. Receive seq surpasses Win(lastseq + nMSDU). So refresh all reorder buffer */
+	/* */
 	else {
 		LONG WinStartSeq, TmpSeq;
 
@@ -1632,7 +1632,7 @@ VOID Indicate_AMPDU_Packet(IN PRTMP_ADAPTER pAd,
 		}
 		WinStartSeq = (TmpSeq + 1) & MAXSEQ;
 		ba_indicate_reordering_mpdus_le_seq(pAd, pBAEntry, WinStartSeq);
-		pBAEntry->LastIndSeq = WinStartSeq;	//TmpSeq;
+		pBAEntry->LastIndSeq = WinStartSeq;	/*TmpSeq; */
 
 		pBAEntry->LastIndSeqAtTimer = Now32;
 
diff --git a/drivers/staging/rt2860/common/cmm_aes.c b/drivers/staging/rt2860/common/cmm_aes.c
index a3758b0..030678c 100644
--- a/drivers/staging/rt2860/common/cmm_aes.c
+++ b/drivers/staging/rt2860/common/cmm_aes.c
@@ -277,7 +277,7 @@ void construct_mic_header2(unsigned char *mic_header2,
 	mic_header2[4] = mpdu[20];
 	mic_header2[5] = mpdu[21];
 
-	// In Sequence Control field, mute sequence numer bits (12-bit)
+	/* In Sequence Control field, mute sequence numer bits (12-bit) */
 	mic_header2[6] = mpdu[22] & 0x0f;	/* SC */
 	mic_header2[7] = 0x00;	/* mpdu[23]; */
 
@@ -403,7 +403,7 @@ void construct_ctr_preload(unsigned char *ctr_preload,
 	for (i = 8; i < 14; i++)
 		ctr_preload[i] = pn_vector[13 - i];	/* ctr_preload[8:13] = PN[5:0] */
 #endif
-	ctr_preload[14] = (unsigned char)(c / 256);	// Ctr
+	ctr_preload[14] = (unsigned char)(c / 256);	/* Ctr */
 	ctr_preload[15] = (unsigned char)(c % 256);
 
 }
@@ -477,12 +477,12 @@ BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
 	PN[4] = *(pData + HeaderLen + 6);
 	PN[5] = *(pData + HeaderLen + 7);
 
-	payload_len = DataByteCnt - HeaderLen - 8 - 8;	// 8 bytes for CCMP header , 8 bytes for MIC
+	payload_len = DataByteCnt - HeaderLen - 8 - 8;	/* 8 bytes for CCMP header , 8 bytes for MIC */
 	payload_remainder = (payload_len) % 16;
 	num_blocks = (payload_len) / 16;
 
-	// Find start of payload
-	payload_index = HeaderLen + 8;	//IV+EIV
+	/* Find start of payload */
+	payload_index = HeaderLen + 8;	/*IV+EIV */
 
 	for (i = 0; i < num_blocks; i++) {
 		construct_ctr_preload(ctr_preload,
@@ -495,10 +495,10 @@ BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
 		payload_index += 16;
 	}
 
-	//
-	// If there is a short final block, then pad it
-	// encrypt it and copy the unpadded part back
-	//
+	/* */
+	/* If there is a short final block, then pad it */
+	/* encrypt it and copy the unpadded part back */
+	/* */
 	if (payload_remainder > 0) {
 		construct_ctr_preload(ctr_preload,
 				      a4_exists,
@@ -515,9 +515,9 @@ BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
 			       payload_remainder);
 		payload_index += payload_remainder;
 	}
-	//
-	// Descrypt the MIC
-	//
+	/* */
+	/* Descrypt the MIC */
+	/* */
 	construct_ctr_preload(ctr_preload, a4_exists, qc_exists, pData, PN, 0);
 	NdisZeroMemory(padded_buffer, 16);
 	NdisMoveMemory(padded_buffer, pData + payload_index, 8);
@@ -528,15 +528,15 @@ BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
 
 	NdisMoveMemory(TrailMIC, chain_buffer, 8);
 
-	//
-	// Calculate MIC
-	//
+	/* */
+	/* Calculate MIC */
+	/* */
 
-	//Force the protected frame bit on
+	/*Force the protected frame bit on */
 	*(pData + 1) = *(pData + 1) | 0x40;
 
-	// Find start of payload
-	// Because the CCMP header has been removed
+	/* Find start of payload */
+	/* Because the CCMP header has been removed */
 	payload_index = HeaderLen;
 
 	construct_mic_iv(mic_iv, qc_exists, a4_exists, pData, payload_len, PN);
@@ -551,14 +551,14 @@ BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
 	bitwise_xor(aes_out, mic_header2, chain_buffer);
 	aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
 
-	// iterate through each 16 byte payload block
+	/* iterate through each 16 byte payload block */
 	for (i = 0; i < num_blocks; i++) {
 		bitwise_xor(aes_out, pData + payload_index, chain_buffer);
 		payload_index += 16;
 		aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
 	}
 
-	// Add on the final payload block if it needs padding
+	/* Add on the final payload block if it needs padding */
 	if (payload_remainder > 0) {
 		NdisZeroMemory(padded_buffer, 16);
 		NdisMoveMemory(padded_buffer, pData + payload_index,
@@ -567,13 +567,13 @@ BOOLEAN RTMPSoftDecryptAES(IN PRTMP_ADAPTER pAd,
 		bitwise_xor(aes_out, padded_buffer, chain_buffer);
 		aes128k128d(pWpaKey[KeyID].Key, chain_buffer, aes_out);
 	}
-	// aes_out contains padded mic, discard most significant
-	// 8 bytes to generate 64 bit MIC
+	/* aes_out contains padded mic, discard most significant */
+	/* 8 bytes to generate 64 bit MIC */
 	for (i = 0; i < 8; i++)
 		MIC[i] = aes_out[i];
 
 	if (!NdisEqualMemory(MIC, TrailMIC, 8)) {
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptAES, MIC Error !\n"));	//MIC error.
+		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptAES, MIC Error !\n"));	/*MIC error. */
 		return FALSE;
 	}
 
@@ -1208,27 +1208,27 @@ VOID AES_GTK_KEY_WRAP(IN UCHAR * key,
 {
 	UCHAR A[8], BIN[16], BOUT[16];
 	UCHAR R[512];
-	INT num_blocks = p_len / 8;	// unit:64bits
+	INT num_blocks = p_len / 8;	/* unit:64bits */
 	INT i, j;
 	aes_context aesctx;
 	UCHAR xor;
 
 	rt_aes_set_key(&aesctx, key, 128);
 
-	// Init IA
+	/* Init IA */
 	for (i = 0; i < 8; i++)
 		A[i] = 0xa6;
 
-	//Input plaintext
+	/*Input plaintext */
 	for (i = 0; i < num_blocks; i++) {
 		for (j = 0; j < 8; j++)
 			R[8 * (i + 1) + j] = plaintext[8 * i + j];
 	}
 
-	// Key Mix
+	/* Key Mix */
 	for (j = 0; j < 6; j++) {
 		for (i = 1; i <= num_blocks; i++) {
-			//phase 1
+			/*phase 1 */
 			NdisMoveMemory(BIN, A, 8);
 			NdisMoveMemory(&BIN[8], &R[8 * i], 8);
 			rt_aes_encrypt(&aesctx, BIN, BOUT);
@@ -1240,7 +1240,7 @@ VOID AES_GTK_KEY_WRAP(IN UCHAR * key,
 		}
 	}
 
-	// Output ciphertext
+	/* Output ciphertext */
 	NdisMoveMemory(ciphertext, A, 8);
 
 	for (i = 1; i <= num_blocks; i++) {
@@ -1273,7 +1273,7 @@ VOID AES_GTK_KEY_UNWRAP(IN UCHAR * key,
 	INT i, j;
 	aes_context aesctx;
 	UCHAR *R;
-	INT num_blocks = c_len / 8;	// unit:64bits
+	INT num_blocks = c_len / 8;	/* unit:64bits */
 
 	os_alloc_mem(NULL, (PUCHAR *) & R, 512);
 
@@ -1283,9 +1283,9 @@ VOID AES_GTK_KEY_UNWRAP(IN UCHAR * key,
 		return;
 	}
 	/* End of if */
-	// Initialize
+	/* Initialize */
 	NdisMoveMemory(A, ciphertext, 8);
-	//Input plaintext
+	/*Input plaintext */
 	for (i = 0; i < (c_len - 8); i++) {
 		R[i] = ciphertext[i + 8];
 	}
@@ -1304,7 +1304,7 @@ VOID AES_GTK_KEY_UNWRAP(IN UCHAR * key,
 		}
 	}
 
-	// OUTPUT
+	/* OUTPUT */
 	for (i = 0; i < c_len; i++) {
 		plaintext[i] = R[i];
 	}
diff --git a/drivers/staging/rt2860/common/cmm_asic.c b/drivers/staging/rt2860/common/cmm_asic.c
index 7205b36..468aba5 100644
--- a/drivers/staging/rt2860/common/cmm_asic.c
+++ b/drivers/staging/rt2860/common/cmm_asic.c
@@ -37,9 +37,9 @@
 
 #include "../rt_config.h"
 
-// Reset the RFIC setting to new series
+/* Reset the RFIC setting to new series */
 RTMP_RF_REGS RF2850RegTable[] = {
-//              ch       R1              R2              R3(TX0~4=0) R4
+/*              ch       R1              R2              R3(TX0~4=0) R4 */
 	{1, 0x98402ecc, 0x984c0786, 0x9816b455, 0x9800510b}
 	,
 	{2, 0x98402ecc, 0x984c0786, 0x98168a55, 0x9800519f}
@@ -69,7 +69,7 @@ RTMP_RF_REGS RF2850RegTable[] = {
 	{14, 0x98402ecc, 0x984c07a2, 0x98168a55, 0x98005193}
 	,
 
-	// 802.11 UNI / HyperLan 2
+	/* 802.11 UNI / HyperLan 2 */
 	{36, 0x98402ecc, 0x984c099a, 0x98158a55, 0x980ed1a3}
 	,
 	{38, 0x98402ecc, 0x984c099e, 0x98158a55, 0x980ed193}
@@ -93,15 +93,15 @@ RTMP_RF_REGS RF2850RegTable[] = {
 	{62, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed193}
 	,
 	{64, 0x98402ec8, 0x984c0692, 0x98158a55, 0x980ed1a3}
-	,			// Plugfest#4, Day4, change RFR3 left4th 9->5.
+	,			/* Plugfest#4, Day4, change RFR3 left4th 9->5. */
 
-	// 802.11 HyperLan 2
+	/* 802.11 HyperLan 2 */
 	{100, 0x98402ec8, 0x984c06b2, 0x98178a55, 0x980ed783}
 	,
 
-	// 2008.04.30 modified
-	// The system team has AN to improve the EVM value
-	// for channel 102 to 108 for the RT2850/RT2750 dual band solution.
+	/* 2008.04.30 modified */
+	/* The system team has AN to improve the EVM value */
+	/* for channel 102 to 108 for the RT2850/RT2750 dual band solution. */
 	{102, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed793}
 	,
 	{104, 0x98402ec8, 0x985c06b2, 0x98578a55, 0x980ed1a3}
@@ -122,7 +122,7 @@ RTMP_RF_REGS RF2850RegTable[] = {
 	{124, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed193}
 	,
 	{126, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed15b}
-	,			// 0x980ed1bb->0x980ed15b required by Rory 20070927
+	,			/* 0x980ed1bb->0x980ed15b required by Rory 20070927 */
 	{128, 0x98402ec4, 0x984c0382, 0x98178a55, 0x980ed1a3}
 	,
 	{132, 0x98402ec4, 0x984c0386, 0x98178a55, 0x980ed18b}
@@ -134,7 +134,7 @@ RTMP_RF_REGS RF2850RegTable[] = {
 	{140, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed183}
 	,
 
-	// 802.11 UNII
+	/* 802.11 UNII */
 	{149, 0x98402ec4, 0x984c038a, 0x98178a55, 0x980ed1a7}
 	,
 	{151, 0x98402ec4, 0x984c038e, 0x98178a55, 0x980ed187}
@@ -158,7 +158,7 @@ RTMP_RF_REGS RF2850RegTable[] = {
 	{173, 0x98402ec4, 0x984c03d6, 0x98179855, 0x9815530f}
 	,
 
-	// Japan
+	/* Japan */
 	{184, 0x95002ccc, 0x9500491e, 0x9509be55, 0x950c0a0b}
 	,
 	{188, 0x95002ccc, 0x95004922, 0x9509be55, 0x950c0a13}
@@ -174,18 +174,18 @@ RTMP_RF_REGS RF2850RegTable[] = {
 	{216, 0x95002ccc, 0x95004982, 0x9509be55, 0x950c0a23}
 	,
 
-	// still lack of MMAC(Japan) ch 34,38,42,46
+	/* still lack of MMAC(Japan) ch 34,38,42,46 */
 };
 
 UCHAR NUM_OF_2850_CHNL = (sizeof(RF2850RegTable) / sizeof(RTMP_RF_REGS));
 
 FREQUENCY_ITEM FreqItems3020[] = {
 	/**************************************************/
-	// ISM : 2.4 to 2.483 GHz                         //
+	/* ISM : 2.4 to 2.483 GHz                         // */
 	/**************************************************/
-	// 11g
+	/* 11g */
 	/**************************************************/
-	//-CH---N-------R---K-----------
+	/*-CH---N-------R---K----------- */
 	{1, 241, 2, 2}
 	,
 	{2, 241, 2, 7}
@@ -227,7 +227,7 @@ VOID AsicUpdateAutoFallBackTable(IN PRTMP_ADAPTER pAd, IN PUCHAR pRateTable)
 	LG_FBK_CFG1_STRUC LgCfg1;
 	PRTMP_TX_RATE_SWITCH pCurrTxRate, pNextTxRate;
 
-	// set to initial value
+	/* set to initial value */
 	HtCfg0.word = 0x65432100;
 	HtCfg1.word = 0xedcba988;
 	LgCfg0.word = 0xedcba988;
@@ -237,9 +237,9 @@ VOID AsicUpdateAutoFallBackTable(IN PRTMP_ADAPTER pAd, IN PUCHAR pRateTable)
 	for (i = 1; i < *((PUCHAR) pRateTable); i++) {
 		pCurrTxRate = (PRTMP_TX_RATE_SWITCH) pRateTable + 1 + i;
 		switch (pCurrTxRate->Mode) {
-		case 0:	//CCK
+		case 0:	/*CCK */
 			break;
-		case 1:	//OFDM
+		case 1:	/*OFDM */
 			{
 				switch (pCurrTxRate->CurrMCS) {
 				case 0:
@@ -309,8 +309,8 @@ VOID AsicUpdateAutoFallBackTable(IN PRTMP_ADAPTER pAd, IN PUCHAR pRateTable)
 				}
 			}
 			break;
-		case 2:	//HT-MIX
-		case 3:	//HT-GF
+		case 2:	/*HT-MIX */
+		case 3:	/*HT-GF */
 			{
 				if ((pNextTxRate->Mode >= MODE_HTMIX)
 				    && (pCurrTxRate->CurrMCS !=
@@ -433,16 +433,16 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 	}
 
 	if (pAd->BATable.numDoneOriginator) {
-		//
-		// enable the RTS/CTS to avoid channel collision
-		//
+		/* */
+		/* enable the RTS/CTS to avoid channel collision */
+		/* */
 		SetMask = ALLN_SETPROTECT;
 		OperationMode = 8;
 	}
-	// Config ASIC RTS threshold register
+	/* Config ASIC RTS threshold register */
 	RTMP_IO_READ32(pAd, TX_RTS_CFG, &MacReg);
 	MacReg &= 0xFF0000FF;
-	// If the user want disable RtsThreshold and enable Amsdu/Ralink-Aggregation, set the RtsThreshold as 4096
+	/* If the user want disable RtsThreshold and enable Amsdu/Ralink-Aggregation, set the RtsThreshold as 4096 */
 	if (((pAd->CommonCfg.BACapability.field.AmsduEnable) ||
 	     (pAd->CommonCfg.bAggregationCapable == TRUE))
 	    && pAd->CommonCfg.RtsThreshold == MAX_RTS_THRESHOLD) {
@@ -453,7 +453,7 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 
 	RTMP_IO_WRITE32(pAd, TX_RTS_CFG, MacReg);
 
-	// Initial common protection settings
+	/* Initial common protection settings */
 	RTMPZeroMemory(Protect, sizeof(Protect));
 	ProtCfg4.word = 0;
 	ProtCfg.word = 0;
@@ -466,72 +466,72 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 	ProtCfg.field.RTSThEn = 1;
 	ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
 
-	// update PHY mode and rate
+	/* update PHY mode and rate */
 	if (pAd->CommonCfg.Channel > 14)
 		ProtCfg.field.ProtectRate = 0x4000;
 	ProtCfg.field.ProtectRate |= pAd->CommonCfg.RtsRate;
 
-	// Handle legacy(B/G) protection
+	/* Handle legacy(B/G) protection */
 	if (bDisableBGProtect) {
-		//ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;
+		/*ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate; */
 		ProtCfg.field.ProtectCtrl = 0;
 		Protect[0] = ProtCfg.word;
 		Protect[1] = ProtCfg.word;
 		pAd->FlgCtsEnabled = 0;	/* CTS-self is not used */
 	} else {
-		//ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate;
-		ProtCfg.field.ProtectCtrl = 0;	// CCK do not need to be protected
+		/*ProtCfg.field.ProtectRate = pAd->CommonCfg.RtsRate; */
+		ProtCfg.field.ProtectCtrl = 0;	/* CCK do not need to be protected */
 		Protect[0] = ProtCfg.word;
-		ProtCfg.field.ProtectCtrl = ASIC_CTS;	// OFDM needs using CCK to protect
+		ProtCfg.field.ProtectCtrl = ASIC_CTS;	/* OFDM needs using CCK to protect */
 		Protect[1] = ProtCfg.word;
 		pAd->FlgCtsEnabled = 1;	/* CTS-self is used */
 	}
 
-	// Decide HT frame protection.
+	/* Decide HT frame protection. */
 	if ((SetMask & ALLN_SETPROTECT) != 0) {
 		switch (OperationMode) {
 		case 0x0:
-			// NO PROTECT
-			// 1.All STAs in the BSS are 20/40 MHz HT
-			// 2. in ai 20/40MHz BSS
-			// 3. all STAs are 20MHz in a 20MHz BSS
-			// Pure HT. no protection.
-
-			// MM20_PROT_CFG
-			//      Reserved (31:27)
-			//      PROT_TXOP(25:20) -- 010111
-			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
-			//  PROT_CTRL(17:16) -- 00 (None)
-			//      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M)
+			/* NO PROTECT */
+			/* 1.All STAs in the BSS are 20/40 MHz HT */
+			/* 2. in ai 20/40MHz BSS */
+			/* 3. all STAs are 20MHz in a 20MHz BSS */
+			/* Pure HT. no protection. */
+
+			/* MM20_PROT_CFG */
+			/*      Reserved (31:27) */
+			/*      PROT_TXOP(25:20) -- 010111 */
+			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
+			/*  PROT_CTRL(17:16) -- 00 (None) */
+			/*      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M) */
 			Protect[2] = 0x01744004;
 
-			// MM40_PROT_CFG
-			//      Reserved (31:27)
-			//      PROT_TXOP(25:20) -- 111111
-			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
-			//  PROT_CTRL(17:16) -- 00 (None)
-			//      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)
+			/* MM40_PROT_CFG */
+			/*      Reserved (31:27) */
+			/*      PROT_TXOP(25:20) -- 111111 */
+			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
+			/*  PROT_CTRL(17:16) -- 00 (None) */
+			/*      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M) */
 			Protect[3] = 0x03f44084;
 
-			// CF20_PROT_CFG
-			//      Reserved (31:27)
-			//      PROT_TXOP(25:20) -- 010111
-			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
-			//  PROT_CTRL(17:16) -- 00 (None)
-			//      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M)
+			/* CF20_PROT_CFG */
+			/*      Reserved (31:27) */
+			/*      PROT_TXOP(25:20) -- 010111 */
+			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
+			/*  PROT_CTRL(17:16) -- 00 (None) */
+			/*      PROT_RATE(15:0)  -- 0x4004 (OFDM 24M) */
 			Protect[4] = 0x01744004;
 
-			// CF40_PROT_CFG
-			//      Reserved (31:27)
-			//      PROT_TXOP(25:20) -- 111111
-			//      PROT_NAV(19:18)  -- 01 (Short NAV protection)
-			//  PROT_CTRL(17:16) -- 00 (None)
-			//      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M)
+			/* CF40_PROT_CFG */
+			/*      Reserved (31:27) */
+			/*      PROT_TXOP(25:20) -- 111111 */
+			/*      PROT_NAV(19:18)  -- 01 (Short NAV protection) */
+			/*  PROT_CTRL(17:16) -- 00 (None) */
+			/*      PROT_RATE(15:0)  -- 0x4084 (duplicate OFDM 24M) */
 			Protect[5] = 0x03f44084;
 
 			if (bNonGFExist) {
-				// PROT_NAV(19:18)  -- 01 (Short NAV protectiion)
-				// PROT_CTRL(17:16) -- 01 (RTS/CTS)
+				/* PROT_NAV(19:18)  -- 01 (Short NAV protectiion) */
+				/* PROT_CTRL(17:16) -- 01 (RTS/CTS) */
 				Protect[4] = 0x01754004;
 				Protect[5] = 0x03f54084;
 			}
@@ -539,16 +539,16 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 			break;
 
 		case 1:
-			// This is "HT non-member protection mode."
-			// If there may be non-HT STAs my BSS
-			ProtCfg.word = 0x01744004;	// PROT_CTRL(17:16) : 0 (None)
-			ProtCfg4.word = 0x03f44084;	// duplicaet legacy 24M. BW set 1.
+			/* This is "HT non-member protection mode." */
+			/* If there may be non-HT STAs my BSS */
+			ProtCfg.word = 0x01744004;	/* PROT_CTRL(17:16) : 0 (None) */
+			ProtCfg4.word = 0x03f44084;	/* duplicaet legacy 24M. BW set 1. */
 			if (OPSTATUS_TEST_FLAG
 			    (pAd, fOP_STATUS_BG_PROTECTION_INUSED)) {
-				ProtCfg.word = 0x01740003;	//ERP use Protection bit is set, use protection rate at Clause 18..
-				ProtCfg4.word = 0x03f40003;	// Don't duplicate RTS/CTS in CCK mode. 0x03f40083;
+				ProtCfg.word = 0x01740003;	/*ERP use Protection bit is set, use protection rate at Clause 18.. */
+				ProtCfg4.word = 0x03f40003;	/* Don't duplicate RTS/CTS in CCK mode. 0x03f40083; */
 			}
-			//Assign Protection method for 20&40 MHz packets
+			/*Assign Protection method for 20&40 MHz packets */
 			ProtCfg.field.ProtectCtrl = ASIC_RTS;
 			ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
 			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
@@ -561,11 +561,11 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 			break;
 
 		case 2:
-			// If only HT STAs are in BSS. at least one is 20MHz. Only protect 40MHz packets
-			ProtCfg.word = 0x01744004;	// PROT_CTRL(17:16) : 0 (None)
-			ProtCfg4.word = 0x03f44084;	// duplicaet legacy 24M. BW set 1.
+			/* If only HT STAs are in BSS. at least one is 20MHz. Only protect 40MHz packets */
+			ProtCfg.word = 0x01744004;	/* PROT_CTRL(17:16) : 0 (None) */
+			ProtCfg4.word = 0x03f44084;	/* duplicaet legacy 24M. BW set 1. */
 
-			//Assign Protection method for 40MHz packets
+			/*Assign Protection method for 40MHz packets */
 			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
 			ProtCfg4.field.ProtectNav = ASIC_SHORTNAV;
 			Protect[2] = ProtCfg.word;
@@ -581,17 +581,17 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 			break;
 
 		case 3:
-			// HT mixed mode.        PROTECT ALL!
-			// Assign Rate
-			ProtCfg.word = 0x01744004;	//duplicaet legacy 24M. BW set 1.
+			/* HT mixed mode.        PROTECT ALL! */
+			/* Assign Rate */
+			ProtCfg.word = 0x01744004;	/*duplicaet legacy 24M. BW set 1. */
 			ProtCfg4.word = 0x03f44084;
-			// both 20MHz and 40MHz are protected. Whether use RTS or CTS-to-self depends on the
+			/* both 20MHz and 40MHz are protected. Whether use RTS or CTS-to-self depends on the */
 			if (OPSTATUS_TEST_FLAG
 			    (pAd, fOP_STATUS_BG_PROTECTION_INUSED)) {
-				ProtCfg.word = 0x01740003;	//ERP use Protection bit is set, use protection rate at Clause 18..
-				ProtCfg4.word = 0x03f40003;	// Don't duplicate RTS/CTS in CCK mode. 0x03f40083
+				ProtCfg.word = 0x01740003;	/*ERP use Protection bit is set, use protection rate at Clause 18.. */
+				ProtCfg4.word = 0x03f40003;	/* Don't duplicate RTS/CTS in CCK mode. 0x03f40083 */
 			}
-			//Assign Protection method for 20&40 MHz packets
+			/*Assign Protection method for 20&40 MHz packets */
 			ProtCfg.field.ProtectCtrl = ASIC_RTS;
 			ProtCfg.field.ProtectNav = ASIC_SHORTNAV;
 			ProtCfg4.field.ProtectCtrl = ASIC_RTS;
@@ -604,7 +604,7 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 			break;
 
 		case 8:
-			// Special on for Atheros problem n chip.
+			/* Special on for Atheros problem n chip. */
 			Protect[2] = 0x01754004;
 			Protect[3] = 0x03f54084;
 			Protect[4] = 0x01754004;
@@ -634,17 +634,17 @@ VOID AsicUpdateProtect(IN PRTMP_ADAPTER pAd,
 VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 {
 	ULONG R2 = 0, R3 = DEFAULT_RF_TX_POWER, R4 = 0;
-	CHAR TxPwer = 0, TxPwer2 = DEFAULT_RF_TX_POWER;	//Bbp94 = BBPR94_DEFAULT, TxPwer2 = DEFAULT_RF_TX_POWER;
+	CHAR TxPwer = 0, TxPwer2 = DEFAULT_RF_TX_POWER;	/*Bbp94 = BBPR94_DEFAULT, TxPwer2 = DEFAULT_RF_TX_POWER; */
 	UCHAR index;
-	UINT32 Value = 0;	//BbpReg, Value;
+	UINT32 Value = 0;	/*BbpReg, Value; */
 	RTMP_RF_REGS *RFRegTable;
 	UCHAR RFValue;
 
 	RFValue = 0;
-	// Search Tx power value
-	// We can't use ChannelList to search channel, since some central channl's txpowr doesn't list
-	// in ChannelList, so use TxPower array instead.
-	//
+	/* Search Tx power value */
+	/* We can't use ChannelList to search channel, since some central channl's txpowr doesn't list */
+	/* in ChannelList, so use TxPower array instead. */
+	/* */
 	for (index = 0; index < MAX_NUM_OF_CHANNELS; index++) {
 		if (Channel == pAd->TxPower[index].Channel) {
 			TxPwer = pAd->TxPower[index].Power;
@@ -659,7 +659,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 			  Channel));
 	}
 #ifdef RT30xx
-	// The RF programming sequence is difference between 3xxx and 2xxx
+	/* The RF programming sequence is difference between 3xxx and 2xxx */
 	if ((IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3390(pAd))
 	    && ((pAd->RfIcType == RFIC_3020) || (pAd->RfIcType == RFIC_2020)
 		|| (pAd->RfIcType == RFIC_3021)
@@ -668,7 +668,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 
 		for (index = 0; index < NUM_OF_3020_CHNL; index++) {
 			if (Channel == FreqItems3020[index].Channel) {
-				// Programming channel parameters
+				/* Programming channel parameters */
 				RT30xxWriteRFRegister(pAd, RF_R02,
 						      FreqItems3020[index].N);
 				RT30xxWriteRFRegister(pAd, RF_R03,
@@ -678,21 +678,21 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 				    (RFValue & 0xFC) | FreqItems3020[index].R;
 				RT30xxWriteRFRegister(pAd, RF_R06, RFValue);
 
-				// Set Tx0 Power
+				/* Set Tx0 Power */
 				RT30xxReadRFRegister(pAd, RF_R12, &RFValue);
 				RFValue = (RFValue & 0xE0) | TxPwer;
 				RT30xxWriteRFRegister(pAd, RF_R12, RFValue);
 
-				// Set Tx1 Power
+				/* Set Tx1 Power */
 				RT30xxReadRFRegister(pAd, RF_R13, &RFValue);
 				RFValue = (RFValue & 0xE0) | TxPwer2;
 				RT30xxWriteRFRegister(pAd, RF_R13, RFValue);
 
-				// Tx/Rx Stream setting
+				/* Tx/Rx Stream setting */
 				RT30xxReadRFRegister(pAd, RF_R01, &RFValue);
-				//if (IS_RT3090(pAd))
-				//      RFValue |= 0x01; // Enable RF block.
-				RFValue &= 0x03;	//clear bit[7~2]
+				/*if (IS_RT3090(pAd)) */
+				/*      RFValue |= 0x01; // Enable RF block. */
+				RFValue &= 0x03;	/*clear bit[7~2] */
 				if (pAd->Antenna.field.TxPath == 1)
 					RFValue |= 0xA0;
 				else if (pAd->Antenna.field.TxPath == 2)
@@ -703,28 +703,28 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 					RFValue |= 0x40;
 				RT30xxWriteRFRegister(pAd, RF_R01, RFValue);
 
-				// Set RF offset
+				/* Set RF offset */
 				RT30xxReadRFRegister(pAd, RF_R23, &RFValue);
 				RFValue = (RFValue & 0x80) | pAd->RfFreqOffset;
 				RT30xxWriteRFRegister(pAd, RF_R23, RFValue);
 
-				// Set BW
+				/* Set BW */
 				if (!bScan
 				    && (pAd->CommonCfg.BBPCurrentBW == BW_40)) {
 					RFValue = pAd->Mlme.CaliBW40RfR24;
-					//DISABLE_11N_CHECK(pAd);
+					/*DISABLE_11N_CHECK(pAd); */
 				} else {
 					RFValue = pAd->Mlme.CaliBW20RfR24;
 				}
 				RT30xxWriteRFRegister(pAd, RF_R24, RFValue);
 				RT30xxWriteRFRegister(pAd, RF_R31, RFValue);
 
-				// Enable RF tuning
+				/* Enable RF tuning */
 				RT30xxReadRFRegister(pAd, RF_R07, &RFValue);
 				RFValue = RFValue | 0x1;
 				RT30xxWriteRFRegister(pAd, RF_R07, RFValue);
 
-				// latch channel for future usage.
+				/* latch channel for future usage. */
 				pAd->LatchRfRegs.Channel = Channel;
 
 				DBGPRINT(RT_DEBUG_TRACE,
@@ -739,7 +739,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 			}
 		}
 	} else
-#endif // RT30xx //
+#endif /* RT30xx // */
 	{
 		RFRegTable = RF2850RegTable;
 		switch (pAd->RfIcType) {
@@ -752,26 +752,26 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 				if (Channel == RFRegTable[index].Channel) {
 					R2 = RFRegTable[index].R2;
 					if (pAd->Antenna.field.TxPath == 1) {
-						R2 |= 0x4000;	// If TXpath is 1, bit 14 = 1;
+						R2 |= 0x4000;	/* If TXpath is 1, bit 14 = 1; */
 					}
 
 					if (pAd->Antenna.field.RxPath == 2) {
-						R2 |= 0x40;	// write 1 to off Rxpath.
+						R2 |= 0x40;	/* write 1 to off Rxpath. */
 					} else if (pAd->Antenna.field.RxPath ==
 						   1) {
-						R2 |= 0x20040;	// write 1 to off RxPath
+						R2 |= 0x20040;	/* write 1 to off RxPath */
 					}
 
 					if (Channel > 14) {
-						// initialize R3, R4
+						/* initialize R3, R4 */
 						R3 = (RFRegTable[index].
 						      R3 & 0xffffc1ff);
 						R4 = (RFRegTable[index].
 						      R4 & (~0x001f87c0)) |
 						    (pAd->RfFreqOffset << 15);
 
-						// 5G band power range: 0xF9~0X0F, TX0 Reg3 bit9/TX1 Reg4 bit6="0" means the TX power reduce 7dB
-						// R3
+						/* 5G band power range: 0xF9~0X0F, TX0 Reg3 bit9/TX1 Reg4 bit6="0" means the TX power reduce 7dB */
+						/* R3 */
 						if ((TxPwer >= -7)
 						    && (TxPwer < 0)) {
 							TxPwer = (7 + TxPwer);
@@ -794,7 +794,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 									      9);
 						}
 
-						// R4
+						/* R4 */
 						if ((TxPwer2 >= -7)
 						    && (TxPwer2 < 0)) {
 							TxPwer2 = (7 + TxPwer2);
@@ -817,17 +817,17 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 									      6);
 						}
 					} else {
-						R3 = (RFRegTable[index].R3 & 0xffffc1ff) | (TxPwer << 9);	// set TX power0
-						R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15) | (TxPwer2 << 6);	// Set freq Offset & TxPwr1
+						R3 = (RFRegTable[index].R3 & 0xffffc1ff) | (TxPwer << 9);	/* set TX power0 */
+						R4 = (RFRegTable[index].R4 & (~0x001f87c0)) | (pAd->RfFreqOffset << 15) | (TxPwer2 << 6);	/* Set freq Offset & TxPwr1 */
 					}
 
-					// Based on BBP current mode before changing RF channel.
+					/* Based on BBP current mode before changing RF channel. */
 					if (!bScan
 					    && (pAd->CommonCfg.BBPCurrentBW ==
 						BW_40)) {
 						R4 |= 0x200000;
 					}
-					// Update variables
+					/* Update variables */
 					pAd->LatchRfRegs.Channel = Channel;
 					pAd->LatchRfRegs.R1 =
 					    RFRegTable[index].R1;
@@ -835,7 +835,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 					pAd->LatchRfRegs.R3 = R3;
 					pAd->LatchRfRegs.R4 = R4;
 
-					// Set RF value 1's set R3[bit2] = [0]
+					/* Set RF value 1's set R3[bit2] = [0] */
 					RTMP_RF_IO_WRITE32(pAd,
 							   pAd->LatchRfRegs.R1);
 					RTMP_RF_IO_WRITE32(pAd,
@@ -848,7 +848,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 
 					RTMPusecDelay(200);
 
-					// Set RF value 2's set R3[bit2] = [1]
+					/* Set RF value 2's set R3[bit2] = [1] */
 					RTMP_RF_IO_WRITE32(pAd,
 							   pAd->LatchRfRegs.R1);
 					RTMP_RF_IO_WRITE32(pAd,
@@ -861,7 +861,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 
 					RTMPusecDelay(200);
 
-					// Set RF value 3's set R3[bit2] = [0]
+					/* Set RF value 3's set R3[bit2] = [0] */
 					RTMP_RF_IO_WRITE32(pAd,
 							   pAd->LatchRfRegs.R1);
 					RTMP_RF_IO_WRITE32(pAd,
@@ -889,9 +889,9 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 			  pAd->LatchRfRegs.R3, pAd->LatchRfRegs.R4));
 	}
 
-	// Change BBP setting during siwtch from a->g, g->a
+	/* Change BBP setting during siwtch from a->g, g->a */
 	if (Channel <= 14) {
-		ULONG TxPinCfg = 0x00050F0A;	//Gary 2007/08/09 0x050A0A
+		ULONG TxPinCfg = 0x00050F0A;	/*Gary 2007/08/09 0x050A0A */
 
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62,
 					     (0x37 - GET_LNA_GAIN(pAd)));
@@ -899,10 +899,10 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 					     (0x37 - GET_LNA_GAIN(pAd)));
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64,
 					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	//(0x44 - GET_LNA_GAIN(pAd)));    // According the Rory's suggestion to solve the middle range issue.
-		//RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x62);
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	/*(0x44 - GET_LNA_GAIN(pAd)));    // According the Rory's suggestion to solve the middle range issue. */
+		/*RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x62); */
 
-		// Rx High power VGA offset for LNA select
+		/* Rx High power VGA offset for LNA select */
 		if (pAd->NicConfig2.field.ExternalLNAForG) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0x62);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x46);
@@ -911,13 +911,13 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x50);
 		}
 
-		// 5G band selection PIN, bit1 and bit2 are complement
+		/* 5G band selection PIN, bit1 and bit2 are complement */
 		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Value);
 		Value &= (~0x6);
 		Value |= (0x04);
 		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
 
-		// Turn off unused PA or LNA when only 1T or 1R
+		/* Turn off unused PA or LNA when only 1T or 1R */
 		if (pAd->Antenna.field.TxPath == 1) {
 			TxPinCfg &= 0xFFFFFFF3;
 		}
@@ -928,7 +928,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 		RTMP_IO_WRITE32(pAd, TX_PIN_CFG, TxPinCfg);
 
 #if defined(RT3090) || defined(RT3390)
-		// PCIe PHY Transmit attenuation adjustment
+		/* PCIe PHY Transmit attenuation adjustment */
 		if (IS_RT3090A(pAd) || IS_RT3390(pAd)) {
 			TX_ATTENUATION_CTRL_STRUC TxAttenuationCtrl = {
 			.word = 0};
@@ -936,14 +936,14 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 			RTMP_IO_READ32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL,
 				       &TxAttenuationCtrl.word);
 
-			if (Channel == 14)	// Channel #14
+			if (Channel == 14)	/* Channel #14 */
 			{
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 1;	// Enable PCIe PHY Tx attenuation
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 4;	// 9/16 full drive level
-			} else	// Channel #1~#13
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 1;	/* Enable PCIe PHY Tx attenuation */
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 4;	/* 9/16 full drive level */
+			} else	/* Channel #1~#13 */
 			{
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 0;	// Disable PCIe PHY Tx attenuation
-				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 0;	// n/a
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_EN = 0;	/* Disable PCIe PHY Tx attenuation */
+				TxAttenuationCtrl.field.PCIE_PHY_TX_ATTEN_VALUE = 0;	/* n/a */
 			}
 
 			RTMP_IO_WRITE32(pAd, PCIE_PHY_TX_ATTENUATION_CTRL,
@@ -951,7 +951,7 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 		}
 #endif
 	} else {
-		ULONG TxPinCfg = 0x00050F05;	//Gary 2007/8/9 0x050505
+		ULONG TxPinCfg = 0x00050F05;	/*Gary 2007/8/9 0x050505 */
 
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R62,
 					     (0x37 - GET_LNA_GAIN(pAd)));
@@ -959,23 +959,23 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 					     (0x37 - GET_LNA_GAIN(pAd)));
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R64,
 					     (0x37 - GET_LNA_GAIN(pAd)));
-		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	//(0x44 - GET_LNA_GAIN(pAd)));   // According the Rory's suggestion to solve the middle range issue.
+		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R86, 0);	/*(0x44 - GET_LNA_GAIN(pAd)));   // According the Rory's suggestion to solve the middle range issue. */
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R82, 0xF2);
 
-		// Rx High power VGA offset for LNA select
+		/* Rx High power VGA offset for LNA select */
 		if (pAd->NicConfig2.field.ExternalLNAForA) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x46);
 		} else {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R75, 0x50);
 		}
 
-		// 5G band selection PIN, bit1 and bit2 are complement
+		/* 5G band selection PIN, bit1 and bit2 are complement */
 		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Value);
 		Value &= (~0x6);
 		Value |= (0x02);
 		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
 
-		// Turn off unused PA or LNA when only 1T or 1R
+		/* Turn off unused PA or LNA when only 1T or 1R */
 		if (pAd->Antenna.field.TxPath == 1) {
 			TxPinCfg &= 0xFFFFFFF3;
 		}
@@ -987,18 +987,18 @@ VOID AsicSwitchChannel(IN PRTMP_ADAPTER pAd, IN UCHAR Channel, IN BOOLEAN bScan)
 
 	}
 
-	// R66 should be set according to Channel and use 20MHz when scanning
-	//RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x2E + GET_LNA_GAIN(pAd)));
+	/* R66 should be set according to Channel and use 20MHz when scanning */
+	/*RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x2E + GET_LNA_GAIN(pAd))); */
 	if (bScan)
 		RTMPSetAGCInitValue(pAd, BW_20);
 	else
 		RTMPSetAGCInitValue(pAd, pAd->CommonCfg.BBPCurrentBW);
 
-	//
-	// On 11A, We should delay and wait RF/BBP to be stable
-	// and the appropriate time should be 1000 micro seconds
-	// 2005/06/05 - On 11G, We also need this delay time. Otherwise it's difficult to pass the WHQL.
-	//
+	/* */
+	/* On 11A, We should delay and wait RF/BBP to be stable */
+	/* and the appropriate time should be 1000 micro seconds */
+	/* 2005/06/05 - On 11G, We also need this delay time. Otherwise it's difficult to pass the WHQL. */
+	/* */
 	RTMPusecDelay(1000);
 }
 
@@ -1006,7 +1006,7 @@ VOID AsicResetBBPAgent(IN PRTMP_ADAPTER pAd)
 {
 	BBP_CSR_CFG_STRUC BbpCsr;
 	DBGPRINT(RT_DEBUG_ERROR, ("Reset BBP Agent busy bit.!! \n"));
-	// Still need to find why BBP agent keeps busy, but in fact, hardware still function ok. Now clear busy first.
+	/* Still need to find why BBP agent keeps busy, but in fact, hardware still function ok. Now clear busy first. */
 	RTMP_IO_READ32(pAd, H2M_BBP_AGENT, &BbpCsr.word);
 	BbpCsr.field.Busy = 0;
 	RTMP_IO_WRITE32(pAd, H2M_BBP_AGENT, BbpCsr.word);
@@ -1067,7 +1067,7 @@ VOID AsicAdjustTxPower(IN PRTMP_ADAPTER pAd)
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE) ||
 #ifdef RTMP_MAC_PCI
 	    (pAd->bPCIclkOff == TRUE) ||
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 	    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF) ||
 	    RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
 		return;
@@ -1107,7 +1107,7 @@ VOID AsicAdjustTxPower(IN PRTMP_ADAPTER pAd)
 		}
 	}
 
-	// TX power compensation for temperature variation based on TSSI. try every 4 second
+	/* TX power compensation for temperature variation based on TSSI. try every 4 second */
 	if (pAd->Mlme.OneSecPeriodicRound % 4 == 0) {
 		if (pAd->CommonCfg.Channel <= 14) {
 			/* bg channel */
@@ -1145,30 +1145,30 @@ VOID AsicAdjustTxPower(IN PRTMP_ADAPTER pAd)
 			/* if value is 0xa5, tx power will be -= TxAgcStep*(2-1) */
 
 			if (BbpR49 > pTssiMinusBoundary[1]) {
-				// Reading is larger than the reference value
-				// check for how large we need to decrease the Tx power
+				/* Reading is larger than the reference value */
+				/* check for how large we need to decrease the Tx power */
 				for (idx = 1; idx < 5; idx++) {
-					if (BbpR49 <= pTssiMinusBoundary[idx])	// Found the range
+					if (BbpR49 <= pTssiMinusBoundary[idx])	/* Found the range */
 						break;
 				}
-				// The index is the step we should decrease, idx = 0 means there is nothing to compensate
-//                              if (R3 > (ULONG) (TxAgcStep * (idx-1)))
+				/* The index is the step we should decrease, idx = 0 means there is nothing to compensate */
+/*                              if (R3 > (ULONG) (TxAgcStep * (idx-1))) */
 				*pTxAgcCompensate = -(TxAgcStep * (idx - 1));
-//                              else
-//                                      *pTxAgcCompensate = -((UCHAR)R3);
+/*                              else */
+/*                                      *pTxAgcCompensate = -((UCHAR)R3); */
 
 				DeltaPwr += (*pTxAgcCompensate);
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("-- Tx Power, BBP R1=%x, TssiRef=%x, TxAgcStep=%x, step = -%d\n",
 					  BbpR49, TssiRef, TxAgcStep, idx - 1));
 			} else if (BbpR49 < pTssiPlusBoundary[1]) {
-				// Reading is smaller than the reference value
-				// check for how large we need to increase the Tx power
+				/* Reading is smaller than the reference value */
+				/* check for how large we need to increase the Tx power */
 				for (idx = 1; idx < 5; idx++) {
-					if (BbpR49 >= pTssiPlusBoundary[idx])	// Found the range
+					if (BbpR49 >= pTssiPlusBoundary[idx])	/* Found the range */
 						break;
 				}
-				// The index is the step we should increase, idx = 0 means there is nothing to compensate
+				/* The index is the step we should increase, idx = 0 means there is nothing to compensate */
 				*pTxAgcCompensate = TxAgcStep * (idx - 1);
 				DeltaPwr += (*pTxAgcCompensate);
 				DBGPRINT(RT_DEBUG_TRACE,
@@ -1198,34 +1198,34 @@ VOID AsicAdjustTxPower(IN PRTMP_ADAPTER pAd)
 	BbpR1 &= 0xFC;
 
 	/* calculate delta power based on the percentage specified from UI */
-	// E2PROM setting is calibrated for maximum TX power (i.e. 100%)
-	// We lower TX power here according to the percentage specified from UI
-	if (pAd->CommonCfg.TxPowerPercentage == 0xffffffff)	// AUTO TX POWER control
+	/* E2PROM setting is calibrated for maximum TX power (i.e. 100%) */
+	/* We lower TX power here according to the percentage specified from UI */
+	if (pAd->CommonCfg.TxPowerPercentage == 0xffffffff)	/* AUTO TX POWER control */
 	{
 		{
-			// to patch high power issue with some APs, like Belkin N1.
+			/* to patch high power issue with some APs, like Belkin N1. */
 			if (Rssi > -35) {
-				BbpR1 |= 0x02;	// DeltaPwr -= 12;
+				BbpR1 |= 0x02;	/* DeltaPwr -= 12; */
 			} else if (Rssi > -40) {
-				BbpR1 |= 0x01;	// DeltaPwr -= 6;
+				BbpR1 |= 0x01;	/* DeltaPwr -= 6; */
 			} else;
 		}
-	} else if (pAd->CommonCfg.TxPowerPercentage > 90)	// 91 ~ 100% & AUTO, treat as 100% in terms of mW
+	} else if (pAd->CommonCfg.TxPowerPercentage > 90)	/* 91 ~ 100% & AUTO, treat as 100% in terms of mW */
 		;
-	else if (pAd->CommonCfg.TxPowerPercentage > 60)	// 61 ~ 90%, treat as 75% in terms of mW               // DeltaPwr -= 1;
+	else if (pAd->CommonCfg.TxPowerPercentage > 60)	/* 61 ~ 90%, treat as 75% in terms of mW               // DeltaPwr -= 1; */
 	{
 		DeltaPwr -= 1;
-	} else if (pAd->CommonCfg.TxPowerPercentage > 30)	// 31 ~ 60%, treat as 50% in terms of mW               // DeltaPwr -= 3;
+	} else if (pAd->CommonCfg.TxPowerPercentage > 30)	/* 31 ~ 60%, treat as 50% in terms of mW               // DeltaPwr -= 3; */
 	{
 		DeltaPwr -= 3;
-	} else if (pAd->CommonCfg.TxPowerPercentage > 15)	// 16 ~ 30%, treat as 25% in terms of mW               // DeltaPwr -= 6;
+	} else if (pAd->CommonCfg.TxPowerPercentage > 15)	/* 16 ~ 30%, treat as 25% in terms of mW               // DeltaPwr -= 6; */
 	{
 		BbpR1 |= 0x01;
-	} else if (pAd->CommonCfg.TxPowerPercentage > 9)	// 10 ~ 15%, treat as 12.5% in terms of mW             // DeltaPwr -= 9;
+	} else if (pAd->CommonCfg.TxPowerPercentage > 9)	/* 10 ~ 15%, treat as 12.5% in terms of mW             // DeltaPwr -= 9; */
 	{
 		BbpR1 |= 0x01;
 		DeltaPwr -= 3;
-	} else			// 0 ~ 9 %, treat as MIN(~3%) in terms of mW             // DeltaPwr -= 12;
+	} else			/* 0 ~ 9 %, treat as MIN(~3%) in terms of mW             // DeltaPwr -= 12; */
 	{
 		BbpR1 |= 0x02;
 	}
@@ -1334,7 +1334,7 @@ VOID AsicSetBssid(IN PRTMP_ADAPTER pAd, IN PUCHAR pBssid)
 	RTMP_IO_WRITE32(pAd, MAC_BSSID_DW0, Addr4);
 
 	Addr4 = 0;
-	// always one BSSID in STA mode
+	/* always one BSSID in STA mode */
 	Addr4 = (ULONG) (pBssid[4]) | (ULONG) (pBssid[5] << 8);
 
 	RTMP_IO_WRITE32(pAd, MAC_BSSID_DW1, Addr4);
@@ -1346,7 +1346,7 @@ VOID AsicSetMcastWC(IN PRTMP_ADAPTER pAd)
 	USHORT offset;
 
 	pEntry->Sst = SST_ASSOC;
-	pEntry->Aid = MCAST_WCID;	// Softap supports 1 BSSID and use WCID=0 as multicast Wcid index
+	pEntry->Aid = MCAST_WCID;	/* Softap supports 1 BSSID and use WCID=0 as multicast Wcid index */
 	pEntry->PsMode = PWR_ACTIVE;
 	pEntry->CurrTxRate = pAd->CommonCfg.MlmeRate;
 	offset = MAC_WCID_BASE + BSS0Mcast_WCID * HW_WCID_ENTRY_SIZE;
@@ -1394,7 +1394,7 @@ VOID AsicEnableRDG(IN PRTMP_ADAPTER pAd)
 	Data |= 0x80;
 	RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
 
-	//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
+	/*OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED); */
 }
 
 /*
@@ -1417,15 +1417,15 @@ VOID AsicDisableRDG(IN PRTMP_ADAPTER pAd)
 	RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
 
 	Data &= 0xFFFFFF00;
-	//Data  |= 0x20;
+	/*Data  |= 0x20; */
 #ifndef WIFI_TEST
-	//if ( pAd->CommonCfg.bEnableTxBurst )
-	//      Data |= 0x60; // for performance issue not set the TXOP to 0
+	/*if ( pAd->CommonCfg.bEnableTxBurst ) */
+	/*      Data |= 0x60; // for performance issue not set the TXOP to 0 */
 #endif
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_DYNAMIC_BE_TXOP_ACTIVE)
 	    && (pAd->MacTab.fAnyStationMIMOPSDynamic == FALSE)
 	    ) {
-		// For CWC test, change txop from 0x30 to 0x20 in TxBurst mode
+		/* For CWC test, change txop from 0x30 to 0x20 in TxBurst mode */
 		if (pAd->CommonCfg.bEnableTxBurst)
 			Data |= 0x20;
 	}
@@ -1447,9 +1447,9 @@ VOID AsicDisableSync(IN PRTMP_ADAPTER pAd)
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--->Disable TSF synchronization\n"));
 
-	// 2003-12-20 disable TSF and TBTT while NIC in power-saving have side effect
-	//                        that NIC will never wakes up because TSF stops and no more
-	//                        TBTT interrupts
+	/* 2003-12-20 disable TSF and TBTT while NIC in power-saving have side effect */
+	/*                        that NIC will never wakes up because TSF stops and no more */
+	/*                        TBTT interrupts */
 	pAd->TbttTickCount = 0;
 	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
 	csr.field.bBeaconGen = 0;
@@ -1475,12 +1475,12 @@ VOID AsicEnableBssSync(IN PRTMP_ADAPTER pAd)
 	DBGPRINT(RT_DEBUG_TRACE, ("--->AsicEnableBssSync(INFRA mode)\n"));
 
 	RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-//      RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, 0x00000000);
+/*      RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, 0x00000000); */
 	{
-		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	// ASIC register in units of 1/16 TU
+		csr.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	/* ASIC register in units of 1/16 TU */
 		csr.field.bTsfTicking = 1;
-		csr.field.TsfSyncMode = 1;	// sync TSF in INFRASTRUCTURE mode
-		csr.field.bBeaconGen = 0;	// do NOT generate BEACON
+		csr.field.TsfSyncMode = 1;	/* sync TSF in INFRASTRUCTURE mode */
+		csr.field.bBeaconGen = 0;	/* do NOT generate BEACON */
 		csr.field.bTBTTEnable = 1;
 	}
 	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
@@ -1515,9 +1515,9 @@ VOID AsicEnableIbssSync(IN PRTMP_ADAPTER pAd)
 	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr9.word);
 
 #ifdef RTMP_MAC_PCI
-	// move BEACON TXD and frame content to on-chip memory
+	/* move BEACON TXD and frame content to on-chip memory */
 	ptr = (PUCHAR) & pAd->BeaconTxWI;
-	for (i = 0; i < TXWI_SIZE; i += 4)	// 16-byte TXWI field
+	for (i = 0; i < TXWI_SIZE; i += 4)	/* 16-byte TXWI field */
 	{
 		UINT32 longptr =
 		    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
@@ -1526,7 +1526,7 @@ VOID AsicEnableIbssSync(IN PRTMP_ADAPTER pAd)
 		ptr += 4;
 	}
 
-	// start right after the 16-byte TXWI field
+	/* start right after the 16-byte TXWI field */
 	ptr = pAd->BeaconBuf;
 	for (i = 0; i < pAd->BeaconTxWI.MPDUtotalByteCount; i += 4) {
 		UINT32 longptr =
@@ -1535,38 +1535,38 @@ VOID AsicEnableIbssSync(IN PRTMP_ADAPTER pAd)
 		RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
 		ptr += 4;
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
-	// move BEACON TXD and frame content to on-chip memory
+	/* move BEACON TXD and frame content to on-chip memory */
 	ptr = (PUCHAR) & pAd->BeaconTxWI;
-	for (i = 0; i < TXWI_SIZE; i += 2)	// 16-byte TXWI field
+	for (i = 0; i < TXWI_SIZE; i += 2)	/* 16-byte TXWI field */
 	{
-		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr);
+		/*UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24); */
+		/*RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + i, longptr); */
 		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + i, ptr, 2);
 		ptr += 2;
 	}
 
-	// start right after the 16-byte TXWI field
+	/* start right after the 16-byte TXWI field */
 	ptr = pAd->BeaconBuf;
 	for (i = 0; i < pAd->BeaconTxWI.MPDUtotalByteCount; i += 2) {
-		//UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24);
-		//RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr);
+		/*UINT32 longptr =  *ptr + (*(ptr+1)<<8) + (*(ptr+2)<<16) + (*(ptr+3)<<24); */
+		/*RTMP_IO_WRITE32(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, longptr); */
 		RTUSBMultiWrite(pAd, HW_BEACON_BASE0 + TXWI_SIZE + i, ptr, 2);
 		ptr += 2;
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	//
-	// For Wi-Fi faily generated beacons between participating stations.
-	// Set TBTT phase adaptive adjustment step to 8us (default 16us)
-	// don't change settings 2006-5- by Jerry
-	//RTMP_IO_WRITE32(pAd, TBTT_SYNC_CFG, 0x00001010);
+	/* */
+	/* For Wi-Fi faily generated beacons between participating stations. */
+	/* Set TBTT phase adaptive adjustment step to 8us (default 16us) */
+	/* don't change settings 2006-5- by Jerry */
+	/*RTMP_IO_WRITE32(pAd, TBTT_SYNC_CFG, 0x00001010); */
 
-	// start sending BEACON
-	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	// ASIC register in units of 1/16 TU
+	/* start sending BEACON */
+	csr9.field.BeaconInterval = pAd->CommonCfg.BeaconPeriod << 4;	/* ASIC register in units of 1/16 TU */
 	csr9.field.bTsfTicking = 1;
-	csr9.field.TsfSyncMode = 2;	// sync TSF in IBSS mode
+	csr9.field.TsfSyncMode = 2;	/* sync TSF in IBSS mode */
 	csr9.field.bTBTTEnable = 1;
 	csr9.field.bBeaconGen = 1;
 	RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr9.word);
@@ -1606,35 +1606,35 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 							 fCLIENT_STATUS_WMM_CAPABLE);
 		}
 
-		//========================================================
-		//      MAC Register has a copy .
-		//========================================================
-//#ifndef WIFI_TEST
+		/*======================================================== */
+		/*      MAC Register has a copy . */
+		/*======================================================== */
+/*#ifndef WIFI_TEST */
 		if (pAd->CommonCfg.bEnableTxBurst) {
-			// For CWC test, change txop from 0x30 to 0x20 in TxBurst mode
-			Ac0Cfg.field.AcTxop = 0x20;	// Suggest by John for TxBurst in HT Mode
+			/* For CWC test, change txop from 0x30 to 0x20 in TxBurst mode */
+			Ac0Cfg.field.AcTxop = 0x20;	/* Suggest by John for TxBurst in HT Mode */
 		} else
-			Ac0Cfg.field.AcTxop = 0;	// QID_AC_BE
-//#else
-//              Ac0Cfg.field.AcTxop = 0;        // QID_AC_BE
-//#endif
+			Ac0Cfg.field.AcTxop = 0;	/* QID_AC_BE */
+/*#else */
+/*              Ac0Cfg.field.AcTxop = 0;        // QID_AC_BE */
+/*#endif */
 		Ac0Cfg.field.Cwmin = CW_MIN_IN_BITS;
 		Ac0Cfg.field.Cwmax = CW_MAX_IN_BITS;
 		Ac0Cfg.field.Aifsn = 2;
 		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Ac0Cfg.word);
 
-		Ac1Cfg.field.AcTxop = 0;	// QID_AC_BK
+		Ac1Cfg.field.AcTxop = 0;	/* QID_AC_BK */
 		Ac1Cfg.field.Cwmin = CW_MIN_IN_BITS;
 		Ac1Cfg.field.Cwmax = CW_MAX_IN_BITS;
 		Ac1Cfg.field.Aifsn = 2;
 		RTMP_IO_WRITE32(pAd, EDCA_AC1_CFG, Ac1Cfg.word);
 
 		if (pAd->CommonCfg.PhyMode == PHY_11B) {
-			Ac2Cfg.field.AcTxop = 192;	// AC_VI: 192*32us ~= 6ms
-			Ac3Cfg.field.AcTxop = 96;	// AC_VO: 96*32us  ~= 3ms
+			Ac2Cfg.field.AcTxop = 192;	/* AC_VI: 192*32us ~= 6ms */
+			Ac3Cfg.field.AcTxop = 96;	/* AC_VO: 96*32us  ~= 3ms */
 		} else {
-			Ac2Cfg.field.AcTxop = 96;	// AC_VI: 96*32us ~= 3ms
-			Ac3Cfg.field.AcTxop = 48;	// AC_VO: 48*32us ~= 1.5ms
+			Ac2Cfg.field.AcTxop = 96;	/* AC_VI: 96*32us ~= 3ms */
+			Ac3Cfg.field.AcTxop = 48;	/* AC_VO: 48*32us ~= 1.5ms */
 		}
 		Ac2Cfg.field.Cwmin = CW_MIN_IN_BITS;
 		Ac2Cfg.field.Cwmax = CW_MAX_IN_BITS;
@@ -1645,18 +1645,18 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 		Ac3Cfg.field.Aifsn = 2;
 		RTMP_IO_WRITE32(pAd, EDCA_AC3_CFG, Ac3Cfg.word);
 
-		//========================================================
-		//      DMA Register has a copy too.
-		//========================================================
-		csr0.field.Ac0Txop = 0;	// QID_AC_BE
-		csr0.field.Ac1Txop = 0;	// QID_AC_BK
+		/*======================================================== */
+		/*      DMA Register has a copy too. */
+		/*======================================================== */
+		csr0.field.Ac0Txop = 0;	/* QID_AC_BE */
+		csr0.field.Ac1Txop = 0;	/* QID_AC_BK */
 		RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
 		if (pAd->CommonCfg.PhyMode == PHY_11B) {
-			csr1.field.Ac2Txop = 192;	// AC_VI: 192*32us ~= 6ms
-			csr1.field.Ac3Txop = 96;	// AC_VO: 96*32us  ~= 3ms
+			csr1.field.Ac2Txop = 192;	/* AC_VI: 192*32us ~= 6ms */
+			csr1.field.Ac3Txop = 96;	/* AC_VO: 96*32us  ~= 3ms */
 		} else {
-			csr1.field.Ac2Txop = 96;	// AC_VI: 96*32us ~= 3ms
-			csr1.field.Ac3Txop = 48;	// AC_VO: 48*32us ~= 1.5ms
+			csr1.field.Ac2Txop = 96;	/* AC_VI: 96*32us ~= 3ms */
+			csr1.field.Ac3Txop = 48;	/* AC_VO: 48*32us ~= 1.5ms */
 		}
 		RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr1.word);
 
@@ -1679,24 +1679,24 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 		NdisZeroMemory(&pAd->CommonCfg.APEdcaParm, sizeof(EDCA_PARM));
 	} else {
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_WMM_INUSED);
-		//========================================================
-		//      MAC Register has a copy.
-		//========================================================
-		//
-		// Modify Cwmin/Cwmax/Txop on queue[QID_AC_VI], Recommend by Jerry 2005/07/27
-		// To degrade our VIDO Queue's throughput for WiFi WMM S3T07 Issue.
-		//
-		//pEdcaParm->Txop[QID_AC_VI] = pEdcaParm->Txop[QID_AC_VI] * 7 / 10; // rt2860c need this
+		/*======================================================== */
+		/*      MAC Register has a copy. */
+		/*======================================================== */
+		/* */
+		/* Modify Cwmin/Cwmax/Txop on queue[QID_AC_VI], Recommend by Jerry 2005/07/27 */
+		/* To degrade our VIDO Queue's throughput for WiFi WMM S3T07 Issue. */
+		/* */
+		/*pEdcaParm->Txop[QID_AC_VI] = pEdcaParm->Txop[QID_AC_VI] * 7 / 10; // rt2860c need this */
 
 		Ac0Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BE];
 		Ac0Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BE];
 		Ac0Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_BE];
-		Ac0Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BE];	//+1;
+		Ac0Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BE];	/*+1; */
 
 		Ac1Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_BK];
-		Ac1Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BK];	//+2;
+		Ac1Cfg.field.Cwmin = pEdcaParm->Cwmin[QID_AC_BK];	/*+2; */
 		Ac1Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_BK];
-		Ac1Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BK];	//+1;
+		Ac1Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_BK];	/*+1; */
 
 		Ac2Cfg.field.AcTxop = (pEdcaParm->Txop[QID_AC_VI] * 6) / 10;
 		if (pAd->Antenna.field.TxPath == 1) {
@@ -1709,16 +1709,16 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 		Ac2Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VI] + 1;
 #ifdef RTMP_MAC_USB
 		Ac2Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VI] + 3;
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 		{
-			// Tuning for Wi-Fi WMM S06
+			/* Tuning for Wi-Fi WMM S06 */
 			if (pAd->CommonCfg.bWiFiTest &&
 			    pEdcaParm->Aifsn[QID_AC_VI] == 10)
 				Ac2Cfg.field.Aifsn -= 1;
 
-			// Tuning for TGn Wi-Fi 5.2.32
-			// STA TestBed changes in this item: conexant legacy sta ==> broadcom 11n sta
+			/* Tuning for TGn Wi-Fi 5.2.32 */
+			/* STA TestBed changes in this item: conexant legacy sta ==> broadcom 11n sta */
 			if (STA_TGN_WIFI_ON(pAd) &&
 			    pEdcaParm->Aifsn[QID_AC_VI] == 10) {
 				Ac0Cfg.field.Aifsn = 3;
@@ -1727,10 +1727,10 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 #ifdef RT30xx
 			if (pAd->RfIcType == RFIC_3020
 			    || pAd->RfIcType == RFIC_2020) {
-				// Tuning for WiFi WMM S3-T07: connexant legacy sta ==> broadcom 11n sta.
+				/* Tuning for WiFi WMM S3-T07: connexant legacy sta ==> broadcom 11n sta. */
 				Ac2Cfg.field.Aifsn = 5;
 			}
-#endif // RT30xx //
+#endif /* RT30xx // */
 		}
 
 		Ac3Cfg.field.AcTxop = pEdcaParm->Txop[QID_AC_VO];
@@ -1738,7 +1738,7 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 		Ac3Cfg.field.Cwmax = pEdcaParm->Cwmax[QID_AC_VO];
 		Ac3Cfg.field.Aifsn = pEdcaParm->Aifsn[QID_AC_VO];
 
-//#ifdef WIFI_TEST
+/*#ifdef WIFI_TEST */
 		if (pAd->CommonCfg.bWiFiTest) {
 			if (Ac3Cfg.field.AcTxop == 102) {
 				Ac0Cfg.field.AcTxop =
@@ -1753,16 +1753,16 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 				    pEdcaParm->Txop[QID_AC_VI];
 			}	/* End of if */
 		}
-//#endif // WIFI_TEST //
+/*#endif // WIFI_TEST // */
 
 		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Ac0Cfg.word);
 		RTMP_IO_WRITE32(pAd, EDCA_AC1_CFG, Ac1Cfg.word);
 		RTMP_IO_WRITE32(pAd, EDCA_AC2_CFG, Ac2Cfg.word);
 		RTMP_IO_WRITE32(pAd, EDCA_AC3_CFG, Ac3Cfg.word);
 
-		//========================================================
-		//      DMA Register has a copy too.
-		//========================================================
+		/*======================================================== */
+		/*      DMA Register has a copy too. */
+		/*======================================================== */
 		csr0.field.Ac0Txop = Ac0Cfg.field.AcTxop;
 		csr0.field.Ac1Txop = Ac1Cfg.field.AcTxop;
 		RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
@@ -1775,7 +1775,7 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 		CwminCsr.field.Cwmin0 = pEdcaParm->Cwmin[QID_AC_BE];
 		CwminCsr.field.Cwmin1 = pEdcaParm->Cwmin[QID_AC_BK];
 		CwminCsr.field.Cwmin2 = pEdcaParm->Cwmin[QID_AC_VI];
-		CwminCsr.field.Cwmin3 = pEdcaParm->Cwmin[QID_AC_VO] - 1;	//for TGn wifi test
+		CwminCsr.field.Cwmin3 = pEdcaParm->Cwmin[QID_AC_VO] - 1;	/*for TGn wifi test */
 		RTMP_IO_WRITE32(pAd, WMM_CWMIN_CFG, CwminCsr.word);
 
 		CwmaxCsr.word = 0;
@@ -1786,18 +1786,18 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 		RTMP_IO_WRITE32(pAd, WMM_CWMAX_CFG, CwmaxCsr.word);
 
 		AifsnCsr.word = 0;
-		AifsnCsr.field.Aifsn0 = Ac0Cfg.field.Aifsn;	//pEdcaParm->Aifsn[QID_AC_BE];
-		AifsnCsr.field.Aifsn1 = Ac1Cfg.field.Aifsn;	//pEdcaParm->Aifsn[QID_AC_BK];
-		AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn;	//pEdcaParm->Aifsn[QID_AC_VI];
+		AifsnCsr.field.Aifsn0 = Ac0Cfg.field.Aifsn;	/*pEdcaParm->Aifsn[QID_AC_BE]; */
+		AifsnCsr.field.Aifsn1 = Ac1Cfg.field.Aifsn;	/*pEdcaParm->Aifsn[QID_AC_BK]; */
+		AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn;	/*pEdcaParm->Aifsn[QID_AC_VI]; */
 
 		{
-			// Tuning for Wi-Fi WMM S06
+			/* Tuning for Wi-Fi WMM S06 */
 			if (pAd->CommonCfg.bWiFiTest &&
 			    pEdcaParm->Aifsn[QID_AC_VI] == 10)
 				AifsnCsr.field.Aifsn2 = Ac2Cfg.field.Aifsn - 4;
 
-			// Tuning for TGn Wi-Fi 5.2.32
-			// STA TestBed changes in this item: connexant legacy sta ==> broadcom 11n sta
+			/* Tuning for TGn Wi-Fi 5.2.32 */
+			/* STA TestBed changes in this item: connexant legacy sta ==> broadcom 11n sta */
 			if (STA_TGN_WIFI_ON(pAd) &&
 			    pEdcaParm->Aifsn[QID_AC_VI] == 10) {
 				AifsnCsr.field.Aifsn0 = 3;
@@ -1811,14 +1811,14 @@ VOID AsicSetEdcaParm(IN PRTMP_ADAPTER pAd, IN PEDCA_PARM pEdcaParm)
 		}
 
 		{
-			AifsnCsr.field.Aifsn3 = Ac3Cfg.field.Aifsn - 1;	//pEdcaParm->Aifsn[QID_AC_VO]; //for TGn wifi test
+			AifsnCsr.field.Aifsn3 = Ac3Cfg.field.Aifsn - 1;	/*pEdcaParm->Aifsn[QID_AC_VO]; //for TGn wifi test */
 #ifdef RT30xx
-			// TODO: Shiang, this modification also suitable for RT3052/RT3050 ???
+			/* TODO: Shiang, this modification also suitable for RT3052/RT3050 ??? */
 			if (pAd->RfIcType == RFIC_3020
 			    || pAd->RfIcType == RFIC_2020) {
-				AifsnCsr.field.Aifsn2 = 0x2;	//pEdcaParm->Aifsn[QID_AC_VI]; //for WiFi WMM S4-T04.
+				AifsnCsr.field.Aifsn2 = 0x2;	/*pEdcaParm->Aifsn[QID_AC_VI]; //for WiFi WMM S4-T04. */
 			}
-#endif // RT30xx //
+#endif /* RT30xx // */
 		}
 		RTMP_IO_WRITE32(pAd, WMM_AIFSN_CFG, AifsnCsr.word);
 
@@ -1885,26 +1885,26 @@ VOID AsicSetSlotTime(IN PRTMP_ADAPTER pAd, IN BOOLEAN bUseShortSlotTime)
 	SlotTime = (bUseShortSlotTime) ? 9 : 20;
 
 	{
-		// force using short SLOT time for FAE to demo performance when TxBurst is ON
+		/* force using short SLOT time for FAE to demo performance when TxBurst is ON */
 		if (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
 		     && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)))
 		    || ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)
 			&& (pAd->CommonCfg.BACapability.field.Policy ==
 			    BA_NOTUSE))
 		    ) {
-			// In this case, we will think it is doing Wi-Fi test
-			// And we will not set to short slot when bEnableTxBurst is TRUE.
+			/* In this case, we will think it is doing Wi-Fi test */
+			/* And we will not set to short slot when bEnableTxBurst is TRUE. */
 		} else if (pAd->CommonCfg.bEnableTxBurst) {
 			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
 			SlotTime = 9;
 		}
 	}
 
-	//
-	// For some reasons, always set it to short slot time.
-	//
-	// ToDo: Should consider capability with 11B
-	//
+	/* */
+	/* For some reasons, always set it to short slot time. */
+	/* */
+	/* ToDo: Should consider capability with 11B */
+	/* */
 	{
 		if (pAd->StaCfg.BssType == BSS_ADHOC) {
 			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED);
@@ -1936,16 +1936,16 @@ VOID AsicAddSharedKeyEntry(IN PRTMP_ADAPTER pAd,
 			   IN UCHAR CipherAlg,
 			   IN PUCHAR pKey, IN PUCHAR pTxMic, IN PUCHAR pRxMic)
 {
-	ULONG offset;		//, csr0;
+	ULONG offset;		/*, csr0; */
 	SHAREDKEY_MODE_STRUC csr1;
 #ifdef RTMP_MAC_PCI
 	INT i;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("AsicAddSharedKeyEntry BssIndex=%d, KeyIdx=%d\n", BssIndex,
 		  KeyIdx));
-//============================================================================================
+/*============================================================================================ */
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("AsicAddSharedKeyEntry: %s key #%d\n", CipherName[CipherAlg],
@@ -1968,10 +1968,10 @@ VOID AsicAddSharedKeyEntry(IN PRTMP_ADAPTER pAd,
 			      pTxMic[0], pTxMic[1], pTxMic[2], pTxMic[3],
 			      pTxMic[4], pTxMic[5], pTxMic[6], pTxMic[7]));
 	}
-//============================================================================================
-	//
-	// fill key material - key + TX MIC + RX MIC
-	//
+/*============================================================================================ */
+	/* */
+	/* fill key material - key + TX MIC + RX MIC */
+	/* */
 #ifdef RTMP_MAC_PCI
 	offset =
 	    SHARED_KEY_TABLE_BASE + (4 * BssIndex + KeyIdx) * HW_KEY_ENTRY_SIZE;
@@ -1992,7 +1992,7 @@ VOID AsicAddSharedKeyEntry(IN PRTMP_ADAPTER pAd,
 			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 	{
 		offset =
@@ -2010,11 +2010,11 @@ VOID AsicAddSharedKeyEntry(IN PRTMP_ADAPTER pAd,
 			RTUSBMultiWrite(pAd, offset, pRxMic, 8);
 		}
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	//
-	// Update cipher algorithm. WSTA always use BSS0
-	//
+	/* */
+	/* Update cipher algorithm. WSTA always use BSS0 */
+	/* */
 	RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
 		       &csr1.word);
 	DBGPRINT(RT_DEBUG_TRACE,
@@ -2047,11 +2047,11 @@ VOID AsicAddSharedKeyEntry(IN PRTMP_ADAPTER pAd,
 
 }
 
-//      IRQL = DISPATCH_LEVEL
+/*      IRQL = DISPATCH_LEVEL */
 VOID AsicRemoveSharedKeyEntry(IN PRTMP_ADAPTER pAd,
 			      IN UCHAR BssIndex, IN UCHAR KeyIdx)
 {
-	//ULONG SecCsr0;
+	/*ULONG SecCsr0; */
 	SHAREDKEY_MODE_STRUC csr1;
 
 	DBGPRINT(RT_DEBUG_TRACE,
@@ -2096,10 +2096,10 @@ VOID AsicUpdateWCIDAttribute(IN PRTMP_ADAPTER pAd,
 {
 	ULONG WCIDAttri = 0, offset;
 
-	//
-	// Update WCID attribute.
-	// Only TxKey could update WCID attribute.
-	//
+	/* */
+	/* Update WCID attribute. */
+	/* Only TxKey could update WCID attribute. */
+	/* */
 	offset = MAC_WCID_ATTRIBUTE_BASE + (WCID * HW_WCID_ATTRI_SIZE);
 	WCIDAttri =
 	    (BssIndex << 4) | (CipherAlg << 1) | (bUsePairewiseKeyTable);
@@ -2171,10 +2171,10 @@ VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
 		     IN BOOLEAN bUsePairewiseKeyTable, IN BOOLEAN bTxKey)
 {
 	ULONG offset;
-//      ULONG   WCIDAttri = 0;
+/*      ULONG   WCIDAttri = 0; */
 	UCHAR IV4 = 0;
 	PUCHAR pKey = pCipherKey->Key;
-//      ULONG           KeyLen = pCipherKey->KeyLen;
+/*      ULONG           KeyLen = pCipherKey->KeyLen; */
 	PUCHAR pTxMic = pCipherKey->TxMic;
 	PUCHAR pRxMic = pCipherKey->RxMic;
 	PUCHAR pTxtsc = pCipherKey->TxTsc;
@@ -2182,14 +2182,14 @@ VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
 	SHAREDKEY_MODE_STRUC csr1;
 #ifdef RTMP_MAC_PCI
 	UCHAR i;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-//      ASSERT(KeyLen <= MAX_LEN_OF_PEER_KEY);
+/*      ASSERT(KeyLen <= MAX_LEN_OF_PEER_KEY); */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> AsicAddKeyEntry\n"));
-	//
-	// 1.) decide key table offset
-	//
+	/* */
+	/* 1.) decide key table offset */
+	/* */
 	if (bUsePairewiseKeyTable)
 		offset = PAIRWISE_KEY_TABLE_BASE + (WCID * HW_KEY_ENTRY_SIZE);
 	else
@@ -2197,19 +2197,19 @@ VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
 		    SHARED_KEY_TABLE_BASE + (4 * BssIndex +
 					     KeyIdx) * HW_KEY_ENTRY_SIZE;
 
-	//
-	// 2.) Set Key to Asic
-	//
-	//for (i = 0; i < KeyLen; i++)
+	/* */
+	/* 2.) Set Key to Asic */
+	/* */
+	/*for (i = 0; i < KeyLen; i++) */
 #ifdef RTMP_MAC_PCI
 	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++) {
 		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
 	}
 	offset += MAX_LEN_OF_PEER_KEY;
 
-	//
-	// 3.) Set MIC key if available
-	//
+	/* */
+	/* 3.) Set MIC key if available */
+	/* */
 	if (pTxMic) {
 		for (i = 0; i < 8; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
@@ -2222,14 +2222,14 @@ VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
 			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 	RTUSBMultiWrite(pAd, offset, pKey, MAX_LEN_OF_PEER_KEY);
 	offset += MAX_LEN_OF_PEER_KEY;
 
-	//
-	// 3.) Set MIC key if available
-	//
+	/* */
+	/* 3.) Set MIC key if available */
+	/* */
 	if (pTxMic) {
 		RTUSBMultiWrite(pAd, offset, pTxMic, 8);
 	}
@@ -2238,18 +2238,18 @@ VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
 	if (pRxMic) {
 		RTUSBMultiWrite(pAd, offset, pRxMic, 8);
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	//
-	// 4.) Modify IV/EIV if needs
-	//     This will force Asic to use this key ID by setting IV.
-	//
+	/* */
+	/* 4.) Modify IV/EIV if needs */
+	/*     This will force Asic to use this key ID by setting IV. */
+	/* */
 	if (bTxKey) {
 #ifdef RTMP_MAC_PCI
 		offset = MAC_IVEIV_TABLE_BASE + (WCID * HW_IVEIV_ENTRY_SIZE);
-		//
-		// Write IV
-		//
+		/* */
+		/* Write IV */
+		/* */
 		RTMP_IO_WRITE8(pAd, offset, pTxtsc[1]);
 		RTMP_IO_WRITE8(pAd, offset + 1, ((pTxtsc[1] | 0x20) & 0x7f));
 		RTMP_IO_WRITE8(pAd, offset + 2, pTxtsc[0]);
@@ -2258,50 +2258,50 @@ VOID AsicAddKeyEntry(IN PRTMP_ADAPTER pAd,
 		if ((CipherAlg == CIPHER_TKIP)
 		    || (CipherAlg == CIPHER_TKIP_NO_MIC)
 		    || (CipherAlg == CIPHER_AES))
-			IV4 |= 0x20;	// turn on extension bit means EIV existence
+			IV4 |= 0x20;	/* turn on extension bit means EIV existence */
 
 		RTMP_IO_WRITE8(pAd, offset + 3, IV4);
 
-		//
-		// Write EIV
-		//
+		/* */
+		/* Write EIV */
+		/* */
 		offset += 4;
 		for (i = 0; i < 4; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pTxtsc[i + 2]);
 		}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 		UINT32 tmpVal;
 
-		//
-		// Write IV
-		//
+		/* */
+		/* Write IV */
+		/* */
 		IV4 = (KeyIdx << 6);
 		if ((CipherAlg == CIPHER_TKIP)
 		    || (CipherAlg == CIPHER_TKIP_NO_MIC)
 		    || (CipherAlg == CIPHER_AES))
-			IV4 |= 0x20;	// turn on extension bit means EIV existence
+			IV4 |= 0x20;	/* turn on extension bit means EIV existence */
 
 		tmpVal =
 		    pTxtsc[1] + (((pTxtsc[1] | 0x20) & 0x7f) << 8) +
 		    (pTxtsc[0] << 16) + (IV4 << 24);
 		RTMP_IO_WRITE32(pAd, offset, tmpVal);
 
-		//
-		// Write EIV
-		//
+		/* */
+		/* Write EIV */
+		/* */
 		offset += 4;
 		RTMP_IO_WRITE32(pAd, offset, *(PUINT32) & pCipherKey->TxTsc[2]);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 		AsicUpdateWCIDAttribute(pAd, WCID, BssIndex, CipherAlg,
 					bUsePairewiseKeyTable);
 	}
 
 	if (!bUsePairewiseKeyTable) {
-		//
-		// Only update the shared key security mode
-		//
+		/* */
+		/* Only update the shared key security mode */
+		/* */
 		RTMP_IO_READ32(pAd, SHARED_KEY_MODE_BASE + 4 * (BssIndex / 2),
 			       &csr1.word);
 		if ((BssIndex % 2) == 0) {
@@ -2350,18 +2350,18 @@ VOID AsicAddPairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
 	PUCHAR pRxMic = pCipherKey->RxMic;
 #ifdef DBG
 	UCHAR CipherAlg = pCipherKey->CipherAlg;
-#endif // DBG //
+#endif /* DBG // */
 
-	// EKEY
+	/* EKEY */
 	offset = PAIRWISE_KEY_TABLE_BASE + (WCID * HW_KEY_ENTRY_SIZE);
 #ifdef RTMP_MAC_PCI
 	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i++) {
 		RTMP_IO_WRITE8(pAd, offset + i, pKey[i]);
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 	RTUSBMultiWrite(pAd, offset, &pCipherKey->Key[0], MAX_LEN_OF_PEER_KEY);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	for (i = 0; i < MAX_LEN_OF_PEER_KEY; i += 4) {
 		UINT32 Value;
 		RTMP_IO_READ32(pAd, offset + i, &Value);
@@ -2369,16 +2369,16 @@ VOID AsicAddPairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
 
 	offset += MAX_LEN_OF_PEER_KEY;
 
-	//  MIC KEY
+	/*  MIC KEY */
 	if (pTxMic) {
 #ifdef RTMP_MAC_PCI
 		for (i = 0; i < 8; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pTxMic[i]);
 		}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 		RTUSBMultiWrite(pAd, offset, &pCipherKey->TxMic[0], 8);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	}
 	offset += 8;
 	if (pRxMic) {
@@ -2386,10 +2386,10 @@ VOID AsicAddPairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
 		for (i = 0; i < 8; i++) {
 			RTMP_IO_WRITE8(pAd, offset + i, pRxMic[i]);
 		}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 		RTUSBMultiWrite(pAd, offset, &pCipherKey->RxMic[0], 8);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE,
@@ -2428,7 +2428,7 @@ VOID AsicRemovePairwiseKeyEntry(IN PRTMP_ADAPTER pAd,
 	ULONG WCIDAttri;
 	USHORT offset;
 
-	// re-set the entry's WCID attribute as OPEN-NONE.
+	/* re-set the entry's WCID attribute as OPEN-NONE. */
 	offset = MAC_WCID_ATTRIBUTE_BASE + (Wcid * HW_WCID_ATTRI_SIZE);
 	WCIDAttri = (BssIdx << 4) | PAIRWISEKEYTABLE;
 	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
@@ -2450,7 +2450,7 @@ VOID AsicSetRxAnt(IN PRTMP_ADAPTER pAd, IN UCHAR Ant)
 #ifdef RT30xx
 	/* RT3572 ATE need not to do this. */
 	RT30xxSetRxAnt(pAd, Ant);
-#endif // RT30xx //
+#endif /* RT30xx // */
 }
 
 VOID AsicTurnOffRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
@@ -2458,7 +2458,7 @@ VOID AsicTurnOffRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 	if (pAd->chipOps.AsicRfTurnOff) {
 		pAd->chipOps.AsicRfTurnOff(pAd);
 	} else {
-		// RF R2 bit 18 = 0
+		/* RF R2 bit 18 = 0 */
 		UINT32 R1 = 0, R2 = 0, R3 = 0;
 		UCHAR index;
 		RTMP_RF_REGS *RFRegTable;
@@ -2480,9 +2480,9 @@ VOID AsicTurnOffRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 					RTMP_RF_IO_WRITE32(pAd, R1);
 					RTMP_RF_IO_WRITE32(pAd, R2);
 
-					// Program R1b13 to 1, R3/b18,19 to 0, R2b18 to 0.
-					// Set RF R2 bit18=0, R3 bit[18:19]=0
-					//if (pAd->StaCfg.bRadio == FALSE)
+					/* Program R1b13 to 1, R3/b18,19 to 0, R2b18 to 0. */
+					/* Set RF R2 bit18=0, R3 bit[18:19]=0 */
+					/*if (pAd->StaCfg.bRadio == FALSE) */
 					if (1) {
 						RTMP_RF_IO_WRITE32(pAd, R3);
 
@@ -2509,17 +2509,17 @@ VOID AsicTurnOffRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 
 VOID AsicTurnOnRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 {
-	// RF R2 bit 18 = 0
+	/* RF R2 bit 18 = 0 */
 	UINT32 R1 = 0, R2 = 0, R3 = 0;
 	UCHAR index;
 	RTMP_RF_REGS *RFRegTable;
 
 #ifdef PCIE_PS_SUPPORT
-	// The RF programming sequence is difference between 3xxx and 2xxx
+	/* The RF programming sequence is difference between 3xxx and 2xxx */
 	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
 		return;
 	}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 
 	RFRegTable = RF2850RegTable;
 
@@ -2541,13 +2541,13 @@ VOID AsicTurnOnRFClk(IN PRTMP_ADAPTER pAd, IN UCHAR Channel)
 
 				R2 = RFRegTable[index].R2;
 				if (pAd->Antenna.field.TxPath == 1) {
-					R2 |= 0x4000;	// If TXpath is 1, bit 14 = 1;
+					R2 |= 0x4000;	/* If TXpath is 1, bit 14 = 1; */
 				}
 
 				if (pAd->Antenna.field.RxPath == 2) {
-					R2 |= 0x40;	// write 1 to off Rxpath.
+					R2 |= 0x40;	/* write 1 to off Rxpath. */
 				} else if (pAd->Antenna.field.RxPath == 1) {
-					R2 |= 0x20040;	// write 1 to off RxPath
+					R2 |= 0x20040;	/* write 1 to off RxPath */
 				}
 				RTMP_RF_IO_WRITE32(pAd, R2);
 
diff --git a/drivers/staging/rt2860/common/cmm_cfg.c b/drivers/staging/rt2860/common/cmm_cfg.c
index 9f33717..7dbcb23 100644
--- a/drivers/staging/rt2860/common/cmm_cfg.c
+++ b/drivers/staging/rt2860/common/cmm_cfg.c
@@ -95,8 +95,8 @@ INT RT_CfgSetCountryRegion(IN PRTMP_ADAPTER pAd, IN PSTRING arg, IN INT band)
 		regionMax = REGION_MAXIMUM_A_BAND;
 	}
 
-	// TODO: Is it neccesay for following check???
-	// Country can be set only when EEPROM not programmed
+	/* TODO: Is it neccesay for following check??? */
+	/* Country can be set only when EEPROM not programmed */
 	if (*pCountryRegion & 0x80) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("CfgSetCountryRegion():CountryRegion in eeprom was programmed\n"));
@@ -154,7 +154,7 @@ INT RT_CfgSetShortSlot(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 	else if (ShortSlot == 0)
 		pAd->CommonCfg.bUseShortSlotTime = FALSE;
 	else
-		return FALSE;	//Invalid argument
+		return FALSE;	/*Invalid argument */
 
 	return TRUE;
 }
@@ -176,29 +176,29 @@ INT RT_CfgSetWepKey(IN PRTMP_ADAPTER pAd,
 	UCHAR CipherAlg = CIPHER_NONE;
 	BOOLEAN bKeyIsHex = FALSE;
 
-	// TODO: Shall we do memset for the original key info??
+	/* TODO: Shall we do memset for the original key info?? */
 	memset(pSharedKey, 0, sizeof(CIPHER_KEY));
 	KeyLen = strlen(keyString);
 	switch (KeyLen) {
-	case 5:		//wep 40 Ascii type
-	case 13:		//wep 104 Ascii type
+	case 5:		/*wep 40 Ascii type */
+	case 13:		/*wep 104 Ascii type */
 		bKeyIsHex = FALSE;
 		pSharedKey->KeyLen = KeyLen;
 		NdisMoveMemory(pSharedKey->Key, keyString, KeyLen);
 		break;
 
-	case 10:		//wep 40 Hex type
-	case 26:		//wep 104 Hex type
+	case 10:		/*wep 40 Hex type */
+	case 26:		/*wep 104 Hex type */
 		for (i = 0; i < KeyLen; i++) {
 			if (!isxdigit(*(keyString + i)))
-				return FALSE;	//Not Hex value;
+				return FALSE;	/*Not Hex value; */
 		}
 		bKeyIsHex = TRUE;
 		pSharedKey->KeyLen = KeyLen / 2;
 		AtoH(keyString, pSharedKey->Key, pSharedKey->KeyLen);
 		break;
 
-	default:		//Invalid argument
+	default:		/*Invalid argument */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("RT_CfgSetWepKey(keyIdx=%d):Invalid argument (arg=%s)\n",
 			  keyIdx, keyString));
diff --git a/drivers/staging/rt2860/common/cmm_data.c b/drivers/staging/rt2860/common/cmm_data.c
index 033a4ea..81766db 100644
--- a/drivers/staging/rt2860/common/cmm_data.c
+++ b/drivers/staging/rt2860/common/cmm_data.c
@@ -30,7 +30,7 @@
 UCHAR SNAP_802_1H[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
 UCHAR SNAP_BRIDGE_TUNNEL[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
 
-// Add Cisco Aironet SNAP heade for CCX2 support
+/* Add Cisco Aironet SNAP heade for CCX2 support */
 UCHAR SNAP_AIRONET[] = { 0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x00 };
 UCHAR CKIP_LLC_SNAP[] = { 0xaa, 0xaa, 0x03, 0x00, 0x40, 0x96, 0x00, 0x02 };
 UCHAR EAPOL_LLC_SNAP[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e };
@@ -41,28 +41,28 @@ UCHAR IPX[] = { 0x81, 0x37 };
 UCHAR APPLE_TALK[] = { 0x80, 0xf3 };
 
 UCHAR RateIdToPlcpSignal[12] = {
-	0, /* RATE_1 */ 1, /* RATE_2 */ 2, /* RATE_5_5 */ 3,	/* RATE_11 */// see BBP spec
-	11, /* RATE_6 */ 15, /* RATE_9 */ 10, /* RATE_12 */ 14,	/* RATE_18 */// see IEEE802.11a-1999 p.14
+	0, /* RATE_1 */ 1, /* RATE_2 */ 2, /* RATE_5_5 */ 3,	/* RATE_11 *//* see BBP spec */
+	11, /* RATE_6 */ 15, /* RATE_9 */ 10, /* RATE_12 */ 14,	/* RATE_18 *//* see IEEE802.11a-1999 p.14 */
 	9, /* RATE_24 */ 13, /* RATE_36 */ 8, /* RATE_48 */ 12 /* RATE_54 */
-};				// see IEEE802.11a-1999 p.14
+};				/* see IEEE802.11a-1999 p.14 */
 
 UCHAR OfdmSignalToRateId[16] = {
-	RATE_54, RATE_54, RATE_54, RATE_54,	// OFDM PLCP Signal = 0,  1,  2,  3 respectively
-	RATE_54, RATE_54, RATE_54, RATE_54,	// OFDM PLCP Signal = 4,  5,  6,  7 respectively
-	RATE_48, RATE_24, RATE_12, RATE_6,	// OFDM PLCP Signal = 8,  9,  10, 11 respectively
-	RATE_54, RATE_36, RATE_18, RATE_9,	// OFDM PLCP Signal = 12, 13, 14, 15 respectively
+	RATE_54, RATE_54, RATE_54, RATE_54,	/* OFDM PLCP Signal = 0,  1,  2,  3 respectively */
+	RATE_54, RATE_54, RATE_54, RATE_54,	/* OFDM PLCP Signal = 4,  5,  6,  7 respectively */
+	RATE_48, RATE_24, RATE_12, RATE_6,	/* OFDM PLCP Signal = 8,  9,  10, 11 respectively */
+	RATE_54, RATE_36, RATE_18, RATE_9,	/* OFDM PLCP Signal = 12, 13, 14, 15 respectively */
 };
 
 UCHAR OfdmRateToRxwiMCS[12] = {
 	0, 0, 0, 0,
-	0, 1, 2, 3,		// OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3
-	4, 5, 6, 7,		// OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7
+	0, 1, 2, 3,		/* OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3 */
+	4, 5, 6, 7,		/* OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7 */
 };
 
 UCHAR RxwiMCSToOfdmRate[12] = {
 	RATE_6, RATE_9, RATE_12, RATE_18,
-	RATE_24, RATE_36, RATE_48, RATE_54,	// OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3
-	4, 5, 6, 7,		// OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7
+	RATE_24, RATE_36, RATE_48, RATE_54,	/* OFDM rate 6,9,12,18 = rxwi mcs 0,1,2,3 */
+	4, 5, 6, 7,		/* OFDM rate 24,36,48,54 = rxwi mcs 4,5,6,7 */
 };
 
 char *MCSToMbps[] =
@@ -73,7 +73,7 @@ char *MCSToMbps[] =
 
 UCHAR default_cwmin[] =
     { CW_MIN_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS - 1, CW_MIN_IN_BITS - 2 };
-//UCHAR default_cwmax[]={CW_MAX_IN_BITS, CW_MAX_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1};
+/*UCHAR default_cwmax[]={CW_MAX_IN_BITS, CW_MAX_IN_BITS, CW_MIN_IN_BITS, CW_MIN_IN_BITS-1}; */
 UCHAR default_sta_aifsn[] = { 3, 7, 2, 2 };
 
 UCHAR MapUserPriorityToAccessCategory[8] =
@@ -110,11 +110,11 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 	PNDIS_PACKET pPacket;
 	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
 	ULONG FreeNum;
-	UCHAR rtmpHwHdr[TXINFO_SIZE + TXWI_SIZE];	//RTMP_HW_HDR_LEN];
+	UCHAR rtmpHwHdr[TXINFO_SIZE + TXWI_SIZE];	/*RTMP_HW_HDR_LEN]; */
 #ifdef RTMP_MAC_PCI
 	unsigned long IrqFlags = 0;
 	UCHAR IrqState;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 	BOOLEAN bUseDataQ = FALSE;
 	int retryCnt = 0;
 
@@ -125,7 +125,7 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 		QueIdx &= (~MGMT_USE_QUEUE_FLAG);
 	}
 #ifdef RTMP_MAC_PCI
-	// 2860C use Tx Ring
+	/* 2860C use Tx Ring */
 	IrqState = pAd->irq_disabled;
 	if (pAd->MACVersion == 0x28600100) {
 		QueIdx = (bUseDataQ == TRUE ? QueIdx : 3);
@@ -133,10 +133,10 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 	}
 	if (bUseDataQ && (!IrqState))
 		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	do {
-		// Reset is in progress, stop immediately
+		/* Reset is in progress, stop immediately */
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
 		    RTMP_TEST_FLAG(pAd,
 				   fRTMP_ADAPTER_HALT_IN_PROGRESS |
@@ -145,22 +145,22 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 			Status = NDIS_STATUS_FAILURE;
 			break;
 		}
-		// Check Free priority queue
-		// Since we use PBF Queue2 for management frame.  Its corresponding DMA ring should be using TxRing.
+		/* Check Free priority queue */
+		/* Since we use PBF Queue2 for management frame.  Its corresponding DMA ring should be using TxRing. */
 #ifdef RTMP_MAC_PCI
 		if (bUseDataQ) {
 			retryCnt = MAX_DATAMM_RETRY;
-			// free Tx(QueIdx) resources
+			/* free Tx(QueIdx) resources */
 			RTMPFreeTXDUponTxDmaDone(pAd, QueIdx);
 			FreeNum = GET_TXRING_FREENO(pAd, QueIdx);
 		} else
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 		{
 			FreeNum = GET_MGMTRING_FREENO(pAd);
 		}
 
 		if ((FreeNum > 0)) {
-			// We need to reserve space for rtmp hardware header. i.e., TxWI for RT2860 and TxInfo+TxWI for RT2870
+			/* We need to reserve space for rtmp hardware header. i.e., TxWI for RT2860 and TxInfo+TxWI for RT2870 */
 			NdisZeroMemory(&rtmpHwHdr, (TXINFO_SIZE + TXWI_SIZE));
 			Status =
 			    RTMPAllocateNdisPacket(pAd, &pPacket,
@@ -172,8 +172,8 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 					 ("MiniportMMRequest (error:: can't allocate NDIS PACKET)\n"));
 				break;
 			}
-			//pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
-			//pAd->CommonCfg.MlmeRate = RATE_2;
+			/*pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK; */
+			/*pAd->CommonCfg.MlmeRate = RATE_2; */
 
 #ifdef RTMP_MAC_PCI
 			if (bUseDataQ) {
@@ -181,7 +181,7 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 				    MlmeDataHardTransmit(pAd, QueIdx, pPacket);
 				retryCnt--;
 			} else
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 				Status = MlmeHardTransmit(pAd, QueIdx, pPacket);
 			if (Status == NDIS_STATUS_SUCCESS)
 				retryCnt = 0;
@@ -202,7 +202,7 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 						  MgmtRingFullCount));
 				}
 			}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("Qidx(%d), not enough space in MgmtRing, MgmtRingFullCount=%ld!\n",
 				  QueIdx,
@@ -213,7 +213,7 @@ NDIS_STATUS MiniportMMRequest(IN PRTMP_ADAPTER pAd,
 #ifdef RTMP_MAC_PCI
 	if (bUseDataQ && (!IrqState))
 		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	return Status;
 }
@@ -265,7 +265,7 @@ NDIS_STATUS MlmeHardTransmit(IN PRTMP_ADAPTER pAd,
 	if (pAd->MACVersion == 0x28600100)
 		return MlmeHardTransmitTxRing(pAd, QueIdx, pPacket);
 	else
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 		return MlmeHardTransmitMgmtRing(pAd, QueIdx, pPacket);
 
 }
@@ -285,22 +285,22 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
-	// Make sure MGMT ring resource won't be used by other threads
+	/* Make sure MGMT ring resource won't be used by other threads */
 	RTMP_SEM_LOCK(&pAd->MgmtRingLock);
 	if (pSrcBufVA == NULL) {
-		// The buffer shouldn't be NULL
+		/* The buffer shouldn't be NULL */
 		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return NDIS_STATUS_FAILURE;
 	}
 
 	{
-		// outgoing frame always wakeup PHY to prevent frame lost
+		/* outgoing frame always wakeup PHY to prevent frame lost */
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 			AsicForceWakeup(pAd, TRUE);
 	}
 
 	pFirstTxWI = (PTXWI_STRUC) (pSrcBufVA + TXINFO_SIZE);
-	pHeader_802_11 = (PHEADER_802_11) (pSrcBufVA + TXINFO_SIZE + TXWI_SIZE);	//TXWI_SIZE);
+	pHeader_802_11 = (PHEADER_802_11) (pSrcBufVA + TXINFO_SIZE + TXWI_SIZE);	/*TXWI_SIZE); */
 
 	if (pHeader_802_11->Addr1[0] & 0x01) {
 		MlmeRate = pAd->CommonCfg.BasicMlmeRate;
@@ -308,8 +308,8 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 		MlmeRate = pAd->CommonCfg.MlmeRate;
 	}
 
-	// Verify Mlme rate for a / g bands.
-	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	// 11A band
+	/* Verify Mlme rate for a / g bands. */
+	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	/* 11A band */
 		MlmeRate = RATE_6;
 
 	if ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
@@ -318,7 +318,7 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 	}
 
 	{
-		// Fixed W52 with Activity scan issue in ABG_MIXED and ABGN_MIXED mode.
+		/* Fixed W52 with Activity scan issue in ABG_MIXED and ABGN_MIXED mode. */
 		if (pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED
 		    || pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED) {
 			if (pAd->LatchRfRegs.Channel > 14)
@@ -328,17 +328,17 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 		}
 	}
 
-	//
-	// Should not be hard code to set PwrMgmt to 0 (PWR_ACTIVE)
-	// Snice it's been set to 0 while on MgtMacHeaderInit
-	// By the way this will cause frame to be send on PWR_SAVE failed.
-	//
-	pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE;	// (pAd->StaCfg.Psm == PWR_SAVE);
-
-	//
-	// In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame
-	// Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD
-//      if ((pHeader_802_11->FC.Type != BTYPE_DATA) && (pHeader_802_11->FC.Type != BTYPE_CNTL))
+	/* */
+	/* Should not be hard code to set PwrMgmt to 0 (PWR_ACTIVE) */
+	/* Snice it's been set to 0 while on MgtMacHeaderInit */
+	/* By the way this will cause frame to be send on PWR_SAVE failed. */
+	/* */
+	pHeader_802_11->FC.PwrMgmt = PWR_ACTIVE;	/* (pAd->StaCfg.Psm == PWR_SAVE); */
+
+	/* */
+	/* In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame */
+	/* Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
+/*      if ((pHeader_802_11->FC.Type != BTYPE_DATA) && (pHeader_802_11->FC.Type != BTYPE_CNTL)) */
 	{
 		if ((pHeader_802_11->FC.SubType == SUBTYPE_ACTION) ||
 		    ((pHeader_802_11->FC.Type == BTYPE_DATA) &&
@@ -353,20 +353,20 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 	}
 
 	bInsertTimestamp = FALSE;
-	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	// must be PS-POLL
+	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	/* must be PS-POLL */
 	{
-		//Set PM bit in ps-poll, to fix WLK 1.2  PowerSaveMode_ext failure issue.
+		/*Set PM bit in ps-poll, to fix WLK 1.2  PowerSaveMode_ext failure issue. */
 		if ((pAd->OpMode == OPMODE_STA)
 		    && (pHeader_802_11->FC.SubType == SUBTYPE_PS_POLL)) {
 			pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
 		}
 		bAckRequired = FALSE;
-	} else			// BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
+	} else			/* BTYPE_MGMT or BTYPE_DATA(must be NULL frame) */
 	{
-		//pAd->Sequence++;
-		//pHeader_802_11->Sequence = pAd->Sequence;
+		/*pAd->Sequence++; */
+		/*pHeader_802_11->Sequence = pAd->Sequence; */
 
-		if (pHeader_802_11->Addr1[0] & 0x01)	// MULTICAST, BROADCAST
+		if (pHeader_802_11->Addr1[0] & 0x01)	/* MULTICAST, BROADCAST */
 		{
 			bAckRequired = FALSE;
 			pHeader_802_11->Duration = 0;
@@ -377,12 +377,12 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 			if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_RSP)
 			    && (pHeader_802_11->FC.Type == BTYPE_MGMT)) {
 				bInsertTimestamp = TRUE;
-				bAckRequired = FALSE;	// Disable ACK to prevent retry 0x1f for Probe Response
+				bAckRequired = FALSE;	/* Disable ACK to prevent retry 0x1f for Probe Response */
 			} else
 			    if ((pHeader_802_11->FC.SubType ==
 				 SUBTYPE_PROBE_REQ)
 				&& (pHeader_802_11->FC.Type == BTYPE_MGMT)) {
-				bAckRequired = FALSE;	// Disable ACK to prevent retry 0x1f for Probe Request
+				bAckRequired = FALSE;	/* Disable ACK to prevent retry 0x1f for Probe Request */
 			}
 		}
 	}
@@ -391,30 +391,30 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 	if (pAd->Sequence > 0xfff)
 		pAd->Sequence = 0;
 
-	// Before radar detection done, mgmt frame can not be sent but probe req
-	// Because we need to use probe req to trigger driver to send probe req in passive scan
+	/* Before radar detection done, mgmt frame can not be sent but probe req */
+	/* Because we need to use probe req to trigger driver to send probe req in passive scan */
 	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ)
 	    && (pAd->CommonCfg.bIEEE80211H == 1)
 	    && (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
-//              if (!IrqState)
+/*              if (!IrqState) */
 		RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 		return (NDIS_STATUS_FAILURE);
 	}
 
-	//
-	// fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET
-	// should always has only one physical buffer, and the whole frame size equals
-	// to the first scatter buffer size
-	//
+	/* */
+	/* fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET */
+	/* should always has only one physical buffer, and the whole frame size equals */
+	/* to the first scatter buffer size */
+	/* */
 
-	// Initialize TX Descriptor
-	// For inter-frame gap, the number is for this frame and next frame
-	// For MLME rate, we will fix as 2Mb to match other vendor's implement
-//      pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
+	/* Initialize TX Descriptor */
+	/* For inter-frame gap, the number is for this frame and next frame */
+	/* For MLME rate, we will fix as 2Mb to match other vendor's implement */
+/*      pAd->CommonCfg.MlmeTransmit.field.MODE = 1; */
 
-// management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not.
+/* management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not. */
 	PID = PID_MGMT;
 
 	if (pMacEntry == NULL) {
@@ -434,11 +434,11 @@ NDIS_STATUS MlmeHardTransmitMgmtRing(IN PRTMP_ADAPTER pAd,
 			      IFS_BACKOFF, FALSE, &pMacEntry->MaxHTPhyMode);
 	}
 
-	// Now do hardware-depened kick out.
+	/* Now do hardware-depened kick out. */
 	HAL_KickOutMgmtTx(pAd, QueIdx, pPacket, pSrcBufVA, SrcBufLen);
 
-	// Make sure to release MGMT ring resource
-//      if (!IrqState)
+	/* Make sure to release MGMT ring resource */
+/*      if (!IrqState) */
 	RTMP_SEM_UNLOCK(&pAd->MgmtRingLock);
 	return NDIS_STATUS_SUCCESS;
 }
@@ -514,17 +514,17 @@ static UCHAR TxPktClassification(IN RTMP_ADAPTER * pAd, IN PNDIS_PACKET pPacket)
 	BOOLEAN bHTRate = FALSE;
 
 	Wcid = RTMP_GET_PACKET_WCID(pPacket);
-	if (Wcid == MCAST_WCID) {	// Handle for RA is Broadcast/Multicast Address.
+	if (Wcid == MCAST_WCID) {	/* Handle for RA is Broadcast/Multicast Address. */
 		return TX_MCAST_FRAME;
 	}
-	// Handle for unicast packets
+	/* Handle for unicast packets */
 	pMacEntry = &pAd->MacTab.Content[Wcid];
-	if (RTMP_GET_PACKET_LOWRATE(pPacket)) {	// It's a specific packet need to force low rate, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame
+	if (RTMP_GET_PACKET_LOWRATE(pPacket)) {	/* It's a specific packet need to force low rate, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame */
 		TxFrameType = TX_LEGACY_FRAME;
-	} else if (IS_HT_RATE(pMacEntry)) {	// it's a 11n capable packet
+	} else if (IS_HT_RATE(pMacEntry)) {	/* it's a 11n capable packet */
 
-		// Depends on HTPhyMode to check if the peer support the HTRate transmission.
-		//      Currently didn't support A-MSDU embedded in A-MPDU
+		/* Depends on HTPhyMode to check if the peer support the HTRate transmission. */
+		/*      Currently didn't support A-MSDU embedded in A-MPDU */
 		bHTRate = TRUE;
 		if (RTMP_GET_PACKET_MOREDATA(pPacket)
 		    || (pMacEntry->PsMode == PWR_SAVE))
@@ -538,15 +538,15 @@ static UCHAR TxPktClassification(IN RTMP_ADAPTER * pAd, IN PNDIS_PACKET pPacket)
 			return TX_AMSDU_FRAME;
 		else
 			TxFrameType = TX_LEGACY_FRAME;
-	} else {		// it's a legacy b/g packet.
-		if ((CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE) && pAd->CommonCfg.bAggregationCapable) && (RTMP_GET_PACKET_TXRATE(pPacket) >= RATE_6) && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	// if peer support Ralink Aggregation, we use it.
+	} else {		/* it's a legacy b/g packet. */
+		if ((CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE) && pAd->CommonCfg.bAggregationCapable) && (RTMP_GET_PACKET_TXRATE(pPacket) >= RATE_6) && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	/* if peer support Ralink Aggregation, we use it. */
 			TxFrameType = TX_RALINK_FRAME;
 		} else {
 			TxFrameType = TX_LEGACY_FRAME;
 		}
 	}
 
-	// Currently, our fragment only support when a unicast packet send as NOT-ARALINK, NOT-AMSDU and NOT-AMPDU.
+	/* Currently, our fragment only support when a unicast packet send as NOT-ARALINK, NOT-AMSDU and NOT-AMPDU. */
 	if ((RTMP_GET_PACKET_FRAGMENTS(pPacket) > 1)
 	    && (TxFrameType == TX_LEGACY_FRAME))
 		TxFrameType = TX_FRAG_FRAME;
@@ -567,14 +567,14 @@ BOOLEAN RTMP_FillTxBlkInfo(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 	pTxBlk->Wcid = RTMP_GET_PACKET_WCID(pPacket);
 	pTxBlk->apidx = RTMP_GET_PACKET_IF(pPacket);
 	pTxBlk->UserPriority = RTMP_GET_PACKET_UP(pPacket);
-	pTxBlk->FrameGap = IFS_HTTXOP;	// ASIC determine Frame Gap
+	pTxBlk->FrameGap = IFS_HTTXOP;	/* ASIC determine Frame Gap */
 
 	if (RTMP_GET_PACKET_CLEAR_EAP_FRAME(pTxBlk->pPacket))
 		TX_BLK_SET_FLAG(pTxBlk, fTX_bClearEAPFrame);
 	else
 		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bClearEAPFrame);
 
-	// Default to clear this flag
+	/* Default to clear this flag */
 	TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bForceNonQoS);
 
 	if (pTxBlk->Wcid == MCAST_WCID) {
@@ -584,8 +584,8 @@ BOOLEAN RTMP_FillTxBlkInfo(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 			    &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
 		}
 
-		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);	// AckRequired = FALSE, when broadcast packet in Adhoc mode.
-		//TX_BLK_SET_FLAG(pTxBlk, fTX_bForceLowRate);
+		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);	/* AckRequired = FALSE, when broadcast packet in Adhoc mode. */
+		/*TX_BLK_SET_FLAG(pTxBlk, fTX_bForceLowRate); */
 		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAllowFrag);
 		TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bWMM);
 		if (RTMP_GET_PACKET_MOREDATA(pPacket)) {
@@ -598,7 +598,7 @@ BOOLEAN RTMP_FillTxBlkInfo(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 
 		pMacEntry = pTxBlk->pMacEntry;
 
-		// For all unicast packets, need Ack unless the Ack Policy is not set as NORMAL_ACK.
+		/* For all unicast packets, need Ack unless the Ack Policy is not set as NORMAL_ACK. */
 		if (pAd->CommonCfg.AckPolicy[pTxBlk->QueIdx] != NORMAL_ACK)
 			TX_BLK_CLEAR_FLAG(pTxBlk, fTX_bAckRequired);
 		else
@@ -614,24 +614,24 @@ BOOLEAN RTMP_FillTxBlkInfo(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 		{
 			{
 
-				// If support WMM, enable it.
+				/* If support WMM, enable it. */
 				if (OPSTATUS_TEST_FLAG
 				    (pAd, fOP_STATUS_WMM_INUSED)
 				    && CLIENT_STATUS_TEST_FLAG(pMacEntry,
 							       fCLIENT_STATUS_WMM_CAPABLE))
 					TX_BLK_SET_FLAG(pTxBlk, fTX_bWMM);
 
-//                              if (pAd->StaCfg.bAutoTxRateSwitch)
-//                                      TX_BLK_SET_FLAG(pTxBlk, fTX_AutoRateSwitch);
+/*                              if (pAd->StaCfg.bAutoTxRateSwitch) */
+/*                                      TX_BLK_SET_FLAG(pTxBlk, fTX_AutoRateSwitch); */
 			}
 		}
 
 		if (pTxBlk->TxFrameType == TX_LEGACY_FRAME) {
-			if ((RTMP_GET_PACKET_LOWRATE(pPacket)) || ((pAd->OpMode == OPMODE_AP) && (pMacEntry->MaxHTPhyMode.field.MODE == MODE_CCK) && (pMacEntry->MaxHTPhyMode.field.MCS == RATE_1))) {	// Specific packet, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame, need force low rate.
+			if ((RTMP_GET_PACKET_LOWRATE(pPacket)) || ((pAd->OpMode == OPMODE_AP) && (pMacEntry->MaxHTPhyMode.field.MODE == MODE_CCK) && (pMacEntry->MaxHTPhyMode.field.MCS == RATE_1))) {	/* Specific packet, i.e., bDHCPFrame, bEAPOLFrame, bWAIFrame, need force low rate. */
 				pTxBlk->pTransmit =
 				    &pAd->MacTab.Content[MCAST_WCID].HTPhyMode;
 
-				// Modify the WMM bit for ICV issue. If we have a packet with EOSP field need to set as 1, how to handle it???
+				/* Modify the WMM bit for ICV issue. If we have a packet with EOSP field need to set as 1, how to handle it??? */
 				if (IS_HT_STA(pTxBlk->pMacEntry) &&
 				    (CLIENT_STATUS_TEST_FLAG
 				     (pMacEntry, fCLIENT_STATUS_RALINK_CHIPSET))
@@ -645,7 +645,7 @@ BOOLEAN RTMP_FillTxBlkInfo(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 				}
 			}
 
-			if ((IS_HT_RATE(pMacEntry) == FALSE) && (CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE))) {	// Currently piggy-back only support when peer is operate in b/g mode.
+			if ((IS_HT_RATE(pMacEntry) == FALSE) && (CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE))) {	/* Currently piggy-back only support when peer is operate in b/g mode. */
 				TX_BLK_SET_FLAG(pTxBlk, fTX_bPiggyBack);
 			}
 
@@ -666,7 +666,7 @@ BOOLEAN CanDoAggregateTransmit(IN RTMP_ADAPTER * pAd,
 			       IN NDIS_PACKET * pPacket, IN TX_BLK * pTxBlk)
 {
 
-	//DBGPRINT(RT_DEBUG_TRACE, ("Check if can do aggregation! TxFrameType=%d!\n", pTxBlk->TxFrameType));
+	/*DBGPRINT(RT_DEBUG_TRACE, ("Check if can do aggregation! TxFrameType=%d!\n", pTxBlk->TxFrameType)); */
 
 	if (RTMP_GET_PACKET_WCID(pPacket) == MCAST_WCID)
 		return FALSE;
@@ -675,15 +675,15 @@ BOOLEAN CanDoAggregateTransmit(IN RTMP_ADAPTER * pAd,
 	    RTMP_GET_PACKET_EAPOL(pPacket) || RTMP_GET_PACKET_WAI(pPacket))
 		return FALSE;
 
-	if ((pTxBlk->TxFrameType == TX_AMSDU_FRAME) && ((pTxBlk->TotalFrameLen + GET_OS_PKT_LEN(pPacket)) > (RX_BUFFER_AGGRESIZE - 100))) {	// For AMSDU, allow the packets with total length < max-amsdu size
+	if ((pTxBlk->TxFrameType == TX_AMSDU_FRAME) && ((pTxBlk->TotalFrameLen + GET_OS_PKT_LEN(pPacket)) > (RX_BUFFER_AGGRESIZE - 100))) {	/* For AMSDU, allow the packets with total length < max-amsdu size */
 		return FALSE;
 	}
 
-	if ((pTxBlk->TxFrameType == TX_RALINK_FRAME) && (pTxBlk->TxPacketList.Number == 2)) {	// For RALINK-Aggregation, allow two frames in one batch.
+	if ((pTxBlk->TxFrameType == TX_RALINK_FRAME) && (pTxBlk->TxPacketList.Number == 2)) {	/* For RALINK-Aggregation, allow two frames in one batch. */
 		return FALSE;
 	}
 
-	if ((INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA))	// must be unicast to AP
+	if ((INFRA_ON(pAd)) && (pAd->OpMode == OPMODE_STA))	/* must be unicast to AP */
 		return TRUE;
 	else
 		return FALSE;
@@ -729,7 +729,7 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 
 	if (QIdx == NUM_OF_TX_RING) {
 		sQIdx = 0;
-		eQIdx = 3;	// 4 ACs, start from 0.
+		eQIdx = 3;	/* 4 ACs, start from 0. */
 	} else {
 		sQIdx = eQIdx = QIdx;
 	}
@@ -764,14 +764,14 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 			FreeNumber[QueIdx] = GET_TXRING_FREENO(pAd, QueIdx);
 
 			if (FreeNumber[QueIdx] <= 5) {
-				// free Tx(QueIdx) resources
+				/* free Tx(QueIdx) resources */
 				RTMPFreeTXDUponTxDmaDone(pAd, QueIdx);
 				FreeNumber[QueIdx] =
 				    GET_TXRING_FREENO(pAd, QueIdx);
 			}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-			// probe the Queue Head
+			/* probe the Queue Head */
 			pQueue = &pAd->TxSwQueue[QueIdx];
 			if ((pEntry = pQueue->Head) == NULL) {
 				DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext,
@@ -781,12 +781,12 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 
 			pTxBlk = &TxBlk;
 			NdisZeroMemory((PUCHAR) pTxBlk, sizeof(TX_BLK));
-			//InitializeQueueHeader(&pTxBlk->TxPacketList);         // Didn't need it because we already memzero it.
+			/*InitializeQueueHeader(&pTxBlk->TxPacketList);         // Didn't need it because we already memzero it. */
 			pTxBlk->QueIdx = QueIdx;
 
 			pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
 
-			// Early check to make sure we have enoguh Tx Resource.
+			/* Early check to make sure we have enoguh Tx Resource. */
 			hasTxDesc =
 			    RTMP_HAS_ENOUGH_FREE_DESC(pAd, pTxBlk,
 						      FreeNumber[QueIdx],
@@ -803,7 +803,7 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 			pTxBlk->TxFrameType = TxPktClassification(pAd, pPacket);
 			pEntry = RemoveHeadQueue(pQueue);
 			pTxBlk->TotalFrameNum++;
-			pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	// The real fragment number maybe vary
+			pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	/* The real fragment number maybe vary */
 			pTxBlk->TotalFrameLen += GET_OS_PKT_LEN(pPacket);
 			pTxBlk->pPacket = pPacket;
 			InsertTailQueue(&pTxBlk->TxPacketList,
@@ -811,7 +811,7 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 
 			if (pTxBlk->TxFrameType == TX_RALINK_FRAME
 			    || pTxBlk->TxFrameType == TX_AMSDU_FRAME) {
-				// Enhance SW Aggregation Mechanism
+				/* Enhance SW Aggregation Mechanism */
 				if (NEED_QUEUE_BACK_FOR_AGG
 				    (pAd, QueIdx, FreeNumber[QueIdx],
 				     pTxBlk->TxFrameType)) {
@@ -827,7 +827,7 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 					if ((pEntry = pQueue->Head) == NULL)
 						break;
 
-					// For TX_AMSDU_FRAME/TX_RALINK_FRAME, Need to check if next pakcet can do aggregation.
+					/* For TX_AMSDU_FRAME/TX_RALINK_FRAME, Need to check if next pakcet can do aggregation. */
 					pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
 					FreeNumber[QueIdx] =
 					    GET_TXRING_FREENO(pAd, QueIdx);
@@ -843,12 +843,12 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 					     (pAd, pPacket, pTxBlk) == FALSE))
 						break;
 
-					//Remove the packet from the TxSwQueue and insert into pTxBlk
+					/*Remove the packet from the TxSwQueue and insert into pTxBlk */
 					pEntry = RemoveHeadQueue(pQueue);
 					ASSERT(pEntry);
 					pPacket = QUEUE_ENTRY_TO_PACKET(pEntry);
 					pTxBlk->TotalFrameNum++;
-					pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	// The real fragment number maybe vary
+					pTxBlk->TotalFragNum += RTMP_GET_PACKET_FRAGMENTS(pPacket);	/* The real fragment number maybe vary */
 					pTxBlk->TotalFrameLen +=
 					    GET_OS_PKT_LEN(pPacket);
 					InsertTailQueue(&pTxBlk->TxPacketList,
@@ -861,18 +861,18 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 			}
 #ifdef RTMP_MAC_USB
 			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 			Count += pTxBlk->TxPacketList.Number;
 
-			// Do HardTransmit now.
+			/* Do HardTransmit now. */
 			Status = STAHardTransmit(pAd, pTxBlk, QueIdx);
 
 #ifdef RTMP_MAC_PCI
 			DEQUEUE_UNLOCK(&pAd->irq_lock, bIntContext, IrqFlags);
-			// static rate also need NICUpdateFifoStaCounters() function.
-			//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
+			/* static rate also need NICUpdateFifoStaCounters() function. */
+			/*if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */
 			NICUpdateFifoStaCounters(pAd);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 		}
 
@@ -881,7 +881,7 @@ VOID RTMPDeQueuePacket(IN PRTMP_ADAPTER pAd, IN BOOLEAN bIntContext, IN UCHAR QI
 #ifdef RTMP_MAC_USB
 		if (!hasTxDesc)
 			RTUSBKickBulkOut(pAd);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	}
 
 }
@@ -912,28 +912,28 @@ USHORT RTMPCalcDuration(IN PRTMP_ADAPTER pAd, IN UCHAR Rate, IN ULONG Size)
 {
 	ULONG Duration = 0;
 
-	if (Rate < RATE_FIRST_OFDM_RATE)	// CCK
+	if (Rate < RATE_FIRST_OFDM_RATE)	/* CCK */
 	{
 		if ((Rate > RATE_1)
 		    && OPSTATUS_TEST_FLAG(pAd,
 					  fOP_STATUS_SHORT_PREAMBLE_INUSED))
-			Duration = 96;	// 72+24 preamble+plcp
+			Duration = 96;	/* 72+24 preamble+plcp */
 		else
-			Duration = 192;	// 144+48 preamble+plcp
+			Duration = 192;	/* 144+48 preamble+plcp */
 
 		Duration += (USHORT) ((Size << 4) / RateIdTo500Kbps[Rate]);
 		if ((Size << 4) % RateIdTo500Kbps[Rate])
 			Duration++;
-	} else if (Rate <= RATE_LAST_OFDM_RATE)	// OFDM rates
+	} else if (Rate <= RATE_LAST_OFDM_RATE)	/* OFDM rates */
 	{
-		Duration = 20 + 6;	// 16+4 preamble+plcp + Signal Extension
+		Duration = 20 + 6;	/* 16+4 preamble+plcp + Signal Extension */
 		Duration +=
 		    4 * (USHORT) ((11 + Size * 4) / RateIdTo500Kbps[Rate]);
 		if ((11 + Size * 4) % RateIdTo500Kbps[Rate])
 			Duration += 4;
-	} else			//mimo rate
+	} else			/*mimo rate */
 	{
-		Duration = 20 + 6;	// 16+4 preamble+plcp + Signal Extension
+		Duration = 20 + 6;	/* 16+4 preamble+plcp + Signal Extension */
 	}
 
 	return (USHORT) Duration;
@@ -968,7 +968,7 @@ USHORT RTMPCalcDuration(IN PRTMP_ADAPTER pAd, IN UCHAR Rate, IN ULONG Size)
 
 	========================================================================
 */
-VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRAG, IN BOOLEAN CFACK, IN BOOLEAN InsTimestamp, IN BOOLEAN AMPDU, IN BOOLEAN Ack, IN BOOLEAN NSeq,	// HW new a sequence.
+VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRAG, IN BOOLEAN CFACK, IN BOOLEAN InsTimestamp, IN BOOLEAN AMPDU, IN BOOLEAN Ack, IN BOOLEAN NSeq,	/* HW new a sequence. */
 		   IN UCHAR BASize,
 		   IN UCHAR WCID,
 		   IN ULONG Length,
@@ -985,10 +985,10 @@ VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRA
 	if (WCID < MAX_LEN_OF_MAC_TABLE)
 		pMac = &pAd->MacTab.Content[WCID];
 
-	//
-	// Always use Long preamble before verifiation short preamble functionality works well.
-	// Todo: remove the following line if short preamble functionality works
-	//
+	/* */
+	/* Always use Long preamble before verifiation short preamble functionality works well. */
+	/* Todo: remove the following line if short preamble functionality works */
+	/* */
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 	NdisZeroMemory(&TxWI, TXWI_SIZE);
 	pTxWI = &TxWI;
@@ -1002,7 +1002,7 @@ VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRA
 	pTxWI->txop = Txopmode;
 
 	pTxWI->NSEQ = NSeq;
-	// John tune the performace with Intel Client in 20 MHz performance
+	/* John tune the performace with Intel Client in 20 MHz performance */
 	BASize = pAd->CommonCfg.TxBASize;
 	if (pAd->MACVersion == 0x28720200) {
 		if (BASize > 13)
@@ -1019,7 +1019,7 @@ VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRA
 	pTxWI->MPDUtotalByteCount = Length;
 	pTxWI->PacketId = PID;
 
-	// If CCK or OFDM, BW must be 20
+	/* If CCK or OFDM, BW must be 20 */
 	pTxWI->BW =
 	    (pTransmit->field.MODE <=
 	     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
@@ -1032,10 +1032,10 @@ VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRA
 		if (pAd->CommonCfg.bMIMOPSEnable) {
 			if ((pMac->MmpsMode == MMPS_DYNAMIC)
 			    && (pTransmit->field.MCS > 7)) {
-				// Dynamic MIMO Power Save Mode
+				/* Dynamic MIMO Power Save Mode */
 				pTxWI->MIMOps = 1;
 			} else if (pMac->MmpsMode == MMPS_STATIC) {
-				// Static MIMO Power Save Mode
+				/* Static MIMO Power Save Mode */
 				if (pTransmit->field.MODE >= MODE_HTMIX
 				    && pTransmit->field.MCS > 7) {
 					pTxWI->MCS = 7;
@@ -1043,7 +1043,7 @@ VOID RTMPWriteTxWI(IN PRTMP_ADAPTER pAd, IN PTXWI_STRUC pOutTxWI, IN BOOLEAN FRA
 				}
 			}
 		}
-		//pTxWI->MIMOps = (pMac->PsMode == PWR_MMPS)? 1:0;
+		/*pTxWI->MIMOps = (pMac->PsMode == PWR_MMPS)? 1:0; */
 		if (pMac->bIAmBadAtheros
 		    && (pMac->WepStatus != Ndis802_11WEPDisabled)) {
 			pTxWI->MpduDensity = 7;
@@ -1068,10 +1068,10 @@ VOID RTMPWriteTxWI_Data(IN PRTMP_ADAPTER pAd,
 	pTransmit = pTxBlk->pTransmit;
 	pMacEntry = pTxBlk->pMacEntry;
 
-	//
-	// Always use Long preamble before verifiation short preamble functionality works well.
-	// Todo: remove the following line if short preamble functionality works
-	//
+	/* */
+	/* Always use Long preamble before verifiation short preamble functionality works well. */
+	/* Todo: remove the following line if short preamble functionality works */
+	/* */
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 	NdisZeroMemory(pTxWI, TXWI_SIZE);
 
@@ -1084,16 +1084,16 @@ VOID RTMPWriteTxWI_Data(IN PRTMP_ADAPTER pAd,
 	pTxWI->MPDUtotalByteCount = pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
 	pTxWI->CFACK = TX_BLK_TEST_FLAG(pTxBlk, fTX_bPiggyBack);
 
-	// If CCK or OFDM, BW must be 20
+	/* If CCK or OFDM, BW must be 20 */
 	pTxWI->BW =
 	    (pTransmit->field.MODE <=
 	     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
 	pTxWI->AMPDU = ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) ? TRUE : FALSE);
 
-	// John tune the performace with Intel Client in 20 MHz performance
+	/* John tune the performace with Intel Client in 20 MHz performance */
 	BASize = pAd->CommonCfg.TxBASize;
 	if ((pTxBlk->TxFrameType == TX_AMPDU_FRAME) && (pMacEntry)) {
-		UCHAR RABAOriIdx = 0;	//The RA's BA Originator table index.
+		UCHAR RABAOriIdx = 0;	/*The RA's BA Originator table index. */
 
 		RABAOriIdx =
 		    pTxBlk->pMacEntry->BAOriWcidArray[pTxBlk->UserPriority];
@@ -1111,10 +1111,10 @@ VOID RTMPWriteTxWI_Data(IN PRTMP_ADAPTER pAd,
 	if (pMacEntry) {
 		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC)
 		    && (pTransmit->field.MCS > 7)) {
-			// Dynamic MIMO Power Save Mode
+			/* Dynamic MIMO Power Save Mode */
 			pTxWI->MIMOps = 1;
 		} else if (pMacEntry->MmpsMode == MMPS_STATIC) {
-			// Static MIMO Power Save Mode
+			/* Static MIMO Power Save Mode */
 			if (pTransmit->field.MODE >= MODE_HTMIX
 			    && pTransmit->field.MCS > 7) {
 				pTxWI->MCS = 7;
@@ -1130,7 +1130,7 @@ VOID RTMPWriteTxWI_Data(IN PRTMP_ADAPTER pAd,
 		}
 	}
 
-	// for rate adapation
+	/* for rate adapation */
 	pTxWI->PacketId = pTxWI->MCS;
 }
 
@@ -1140,19 +1140,19 @@ VOID RTMPWriteTxWI_Cache(IN PRTMP_ADAPTER pAd,
 	PHTTRANSMIT_SETTING /*pTxHTPhyMode, */ pTransmit;
 	PMAC_TABLE_ENTRY pMacEntry;
 
-	//
-	// update TXWI
-	//
+	/* */
+	/* update TXWI */
+	/* */
 	pMacEntry = pTxBlk->pMacEntry;
 	pTransmit = pTxBlk->pTransmit;
 
-	//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
-	//if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pMacEntry))
-	//if (TX_BLK_TEST_FLAG(pTxBlk, fTX_AutoRateSwitch))
+	/*if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */
+	/*if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pMacEntry)) */
+	/*if (TX_BLK_TEST_FLAG(pTxBlk, fTX_AutoRateSwitch)) */
 	if (pMacEntry->bAutoTxRateSwitch) {
 		pTxWI->txop = IFS_HTTXOP;
 
-		// If CCK or OFDM, BW must be 20
+		/* If CCK or OFDM, BW must be 20 */
 		pTxWI->BW =
 		    (pTransmit->field.MODE <=
 		     MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
@@ -1162,7 +1162,7 @@ VOID RTMPWriteTxWI_Cache(IN PRTMP_ADAPTER pAd,
 		pTxWI->MCS = pTransmit->field.MCS;
 		pTxWI->PHYMODE = pTransmit->field.MODE;
 
-		// set PID for TxRateSwitching
+		/* set PID for TxRateSwitching */
 		pTxWI->PacketId = pTransmit->field.MCS;
 	}
 
@@ -1170,13 +1170,13 @@ VOID RTMPWriteTxWI_Cache(IN PRTMP_ADAPTER pAd,
 	pTxWI->MIMOps = 0;
 
 	if (pAd->CommonCfg.bMIMOPSEnable) {
-		// MIMO Power Save Mode
+		/* MIMO Power Save Mode */
 		if ((pMacEntry->MmpsMode == MMPS_DYNAMIC)
 		    && (pTransmit->field.MCS > 7)) {
-			// Dynamic MIMO Power Save Mode
+			/* Dynamic MIMO Power Save Mode */
 			pTxWI->MIMOps = 1;
 		} else if (pMacEntry->MmpsMode == MMPS_STATIC) {
-			// Static MIMO Power Save Mode
+			/* Static MIMO Power Save Mode */
 			if ((pTransmit->field.MODE >= MODE_HTMIX)
 			    && (pTransmit->field.MCS > 7)) {
 				pTxWI->MCS = 7;
@@ -1189,26 +1189,26 @@ VOID RTMPWriteTxWI_Cache(IN PRTMP_ADAPTER pAd,
 
 }
 
-// should be called only when -
-// 1. MEADIA_CONNECTED
-// 2. AGGREGATION_IN_USED
-// 3. Fragmentation not in used
-// 4. either no previous frame (pPrevAddr1=NULL) .OR. previoud frame is aggregatible
+/* should be called only when - */
+/* 1. MEADIA_CONNECTED */
+/* 2. AGGREGATION_IN_USED */
+/* 3. Fragmentation not in used */
+/* 4. either no previous frame (pPrevAddr1=NULL) .OR. previoud frame is aggregatible */
 BOOLEAN TxFrameIsAggregatible(IN PRTMP_ADAPTER pAd,
 			      IN PUCHAR pPrevAddr1, IN PUCHAR p8023hdr)
 {
 
-	// can't aggregate EAPOL (802.1x) frame
+	/* can't aggregate EAPOL (802.1x) frame */
 	if ((p8023hdr[12] == 0x88) && (p8023hdr[13] == 0x8e))
 		return FALSE;
 
-	// can't aggregate multicast/broadcast frame
+	/* can't aggregate multicast/broadcast frame */
 	if (p8023hdr[0] & 0x01)
 		return FALSE;
 
-	if (INFRA_ON(pAd))	// must be unicast to AP
+	if (INFRA_ON(pAd))	/* must be unicast to AP */
 		return TRUE;
-	else if ((pPrevAddr1 == NULL) || MAC_ADDR_EQUAL(pPrevAddr1, p8023hdr))	// unicast to same STA
+	else if ((pPrevAddr1 == NULL) || MAC_ADDR_EQUAL(pPrevAddr1, p8023hdr))	/* unicast to same STA */
 		return TRUE;
 	else
 		return FALSE;
@@ -1241,10 +1241,10 @@ BOOLEAN PeerIsAggreOn(IN PRTMP_ADAPTER pAd,
 			return TRUE;
 		}
 #ifdef AGGREGATION_SUPPORT
-		if (TxRate >= RATE_6 && pAd->CommonCfg.bAggregationCapable && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	// legacy  Ralink Aggregation support
+		if (TxRate >= RATE_6 && pAd->CommonCfg.bAggregationCapable && (!(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && CLIENT_STATUS_TEST_FLAG(pMacEntry, fCLIENT_STATUS_WMM_CAPABLE)))) {	/* legacy  Ralink Aggregation support */
 			return TRUE;
 		}
-#endif // AGGREGATION_SUPPORT //
+#endif /* AGGREGATION_SUPPORT // */
 	}
 
 	return FALSE;
@@ -1273,9 +1273,9 @@ PQUEUE_HEADER RTMPCheckTxSwQueue(IN PRTMP_ADAPTER pAd, OUT PUCHAR pQueIdx)
 {
 
 	ULONG Number;
-	// 2004-11-15 to be removed. test aggregation only
-//      if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)) && (*pNumber < 2))
-//               return NULL;
+	/* 2004-11-15 to be removed. test aggregation only */
+/*      if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)) && (*pNumber < 2)) */
+/*               return NULL; */
 
 	Number = pAd->TxSwQueue[QID_AC_BK].Number
 	    + pAd->TxSwQueue[QID_AC_BE].Number
@@ -1295,7 +1295,7 @@ PQUEUE_HEADER RTMPCheckTxSwQueue(IN PRTMP_ADAPTER pAd, OUT PUCHAR pQueIdx)
 		*pQueIdx = QID_AC_BK;
 		return (&pAd->TxSwQueue[QID_AC_BK]);
 	}
-	// No packet pending in Tx Sw queue
+	/* No packet pending in Tx Sw queue */
 	*pQueIdx = QID_AC_BK;
 
 	return (NULL);
@@ -1321,19 +1321,19 @@ VOID RTMPSuspendMsduTransmission(IN PRTMP_ADAPTER pAd)
 {
 	DBGPRINT(RT_DEBUG_TRACE, ("SCANNING, suspend MSDU transmission ...\n"));
 
-	//
-	// Before BSS_SCAN_IN_PROGRESS, we need to keep Current R66 value and
-	// use Lowbound as R66 value on ScanNextChannel(...)
-	//
+	/* */
+	/* Before BSS_SCAN_IN_PROGRESS, we need to keep Current R66 value and */
+	/* use Lowbound as R66 value on ScanNextChannel(...) */
+	/* */
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66,
 				    &pAd->BbpTuning.R66CurrentValue);
 
-	// set BBP_R66 to 0x30/0x40 when scanning (AsicSwitchChannel will set R66 according to channel when scanning)
-	//RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x26 + GET_LNA_GAIN(pAd)));
+	/* set BBP_R66 to 0x30/0x40 when scanning (AsicSwitchChannel will set R66 according to channel when scanning) */
+	/*RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, (0x26 + GET_LNA_GAIN(pAd))); */
 	RTMPSetAGCInitValue(pAd, BW_20);
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-	//RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x000f0000);                // abort all TX rings
+	/*RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x000f0000);                // abort all TX rings */
 }
 
 /*
@@ -1356,12 +1356,12 @@ VOID RTMPSuspendMsduTransmission(IN PRTMP_ADAPTER pAd)
 */
 VOID RTMPResumeMsduTransmission(IN PRTMP_ADAPTER pAd)
 {
-//    UCHAR                     IrqState;
+/*    UCHAR                     IrqState; */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("SCAN done, resume MSDU transmission ...\n"));
 
-	// After finish BSS_SCAN_IN_PROGRESS, we need to restore Current R66 value
-	// R66 should not be 0
+	/* After finish BSS_SCAN_IN_PROGRESS, we need to restore Current R66 value */
+	/* R66 should not be 0 */
 	if (pAd->BbpTuning.R66CurrentValue == 0) {
 		pAd->BbpTuning.R66CurrentValue = 0x38;
 		DBGPRINT_ERR(("RTMPResumeMsduTransmission, R66CurrentValue=0...\n"));
@@ -1371,11 +1371,11 @@ VOID RTMPResumeMsduTransmission(IN PRTMP_ADAPTER pAd)
 				     pAd->BbpTuning.R66CurrentValue);
 
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
-// sample, for IRQ LOCK to SEM LOCK
-//    IrqState = pAd->irq_disabled;
-//      if (IrqState)
-//              RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS);
-//    else
+/* sample, for IRQ LOCK to SEM LOCK */
+/*    IrqState = pAd->irq_disabled; */
+/*      if (IrqState) */
+/*              RTMPDeQueuePacket(pAd, TRUE, NUM_OF_TX_RING, MAX_TX_PROCESS); */
+/*    else */
 	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 }
 
@@ -1398,9 +1398,9 @@ UINT deaggregate_AMSDU_announce(IN PRTMP_ADAPTER pAd,
 
 		nMSDU++;
 
-		//hex_dump("subheader", pData, 64);
+		/*hex_dump("subheader", pData, 64); */
 		pAMSDUsubheader = (PHEADER_802_3) pData;
-		//pData += LENGTH_802_3;
+		/*pData += LENGTH_802_3; */
 		PayloadSize =
 		    pAMSDUsubheader->Octet[1] +
 		    (pAMSDUsubheader->Octet[0] << 8);
@@ -1409,13 +1409,13 @@ UINT deaggregate_AMSDU_announce(IN PRTMP_ADAPTER pAd,
 		if ((DataSize < SubFrameSize) || (PayloadSize > 1518)) {
 			break;
 		}
-		//DBGPRINT(RT_DEBUG_TRACE,("%d subframe: Size = %d\n",  nMSDU, PayloadSize));
+		/*DBGPRINT(RT_DEBUG_TRACE,("%d subframe: Size = %d\n",  nMSDU, PayloadSize)); */
 
 		pPayload = pData + LENGTH_802_3;
 		pDA = pData;
 		pSA = pData + MAC_ADDR_LEN;
 
-		// convert to 802.3 header
+		/* convert to 802.3 header */
 		CONVERT_TO_802_3(Header802_3, pDA, pSA, pPayload, PayloadSize,
 				 pRemovedLLCSNAP);
 
@@ -1431,7 +1431,7 @@ UINT deaggregate_AMSDU_announce(IN PRTMP_ADAPTER pAd,
 				Elem->MsgLen =
 				    LENGTH_802_11 + LENGTH_802_1_H +
 				    PayloadSize;
-				//WpaEAPOLKeyAction(pAd, Elem);
+				/*WpaEAPOLKeyAction(pAd, Elem); */
 				REPORT_MGMT_FRAME_TO_MLME(pAd, BSSID_WCID,
 							  Elem->Msg,
 							  Elem->MsgLen, 0, 0, 0,
@@ -1456,8 +1456,8 @@ UINT deaggregate_AMSDU_announce(IN PRTMP_ADAPTER pAd,
 							 (pPacket));
 		}
 
-		// A-MSDU has padding to multiple of 4 including subframe header.
-		// align SubFrameSize up to multiple of 4
+		/* A-MSDU has padding to multiple of 4 including subframe header. */
+		/* align SubFrameSize up to multiple of 4 */
 		SubFrameSize = (SubFrameSize + 3) & (~0x3);
 
 		if (SubFrameSize > 1528 || SubFrameSize < 32) {
@@ -1468,12 +1468,12 @@ UINT deaggregate_AMSDU_announce(IN PRTMP_ADAPTER pAd,
 			pData += SubFrameSize;
 			DataSize -= SubFrameSize;
 		} else {
-			// end of A-MSDU
+			/* end of A-MSDU */
 			DataSize = 0;
 		}
 	}
 
-	// finally release original rx packet
+	/* finally release original rx packet */
 	RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_SUCCESS);
 
 	return nMSDU;
@@ -1528,10 +1528,10 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
 	UCHAR HashIdx;
 	int i, FirstWcid;
 	MAC_TABLE_ENTRY *pEntry = NULL, *pCurrEntry;
-//      USHORT  offset;
-//      ULONG   addr;
+/*      USHORT  offset; */
+/*      ULONG   addr; */
 
-	// if FULL, return
+	/* if FULL, return */
 	if (pAd->MacTab.Size >= MAX_LEN_OF_MAC_TABLE)
 		return NULL;
 
@@ -1540,11 +1540,11 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
 	if (pAd->StaCfg.BssType == BSS_INFRA)
 		FirstWcid = 2;
 
-	// allocate one MAC entry
+	/* allocate one MAC entry */
 	NdisAcquireSpinLock(&pAd->MacTabLock);
-	for (i = FirstWcid; i < MAX_LEN_OF_MAC_TABLE; i++)	// skip entry#0 so that "entry index == AID" for fast lookup
+	for (i = FirstWcid; i < MAX_LEN_OF_MAC_TABLE; i++)	/* skip entry#0 so that "entry index == AID" for fast lookup */
 	{
-		// pick up the first available vacancy
+		/* pick up the first available vacancy */
 		if ((pAd->MacTab.Content[i].ValidAsCLI == FALSE) &&
 		    (pAd->MacTab.Content[i].ValidAsWDS == FALSE) &&
 		    (pAd->MacTab.Content[i].ValidAsApCli == FALSE) &&
@@ -1602,7 +1602,7 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
 								   pEntry->
 								   apidx,
 								   (UCHAR) i);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 				}
 			}
 
@@ -1615,7 +1615,7 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
 			COPY_MAC_ADDR(pEntry->Addr, pAddr);
 			pEntry->Sst = SST_NOT_AUTH;
 			pEntry->AuthState = AS_NOT_AUTH;
-			pEntry->Aid = (USHORT) i;	//0;
+			pEntry->Aid = (USHORT) i;	/*0; */
 			pEntry->CapabilityInfo = 0;
 			pEntry->PsMode = PWR_ACTIVE;
 			pEntry->PsQIdleCount = 0;
@@ -1625,7 +1625,7 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
 			InitializeQueueHeader(&pEntry->PsQueue);
 
 			pAd->MacTab.Size++;
-			// Add this entry into ASIC RX WCID search table
+			/* Add this entry into ASIC RX WCID search table */
 			RTMP_STA_ENTRY_ADD(pAd, pEntry);
 
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -1635,7 +1635,7 @@ MAC_TABLE_ENTRY *MacTableInsertEntry(IN PRTMP_ADAPTER pAd,
 		}
 	}
 
-	// add this MAC entry into HASH table
+	/* add this MAC entry into HASH table */
 	if (pEntry) {
 		HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
 		if (pAd->MacTab.Hash[HashIdx] == NULL) {
@@ -1664,8 +1664,8 @@ BOOLEAN MacTableDeleteEntry(IN PRTMP_ADAPTER pAd,
 	USHORT HashIdx;
 	MAC_TABLE_ENTRY *pEntry, *pPrevEntry, *pProbeEntry;
 	BOOLEAN Cancelled;
-	//USHORT        offset; // unused variable
-	//UCHAR j;                      // unused variable
+	/*USHORT        offset; // unused variable */
+	/*UCHAR j;                      // unused variable */
 
 	if (wcid >= MAX_LEN_OF_MAC_TABLE)
 		return FALSE;
@@ -1673,7 +1673,7 @@ BOOLEAN MacTableDeleteEntry(IN PRTMP_ADAPTER pAd,
 	NdisAcquireSpinLock(&pAd->MacTabLock);
 
 	HashIdx = MAC_ADDR_HASH_INDEX(pAddr);
-	//pEntry = pAd->MacTab.Hash[HashIdx];
+	/*pEntry = pAd->MacTab.Hash[HashIdx]; */
 	pEntry = &pAd->MacTab.Content[wcid];
 
 	if (pEntry
@@ -1681,17 +1681,17 @@ BOOLEAN MacTableDeleteEntry(IN PRTMP_ADAPTER pAd,
 		|| pEntry->ValidAsMesh)) {
 		if (MAC_ADDR_EQUAL(pEntry->Addr, pAddr)) {
 
-			// Delete this entry from ASIC on-chip WCID Table
+			/* Delete this entry from ASIC on-chip WCID Table */
 			RTMP_STA_ENTRY_MAC_RESET(pAd, wcid);
 
-			// free resources of BA
+			/* free resources of BA */
 			BASessionTearDownALL(pAd, pEntry->Aid);
 
 			pPrevEntry = NULL;
 			pProbeEntry = pAd->MacTab.Hash[HashIdx];
 			ASSERT(pProbeEntry);
 
-			// update Hash list
+			/* update Hash list */
 			do {
 				if (pProbeEntry == pEntry) {
 					if (pPrevEntry == NULL) {
@@ -1708,7 +1708,7 @@ BOOLEAN MacTableDeleteEntry(IN PRTMP_ADAPTER pAd,
 				pProbeEntry = pProbeEntry->pNext;
 			} while (pProbeEntry);
 
-			// not found !!!
+			/* not found !!! */
 			ASSERT(pProbeEntry != NULL);
 
 			RTMP_STA_ENTRY_KEY_DEL(pAd, BSS0, wcid);
@@ -1736,11 +1736,10 @@ BOOLEAN MacTableDeleteEntry(IN PRTMP_ADAPTER pAd,
 
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
-	//Reset operating mode when no Sta.
+	/*Reset operating mode when no Sta. */
 	if (pAd->MacTab.Size == 0) {
 		pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode = 0;
-		//AsicUpdateProtect(pAd, 0 /*pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode*/, (ALLN_SETPROTECT), TRUE, 0 /*pAd->MacTab.fAnyStationNonGF*/);
-		RTMP_UPDATE_PROTECT(pAd);	// edit by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet
+		RTMP_UPDATE_PROTECT(pAd);	/* edit by johnli, fix "in_interrupt" error when call "MacTableDeleteEntry" in Rx tasklet */
 	}
 
 	return TRUE;
@@ -1758,15 +1757,15 @@ VOID MacTableReset(IN PRTMP_ADAPTER pAd)
 	int i;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("MacTableReset\n"));
-	//NdisAcquireSpinLock(&pAd->MacTabLock);
+	/*NdisAcquireSpinLock(&pAd->MacTabLock); */
 
 	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 #ifdef RTMP_MAC_PCI
 		RTMP_STA_ENTRY_MAC_RESET(pAd, i);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE) {
 
-			// free resources of BA
+			/* free resources of BA */
 			BASessionTearDownALL(pAd, i);
 
 			pAd->MacTab.Content[i].ValidAsCLI = FALSE;
@@ -1774,9 +1773,9 @@ VOID MacTableReset(IN PRTMP_ADAPTER pAd)
 #ifdef RTMP_MAC_USB
 			NdisZeroMemory(pAd->MacTab.Content[i].Addr, 6);
 			RTMP_STA_ENTRY_MAC_RESET(pAd, i);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-			//AsicDelWcidTab(pAd, i);
+			/*AsicDelWcidTab(pAd, i); */
 		}
 	}
 
@@ -1798,8 +1797,8 @@ VOID AssocParmFill(IN PRTMP_ADAPTER pAd,
 		   IN ULONG Timeout, IN USHORT ListenIntv)
 {
 	COPY_MAC_ADDR(AssocReq->Addr, pAddr);
-	// Add mask to support 802.11b mode only
-	AssocReq->CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;	// not cf-pollable, not cf-poll-request
+	/* Add mask to support 802.11b mode only */
+	AssocReq->CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;	/* not cf-pollable, not cf-poll-request */
 	AssocReq->Timeout = Timeout;
 	AssocReq->ListenIntv = ListenIntv;
 }
@@ -1874,9 +1873,9 @@ BOOLEAN RTMPCheckDHCPFrame(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 	pSrc = (PUCHAR) pVirtualAddress;
 	Protocol = *(pSrc + 12) * 256 + *(pSrc + 13);
 
-	//
-	// Check DHCP & BOOTP protocol
-	//
+	/* */
+	/* Check DHCP & BOOTP protocol */
+	/* */
 	while (NumberOfBytesRead <= PacketInfo.TotalPacketLength) {
 		if ((NumberOfBytesRead >= 35) && (ReadFirstParm == TRUE)) {
 			CurrentOffset =
@@ -1889,19 +1888,19 @@ BOOLEAN RTMPCheckDHCPFrame(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 			CurrentOffset =
 			    37 - (NumberOfBytesRead - NdisBufferLength);
 			ByteOffset38 = *(pSrc + CurrentOffset);
-			//End of Read
+			/*End of Read */
 			break;
 		}
 		return FALSE;
 	}
 
-	// Check for DHCP & BOOTP protocol
+	/* Check for DHCP & BOOTP protocol */
 	if ((ByteOffset36 != 0x44) || (ByteOffset38 != 0x43)) {
-		//
-		// 2054 (hex 0806) for ARP datagrams
-		// if this packet is not ARP datagrams, then do nothing
-		// ARP datagrams will also be duplicate at 1mb broadcast frames
-		//
+		/* */
+		/* 2054 (hex 0806) for ARP datagrams */
+		/* if this packet is not ARP datagrams, then do nothing */
+		/* ARP datagrams will also be duplicate at 1mb broadcast frames */
+		/* */
 		if (Protocol != 0x0806)
 			return FALSE;
 	}
@@ -1925,12 +1924,12 @@ BOOLEAN RTMPCheckEtherType(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 
 	RTMP_SET_PACKET_SPECIFIC(pPacket, 0);
 
-	// get Ethernet protocol field
+	/* get Ethernet protocol field */
 	TypeLen = (pSrcBuf[12] << 8) | pSrcBuf[13];
 
-	pSrcBuf += LENGTH_802_3;	// Skip the Ethernet Header.
+	pSrcBuf += LENGTH_802_3;	/* Skip the Ethernet Header. */
 
-	if (TypeLen <= 1500) {	// 802.3, 802.3 LLC
+	if (TypeLen <= 1500) {	/* 802.3, 802.3 LLC */
 		/*
 		   DestMAC(6) + SrcMAC(6) + Lenght(2) +
 		   DSAP(1) + SSAP(1) + Control(1) +
@@ -1943,12 +1942,12 @@ BOOLEAN RTMPCheckEtherType(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 						  &Byte0, &Byte1);
 			RTMP_SET_PACKET_LLCSNAP(pPacket, 1);
 			TypeLen = (USHORT) ((Byte0 << 8) + Byte1);
-			pSrcBuf += 8;	// Skip this LLC/SNAP header
+			pSrcBuf += 8;	/* Skip this LLC/SNAP header */
 		} else {
-			//It just has 3-byte LLC header, maybe a legacy ether type frame. we didn't handle it.
+			/*It just has 3-byte LLC header, maybe a legacy ether type frame. we didn't handle it. */
 		}
 	}
-	// If it's a VLAN packet, get the real Type/Length field.
+	/* If it's a VLAN packet, get the real Type/Length field. */
 	if (TypeLen == 0x8100) {
 		/* 0x8100 means VLAN packets */
 
@@ -1966,17 +1965,17 @@ BOOLEAN RTMPCheckEtherType(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 					  &Byte1);
 		TypeLen = (USHORT) ((Byte0 << 8) + Byte1);
 
-		pSrcBuf += 4;	// Skip the VLAN Header.
+		pSrcBuf += 4;	/* Skip the VLAN Header. */
 	}
 
 	switch (TypeLen) {
 	case 0x0800:
 		{
 			ASSERT((pktLen > 34));
-			if (*(pSrcBuf + 9) == 0x11) {	// udp packet
-				ASSERT((pktLen > 34));	// 14 for ethernet header, 20 for IP header
+			if (*(pSrcBuf + 9) == 0x11) {	/* udp packet */
+				ASSERT((pktLen > 34));	/* 14 for ethernet header, 20 for IP header */
 
-				pSrcBuf += 20;	// Skip the IP header
+				pSrcBuf += 20;	/* Skip the IP header */
 				srcPort =
 				    OS_NTOHS(get_unaligned
 					     ((PUINT16) (pSrcBuf)));
@@ -1984,7 +1983,7 @@ BOOLEAN RTMPCheckEtherType(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 				    OS_NTOHS(get_unaligned
 					     ((PUINT16) (pSrcBuf + 2)));
 
-				if ((srcPort == 0x44 && dstPort == 0x43) || (srcPort == 0x43 && dstPort == 0x44)) {	//It's a BOOTP/DHCP packet
+				if ((srcPort == 0x44 && dstPort == 0x43) || (srcPort == 0x43 && dstPort == 0x44)) {	/*It's a BOOTP/DHCP packet */
 					RTMP_SET_PACKET_DHCP(pPacket, 1);
 				}
 			}
@@ -1992,13 +1991,13 @@ BOOLEAN RTMPCheckEtherType(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		break;
 	case 0x0806:
 		{
-			//ARP Packet.
+			/*ARP Packet. */
 			RTMP_SET_PACKET_DHCP(pPacket, 1);
 		}
 		break;
 	case 0x888e:
 		{
-			// EAPOL Packet.
+			/* EAPOL Packet. */
 			RTMP_SET_PACKET_EAPOL(pPacket, 1);
 		}
 		break;
@@ -2040,22 +2039,22 @@ VOID Update_Rssi_Sample(IN PRTMP_ADAPTER pAd,
 	}
 }
 
-// Normal legacy Rx packet indication
+/* Normal legacy Rx packet indication */
 VOID Indicate_Legacy_Packet(IN PRTMP_ADAPTER pAd,
 			    IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
 	PNDIS_PACKET pRxPacket = pRxBlk->pRxPacket;
 	UCHAR Header802_3[LENGTH_802_3];
 
-	// 1. get 802.3 Header
-	// 2. remove LLC
-	//              a. pointer pRxBlk->pData to payload
-	//      b. modify pRxBlk->DataSize
+	/* 1. get 802.3 Header */
+	/* 2. remove LLC */
+	/*              a. pointer pRxBlk->pData to payload */
+	/*      b. modify pRxBlk->DataSize */
 	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
 
 	if (pRxBlk->DataSize > MAX_RX_PKT_LEN) {
 
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
 		return;
 	}
@@ -2070,13 +2069,13 @@ VOID Indicate_Legacy_Packet(IN PRTMP_ADAPTER pAd,
 		UCHAR TID = pRxBlk->pRxWI->TID;
 		USHORT Idx;
 
-#define REORDERING_PACKET_TIMEOUT		((100 * OS_HZ)/1000)	// system ticks -- 100 ms
+#define REORDERING_PACKET_TIMEOUT		((100 * OS_HZ)/1000)	/* system ticks -- 100 ms */
 
 		if (Wcid < MAX_LEN_OF_MAC_TABLE) {
 			Idx = pAd->MacTab.Content[Wcid].BARecWcidArray[TID];
 			if (Idx != 0) {
 				pBAEntry = &pAd->BATable.BARecEntry[Idx];
-				// update last rx time
+				/* update last rx time */
 				NdisGetSystemUpTime(&Now32);
 				if ((pBAEntry->list.qlen > 0) &&
 				    RTMP_TIME_AFTER((unsigned long)Now32,
@@ -2101,17 +2100,17 @@ VOID Indicate_Legacy_Packet(IN PRTMP_ADAPTER pAd,
 			}
 		}
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 	wlan_802_11_to_802_3_packet(pAd, pRxBlk, Header802_3, FromWhichBSSID);
 
-	//
-	// pass this 802.3 packet to upper layer or forward this packet to WM directly
-	//
+	/* */
+	/* pass this 802.3 packet to upper layer or forward this packet to WM directly */
+	/* */
 	ANNOUNCE_OR_FORWARD_802_3_PACKET(pAd, pRxPacket, FromWhichBSSID);
 }
 
-// Normal, AMPDU or AMSDU
+/* Normal, AMPDU or AMSDU */
 VOID CmmRxnonRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
 				 IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
@@ -2120,7 +2119,7 @@ VOID CmmRxnonRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
 		Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
 	} else {
 		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMSDU)) {
-			// handle A-MSDU
+			/* handle A-MSDU */
 			Indicate_AMSDU_Packet(pAd, pRxBlk, FromWhichBSSID);
 		} else {
 			Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
@@ -2145,18 +2144,18 @@ VOID CmmRxRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
 		pRxBlk->pData += 2;
 		pRxBlk->DataSize -= 2;
 	} else {
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 		return;
 	}
 
-	// get 802.3 Header and  remove LLC
+	/* get 802.3 Header and  remove LLC */
 	RTMP_802_11_REMOVE_LLC_AND_CONVERT_TO_802_3(pRxBlk, Header802_3);
 
 	ASSERT(pRxBlk->pRxPacket);
 
-	// Ralink Aggregation frame
+	/* Ralink Aggregation frame */
 	pAd->RalinkCounters.OneSecRxAggregationCount++;
 	Payload1Size = pRxBlk->DataSize - Msdu2Size;
 	Payload2Size = Msdu2Size - LENGTH_802_3;
@@ -2168,12 +2167,12 @@ VOID CmmRxRalinkFrameIndicate(IN PRTMP_ADAPTER pAd,
 			  Payload2Size, FromWhichBSSID);
 
 	if (!pPacket2) {
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 		return;
 	}
-	// update payload size of 1st packet
+	/* update payload size of 1st packet */
 	pRxBlk->DataSize = Payload1Size;
 	wlan_802_11_to_802_3_packet(pAd, pRxBlk, Header802_3, FromWhichBSSID);
 
@@ -2208,10 +2207,10 @@ PNDIS_PACKET RTMPDeFragmentDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 
 	HeaderRoom = pData - (UCHAR *) pHeader;
 
-	// Re-assemble the fragmented packets
-	if (pHeader->Frag == 0)	// Frag. Number is 0 : First frag or only one pkt
+	/* Re-assemble the fragmented packets */
+	if (pHeader->Frag == 0)	/* Frag. Number is 0 : First frag or only one pkt */
 	{
-		// the first pkt of fragment, record it.
+		/* the first pkt of fragment, record it. */
 		if (pHeader->FC.MoreFrag) {
 			ASSERT(pAd->FragFrame.pFragPacket);
 			pFragBuffer =
@@ -2220,67 +2219,67 @@ PNDIS_PACKET RTMPDeFragmentDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 			NdisMoveMemory(pFragBuffer, pHeader,
 				       pAd->FragFrame.RxSize);
 			pAd->FragFrame.Sequence = pHeader->Sequence;
-			pAd->FragFrame.LastFrag = pHeader->Frag;	// Should be 0
+			pAd->FragFrame.LastFrag = pHeader->Frag;	/* Should be 0 */
 			ASSERT(pAd->FragFrame.LastFrag == 0);
-			goto done;	// end of processing this frame
+			goto done;	/* end of processing this frame */
 		}
-	} else			//Middle & End of fragment
+	} else			/*Middle & End of fragment */
 	{
 		if ((pHeader->Sequence != pAd->FragFrame.Sequence) ||
 		    (pHeader->Frag != (pAd->FragFrame.LastFrag + 1))) {
-			// Fragment is not the same sequence or out of fragment number order
-			// Reset Fragment control blk
+			/* Fragment is not the same sequence or out of fragment number order */
+			/* Reset Fragment control blk */
 			RESET_FRAGFRAME(pAd->FragFrame);
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("Fragment is not the same sequence or out of fragment number order.\n"));
-			goto done;	// give up this frame
+			goto done;	/* give up this frame */
 		} else if ((pAd->FragFrame.RxSize + DataSize) > MAX_FRAME_SIZE) {
-			// Fragment frame is too large, it exeeds the maximum frame size.
-			// Reset Fragment control blk
+			/* Fragment frame is too large, it exeeds the maximum frame size. */
+			/* Reset Fragment control blk */
 			RESET_FRAGFRAME(pAd->FragFrame);
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("Fragment frame is too large, it exeeds the maximum frame size.\n"));
-			goto done;	// give up this frame
+			goto done;	/* give up this frame */
 		}
-		//
-		// Broadcom AP(BCM94704AGR) will send out LLC in fragment's packet, LLC only can accpet at first fragment.
-		// In this case, we will dropt it.
-		//
+		/* */
+		/* Broadcom AP(BCM94704AGR) will send out LLC in fragment's packet, LLC only can accpet at first fragment. */
+		/* In this case, we will dropt it. */
+		/* */
 		if (NdisEqualMemory(pData, SNAP_802_1H, sizeof(SNAP_802_1H))) {
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("Find another LLC at Middle or End fragment(SN=%d, Frag=%d)\n",
 				  pHeader->Sequence, pHeader->Frag));
-			goto done;	// give up this frame
+			goto done;	/* give up this frame */
 		}
 
 		pFragBuffer = GET_OS_PKT_DATAPTR(pAd->FragFrame.pFragPacket);
 
-		// concatenate this fragment into the re-assembly buffer
+		/* concatenate this fragment into the re-assembly buffer */
 		NdisMoveMemory((pFragBuffer + pAd->FragFrame.RxSize), pData,
 			       DataSize);
 		pAd->FragFrame.RxSize += DataSize;
-		pAd->FragFrame.LastFrag = pHeader->Frag;	// Update fragment number
+		pAd->FragFrame.LastFrag = pHeader->Frag;	/* Update fragment number */
 
-		// Last fragment
+		/* Last fragment */
 		if (pHeader->FC.MoreFrag == FALSE) {
 			bReassDone = TRUE;
 		}
 	}
 
 done:
-	// always release rx fragmented packet
+	/* always release rx fragmented packet */
 	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
 
-	// return defragmented packet if packet is reassembled completely
-	// otherwise return NULL
+	/* return defragmented packet if packet is reassembled completely */
+	/* otherwise return NULL */
 	if (bReassDone) {
 		PNDIS_PACKET pNewFragPacket;
 
-		// allocate a new packet buffer for fragment
+		/* allocate a new packet buffer for fragment */
 		pNewFragPacket =
 		    RTMP_AllocateFragPacketBuffer(pAd, RX_BUFFER_NORMSIZE);
 		if (pNewFragPacket) {
-			// update RxBlk
+			/* update RxBlk */
 			pRetPacket = pAd->FragFrame.pFragPacket;
 			pAd->FragFrame.pFragPacket = pNewFragPacket;
 			pRxBlk->pHeader =
@@ -2322,14 +2321,14 @@ VOID Indicate_EAPOL_Packet(IN PRTMP_ADAPTER pAd,
 	if (pEntry == NULL) {
 		DBGPRINT(RT_DEBUG_WARN,
 			 ("Indicate_EAPOL_Packet: drop and release the invalid packet.\n"));
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 		return;
 	}
 }
 
-#define BCN_TBTT_OFFSET		64	//defer 64 us
+#define BCN_TBTT_OFFSET		64	/*defer 64 us */
 VOID ReSyncBeaconTime(IN PRTMP_ADAPTER pAd)
 {
 
@@ -2339,21 +2338,21 @@ VOID ReSyncBeaconTime(IN PRTMP_ADAPTER pAd)
 
 	pAd->TbttTickCount++;
 
-	//
-	// The updated BeaconInterval Value will affect Beacon Interval after two TBTT
-	// beacasue the original BeaconInterval had been loaded into next TBTT_TIMER
-	//
+	/* */
+	/* The updated BeaconInterval Value will affect Beacon Interval after two TBTT */
+	/* beacasue the original BeaconInterval had been loaded into next TBTT_TIMER */
+	/* */
 	if (Offset == (BCN_TBTT_OFFSET - 2)) {
 		BCN_TIME_CFG_STRUC csr;
 		RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-		csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod << 4) - 1;	// ASIC register in units of 1/16 TU = 64us
+		csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod << 4) - 1;	/* ASIC register in units of 1/16 TU = 64us */
 		RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
 	} else {
 		if (Offset == (BCN_TBTT_OFFSET - 1)) {
 			BCN_TIME_CFG_STRUC csr;
 
 			RTMP_IO_READ32(pAd, BCN_TIME_CFG, &csr.word);
-			csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod) << 4;	// ASIC register in units of 1/16 TU
+			csr.field.BeaconInterval = (pAd->CommonCfg.BeaconPeriod) << 4;	/* ASIC register in units of 1/16 TU */
 			RTMP_IO_WRITE32(pAd, BCN_TIME_CFG, csr.word);
 		}
 	}
diff --git a/drivers/staging/rt2860/common/cmm_data_pci.c b/drivers/staging/rt2860/common/cmm_data_pci.c
index f98f1a8..157ebc6 100644
--- a/drivers/staging/rt2860/common/cmm_data_pci.c
+++ b/drivers/staging/rt2860/common/cmm_data_pci.c
@@ -44,23 +44,23 @@ USHORT RtmpPCI_WriteTxResource(IN PRTMP_ADAPTER pAd,
 	PRTMP_TX_RING pTxRing;
 	USHORT hwHeaderLen;
 
-	//
-	// get Tx Ring Resource
-	//
+	/* */
+	/* get Tx Ring Resource */
+	/* */
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
 	BufBasePaLow =
 	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
-	// copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
+	/* copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
 	if (pTxBlk->TxFrameType == TX_AMSDU_FRAME) {
-		//hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD;
+		/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD; */
 		hwHeaderLen =
 		    pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD +
 		    pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
 	} else {
-		//hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
+		/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
 		hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 	}
 	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf,
@@ -69,15 +69,15 @@ USHORT RtmpPCI_WriteTxResource(IN PRTMP_ADAPTER pAd,
 	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
 	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
 
-	//
-	// build Tx Descriptor
-	//
+	/* */
+	/* build Tx Descriptor */
+	/* */
 
 	pTxD = (PTXD_STRUC) pTxRing->Cell[TxIdx].AllocVa;
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	// include padding
+	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	/* include padding */
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -86,9 +86,9 @@ USHORT RtmpPCI_WriteTxResource(IN PRTMP_ADAPTER pAd,
 	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
 
 	RetTxIdx = TxIdx;
-	//
-	// Update Tx index
-	//
+	/* */
+	/* Update Tx index */
+	/* */
 	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
 	pTxRing->TxCpuIdx = TxIdx;
 
@@ -110,17 +110,17 @@ USHORT RtmpPCI_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 	PRTMP_TX_RING pTxRing;
 	USHORT hwHeaderLen;
 
-	//
-	// get Tx Ring Resource
-	//
+	/* */
+	/* get Tx Ring Resource */
+	/* */
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
 	BufBasePaLow =
 	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
-	// copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
-	//hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
+	/* copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
+	/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
 	hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
 	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf,
@@ -129,14 +129,14 @@ USHORT RtmpPCI_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
 	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
 
-	//
-	// build Tx Descriptor
-	//
+	/* */
+	/* build Tx Descriptor */
+	/* */
 	pTxD = (PTXD_STRUC) pTxRing->Cell[TxIdx].AllocVa;
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	// include padding
+	pTxD->SDLen0 = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;	/* include padding */
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);;
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -145,9 +145,9 @@ USHORT RtmpPCI_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
 
 	RetTxIdx = TxIdx;
-	//
-	// Update Tx index
-	//
+	/* */
+	/* Update Tx index */
+	/* */
 	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
 	pTxRing->TxCpuIdx = TxIdx;
 
@@ -171,9 +171,9 @@ USHORT RtmpPCI_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 
 	bIsLast = ((frameNum == (pTxBlk->TotalFrameNum - 1)) ? 1 : 0);
 
-	//
-	// get Tx Ring Resource
-	//
+	/* */
+	/* get Tx Ring Resource */
+	/* */
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
@@ -181,20 +181,20 @@ USHORT RtmpPCI_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
 	if (frameNum == 0) {
-		// copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
+		/* copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
 		if (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
-			//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD;
+			/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD; */
 			hwHdrLen =
 			    pTxBlk->MpduHeaderLen - LENGTH_AMSDU_SUBFRAMEHEAD +
 			    pTxBlk->HdrPadLen + LENGTH_AMSDU_SUBFRAMEHEAD;
 		else if (pTxBlk->TxFrameType == TX_RALINK_FRAME)
-			//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD;
+			/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD; */
 			hwHdrLen =
 			    pTxBlk->MpduHeaderLen -
 			    LENGTH_ARALINK_HEADER_FIELD + pTxBlk->HdrPadLen +
 			    LENGTH_ARALINK_HEADER_FIELD;
 		else
-			//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
+			/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
 			hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
 		firstDMALen = TXINFO_SIZE + TXWI_SIZE + hwHdrLen;
@@ -207,14 +207,14 @@ USHORT RtmpPCI_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 	pTxRing->Cell[TxIdx].pNdisPacket = pTxBlk->pPacket;
 	pTxRing->Cell[TxIdx].pNextNdisPacket = NULL;
 
-	//
-	// build Tx Descriptor
-	//
+	/* */
+	/* build Tx Descriptor */
+	/* */
 	pTxD = (PTXD_STRUC) pTxRing->Cell[TxIdx].AllocVa;
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = firstDMALen;	// include padding
+	pTxD->SDLen0 = firstDMALen;	/* include padding */
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);;
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -223,9 +223,9 @@ USHORT RtmpPCI_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 	RTMPWriteTxDescriptor(pAd, pTxD, FALSE, FIFO_EDCA);
 
 	RetTxIdx = TxIdx;
-	//
-	// Update Tx index
-	//
+	/* */
+	/* Update Tx index */
+	/* */
 	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
 	pTxRing->TxCpuIdx = TxIdx;
 
@@ -243,9 +243,9 @@ VOID RtmpPCI_FinalWriteTxResource(IN PRTMP_ADAPTER pAd,
 	PTXWI_STRUC pTxWI;
 	PRTMP_TX_RING pTxRing;
 
-	//
-	// get Tx Ring Resource
-	//
+	/* */
+	/* get Tx Ring Resource */
+	/* */
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	pTxWI = (PTXWI_STRUC) pTxRing->Cell[FirstTxIdx].DmaBuf.AllocVa;
 	pTxWI->MPDUtotalByteCount = totalMPDUSize;
@@ -258,14 +258,14 @@ VOID RtmpPCIDataLastTxIdx(IN PRTMP_ADAPTER pAd,
 	PTXD_STRUC pTxD;
 	PRTMP_TX_RING pTxRing;
 
-	//
-	// get Tx Ring Resource
-	//
+	/* */
+	/* get Tx Ring Resource */
+	/* */
 	pTxRing = &pAd->TxRing[QueIdx];
 
-	//
-	// build Tx Descriptor
-	//
+	/* */
+	/* build Tx Descriptor */
+	/* */
 	pTxD = (PTXD_STRUC) pTxRing->Cell[LastTxIdx].AllocVa;
 
 	pTxD->LastSec1 = 1;
@@ -284,27 +284,27 @@ USHORT RtmpPCI_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 	USHORT hwHeaderLen;
 	UINT32 firstDMALen;
 
-	//
-	// Get Tx Ring Resource
-	//
+	/* */
+	/* Get Tx Ring Resource */
+	/* */
 	pTxRing = &pAd->TxRing[pTxBlk->QueIdx];
 	TxIdx = pAd->TxRing[pTxBlk->QueIdx].TxCpuIdx;
 	pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
 	BufBasePaLow =
 	    RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 
-	//
-	// Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
-	//
-	//hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
+	/* */
+	/* Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
+	/* */
+	/*hwHeaderLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
 	hwHeaderLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
 	firstDMALen = TXINFO_SIZE + TXWI_SIZE + hwHeaderLen;
 	NdisMoveMemory(pDMAHeaderBufVA, pTxBlk->HeaderBuf, firstDMALen);
 
-	//
-	// Build Tx Descriptor
-	//
+	/* */
+	/* Build Tx Descriptor */
+	/* */
 	pTxD = (PTXD_STRUC) pTxRing->Cell[TxIdx].AllocVa;
 	NdisZeroMemory(pTxD, TXD_SIZE);
 
@@ -314,7 +314,7 @@ USHORT RtmpPCI_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 	}
 
 	pTxD->SDPtr0 = BufBasePaLow;
-	pTxD->SDLen0 = firstDMALen;	// include padding
+	pTxD->SDLen0 = firstDMALen;	/* include padding */
 	pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, pTxBlk, 0, 1, PCI_DMA_TODEVICE);
 	pTxD->SDLen1 = pTxBlk->SrcBufLen;
 	pTxD->LastSec0 = 0;
@@ -325,9 +325,9 @@ USHORT RtmpPCI_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 	RetTxIdx = TxIdx;
 	pTxBlk->Priv += pTxBlk->SrcBufLen;
 
-	//
-	// Update Tx index
-	//
+	/* */
+	/* Update Tx index */
+	/* */
 	INC_RING_INDEX(TxIdx, TX_RING_SIZE);
 	pTxRing->TxCpuIdx = TxIdx;
 
@@ -363,7 +363,7 @@ int RtmpPCIMgmtKickOut(IN RTMP_ADAPTER * pAd,
 	    PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
 	pTxD->SDLen0 = SrcBufLen;
 
-//==================================================================
+/*================================================================== */
 /*	DBGPRINT_RAW(RT_DEBUG_TRACE, ("MLMEHardTransmit\n"));
 	for (i = 0; i < (TXWI_SIZE+24); i++)
 	{
@@ -375,12 +375,12 @@ int RtmpPCIMgmtKickOut(IN RTMP_ADAPTER * pAd,
 			DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n      "));
 	}
 	DBGPRINT_RAW(RT_DEBUG_TRACE, ("\n      "));*/
-//=======================================================================
+/*======================================================================= */
 
 	pAd->RalinkCounters.KickTxCount++;
 	pAd->RalinkCounters.OneSecTxDoneCount++;
 
-	// Increase TX_CTX_IDX, but write to register later.
+	/* Increase TX_CTX_IDX, but write to register later. */
 	INC_RING_INDEX(pAd->MgmtRing.TxCpuIdx, MGMT_RING_SIZE);
 
 	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
@@ -412,9 +412,9 @@ NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
 	PCIPHER_KEY pWpaKey;
 	INT dBm;
 
-	// Phy errors & CRC errors
+	/* Phy errors & CRC errors */
 	if ( /*(pRxD->PhyErr) || */ (pRxD->Crc)) {
-		// Check RSSI for Noise Hist statistic collection.
+		/* Check RSSI for Noise Hist statistic collection. */
 		dBm = (INT) (pRxWI->RSSI0) - pAd->BbpRssiToDbmDelta;
 		if (dBm <= -87)
 			pAd->StaCfg.RPIDensity[0] += 1;
@@ -435,21 +435,21 @@ NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
 
 		return (NDIS_STATUS_FAILURE);
 	}
-	// Add Rx size to channel load counter, we should ignore error counts
+	/* Add Rx size to channel load counter, we should ignore error counts */
 	pAd->StaCfg.CLBusyBytes += (pRxD->SDL0 + 14);
 
-	// Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics
+	/* Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics */
 	if (pHeader != NULL) {
 		if (pHeader->FC.ToDs) {
 			return (NDIS_STATUS_FAILURE);
 		}
 	}
-	// Drop not U2M frames, cant's drop here because we will drop beacon in this case
-	// I am kind of doubting the U2M bit operation
-	// if (pRxD->U2M == 0)
-	//      return(NDIS_STATUS_FAILURE);
+	/* Drop not U2M frames, cant's drop here because we will drop beacon in this case */
+	/* I am kind of doubting the U2M bit operation */
+	/* if (pRxD->U2M == 0) */
+	/*      return(NDIS_STATUS_FAILURE); */
 
-	// drop decyption fail frame
+	/* drop decyption fail frame */
 	if (pRxD->CipherErr) {
 		if (pRxD->CipherErr == 2) {
 			DBGPRINT_RAW(RT_DEBUG_TRACE,
@@ -471,12 +471,12 @@ NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
 			      pRxD->CipherErr, pRxD->SDL0,
 			      pRxD->Mcast | pRxD->Bcast, pRxD->MyBss,
 			      pRxWI->WirelessCliID,
-//                      CipherName[pRxD->CipherAlg],
+/*                      CipherName[pRxD->CipherAlg], */
 			      pRxWI->KeyIndex));
 
-		//
-		// MIC Error
-		//
+		/* */
+		/* MIC Error */
+		/* */
 		if (pRxD->CipherErr == 2) {
 			pWpaKey = &pAd->SharedKey[BSS0][pRxWI->KeyIndex];
 			if (pAd->StaCfg.WpaSupplicantUP)
@@ -523,7 +523,7 @@ BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx)
 	PNDIS_PACKET pPacket;
 	UCHAR FREE = 0;
 	TXD_STRUC TxD, *pOriTxD;
-	//ULONG         IrqFlags;
+	/*ULONG         IrqFlags; */
 	BOOLEAN bReschedule = FALSE;
 
 	ASSERT(QueIdx < NUM_OF_TX_RING);
@@ -532,10 +532,10 @@ BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx)
 	RTMP_IO_READ32(pAd, TX_DTX_IDX0 + QueIdx * RINGREG_DIFF,
 		       &pTxRing->TxDmaIdx);
 	while (pTxRing->TxSwFreeIdx != pTxRing->TxDmaIdx) {
-//              RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
+/*              RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags); */
 
-		// static rate also need NICUpdateFifoStaCounters() function.
-		//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED))
+		/* static rate also need NICUpdateFifoStaCounters() function. */
+		/*if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */
 		NICUpdateFifoStaCounters(pAd);
 
 		/* Note : If (pAd->ate.bQATxStart == TRUE), we will never reach here. */
@@ -558,7 +558,7 @@ BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx)
 				RELEASE_NDIS_PACKET(pAd, pPacket,
 						    NDIS_STATUS_SUCCESS);
 			}
-			//Always assign pNdisPacket as NULL after clear
+			/*Always assign pNdisPacket as NULL after clear */
 			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNdisPacket = NULL;
 
 			pPacket =
@@ -572,7 +572,7 @@ BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx)
 				RELEASE_NDIS_PACKET(pAd, pPacket,
 						    NDIS_STATUS_SUCCESS);
 			}
-			//Always assign pNextNdisPacket as NULL after clear
+			/*Always assign pNextNdisPacket as NULL after clear */
 			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket =
 			    NULL;
 		}
@@ -586,7 +586,7 @@ BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx)
 			       &pTxRing->TxDmaIdx);
 		NdisMoveMemory(pOriTxD, pTxD, sizeof(TXD_STRUC));
 
-//         RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
+/*         RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags); */
 	}
 
 	return bReschedule;
@@ -612,12 +612,12 @@ BOOLEAN RTMPFreeTXDUponTxDmaDone(IN PRTMP_ADAPTER pAd, IN UCHAR QueIdx)
 BOOLEAN RTMPHandleTxRingDmaDoneInterrupt(IN PRTMP_ADAPTER pAd,
 					 IN INT_SOURCE_CSR_STRUC TxRingBitmap)
 {
-//      UCHAR                   Count = 0;
+/*      UCHAR                   Count = 0; */
 	unsigned long IrqFlags;
 	BOOLEAN bReschedule = FALSE;
 
-	// Make sure Tx ring resource won't be used by other threads
-	//NdisAcquireSpinLock(&pAd->TxRingLock);
+	/* Make sure Tx ring resource won't be used by other threads */
+	/*NdisAcquireSpinLock(&pAd->TxRingLock); */
 
 	RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
 
@@ -633,11 +633,11 @@ BOOLEAN RTMPHandleTxRingDmaDoneInterrupt(IN PRTMP_ADAPTER pAd,
 	if (TxRingBitmap.field.Ac1DmaDone)
 		bReschedule |= RTMPFreeTXDUponTxDmaDone(pAd, QID_AC_BK);
 
-	// Make sure to release Tx ring resource
-	//NdisReleaseSpinLock(&pAd->TxRingLock);
+	/* Make sure to release Tx ring resource */
+	/*NdisReleaseSpinLock(&pAd->TxRingLock); */
 	RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
 
-	// Dequeue outgoing frames from TxSwQueue[] and process it
+	/* Dequeue outgoing frames from TxSwQueue[] and process it */
 	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 
 	return bReschedule;
@@ -665,7 +665,7 @@ VOID RTMPHandleMgmtRingDmaDoneInterrupt(IN PRTMP_ADAPTER pAd)
 {
 	PTXD_STRUC pTxD;
 	PNDIS_PACKET pPacket;
-//      int              i;
+/*      int              i; */
 	UCHAR FREE = 0;
 	PRTMP_MGMT_RING pMgmtRing = &pAd->MgmtRing;
 
@@ -789,15 +789,15 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 	RTMP_SEM_LOCK(&pAd->RxRingLock);
 
 	if (*pRxPending == 0) {
-		// Get how may packets had been received
+		/* Get how may packets had been received */
 		RTMP_IO_READ32(pAd, RX_DRX_IDX, &pAd->RxRing.RxDmaIdx);
 
 		if (pAd->RxRing.RxSwReadIdx == pAd->RxRing.RxDmaIdx) {
-			// no more rx packets
+			/* no more rx packets */
 			bReschedule = FALSE;
 			goto done;
 		}
-		// get rx pending count
+		/* get rx pending count */
 		if (pAd->RxRing.RxDmaIdx > pAd->RxRing.RxSwReadIdx)
 			*pRxPending =
 			    pAd->RxRing.RxDmaIdx - pAd->RxRing.RxSwReadIdx;
@@ -810,17 +810,17 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 
 	pRxCell = &pAd->RxRing.Cell[pAd->RxRing.RxSwReadIdx];
 
-	// Point to Rx indexed rx ring descriptor
+	/* Point to Rx indexed rx ring descriptor */
 	pRxD = (PRXD_STRUC) pRxCell->AllocVa;
 
 	if (pRxD->DDONE == 0) {
 		*pRxPending = 0;
-		// DMAIndx had done but DDONE bit not ready
+		/* DMAIndx had done but DDONE bit not ready */
 		bReschedule = TRUE;
 		goto done;
 	}
 
-	// return rx descriptor
+	/* return rx descriptor */
 	NdisMoveMemory(pSaveRxD, pRxD, RXD_SIZE);
 
 	pNewPacket =
@@ -828,7 +828,7 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 					&AllocVa, &AllocPa);
 
 	if (pNewPacket) {
-		// unmap the rx buffer
+		/* unmap the rx buffer */
 		PCI_UNMAP_SINGLE(pAd, pRxCell->DmaBuf.AllocPa,
 				 pRxCell->DmaBuf.AllocSize, PCI_DMA_FROMDEVICE);
 		pRxPacket = pRxCell->pNdisPacket;
@@ -840,17 +840,17 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 		/* update SDP0 to new buffer of rx packet */
 		pRxD->SDP0 = AllocPa;
 	} else {
-		//DBGPRINT(RT_DEBUG_TRACE,("No Rx Buffer\n"));
+		/*DBGPRINT(RT_DEBUG_TRACE,("No Rx Buffer\n")); */
 		pRxPacket = NULL;
 		bReschedule = TRUE;
 	}
 
 	pRxD->DDONE = 0;
 
-	// had handled one rx packet
+	/* had handled one rx packet */
 	*pRxPending = *pRxPending - 1;
 
-	// update rx descriptor and kick rx
+	/* update rx descriptor and kick rx */
 	INC_RING_INDEX(pAd->RxRing.RxSwReadIdx, RX_RING_SIZE);
 
 	pAd->RxRing.RxCpuIdx =
@@ -874,28 +874,28 @@ NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
 	PHEADER_802_11 pHeader_802_11;
 	BOOLEAN bAckRequired, bInsertTimestamp;
 	ULONG SrcBufPA;
-	//UCHAR                 TxBufIdx;
+	/*UCHAR                 TxBufIdx; */
 	UCHAR MlmeRate;
 	ULONG SwIdx = pAd->TxRing[QueIdx].TxCpuIdx;
 	PTXWI_STRUC pFirstTxWI;
-	//ULONG i;
-	//HTTRANSMIT_SETTING    MlmeTransmit;   //Rate for this MGMT frame.
+	/*ULONG i; */
+	/*HTTRANSMIT_SETTING    MlmeTransmit;   //Rate for this MGMT frame. */
 	ULONG FreeNum;
 	MAC_TABLE_ENTRY *pMacEntry = NULL;
 
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
 	if (pSrcBufVA == NULL) {
-		// The buffer shouldn't be NULL
+		/* The buffer shouldn't be NULL */
 		return NDIS_STATUS_FAILURE;
 	}
-	// Make sure MGMT ring resource won't be used by other threads
-	//NdisAcquireSpinLock(&pAd->TxRingLock);
+	/* Make sure MGMT ring resource won't be used by other threads */
+	/*NdisAcquireSpinLock(&pAd->TxRingLock); */
 
 	FreeNum = GET_TXRING_FREENO(pAd, QueIdx);
 
 	if (FreeNum == 0) {
-		//NdisReleaseSpinLock(&pAd->TxRingLock);
+		/*NdisReleaseSpinLock(&pAd->TxRingLock); */
 		return NDIS_STATUS_FAILURE;
 	}
 
@@ -905,13 +905,13 @@ NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
 
 	if (pAd->TxRing[QueIdx].Cell[SwIdx].pNdisPacket) {
 		DBGPRINT(RT_DEBUG_OFF, ("MlmeHardTransmit Error\n"));
-		//NdisReleaseSpinLock(&pAd->TxRingLock);
+		/*NdisReleaseSpinLock(&pAd->TxRingLock); */
 		return NDIS_STATUS_FAILURE;
 	}
 
 	{
-		// outgoing frame always wakeup PHY to prevent frame lost
-		// if (pAd->StaCfg.Psm == PWR_SAVE)
+		/* outgoing frame always wakeup PHY to prevent frame lost */
+		/* if (pAd->StaCfg.Psm == PWR_SAVE) */
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 			AsicForceWakeup(pAd, TRUE);
 	}
@@ -928,18 +928,18 @@ NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
 	    (pHeader_802_11->FC.SubType == SUBTYPE_QOS_NULL)) {
 		pMacEntry = MacTableLookup(pAd, pHeader_802_11->Addr1);
 	}
-	// Verify Mlme rate for a / g bands.
-	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	// 11A band
+	/* Verify Mlme rate for a / g bands. */
+	if ((pAd->LatchRfRegs.Channel > 14) && (MlmeRate < RATE_6))	/* 11A band */
 		MlmeRate = RATE_6;
 
-	//
-	// Should not be hard code to set PwrMgmt to 0 (PWR_ACTIVE)
-	// Snice it's been set to 0 while on MgtMacHeaderInit
-	// By the way this will cause frame to be send on PWR_SAVE failed.
-	//
-	//
-	// In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame
-	// Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD
+	/* */
+	/* Should not be hard code to set PwrMgmt to 0 (PWR_ACTIVE) */
+	/* Snice it's been set to 0 while on MgtMacHeaderInit */
+	/* By the way this will cause frame to be send on PWR_SAVE failed. */
+	/* */
+	/* */
+	/* In WMM-UAPSD, mlme frame should be set psm as power saving but probe request frame */
+	/* Data-Null packets alse pass through MMRequest in RT2860, however, we hope control the psm bit to pass APSD */
 	if (pHeader_802_11->FC.Type != BTYPE_DATA) {
 		if ((pHeader_802_11->FC.SubType == SUBTYPE_PROBE_REQ)
 		    || !(pAd->CommonCfg.bAPSDCapable
@@ -952,12 +952,12 @@ NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
 	}
 
 	bInsertTimestamp = FALSE;
-	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	// must be PS-POLL
+	if (pHeader_802_11->FC.Type == BTYPE_CNTL)	/* must be PS-POLL */
 	{
 		bAckRequired = FALSE;
-	} else			// BTYPE_MGMT or BTYPE_DATA(must be NULL frame)
+	} else			/* BTYPE_MGMT or BTYPE_DATA(must be NULL frame) */
 	{
-		if (pHeader_802_11->Addr1[0] & 0x01)	// MULTICAST, BROADCAST
+		if (pHeader_802_11->Addr1[0] & 0x01)	/* MULTICAST, BROADCAST */
 		{
 			bAckRequired = FALSE;
 			pHeader_802_11->Duration = 0;
@@ -973,29 +973,29 @@ NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
 	pHeader_802_11->Sequence = pAd->Sequence++;
 	if (pAd->Sequence > 0xfff)
 		pAd->Sequence = 0;
-	// Before radar detection done, mgmt frame can not be sent but probe req
-	// Because we need to use probe req to trigger driver to send probe req in passive scan
+	/* Before radar detection done, mgmt frame can not be sent but probe req */
+	/* Because we need to use probe req to trigger driver to send probe req in passive scan */
 	if ((pHeader_802_11->FC.SubType != SUBTYPE_PROBE_REQ)
 	    && (pAd->CommonCfg.bIEEE80211H == 1)
 	    && (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE)) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("MlmeHardTransmit --> radar detect not in normal mode !!!\n"));
-		//NdisReleaseSpinLock(&pAd->TxRingLock);
+		/*NdisReleaseSpinLock(&pAd->TxRingLock); */
 		return (NDIS_STATUS_FAILURE);
 	}
-	//
-	// fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET
-	// should always has only one ohysical buffer, and the whole frame size equals
-	// to the first scatter buffer size
-	//
-
-	// Initialize TX Descriptor
-	// For inter-frame gap, the number is for this frame and next frame
-	// For MLME rate, we will fix as 2Mb to match other vendor's implement
-//      pAd->CommonCfg.MlmeTransmit.field.MODE = 1;
-
-// management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not.
-	// Only beacon use Nseq=TRUE. So here we use Nseq=FALSE.
+	/* */
+	/* fill scatter-and-gather buffer list into TXD. Internally created NDIS PACKET */
+	/* should always has only one ohysical buffer, and the whole frame size equals */
+	/* to the first scatter buffer size */
+	/* */
+
+	/* Initialize TX Descriptor */
+	/* For inter-frame gap, the number is for this frame and next frame */
+	/* For MLME rate, we will fix as 2Mb to match other vendor's implement */
+/*      pAd->CommonCfg.MlmeTransmit.field.MODE = 1; */
+
+/* management frame doesn't need encryption. so use RESERVED_WCID no matter u are sending to specific wcid or not. */
+	/* Only beacon use Nseq=TRUE. So here we use Nseq=FALSE. */
 	if (pMacEntry == NULL) {
 		RTMPWriteTxWI(pAd, pFirstTxWI, FALSE, FALSE, bInsertTimestamp,
 			      FALSE, bAckRequired, FALSE, 0, RESERVED_WCID,
@@ -1013,7 +1013,7 @@ NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
 
 	pAd->TxRing[QueIdx].Cell[SwIdx].pNdisPacket = pPacket;
 	pAd->TxRing[QueIdx].Cell[SwIdx].pNextNdisPacket = NULL;
-//      pFirstTxWI->MPDUtotalByteCount = SrcBufLen - TXWI_SIZE;
+/*      pFirstTxWI->MPDUtotalByteCount = SrcBufLen - TXWI_SIZE; */
 	SrcBufPA =
 	    PCI_MAP_SINGLE(pAd, pSrcBufVA, SrcBufLen, 0, PCI_DMA_TODEVICE);
 
@@ -1028,14 +1028,14 @@ NDIS_STATUS MlmeHardTransmitTxRing(IN PRTMP_ADAPTER pAd,
 	pAd->RalinkCounters.KickTxCount++;
 	pAd->RalinkCounters.OneSecTxDoneCount++;
 
-	// Increase TX_CTX_IDX, but write to register later.
+	/* Increase TX_CTX_IDX, but write to register later. */
 	INC_RING_INDEX(pAd->TxRing[QueIdx].TxCpuIdx, TX_RING_SIZE);
 
 	RTMP_IO_WRITE32(pAd, TX_CTX_IDX0 + QueIdx * 0x10,
 			pAd->TxRing[QueIdx].TxCpuIdx);
 
-	// Make sure to release MGMT ring resource
-//      NdisReleaseSpinLock(&pAd->TxRingLock);
+	/* Make sure to release MGMT ring resource */
+/*      NdisReleaseSpinLock(&pAd->TxRingLock); */
 
 	return NDIS_STATUS_SUCCESS;
 }
@@ -1082,15 +1082,15 @@ VOID RTMPWriteTxDescriptor(IN PRTMP_ADAPTER pAd,
 			   IN PTXD_STRUC pTxD,
 			   IN BOOLEAN bWIV, IN UCHAR QueueSEL)
 {
-	//
-	// Always use Long preamble before verifiation short preamble functionality works well.
-	// Todo: remove the following line if short preamble functionality works
-	//
+	/* */
+	/* Always use Long preamble before verifiation short preamble functionality works well. */
+	/* Todo: remove the following line if short preamble functionality works */
+	/* */
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 
 	pTxD->WIV = (bWIV) ? 1 : 0;
 	pTxD->QSEL = (QueueSEL);
-	//RT2860c??  fixed using EDCA queue for test...  We doubt Queue1 has problem.  2006-09-26 Jan
-	//pTxD->QSEL= FIFO_EDCA;
+	/*RT2860c??  fixed using EDCA queue for test...  We doubt Queue1 has problem.  2006-09-26 Jan */
+	/*pTxD->QSEL= FIFO_EDCA; */
 	pTxD->DMADONE = 0;
 }
diff --git a/drivers/staging/rt2860/common/cmm_data_usb.c b/drivers/staging/rt2860/common/cmm_data_usb.c
index fbcb3a3..da79fc0 100644
--- a/drivers/staging/rt2860/common/cmm_data_usb.c
+++ b/drivers/staging/rt2860/common/cmm_data_usb.c
@@ -73,7 +73,7 @@ USHORT RtmpUSB_WriteSubTxResource(IN PRTMP_ADAPTER pAd,
 				  IN BOOLEAN bIsLast, OUT USHORT * FreeNumber)
 {
 
-	// Dummy function. Should be removed in the future.
+	/* Dummy function. Should be removed in the future. */
 	return 0;
 
 }
@@ -83,7 +83,7 @@ USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 				   IN UCHAR fragNum, OUT USHORT * FreeNumber)
 {
 	HT_TX_CONTEXT *pHTTXContext;
-	USHORT hwHdrLen;	// The hwHdrLen consist of 802.11 header length plus the header padding length.
+	USHORT hwHdrLen;	/* The hwHdrLen consist of 802.11 header length plus the header padding length. */
 	UINT32 fillOffset;
 	TXINFO_STRUC *pTxInfo;
 	TXWI_STRUC *pTxWI;
@@ -94,9 +94,9 @@ USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 	UINT32 USBDMApktLen = 0, DMAHdrLen, padding;
 	BOOLEAN TxQLastRound = FALSE;
 
-	//
-	// get Tx Ring Resource & Dma Buffer address
-	//
+	/* */
+	/* get Tx Ring Resource & Dma Buffer address */
+	/* */
 	QueIdx = pTxBlk->QueIdx;
 	pHTTXContext = &pAd->TxContext[QueIdx];
 
@@ -106,12 +106,12 @@ USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 	fillOffset = pHTTXContext->CurWritePosition;
 
 	if (fragNum == 0) {
-		// Check if we have enough space for this bulk-out batch.
+		/* Check if we have enough space for this bulk-out batch. */
 		Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
 		if (Status == NDIS_STATUS_SUCCESS) {
 			pHTTXContext->bCurWriting = TRUE;
 
-			// Reserve space for 8 bytes padding.
+			/* Reserve space for 8 bytes padding. */
 			if ((pHTTXContext->ENextBulkOutPosition ==
 			     pHTTXContext->CurWritePosition)) {
 				pHTTXContext->ENextBulkOutPosition += 8;
@@ -130,7 +130,7 @@ USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 			return (Status);
 		}
 	} else {
-		// For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer.
+		/* For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer. */
 		Status =
 		    ((pHTTXContext->bCurWriting ==
 		      TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
@@ -153,19 +153,19 @@ USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 	pWirelessPacket =
 	    &pHTTXContext->TransferBuffer->field.WirelessPacket[fillOffset];
 
-	// copy TXWI + WLAN Header + LLC into DMA Header Buffer
-	//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
+	/* copy TXWI + WLAN Header + LLC into DMA Header Buffer */
+	/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
 	hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
-	// Build our URB for USBD
+	/* Build our URB for USBD */
 	DMAHdrLen = TXWI_SIZE + hwHdrLen;
 	USBDMApktLen = DMAHdrLen + pTxBlk->SrcBufLen;
-	padding = (4 - (USBDMApktLen % 4)) & 0x03;	// round up to 4 byte alignment
+	padding = (4 - (USBDMApktLen % 4)) & 0x03;	/* round up to 4 byte alignment */
 	USBDMApktLen += padding;
 
 	pTxBlk->Priv += (TXINFO_SIZE + USBDMApktLen);
 
-	// For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload
+	/* For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload */
 	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (USBDMApktLen), FALSE, FIFO_EDCA,
 			FALSE /*NextValid */ , FALSE);
 
@@ -189,25 +189,25 @@ USHORT RtmpUSB_WriteFragTxResource(IN PRTMP_ADAPTER pAd,
 
 	NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen);
 
-	//      Zero the last padding.
+	/*      Zero the last padding. */
 	pWirelessPacket += pTxBlk->SrcBufLen;
 	NdisZeroMemory(pWirelessPacket, padding + 8);
 
 	if (fragNum == pTxBlk->TotalFragNum) {
 		RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-		// Update the pHTTXContext->CurWritePosition. 3906 used to prevent the NextBulkOut is a A-RALINK/A-MSDU Frame.
+		/* Update the pHTTXContext->CurWritePosition. 3906 used to prevent the NextBulkOut is a A-RALINK/A-MSDU Frame. */
 		pHTTXContext->CurWritePosition += pTxBlk->Priv;
 		if (TxQLastRound == TRUE)
 			pHTTXContext->CurWritePosition = 8;
 		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
 
-		// Finally, set bCurWriting as FALSE
+		/* Finally, set bCurWriting as FALSE */
 		pHTTXContext->bCurWriting = FALSE;
 
 		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-		// succeed and release the skb buffer
+		/* succeed and release the skb buffer */
 		RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
 	}
 
@@ -232,19 +232,19 @@ USHORT RtmpUSB_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 	UINT32 USBDMApktLen = 0, DMAHdrLen, padding;
 	BOOLEAN bTxQLastRound = FALSE;
 
-	// For USB, didn't need PCI_MAP_SINGLE()
-	//SrcBufPA = PCI_MAP_SINGLE(pAd, (char *) pTxBlk->pSrcBufData, pTxBlk->SrcBufLen, PCI_DMA_TODEVICE);
+	/* For USB, didn't need PCI_MAP_SINGLE() */
+	/*SrcBufPA = PCI_MAP_SINGLE(pAd, (char *) pTxBlk->pSrcBufData, pTxBlk->SrcBufLen, PCI_DMA_TODEVICE); */
 
-	//
-	// get Tx Ring Resource & Dma Buffer address
-	//
+	/* */
+	/* get Tx Ring Resource & Dma Buffer address */
+	/* */
 	QueIdx = pTxBlk->QueIdx;
 
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 	pHTTXContext = &pAd->TxContext[QueIdx];
 	fillOffset = pHTTXContext->CurWritePosition;
 
-	// Check ring full.
+	/* Check ring full. */
 	Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
 	if (Status == NDIS_STATUS_SUCCESS) {
 		pHTTXContext->bCurWriting = TRUE;
@@ -252,7 +252,7 @@ USHORT RtmpUSB_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 		pTxInfo = (PTXINFO_STRUC) (&pTxBlk->HeaderBuf[0]);
 		pTxWI = (PTXWI_STRUC) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
 
-		// Reserve space for 8 bytes padding.
+		/* Reserve space for 8 bytes padding. */
 		if ((pHTTXContext->ENextBulkOutPosition ==
 		     pHTTXContext->CurWritePosition)) {
 			pHTTXContext->ENextBulkOutPosition += 8;
@@ -265,19 +265,19 @@ USHORT RtmpUSB_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 		    &pHTTXContext->TransferBuffer->field.
 		    WirelessPacket[fillOffset];
 
-		// copy TXWI + WLAN Header + LLC into DMA Header Buffer
-		//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
+		/* copy TXWI + WLAN Header + LLC into DMA Header Buffer */
+		/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
 		hwHdrLen = pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
-		// Build our URB for USBD
+		/* Build our URB for USBD */
 		DMAHdrLen = TXWI_SIZE + hwHdrLen;
 		USBDMApktLen = DMAHdrLen + pTxBlk->SrcBufLen;
-		padding = (4 - (USBDMApktLen % 4)) & 0x03;	// round up to 4 byte alignment
+		padding = (4 - (USBDMApktLen % 4)) & 0x03;	/* round up to 4 byte alignment */
 		USBDMApktLen += padding;
 
 		pTxBlk->Priv = (TXINFO_SIZE + USBDMApktLen);
 
-		// For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload
+		/* For TxInfo, the length of USBDMApktLen = TXWI_SIZE + 802.11 header + payload */
 		RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (USBDMApktLen), FALSE,
 				FIFO_EDCA, FALSE /*NextValid */ , FALSE);
 
@@ -290,16 +290,16 @@ USHORT RtmpUSB_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 			       TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 		pWirelessPacket += (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 
-		// We unlock it here to prevent the first 8 bytes maybe over-writed issue.
-		//      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxcontext.
-		//      2. An interrupt break our routine and handle bulk-out complete.
-		//      3. In the bulk-out compllete, it need to do another bulk-out,
-		//                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition,
-		//                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE.
-		//      4. Interrupt complete.
-		//  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext.
-		//      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition.
-		//              and the packet will wrong.
+		/* We unlock it here to prevent the first 8 bytes maybe over-writed issue. */
+		/*      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxcontext. */
+		/*      2. An interrupt break our routine and handle bulk-out complete. */
+		/*      3. In the bulk-out compllete, it need to do another bulk-out, */
+		/*                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition, */
+		/*                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE. */
+		/*      4. Interrupt complete. */
+		/*  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext. */
+		/*      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition. */
+		/*              and the packet will wrong. */
 		pHTTXContext->CurWriteRealPos +=
 		    (TXINFO_SIZE + TXWI_SIZE + hwHdrLen);
 		RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
@@ -321,7 +321,7 @@ USHORT RtmpUSB_WriteSingleTxResource(IN PRTMP_ADAPTER pAd,
 
 	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
-	// succeed and release the skb buffer
+	/* succeed and release the skb buffer */
 	RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
 
 	return (Status);
@@ -333,7 +333,7 @@ USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 				    IN UCHAR frameNum, OUT USHORT * FreeNumber)
 {
 	HT_TX_CONTEXT *pHTTXContext;
-	USHORT hwHdrLen;	// The hwHdrLen consist of 802.11 header length plus the header padding length.
+	USHORT hwHdrLen;	/* The hwHdrLen consist of 802.11 header length plus the header padding length. */
 	UINT32 fillOffset;
 	TXINFO_STRUC *pTxInfo;
 	TXWI_STRUC *pTxWI;
@@ -341,18 +341,18 @@ USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 	UCHAR QueIdx;
 	NDIS_STATUS Status;
 	unsigned long IrqFlags;
-	//UINT32                        USBDMApktLen = 0, DMAHdrLen, padding;
+	/*UINT32                        USBDMApktLen = 0, DMAHdrLen, padding; */
 
-	//
-	// get Tx Ring Resource & Dma Buffer address
-	//
+	/* */
+	/* get Tx Ring Resource & Dma Buffer address */
+	/* */
 	QueIdx = pTxBlk->QueIdx;
 	pHTTXContext = &pAd->TxContext[QueIdx];
 
 	RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
 	if (frameNum == 0) {
-		// Check if we have enough space for this bulk-out batch.
+		/* Check if we have enough space for this bulk-out batch. */
 		Status = RtmpUSBCanDoWrite(pAd, QueIdx, pHTTXContext);
 		if (Status == NDIS_STATUS_SUCCESS) {
 			pHTTXContext->bCurWriting = TRUE;
@@ -360,7 +360,7 @@ USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 			pTxInfo = (PTXINFO_STRUC) (&pTxBlk->HeaderBuf[0]);
 			pTxWI = (PTXWI_STRUC) (&pTxBlk->HeaderBuf[TXINFO_SIZE]);
 
-			// Reserve space for 8 bytes padding.
+			/* Reserve space for 8 bytes padding. */
 			if ((pHTTXContext->ENextBulkOutPosition ==
 			     pHTTXContext->CurWritePosition)) {
 
@@ -375,43 +375,43 @@ USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 			    &pHTTXContext->TransferBuffer->field.
 			    WirelessPacket[fillOffset];
 
-			//
-			// Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer
-			//
+			/* */
+			/* Copy TXINFO + TXWI + WLAN Header + LLC into DMA Header Buffer */
+			/* */
 			if (pTxBlk->TxFrameType == TX_AMSDU_FRAME)
-				//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD;
+				/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_AMSDU_SUBFRAMEHEAD, 4)+LENGTH_AMSDU_SUBFRAMEHEAD; */
 				hwHdrLen =
 				    pTxBlk->MpduHeaderLen -
 				    LENGTH_AMSDU_SUBFRAMEHEAD +
 				    pTxBlk->HdrPadLen +
 				    LENGTH_AMSDU_SUBFRAMEHEAD;
 			else if (pTxBlk->TxFrameType == TX_RALINK_FRAME)
-				//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD;
+				/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen-LENGTH_ARALINK_HEADER_FIELD, 4)+LENGTH_ARALINK_HEADER_FIELD; */
 				hwHdrLen =
 				    pTxBlk->MpduHeaderLen -
 				    LENGTH_ARALINK_HEADER_FIELD +
 				    pTxBlk->HdrPadLen +
 				    LENGTH_ARALINK_HEADER_FIELD;
 			else
-				//hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4);
+				/*hwHdrLen = ROUND_UP(pTxBlk->MpduHeaderLen, 4); */
 				hwHdrLen =
 				    pTxBlk->MpduHeaderLen + pTxBlk->HdrPadLen;
 
-			// Update the pTxBlk->Priv.
+			/* Update the pTxBlk->Priv. */
 			pTxBlk->Priv = TXINFO_SIZE + TXWI_SIZE + hwHdrLen;
 
-			//      pTxInfo->USBDMApktLen now just a temp value and will to correct latter.
+			/*      pTxInfo->USBDMApktLen now just a temp value and will to correct latter. */
 			RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (pTxBlk->Priv),
 					FALSE, FIFO_EDCA, FALSE /*NextValid */ ,
 					FALSE);
 
-			// Copy it.
+			/* Copy it. */
 			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
 				       pTxBlk->Priv);
 			pHTTXContext->CurWriteRealPos += pTxBlk->Priv;
 			pWirelessPacket += pTxBlk->Priv;
 		}
-	} else {		// For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer.
+	} else {		/* For sub-sequent frames of this bulk-out batch. Just copy it to our bulk-out buffer. */
 
 		Status =
 		    ((pHTTXContext->bCurWriting ==
@@ -423,28 +423,28 @@ USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 			    &pHTTXContext->TransferBuffer->field.
 			    WirelessPacket[fillOffset];
 
-			//hwHdrLen = pTxBlk->MpduHeaderLen;
+			/*hwHdrLen = pTxBlk->MpduHeaderLen; */
 			NdisMoveMemory(pWirelessPacket, pTxBlk->HeaderBuf,
 				       pTxBlk->MpduHeaderLen);
 			pWirelessPacket += (pTxBlk->MpduHeaderLen);
 			pTxBlk->Priv += pTxBlk->MpduHeaderLen;
-		} else {	// It should not happened now unless we are going to shutdown.
+		} else {	/* It should not happened now unless we are going to shutdown. */
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("WriteMultiTxResource():bCurWriting is FALSE when handle sub-sequent frames.\n"));
 			Status = NDIS_STATUS_FAILURE;
 		}
 	}
 
-	// We unlock it here to prevent the first 8 bytes maybe over-write issue.
-	//      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxContext.
-	//      2. An interrupt break our routine and handle bulk-out complete.
-	//      3. In the bulk-out compllete, it need to do another bulk-out,
-	//                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition,
-	//                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE.
-	//      4. Interrupt complete.
-	//  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext.
-	//      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition.
-	//              and the packet will wrong.
+	/* We unlock it here to prevent the first 8 bytes maybe over-write issue. */
+	/*      1. First we got CurWritePosition but the first 8 bytes still not write to the pTxContext. */
+	/*      2. An interrupt break our routine and handle bulk-out complete. */
+	/*      3. In the bulk-out compllete, it need to do another bulk-out, */
+	/*                      if the ENextBulkOutPosition is just the same as CurWritePosition, it will save the first 8 bytes from CurWritePosition, */
+	/*                      but the payload still not copyed. the pTxContext->SavedPad[] will save as allzero. and set the bCopyPad = TRUE. */
+	/*      4. Interrupt complete. */
+	/*  5. Our interrupted routine go back and fill the first 8 bytes to pTxContext. */
+	/*      6. Next time when do bulk-out, it found the bCopyPad==TRUE and will copy the SavedPad[] to pTxContext->NextBulkOutPosition. */
+	/*              and the packet will wrong. */
 	RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
 
 	if (Status != NDIS_STATUS_SUCCESS) {
@@ -454,13 +454,13 @@ USHORT RtmpUSB_WriteMultiTxResource(IN PRTMP_ADAPTER pAd,
 			  pHTTXContext->NextBulkOutPosition));
 		goto done;
 	}
-	// Copy the frame content into DMA buffer and update the pTxBlk->Priv
+	/* Copy the frame content into DMA buffer and update the pTxBlk->Priv */
 	NdisMoveMemory(pWirelessPacket, pTxBlk->pSrcBufData, pTxBlk->SrcBufLen);
 	pWirelessPacket += pTxBlk->SrcBufLen;
 	pTxBlk->Priv += pTxBlk->SrcBufLen;
 
 done:
-	// Release the skb buffer here
+	/* Release the skb buffer here */
 	RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_SUCCESS);
 
 	return (Status);
@@ -498,47 +498,47 @@ VOID RtmpUSB_FinalWriteTxResource(IN PRTMP_ADAPTER pAd,
 			    (PUCHAR) (&pHTTXContext->TransferBuffer->field.
 				      WirelessPacket[fillOffset]);
 
-		//
-		// Update TxInfo->USBDMApktLen ,
-		//              the length = TXWI_SIZE + 802.11_hdr + 802.11_hdr_pad + payload_of_all_batch_frames + Bulk-Out-padding
-		//
+		/* */
+		/* Update TxInfo->USBDMApktLen , */
+		/*              the length = TXWI_SIZE + 802.11_hdr + 802.11_hdr_pad + payload_of_all_batch_frames + Bulk-Out-padding */
+		/* */
 		pTxInfo = (PTXINFO_STRUC) (pWirelessPacket);
 
-		// Calculate the bulk-out padding
+		/* Calculate the bulk-out padding */
 		USBDMApktLen = pTxBlk->Priv - TXINFO_SIZE;
-		padding = (4 - (USBDMApktLen % 4)) & 0x03;	// round up to 4 byte alignment
+		padding = (4 - (USBDMApktLen % 4)) & 0x03;	/* round up to 4 byte alignment */
 		USBDMApktLen += padding;
 
 		pTxInfo->USBDMATxPktLen = USBDMApktLen;
 
-		//
-		// Update TXWI->MPDUtotalByteCount ,
-		//              the length = 802.11 header + payload_of_all_batch_frames
+		/* */
+		/* Update TXWI->MPDUtotalByteCount , */
+		/*              the length = 802.11 header + payload_of_all_batch_frames */
 		pTxWI = (PTXWI_STRUC) (pWirelessPacket + TXINFO_SIZE);
 		pTxWI->MPDUtotalByteCount = totalMPDUSize;
 
-		//
-		// Update the pHTTXContext->CurWritePosition
-		//
+		/* */
+		/* Update the pHTTXContext->CurWritePosition */
+		/* */
 		pHTTXContext->CurWritePosition += (TXINFO_SIZE + USBDMApktLen);
-		if ((pHTTXContext->CurWritePosition + 3906) > MAX_TXBULK_LIMIT) {	// Add 3906 for prevent the NextBulkOut packet size is a A-RALINK/A-MSDU Frame.
+		if ((pHTTXContext->CurWritePosition + 3906) > MAX_TXBULK_LIMIT) {	/* Add 3906 for prevent the NextBulkOut packet size is a A-RALINK/A-MSDU Frame. */
 			pHTTXContext->CurWritePosition = 8;
 			pTxInfo->SwUseLastRound = 1;
 		}
 		pHTTXContext->CurWriteRealPos = pHTTXContext->CurWritePosition;
 
-		//
-		//      Zero the last padding.
-		//
+		/* */
+		/*      Zero the last padding. */
+		/* */
 		pWirelessPacket =
 		    (&pHTTXContext->TransferBuffer->field.
 		     WirelessPacket[fillOffset + pTxBlk->Priv]);
 		NdisZeroMemory(pWirelessPacket, padding + 8);
 
-		// Finally, set bCurWriting as FALSE
+		/* Finally, set bCurWriting as FALSE */
 		pHTTXContext->bCurWriting = FALSE;
 
-	} else {		// It should not happened now unless we are going to shutdown.
+	} else {		/* It should not happened now unless we are going to shutdown. */
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("FinalWriteTxResource():bCurWriting is FALSE when handle last frames.\n"));
 	}
@@ -550,7 +550,7 @@ VOID RtmpUSB_FinalWriteTxResource(IN PRTMP_ADAPTER pAd,
 VOID RtmpUSBDataLastTxIdx(IN PRTMP_ADAPTER pAd,
 			  IN UCHAR QueIdx, IN USHORT TxIdx)
 {
-	// DO nothing for USB.
+	/* DO nothing for USB. */
 }
 
 /*
@@ -589,22 +589,22 @@ int RtmpUSBMgmtKickOut(IN RTMP_ADAPTER * pAd,
 
 	pTxInfo = (PTXINFO_STRUC) (pSrcBufVA);
 
-	// Build our URB for USBD
+	/* Build our URB for USBD */
 	BulkOutSize = SrcBufLen;
 	BulkOutSize = (BulkOutSize + 3) & (~3);
 	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT) (BulkOutSize - TXINFO_SIZE),
 			TRUE, EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
 
-	BulkOutSize += 4;	// Always add 4 extra bytes at every packet.
+	BulkOutSize += 4;	/* Always add 4 extra bytes at every packet. */
 
-	// If BulkOutSize is multiple of BulkOutMaxPacketSize, add extra 4 bytes again.
+	/* If BulkOutSize is multiple of BulkOutMaxPacketSize, add extra 4 bytes again. */
 	if ((BulkOutSize % pAd->BulkOutMaxPacketSize) == 0)
 		BulkOutSize += 4;
 
 	padLen = BulkOutSize - SrcBufLen;
 	ASSERT((padLen <= RTMP_PKT_TAIL_PADDING));
 
-	// Now memzero all extra padding bytes.
+	/* Now memzero all extra padding bytes. */
 	pDest = (PUCHAR) (pSrcBufVA + SrcBufLen);
 	skb_put(GET_OS_PKT_TYPE(pPacket), padLen);
 	NdisZeroMemory(pDest, padLen);
@@ -615,28 +615,28 @@ int RtmpUSBMgmtKickOut(IN RTMP_ADAPTER * pAd,
 	pMLMEContext->TransferBuffer =
 	    (PTX_BUFFER) (GET_OS_PKT_DATAPTR(pPacket));
 
-	// Length in TxInfo should be 8 less than bulkout size.
+	/* Length in TxInfo should be 8 less than bulkout size. */
 	pMLMEContext->BulkOutSize = BulkOutSize;
 	pMLMEContext->InUse = TRUE;
 	pMLMEContext->bWaitingBulkOut = TRUE;
 
-	//for debug
-	//hex_dump("RtmpUSBMgmtKickOut", &pMLMEContext->TransferBuffer->field.WirelessPacket[0], (pMLMEContext->BulkOutSize > 16 ? 16 : pMLMEContext->BulkOutSize));
+	/*for debug */
+	/*hex_dump("RtmpUSBMgmtKickOut", &pMLMEContext->TransferBuffer->field.WirelessPacket[0], (pMLMEContext->BulkOutSize > 16 ? 16 : pMLMEContext->BulkOutSize)); */
 
-	//pAd->RalinkCounters.KickTxCount++;
-	//pAd->RalinkCounters.OneSecTxDoneCount++;
+	/*pAd->RalinkCounters.KickTxCount++; */
+	/*pAd->RalinkCounters.OneSecTxDoneCount++; */
 
-	//if (pAd->MgmtRing.TxSwFreeIdx == MGMT_RING_SIZE)
-	//      needKickOut = TRUE;
+	/*if (pAd->MgmtRing.TxSwFreeIdx == MGMT_RING_SIZE) */
+	/*      needKickOut = TRUE; */
 
-	// Decrease the TxSwFreeIdx and Increase the TX_CTX_IDX
+	/* Decrease the TxSwFreeIdx and Increase the TX_CTX_IDX */
 	pAd->MgmtRing.TxSwFreeIdx--;
 	INC_RING_INDEX(pAd->MgmtRing.TxCpuIdx, MGMT_RING_SIZE);
 
 	RTMP_IRQ_UNLOCK(&pAd->MLMEBulkOutLock, IrqFlags);
 
 	RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_MLME);
-	//if (needKickOut)
+	/*if (needKickOut) */
 	RTUSBKickBulkOut(pAd);
 
 	return 0;
@@ -654,7 +654,7 @@ VOID RtmpUSBNullFrameKickOut(IN RTMP_ADAPTER * pAd,
 
 		pNullContext = &(pAd->NullContext);
 
-		// Set the in use bit
+		/* Set the in use bit */
 		pNullContext->InUse = TRUE;
 		pWirelessPkt =
 		    (PUCHAR) & pNullContext->TransferBuffer->field.
@@ -677,14 +677,14 @@ VOID RtmpUSBNullFrameKickOut(IN RTMP_ADAPTER * pAd,
 		pAd->NullContext.BulkOutSize =
 		    TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
 
-		// Fill out frame length information for global Bulk out arbitor
-		//pNullContext->BulkOutSize = TransferBufferLength;
+		/* Fill out frame length information for global Bulk out arbitor */
+		/*pNullContext->BulkOutSize = TransferBufferLength; */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("SYNC - send NULL Frame @%d Mbps...\n",
 			  RateIdToMbps[pAd->CommonCfg.TxRate]));
 		RTUSB_SET_BULK_FLAG(pAd, fRTUSB_BULK_OUT_DATA_NULL);
 
-		// Kick bulk out
+		/* Kick bulk out */
 		RTUSBKickBulkOut(pAd);
 	}
 
@@ -731,7 +731,7 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 	}
 
 	pData = &pRxContext->TransferBuffer[pAd->ReadPosition];	/* 4KB */
-	// The RXDMA field is 4 bytes, now just use the first 2 bytes. The Length including the (RXWI + MSDU + Padding)
+	/* The RXDMA field is 4 bytes, now just use the first 2 bytes. The Length including the (RXWI + MSDU + Padding) */
 	ThisFrameLen = *pData + (*(pData + 1) << 8);
 	if (ThisFrameLen == 0) {
 		DBGPRINT(RT_DEBUG_TRACE,
@@ -748,7 +748,7 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 		goto label_null;
 	}
 
-	if ((ThisFrameLen + 8) > RxBufferLength)	// 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXINFO_STRUC))
+	if ((ThisFrameLen + 8) > RxBufferLength)	/* 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXINFO_STRUC)) */
 	{
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("BIRIdx(%d):FrameLen(0x%lx) outranges. BulkInLen=0x%lx, remaining RxBufLen=0x%lx, ReadPos=0x%lx\n",
@@ -756,10 +756,10 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 			  pRxContext->BulkInOffset, RxBufferLength,
 			  pAd->ReadPosition));
 
-		// error frame. finish this loop
+		/* error frame. finish this loop */
 		goto label_null;
 	}
-	// skip USB frame length field
+	/* skip USB frame length field */
 	pData += RT2870_RXDMALEN_FIELD_SIZE;
 	pRxWI = (PRXWI_STRUC) pData;
 	if (pRxWI->MPDUtotalByteCount > ThisFrameLen) {
@@ -769,7 +769,7 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 			  ThisFrameLen));
 		goto label_null;
 	}
-	// allocate a rx packet
+	/* allocate a rx packet */
 	pSkb = dev_alloc_skb(ThisFrameLen);
 	if (pSkb == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR,
@@ -777,16 +777,16 @@ PNDIS_PACKET GetPacketFromRxRing(IN PRTMP_ADAPTER pAd,
 			  __FUNCTION__));
 		goto label_null;
 	}
-	// copy the rx packet
+	/* copy the rx packet */
 	memcpy(skb_put(pSkb, ThisFrameLen), pData, ThisFrameLen);
 	RTPKT_TO_OSPKT(pSkb)->dev = get_netdev_from_bssid(pAd, BSS0);
 	RTMP_SET_PACKET_SOURCE(OSPKT_TO_RTPKT(pSkb), PKTSRC_NDIS);
 
-	// copy RxD
+	/* copy RxD */
 	*pSaveRxD = *(PRXINFO_STRUC) (pData + ThisFrameLen);
 
-	// update next packet read position.
-	pAd->ReadPosition += (ThisFrameLen + RT2870_RXDMALEN_FIELD_SIZE + RXINFO_SIZE);	// 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXINFO_STRUC))
+	/* update next packet read position. */
+	pAd->ReadPosition += (ThisFrameLen + RT2870_RXDMALEN_FIELD_SIZE + RXINFO_SIZE);	/* 8 for (RT2870_RXDMALEN_FIELD_SIZE + sizeof(RXINFO_STRUC)) */
 
 	return pSkb;
 
@@ -824,9 +824,9 @@ NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
 	if (pRxINFO == NULL)
 		return (NDIS_STATUS_FAILURE);
 
-	// Phy errors & CRC errors
+	/* Phy errors & CRC errors */
 	if (pRxINFO->Crc) {
-		// Check RSSI for Noise Hist statistic collection.
+		/* Check RSSI for Noise Hist statistic collection. */
 		dBm = (INT) (pRxWI->RSSI0) - pAd->BbpRssiToDbmDelta;
 		if (dBm <= -87)
 			pAd->StaCfg.RPIDensity[0] += 1;
@@ -847,25 +847,25 @@ NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
 
 		return (NDIS_STATUS_FAILURE);
 	}
-	// Add Rx size to channel load counter, we should ignore error counts
+	/* Add Rx size to channel load counter, we should ignore error counts */
 	pAd->StaCfg.CLBusyBytes += (pRxWI->MPDUtotalByteCount + 14);
 
-	// Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics
+	/* Drop ToDs promiscous frame, it is opened due to CCX 2 channel load statistics */
 	if (pHeader->FC.ToDs) {
 		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Err;FC.ToDs\n"));
 		return NDIS_STATUS_FAILURE;
 	}
-	// Paul 04-03 for OFDM Rx length issue
+	/* Paul 04-03 for OFDM Rx length issue */
 	if (pRxWI->MPDUtotalByteCount > MAX_AGGREGATION_SIZE) {
 		DBGPRINT_RAW(RT_DEBUG_ERROR, ("received packet too long\n"));
 		return NDIS_STATUS_FAILURE;
 	}
-	// Drop not U2M frames, cant's drop here because we will drop beacon in this case
-	// I am kind of doubting the U2M bit operation
-	// if (pRxD->U2M == 0)
-	//      return(NDIS_STATUS_FAILURE);
+	/* Drop not U2M frames, cant's drop here because we will drop beacon in this case */
+	/* I am kind of doubting the U2M bit operation */
+	/* if (pRxD->U2M == 0) */
+	/*      return(NDIS_STATUS_FAILURE); */
 
-	// drop decyption fail frame
+	/* drop decyption fail frame */
 	if (pRxINFO->Decrypted && pRxINFO->CipherErr) {
 
 		if (((pRxINFO->CipherErr & 1) == 1)
@@ -879,9 +879,9 @@ NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
 			RTMPSendWirelessEvent(pAd, IW_MIC_ERROR_EVENT_FLAG,
 					      pAd->MacTab.Content[BSSID_WCID].
 					      Addr, BSS0, 0);
-		//
-		// MIC Error
-		//
+		/* */
+		/* MIC Error */
+		/* */
 		if ((pRxINFO->CipherErr == 2) && pRxINFO->MyBss) {
 			pWpaKey = &pAd->SharedKey[BSS0][pRxWI->KeyIndex];
 			RTMPReportMicError(pAd, pWpaKey);
@@ -892,9 +892,9 @@ NDIS_STATUS RTMPCheckRxError(IN PRTMP_ADAPTER pAd,
 		    (pAd->SharedKey[BSS0][pRxWI->KeyIndex].CipherAlg ==
 		     CIPHER_AES)
 		    && (pHeader->Sequence == pAd->FragFrame.Sequence)) {
-			//
-			// Acceptable since the First FragFrame no CipherErr problem.
-			//
+			/* */
+			/* Acceptable since the First FragFrame no CipherErr problem. */
+			/* */
 			return (NDIS_STATUS_SUCCESS);
 		}
 
@@ -935,17 +935,17 @@ VOID RT28xxUsbStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
 					 IN USHORT TbttNumToNextWakeUp)
 {
 
-	// we have decided to SLEEP, so at least do it for a BEACON period.
+	/* we have decided to SLEEP, so at least do it for a BEACON period. */
 	if (TbttNumToNextWakeUp == 0)
 		TbttNumToNextWakeUp = 1;
 
 	RTMPSetTimer(&pAd->Mlme.AutoWakeupTimer, AUTO_WAKEUP_TIMEOUT);
 	pAd->Mlme.AutoWakeupTimerRunning = TRUE;
 
-	AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);	// send POWER-SAVE command to MCU. Timeout 40us.
+	AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);	/* send POWER-SAVE command to MCU. Timeout 40us. */
 
 	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
 
 }
 
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
diff --git a/drivers/staging/rt2860/common/cmm_info.c b/drivers/staging/rt2860/common/cmm_info.c
index be01b07..610eb75 100644
--- a/drivers/staging/rt2860/common/cmm_info.c
+++ b/drivers/staging/rt2860/common/cmm_info.c
@@ -53,144 +53,144 @@ VOID RTMPSetDesiredRates(IN PRTMP_ADAPTER pAdapter, IN LONG Rates)
 
 	memset(&aryRates, 0x00, sizeof(NDIS_802_11_RATES));
 	switch (pAdapter->CommonCfg.PhyMode) {
-	case PHY_11A:		// A only
+	case PHY_11A:		/* A only */
 		switch (Rates) {
-		case 6000000:	//6M
-			aryRates[0] = 0x0c;	// 6M
+		case 6000000:	/*6M */
+			aryRates[0] = 0x0c;	/* 6M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_0;
 			break;
-		case 9000000:	//9M
-			aryRates[0] = 0x12;	// 9M
+		case 9000000:	/*9M */
+			aryRates[0] = 0x12;	/* 9M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_1;
 			break;
-		case 12000000:	//12M
-			aryRates[0] = 0x18;	// 12M
+		case 12000000:	/*12M */
+			aryRates[0] = 0x18;	/* 12M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_2;
 			break;
-		case 18000000:	//18M
-			aryRates[0] = 0x24;	// 18M
+		case 18000000:	/*18M */
+			aryRates[0] = 0x24;	/* 18M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_3;
 			break;
-		case 24000000:	//24M
-			aryRates[0] = 0x30;	// 24M
+		case 24000000:	/*24M */
+			aryRates[0] = 0x30;	/* 24M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_4;
 			break;
-		case 36000000:	//36M
-			aryRates[0] = 0x48;	// 36M
+		case 36000000:	/*36M */
+			aryRates[0] = 0x48;	/* 36M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_5;
 			break;
-		case 48000000:	//48M
-			aryRates[0] = 0x60;	// 48M
+		case 48000000:	/*48M */
+			aryRates[0] = 0x60;	/* 48M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_6;
 			break;
-		case 54000000:	//54M
-			aryRates[0] = 0x6c;	// 54M
+		case 54000000:	/*54M */
+			aryRates[0] = 0x6c;	/* 54M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_7;
 			break;
-		case -1:	//Auto
+		case -1:	/*Auto */
 		default:
-			aryRates[0] = 0x6c;	// 54Mbps
-			aryRates[1] = 0x60;	// 48Mbps
-			aryRates[2] = 0x48;	// 36Mbps
-			aryRates[3] = 0x30;	// 24Mbps
-			aryRates[4] = 0x24;	// 18M
-			aryRates[5] = 0x18;	// 12M
-			aryRates[6] = 0x12;	// 9M
-			aryRates[7] = 0x0c;	// 6M
+			aryRates[0] = 0x6c;	/* 54Mbps */
+			aryRates[1] = 0x60;	/* 48Mbps */
+			aryRates[2] = 0x48;	/* 36Mbps */
+			aryRates[3] = 0x30;	/* 24Mbps */
+			aryRates[4] = 0x24;	/* 18M */
+			aryRates[5] = 0x18;	/* 12M */
+			aryRates[6] = 0x12;	/* 9M */
+			aryRates[7] = 0x0c;	/* 6M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_AUTO;
 			break;
 		}
 		break;
-	case PHY_11BG_MIXED:	// B/G Mixed
-	case PHY_11B:		// B only
-	case PHY_11ABG_MIXED:	// A/B/G Mixed
+	case PHY_11BG_MIXED:	/* B/G Mixed */
+	case PHY_11B:		/* B only */
+	case PHY_11ABG_MIXED:	/* A/B/G Mixed */
 	default:
 		switch (Rates) {
-		case 1000000:	//1M
+		case 1000000:	/*1M */
 			aryRates[0] = 0x02;
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_0;
 			break;
-		case 2000000:	//2M
+		case 2000000:	/*2M */
 			aryRates[0] = 0x04;
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_1;
 			break;
-		case 5000000:	//5.5M
-			aryRates[0] = 0x0b;	// 5.5M
+		case 5000000:	/*5.5M */
+			aryRates[0] = 0x0b;	/* 5.5M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_2;
 			break;
-		case 11000000:	//11M
-			aryRates[0] = 0x16;	// 11M
+		case 11000000:	/*11M */
+			aryRates[0] = 0x16;	/* 11M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_3;
 			break;
-		case 6000000:	//6M
-			aryRates[0] = 0x0c;	// 6M
+		case 6000000:	/*6M */
+			aryRates[0] = 0x0c;	/* 6M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_0;
 			break;
-		case 9000000:	//9M
-			aryRates[0] = 0x12;	// 9M
+		case 9000000:	/*9M */
+			aryRates[0] = 0x12;	/* 9M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_1;
 			break;
-		case 12000000:	//12M
-			aryRates[0] = 0x18;	// 12M
+		case 12000000:	/*12M */
+			aryRates[0] = 0x18;	/* 12M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_2;
 			break;
-		case 18000000:	//18M
-			aryRates[0] = 0x24;	// 18M
+		case 18000000:	/*18M */
+			aryRates[0] = 0x24;	/* 18M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_3;
 			break;
-		case 24000000:	//24M
-			aryRates[0] = 0x30;	// 24M
+		case 24000000:	/*24M */
+			aryRates[0] = 0x30;	/* 24M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_4;
 			break;
-		case 36000000:	//36M
-			aryRates[0] = 0x48;	// 36M
+		case 36000000:	/*36M */
+			aryRates[0] = 0x48;	/* 36M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_5;
 			break;
-		case 48000000:	//48M
-			aryRates[0] = 0x60;	// 48M
+		case 48000000:	/*48M */
+			aryRates[0] = 0x60;	/* 48M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_6;
 			break;
-		case 54000000:	//54M
-			aryRates[0] = 0x6c;	// 54M
+		case 54000000:	/*54M */
+			aryRates[0] = 0x6c;	/* 54M */
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_7;
 			break;
-		case -1:	//Auto
+		case -1:	/*Auto */
 		default:
-			if (pAdapter->CommonCfg.PhyMode == PHY_11B) {	//B Only
-				aryRates[0] = 0x16;	// 11Mbps
-				aryRates[1] = 0x0b;	// 5.5Mbps
-				aryRates[2] = 0x04;	// 2Mbps
-				aryRates[3] = 0x02;	// 1Mbps
-			} else {	//(B/G) Mixed or (A/B/G) Mixed
-				aryRates[0] = 0x6c;	// 54Mbps
-				aryRates[1] = 0x60;	// 48Mbps
-				aryRates[2] = 0x48;	// 36Mbps
-				aryRates[3] = 0x30;	// 24Mbps
-				aryRates[4] = 0x16;	// 11Mbps
-				aryRates[5] = 0x0b;	// 5.5Mbps
-				aryRates[6] = 0x04;	// 2Mbps
-				aryRates[7] = 0x02;	// 1Mbps
+			if (pAdapter->CommonCfg.PhyMode == PHY_11B) {	/*B Only */
+				aryRates[0] = 0x16;	/* 11Mbps */
+				aryRates[1] = 0x0b;	/* 5.5Mbps */
+				aryRates[2] = 0x04;	/* 2Mbps */
+				aryRates[3] = 0x02;	/* 1Mbps */
+			} else {	/*(B/G) Mixed or (A/B/G) Mixed */
+				aryRates[0] = 0x6c;	/* 54Mbps */
+				aryRates[1] = 0x60;	/* 48Mbps */
+				aryRates[2] = 0x48;	/* 36Mbps */
+				aryRates[3] = 0x30;	/* 24Mbps */
+				aryRates[4] = 0x16;	/* 11Mbps */
+				aryRates[5] = 0x0b;	/* 5.5Mbps */
+				aryRates[6] = 0x04;	/* 2Mbps */
+				aryRates[7] = 0x02;	/* 1Mbps */
 			}
 			pAdapter->StaCfg.DesiredTransmitSetting.field.MCS =
 			    MCS_AUTO;
@@ -213,7 +213,7 @@ VOID RTMPSetDesiredRates(IN PRTMP_ADAPTER pAdapter, IN LONG Rates)
 		  pAdapter->CommonCfg.DesireRate[5],
 		  pAdapter->CommonCfg.DesireRate[6],
 		  pAdapter->CommonCfg.DesireRate[7]));
-	// Changing DesiredRate may affect the MAX TX rate we used to TX frames out
+	/* Changing DesiredRate may affect the MAX TX rate we used to TX frames out */
 	MlmeUpdateTxRates(pAdapter, FALSE, 0);
 }
 
@@ -244,20 +244,20 @@ VOID RTMPWPARemoveAllKeys(IN PRTMP_ADAPTER pAd)
 		 ("RTMPWPARemoveAllKeys(AuthMode=%d, WepStatus=%d)\n",
 		  pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus));
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
-	// For WEP/CKIP, there is no need to remove it, since WinXP won't set it again after
-	// Link up. And it will be replaced if user changed it.
+	/* For WEP/CKIP, there is no need to remove it, since WinXP won't set it again after */
+	/* Link up. And it will be replaced if user changed it. */
 	if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
 		return;
 
-	// For WPA-None, there is no need to remove it, since WinXP won't set it again after
-	// Link up. And it will be replaced if user changed it.
+	/* For WPA-None, there is no need to remove it, since WinXP won't set it again after */
+	/* Link up. And it will be replaced if user changed it. */
 	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
 		return;
 
-	// set BSSID wcid entry of the Pair-wise Key table as no-security mode
+	/* set BSSID wcid entry of the Pair-wise Key table as no-security mode */
 	AsicRemovePairwiseKeyEntry(pAd, BSS0, BSSID_WCID);
 
-	// set all shared key mode as no-security.
+	/* set all shared key mode as no-security. */
 	for (i = 0; i < SHARE_KEY_NUM; i++) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("remove %s key #%d\n",
@@ -310,9 +310,9 @@ VOID RTMPWPARemoveAllKeys(IN PRTMP_ADAPTER pAd)
 VOID RTMPSetPhyMode(IN PRTMP_ADAPTER pAd, IN ULONG phymode)
 {
 	INT i;
-	// the selected phymode must be supported by the RF IC encoded in E2PROM
+	/* the selected phymode must be supported by the RF IC encoded in E2PROM */
 
-	// if no change, do nothing
+	/* if no change, do nothing */
 	/* bug fix
 	   if (pAd->CommonCfg.PhyMode == phymode)
 	   return;
@@ -325,7 +325,7 @@ VOID RTMPSetPhyMode(IN PRTMP_ADAPTER pAd, IN ULONG phymode)
 
 	BuildChannelList(pAd);
 
-	// sanity check user setting
+	/* sanity check user setting */
 	for (i = 0; i < pAd->ChannelListNum; i++) {
 		if (pAd->CommonCfg.Channel == pAd->ChannelList[i].Channel)
 			break;
@@ -343,17 +343,17 @@ VOID RTMPSetPhyMode(IN PRTMP_ADAPTER pAd, IN ULONG phymode)
 	NdisZeroMemory(pAd->CommonCfg.DesireRate, MAX_LEN_OF_SUPPORTED_RATES);
 	switch (phymode) {
 	case PHY_11B:
-		pAd->CommonCfg.SupRate[0] = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[1] = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[2] = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[3] = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
+		pAd->CommonCfg.SupRate[0] = 0x82;	/* 1 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[1] = 0x84;	/* 2 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[2] = 0x8B;	/* 5.5 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[3] = 0x96;	/* 11 mbps, in units of 0.5 Mbps, basic rate */
 		pAd->CommonCfg.SupRateLen = 4;
 		pAd->CommonCfg.ExtRateLen = 0;
-		pAd->CommonCfg.DesireRate[0] = 2;	// 1 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[1] = 4;	// 2 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[2] = 11;	// 5.5 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[3] = 22;	// 11 mbps, in units of 0.5 Mbps
-		//pAd->CommonCfg.HTPhyMode.field.MODE = MODE_CCK; // This MODE is only FYI. not use
+		pAd->CommonCfg.DesireRate[0] = 2;	/* 1 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[1] = 4;	/* 2 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[2] = 11;	/* 5.5 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[3] = 22;	/* 11 mbps, in units of 0.5 Mbps */
+		/*pAd->CommonCfg.HTPhyMode.field.MODE = MODE_CCK; // This MODE is only FYI. not use */
 		break;
 
 	case PHY_11G:
@@ -363,57 +363,57 @@ VOID RTMPSetPhyMode(IN PRTMP_ADAPTER pAd, IN ULONG phymode)
 	case PHY_11ABGN_MIXED:
 	case PHY_11BGN_MIXED:
 	case PHY_11GN_MIXED:
-		pAd->CommonCfg.SupRate[0] = 0x82;	// 1 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[1] = 0x84;	// 2 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[2] = 0x8B;	// 5.5 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[3] = 0x96;	// 11 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[4] = 0x12;	// 9 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.SupRate[5] = 0x24;	// 18 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.SupRate[6] = 0x48;	// 36 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.SupRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[0] = 0x82;	/* 1 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[1] = 0x84;	/* 2 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[2] = 0x8B;	/* 5.5 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[3] = 0x96;	/* 11 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[4] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.SupRate[5] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.SupRate[6] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.SupRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
 		pAd->CommonCfg.SupRateLen = 8;
-		pAd->CommonCfg.ExtRate[0] = 0x0C;	// 6 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.ExtRate[1] = 0x18;	// 12 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.ExtRate[2] = 0x30;	// 24 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.ExtRate[3] = 0x60;	// 48 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.ExtRate[0] = 0x0C;	/* 6 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.ExtRate[1] = 0x18;	/* 12 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.ExtRate[2] = 0x30;	/* 24 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.ExtRate[3] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
 		pAd->CommonCfg.ExtRateLen = 4;
-		pAd->CommonCfg.DesireRate[0] = 2;	// 1 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[1] = 4;	// 2 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[2] = 11;	// 5.5 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[3] = 22;	// 11 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[4] = 12;	// 6 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[5] = 18;	// 9 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[6] = 24;	// 12 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[7] = 36;	// 18 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[8] = 48;	// 24 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[9] = 72;	// 36 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[10] = 96;	// 48 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[11] = 108;	// 54 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.DesireRate[0] = 2;	/* 1 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[1] = 4;	/* 2 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[2] = 11;	/* 5.5 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[3] = 22;	/* 11 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[4] = 12;	/* 6 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[5] = 18;	/* 9 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[6] = 24;	/* 12 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[7] = 36;	/* 18 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[8] = 48;	/* 24 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[9] = 72;	/* 36 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[10] = 96;	/* 48 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[11] = 108;	/* 54 mbps, in units of 0.5 Mbps */
 		break;
 
 	case PHY_11A:
 	case PHY_11AN_MIXED:
 	case PHY_11AGN_MIXED:
 	case PHY_11N_5G:
-		pAd->CommonCfg.SupRate[0] = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[1] = 0x12;	// 9 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.SupRate[2] = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[3] = 0x24;	// 18 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.SupRate[4] = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
-		pAd->CommonCfg.SupRate[5] = 0x48;	// 36 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.SupRate[6] = 0x60;	// 48 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.SupRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		pAd->CommonCfg.SupRate[0] = 0x8C;	/* 6 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[1] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.SupRate[2] = 0x98;	/* 12 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[3] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.SupRate[4] = 0xb0;	/* 24 mbps, in units of 0.5 Mbps, basic rate */
+		pAd->CommonCfg.SupRate[5] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.SupRate[6] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.SupRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
 		pAd->CommonCfg.SupRateLen = 8;
 		pAd->CommonCfg.ExtRateLen = 0;
-		pAd->CommonCfg.DesireRate[0] = 12;	// 6 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[1] = 18;	// 9 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[2] = 24;	// 12 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[3] = 36;	// 18 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[4] = 48;	// 24 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[5] = 72;	// 36 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[6] = 96;	// 48 mbps, in units of 0.5 Mbps
-		pAd->CommonCfg.DesireRate[7] = 108;	// 54 mbps, in units of 0.5 Mbps
-		//pAd->CommonCfg.HTPhyMode.field.MODE = MODE_OFDM; // This MODE is only FYI. not use
+		pAd->CommonCfg.DesireRate[0] = 12;	/* 6 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[1] = 18;	/* 9 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[2] = 24;	/* 12 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[3] = 36;	/* 18 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[4] = 48;	/* 24 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[5] = 72;	/* 36 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[6] = 96;	/* 48 mbps, in units of 0.5 Mbps */
+		pAd->CommonCfg.DesireRate[7] = 108;	/* 54 mbps, in units of 0.5 Mbps */
+		/*pAd->CommonCfg.HTPhyMode.field.MODE = MODE_OFDM; // This MODE is only FYI. not use */
 		break;
 
 	default:
@@ -437,7 +437,7 @@ VOID RTMPSetPhyMode(IN PRTMP_ADAPTER pAd, IN ULONG phymode)
 */
 VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 {
-	//ULONG *pmcs;
+	/*ULONG *pmcs; */
 	UINT32 Value = 0;
 	UCHAR BBPValue = 0;
 	UCHAR BBP3Value = 0;
@@ -448,7 +448,7 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 		  pHTPhyMode->HtMode, pHTPhyMode->ExtOffset, pHTPhyMode->MCS,
 		  pHTPhyMode->BW, pHTPhyMode->STBC, pHTPhyMode->SHORTGI));
 
-	// Don't zero supportedHyPhy structure.
+	/* Don't zero supportedHyPhy structure. */
 	RTMPZeroMemory(&pAd->CommonCfg.HtCapability,
 		       sizeof(pAd->CommonCfg.HtCapability));
 	RTMPZeroMemory(&pAd->CommonCfg.AddHTInfo,
@@ -473,7 +473,7 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 		 ("RTMPSetHT : RxBAWinLimit = %d\n",
 		  pAd->CommonCfg.BACapability.field.RxBAWinLimit));
 
-	// Mimo power save, A-MSDU size,
+	/* Mimo power save, A-MSDU size, */
 	pAd->CommonCfg.DesiredHtPhy.AmsduEnable =
 	    (USHORT) pAd->CommonCfg.BACapability.field.AmsduEnable;
 	pAd->CommonCfg.DesiredHtPhy.AmsduSize =
@@ -503,7 +503,7 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 	} else
 		pAd->CommonCfg.DesiredHtPhy.GF = 0;
 
-	// Decide Rx MCSSet
+	/* Decide Rx MCSSet */
 	switch (RxStream) {
 	case 1:
 		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
@@ -515,7 +515,7 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 		pAd->CommonCfg.HtCapability.MCSSet[1] = 0xff;
 		break;
 
-	case 3:		// 3*3
+	case 3:		/* 3*3 */
 		pAd->CommonCfg.HtCapability.MCSSet[0] = 0xff;
 		pAd->CommonCfg.HtCapability.MCSSet[1] = 0xff;
 		pAd->CommonCfg.HtCapability.MCSSet[2] = 0xff;
@@ -529,7 +529,7 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 	}
 
 	if (pHTPhyMode->BW == BW_40) {
-		pAd->CommonCfg.HtCapability.MCSSet[4] = 0x1;	// MCS 32
+		pAd->CommonCfg.HtCapability.MCSSet[4] = 0x1;	/* MCS 32 */
 		pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth = 1;
 		if (pAd->CommonCfg.Channel <= 14)
 			pAd->CommonCfg.HtCapability.HtCapInfo.CCKmodein40 = 1;
@@ -539,7 +539,7 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset =
 		    (pHTPhyMode->ExtOffset ==
 		     EXTCHA_BELOW) ? (EXTCHA_BELOW) : EXTCHA_ABOVE;
-		// Set Regsiter for extension channel position.
+		/* Set Regsiter for extension channel position. */
 		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Value);
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBP3Value);
 		if ((pHTPhyMode->ExtOffset == EXTCHA_BELOW)) {
@@ -551,8 +551,8 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 			BBP3Value &= (~0x20);
 			RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Value);
 		}
-		// Turn on BBP 40MHz mode now only as AP .
-		// Sta can turn on BBP 40MHz after connection with 40MHz AP. Sta only broadcast 40MHz capability before connection.
+		/* Turn on BBP 40MHz mode now only as AP . */
+		/* Sta can turn on BBP 40MHz after connection with 40MHz AP. Sta only broadcast 40MHz capability before connection. */
 		if ((pAd->OpMode == OPMODE_AP) || INFRA_ON(pAd) || ADHOC_ON(pAd)
 		    ) {
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
@@ -569,7 +569,7 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 		pAd->CommonCfg.AddHTInfo.AddHtInfo.RecomWidth = 0;
 		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = EXTCHA_NONE;
 		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
-		// Turn on BBP 20MHz mode by request here.
+		/* Turn on BBP 20MHz mode by request here. */
 		{
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 			BBPValue &= (~0x18);
@@ -600,12 +600,12 @@ VOID RTMPSetHT(IN PRTMP_ADAPTER pAd, IN OID_SET_HT_PHYMODE * pHTPhyMode)
 		pAd->CommonCfg.DesiredHtPhy.ShortGIfor40 = 0;
 	}
 
-	// We support link adaptation for unsolicit MCS feedback, set to 2.
-	pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback = MCSFBK_NONE;	//MCSFBK_UNSOLICIT;
+	/* We support link adaptation for unsolicit MCS feedback, set to 2. */
+	pAd->CommonCfg.HtCapability.ExtHtCapInfo.MCSFeedback = MCSFBK_NONE;	/*MCSFBK_UNSOLICIT; */
 	pAd->CommonCfg.AddHTInfo.ControlChan = pAd->CommonCfg.Channel;
-	// 1, the extension channel above the control channel.
+	/* 1, the extension channel above the control channel. */
 
-	// EDCA parameters used for AP's own transmission
+	/* EDCA parameters used for AP's own transmission */
 	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE) {
 		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
 		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
@@ -659,7 +659,7 @@ VOID RTMPSetIndividualHT(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 			pDesired_ht_phy = &pAd->StaCfg.DesiredHtPhyInfo;
 			DesiredMcs =
 			    pAd->StaCfg.DesiredTransmitSetting.field.MCS;
-			//pAd->StaCfg.bAutoTxRateSwitch = (DesiredMcs == MCS_AUTO) ? TRUE : FALSE;
+			/*pAd->StaCfg.bAutoTxRateSwitch = (DesiredMcs == MCS_AUTO) ? TRUE : FALSE; */
 			break;
 		}
 	} while (FALSE);
@@ -673,7 +673,7 @@ VOID RTMPSetIndividualHT(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("RTMPSetIndividualHT : Desired MCS = %d\n", DesiredMcs));
-	// Check the validity of MCS
+	/* Check the validity of MCS */
 	if ((TxStream == 1)
 	    && ((DesiredMcs >= MCS_8) && (DesiredMcs <= MCS_15))) {
 		DBGPRINT(RT_DEBUG_WARN,
@@ -691,7 +691,7 @@ VOID RTMPSetIndividualHT(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 
 	pDesired_ht_phy->bHtEnable = TRUE;
 
-	// Decide desired Tx MCS
+	/* Decide desired Tx MCS */
 	switch (TxStream) {
 	case 1:
 		if (DesiredMcs == MCS_AUTO) {
@@ -717,7 +717,7 @@ VOID RTMPSetIndividualHT(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 		}
 		break;
 
-	case 3:		// 3*3
+	case 3:		/* 3*3 */
 		if (DesiredMcs == MCS_AUTO) {
 			/* MCS0 ~ MCS23, 3 bytes */
 			pDesired_ht_phy->MCSSet[0] = 0xff;
@@ -738,7 +738,7 @@ VOID RTMPSetIndividualHT(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 		if (DesiredMcs == MCS_AUTO || DesiredMcs == MCS_32)
 			pDesired_ht_phy->MCSSet[4] = 0x1;
 	}
-	// update HT Rate setting
+	/* update HT Rate setting */
 	if (pAd->OpMode == OPMODE_STA)
 		MlmeUpdateHtTxRates(pAd, BSS0);
 	else
@@ -778,7 +778,7 @@ VOID RTMPUpdateHTIE(IN RT_HT_CAPABILITY * pRtHt,
 	pAddHtInfo->AddHtInfo.RecomWidth = pRtHt->RecomWidth;
 	pAddHtInfo->AddHtInfo2.OperaionMode = pRtHt->OperaionMode;
 	pAddHtInfo->AddHtInfo2.NonGfPresent = pRtHt->NonGfPresent;
-	RTMPMoveMemory(pAddHtInfo->MCSSet, /*pRtHt->MCSSet */ pMcsSet, 4);	// rt2860 only support MCS max=32, no need to copy all 16 uchar.
+	RTMPMoveMemory(pAddHtInfo->MCSSet, /*pRtHt->MCSSet */ pMcsSet, 4);	/* rt2860 only support MCS max=32, no need to copy all 16 uchar. */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("RTMPUpdateHTIE <== \n"));
 }
@@ -808,9 +808,9 @@ VOID RTMPAddWcidAttributeEntry(IN PRTMP_ADAPTER pAd,
 					  BssIdx));
 				return;
 			}
-			// 1.   In ADHOC mode, the AID is wcid number. And NO mesh link exists.
-			// 2.   In Infra mode, the AID:1 MUST be wcid of infra STA.
-			//                                         the AID:2~ assign to mesh link entry.
+			/* 1.   In ADHOC mode, the AID is wcid number. And NO mesh link exists. */
+			/* 2.   In Infra mode, the AID:1 MUST be wcid of infra STA. */
+			/*                                         the AID:2~ assign to mesh link entry. */
 			if (pEntry)
 				Wcid = pEntry->Aid;
 			else
@@ -818,7 +818,7 @@ VOID RTMPAddWcidAttributeEntry(IN PRTMP_ADAPTER pAd,
 		}
 	}
 
-	// Update WCID attribute table
+	/* Update WCID attribute table */
 	offset = MAC_WCID_ATTRIBUTE_BASE + (Wcid * HW_WCID_ATTRI_SIZE);
 
 	{
@@ -830,26 +830,26 @@ VOID RTMPAddWcidAttributeEntry(IN PRTMP_ADAPTER pAd,
 
 	RTMP_IO_WRITE32(pAd, offset, WCIDAttri);
 
-	// Update IV/EIV table
+	/* Update IV/EIV table */
 	offset = MAC_IVEIV_TABLE_BASE + (Wcid * HW_IVEIV_ENTRY_SIZE);
 
-	// WPA mode
+	/* WPA mode */
 	if ((CipherAlg == CIPHER_TKIP) || (CipherAlg == CIPHER_TKIP_NO_MIC)
 	    || (CipherAlg == CIPHER_AES)) {
-		// Eiv bit on. keyid always is 0 for pairwise key
+		/* Eiv bit on. keyid always is 0 for pairwise key */
 		IVEIV = (KeyIdx << 6) | 0x20;
 	} else {
-		// WEP KeyIdx is default tx key.
+		/* WEP KeyIdx is default tx key. */
 		IVEIV = (KeyIdx << 6);
 	}
 
-	// For key index and ext IV bit, so only need to update the position(offset+3).
+	/* For key index and ext IV bit, so only need to update the position(offset+3). */
 #ifdef RTMP_MAC_PCI
 	RTMP_IO_WRITE8(pAd, offset + 3, IVEIV);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 	RTUSBMultiWrite_OneByte(pAd, offset + 3, &IVEIV);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("RTMPAddWcidAttributeEntry: WCID #%d, KeyIndex #%d, Alg=%s\n",
diff --git a/drivers/staging/rt2860/common/cmm_mac_pci.c b/drivers/staging/rt2860/common/cmm_mac_pci.c
index c920925..3b6f577 100644
--- a/drivers/staging/rt2860/common/cmm_mac_pci.c
+++ b/drivers/staging/rt2860/common/cmm_mac_pci.c
@@ -61,23 +61,23 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 	PRTMP_TX_RING pTxRing;
 	PRTMP_DMABUF pDmaBuf;
 	PNDIS_PACKET pPacket;
-//      PRTMP_REORDERBUF        pReorderBuf;
+/*      PRTMP_REORDERBUF        pReorderBuf; */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocTxRxRingMemory\n"));
 	do {
-		//
-		// Allocate all ring descriptors, include TxD, RxD, MgmtD.
-		// Although each size is different, to prevent cacheline and alignment
-		// issue, I intentional set them all to 64 bytes.
-		//
+		/* */
+		/* Allocate all ring descriptors, include TxD, RxD, MgmtD. */
+		/* Although each size is different, to prevent cacheline and alignment */
+		/* issue, I intentional set them all to 64 bytes. */
+		/* */
 		for (num = 0; num < NUM_OF_TX_RING; num++) {
 			ULONG BufBasePaHigh;
 			ULONG BufBasePaLow;
 			PVOID BufBaseVa;
 
-			//
-			// Allocate Tx ring descriptor's memory (5 TX rings = 4 ACs + 1 HCCA)
-			//
+			/* */
+			/* Allocate Tx ring descriptor's memory (5 TX rings = 4 ACs + 1 HCCA) */
+			/* */
 			pAd->TxDescRing[num].AllocSize =
 			    TX_RING_SIZE * TXD_SIZE;
 			RTMP_AllocateTxDescMemory(pAd, num,
@@ -93,11 +93,11 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 				Status = NDIS_STATUS_RESOURCES;
 				break;
 			}
-			// Zero init this memory block
+			/* Zero init this memory block */
 			NdisZeroMemory(pAd->TxDescRing[num].AllocVa,
 				       pAd->TxDescRing[num].AllocSize);
 
-			// Save PA & VA for further operation
+			/* Save PA & VA for further operation */
 			RingBasePaHigh =
 			    RTMP_GetPhysicalAddressHigh(pAd->TxDescRing[num].
 							AllocPa);
@@ -106,9 +106,9 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 						       AllocPa);
 			RingBaseVa = pAd->TxDescRing[num].AllocVa;
 
-			//
-			// Allocate all 1st TXBuf's memory for this TxRing
-			//
+			/* */
+			/* Allocate all 1st TXBuf's memory for this TxRing */
+			/* */
 			pAd->TxBufSpace[num].AllocSize =
 			    TX_RING_SIZE * TX_DMA_1ST_BUFFER_SIZE;
 			RTMP_AllocateFirstTxBuffer(pAd, num,
@@ -125,11 +125,11 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 				Status = NDIS_STATUS_RESOURCES;
 				break;
 			}
-			// Zero init this memory block
+			/* Zero init this memory block */
 			NdisZeroMemory(pAd->TxBufSpace[num].AllocVa,
 				       pAd->TxBufSpace[num].AllocSize);
 
-			// Save PA & VA for further operation
+			/* Save PA & VA for further operation */
 			BufBasePaHigh =
 			    RTMP_GetPhysicalAddressHigh(pAd->TxBufSpace[num].
 							AllocPa);
@@ -138,14 +138,14 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 						       AllocPa);
 			BufBaseVa = pAd->TxBufSpace[num].AllocVa;
 
-			//
-			// Initialize Tx Ring Descriptor and associated buffer memory
-			//
+			/* */
+			/* Initialize Tx Ring Descriptor and associated buffer memory */
+			/* */
 			pTxRing = &pAd->TxRing[num];
 			for (index = 0; index < TX_RING_SIZE; index++) {
 				pTxRing->Cell[index].pNdisPacket = NULL;
 				pTxRing->Cell[index].pNextNdisPacket = NULL;
-				// Init Tx Ring Size, Va, Pa variables
+				/* Init Tx Ring Size, Va, Pa variables */
 				pTxRing->Cell[index].AllocSize = TXD_SIZE;
 				pTxRing->Cell[index].AllocVa = RingBaseVa;
 				RTMP_SetPhysicalAddressHigh(pTxRing->
@@ -155,7 +155,7 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 							   AllocPa,
 							   RingBasePaLow);
 
-				// Setup Tx Buffer size & address. only 802.11 header will store in this space
+				/* Setup Tx Buffer size & address. only 802.11 header will store in this space */
 				pDmaBuf = &pTxRing->Cell[index].DmaBuf;
 				pDmaBuf->AllocSize = TX_DMA_1ST_BUFFER_SIZE;
 				pDmaBuf->AllocVa = BufBaseVa;
@@ -164,16 +164,16 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 				RTMP_SetPhysicalAddressLow(pDmaBuf->AllocPa,
 							   BufBasePaLow);
 
-				// link the pre-allocated TxBuf to TXD
+				/* link the pre-allocated TxBuf to TXD */
 				pTxD =
 				    (PTXD_STRUC) pTxRing->Cell[index].AllocVa;
 				pTxD->SDPtr0 = BufBasePaLow;
-				// advance to next ring descriptor address
+				/* advance to next ring descriptor address */
 				pTxD->DMADONE = 1;
 				RingBasePaLow += TXD_SIZE;
 				RingBaseVa = (PUCHAR) RingBaseVa + TXD_SIZE;
 
-				// advance to next TxBuf address
+				/* advance to next TxBuf address */
 				BufBasePaLow += TX_DMA_1ST_BUFFER_SIZE;
 				BufBaseVa =
 				    (PUCHAR) BufBaseVa + TX_DMA_1ST_BUFFER_SIZE;
@@ -185,9 +185,9 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 		if (Status == NDIS_STATUS_RESOURCES)
 			break;
 
-		//
-		// Allocate MGMT ring descriptor's memory except Tx ring which allocated eariler
-		//
+		/* */
+		/* Allocate MGMT ring descriptor's memory except Tx ring which allocated eariler */
+		/* */
 		pAd->MgmtDescRing.AllocSize = MGMT_RING_SIZE * TXD_SIZE;
 		RTMP_AllocateMgmtDescMemory(pAd,
 					    pAd->MgmtDescRing.AllocSize,
@@ -201,24 +201,24 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 			Status = NDIS_STATUS_RESOURCES;
 			break;
 		}
-		// Zero init this memory block
+		/* Zero init this memory block */
 		NdisZeroMemory(pAd->MgmtDescRing.AllocVa,
 			       pAd->MgmtDescRing.AllocSize);
 
-		// Save PA & VA for further operation
+		/* Save PA & VA for further operation */
 		RingBasePaHigh =
 		    RTMP_GetPhysicalAddressHigh(pAd->MgmtDescRing.AllocPa);
 		RingBasePaLow =
 		    RTMP_GetPhysicalAddressLow(pAd->MgmtDescRing.AllocPa);
 		RingBaseVa = pAd->MgmtDescRing.AllocVa;
 
-		//
-		// Initialize MGMT Ring and associated buffer memory
-		//
+		/* */
+		/* Initialize MGMT Ring and associated buffer memory */
+		/* */
 		for (index = 0; index < MGMT_RING_SIZE; index++) {
 			pAd->MgmtRing.Cell[index].pNdisPacket = NULL;
 			pAd->MgmtRing.Cell[index].pNextNdisPacket = NULL;
-			// Init MGMT Ring Size, Va, Pa variables
+			/* Init MGMT Ring Size, Va, Pa variables */
 			pAd->MgmtRing.Cell[index].AllocSize = TXD_SIZE;
 			pAd->MgmtRing.Cell[index].AllocVa = RingBaseVa;
 			RTMP_SetPhysicalAddressHigh(pAd->MgmtRing.Cell[index].
@@ -226,22 +226,22 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 			RTMP_SetPhysicalAddressLow(pAd->MgmtRing.Cell[index].
 						   AllocPa, RingBasePaLow);
 
-			// Offset to next ring descriptor address
+			/* Offset to next ring descriptor address */
 			RingBasePaLow += TXD_SIZE;
 			RingBaseVa = (PUCHAR) RingBaseVa + TXD_SIZE;
 
-			// link the pre-allocated TxBuf to TXD
+			/* link the pre-allocated TxBuf to TXD */
 			pTxD = (PTXD_STRUC) pAd->MgmtRing.Cell[index].AllocVa;
 			pTxD->DMADONE = 1;
 
-			// no pre-allocated buffer required in MgmtRing for scatter-gather case
+			/* no pre-allocated buffer required in MgmtRing for scatter-gather case */
 		}
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("MGMT Ring: total %d entry allocated\n", index));
 
-		//
-		// Allocate RX ring descriptor's memory except Tx ring which allocated eariler
-		//
+		/* */
+		/* Allocate RX ring descriptor's memory except Tx ring which allocated eariler */
+		/* */
 		pAd->RxDescRing.AllocSize = RX_RING_SIZE * RXD_SIZE;
 		RTMP_AllocateRxDescMemory(pAd,
 					  pAd->RxDescRing.AllocSize,
@@ -255,7 +255,7 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 			Status = NDIS_STATUS_RESOURCES;
 			break;
 		}
-		// Zero init this memory block
+		/* Zero init this memory block */
 		NdisZeroMemory(pAd->RxDescRing.AllocVa,
 			       pAd->RxDescRing.AllocSize);
 
@@ -263,18 +263,18 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 			 ("RX DESC %p  size = %ld\n", pAd->RxDescRing.AllocVa,
 			  pAd->RxDescRing.AllocSize));
 
-		// Save PA & VA for further operation
+		/* Save PA & VA for further operation */
 		RingBasePaHigh =
 		    RTMP_GetPhysicalAddressHigh(pAd->RxDescRing.AllocPa);
 		RingBasePaLow =
 		    RTMP_GetPhysicalAddressLow(pAd->RxDescRing.AllocPa);
 		RingBaseVa = pAd->RxDescRing.AllocVa;
 
-		//
-		// Initialize Rx Ring and associated buffer memory
-		//
+		/* */
+		/* Initialize Rx Ring and associated buffer memory */
+		/* */
 		for (index = 0; index < RX_RING_SIZE; index++) {
-			// Init RX Ring Size, Va, Pa variables
+			/* Init RX Ring Size, Va, Pa variables */
 			pAd->RxRing.Cell[index].AllocSize = RXD_SIZE;
 			pAd->RxRing.Cell[index].AllocVa = RingBaseVa;
 			RTMP_SetPhysicalAddressHigh(pAd->RxRing.Cell[index].
@@ -282,13 +282,13 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 			RTMP_SetPhysicalAddressLow(pAd->RxRing.Cell[index].
 						   AllocPa, RingBasePaLow);
 
-			//NdisZeroMemory(RingBaseVa, RXD_SIZE);
+			/*NdisZeroMemory(RingBaseVa, RXD_SIZE); */
 
-			// Offset to next ring descriptor address
+			/* Offset to next ring descriptor address */
 			RingBasePaLow += RXD_SIZE;
 			RingBaseVa = (PUCHAR) RingBaseVa + RXD_SIZE;
 
-			// Setup Rx associated Buffer size & allocate share memory
+			/* Setup Rx associated Buffer size & allocate share memory */
 			pDmaBuf = &pAd->RxRing.Cell[index].DmaBuf;
 			pDmaBuf->AllocSize = RX_BUFFER_AGGRESIZE;
 			pPacket = RTMP_AllocateRxPacketBuffer(pAd,
@@ -301,17 +301,17 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 			/* keep allocated rx packet */
 			pAd->RxRing.Cell[index].pNdisPacket = pPacket;
 
-			// Error handling
+			/* Error handling */
 			if (pDmaBuf->AllocVa == NULL) {
 				ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
 				DBGPRINT_ERR(("Failed to allocate RxRing's 1st buffer\n"));
 				Status = NDIS_STATUS_RESOURCES;
 				break;
 			}
-			// Zero init this memory block
+			/* Zero init this memory block */
 			NdisZeroMemory(pDmaBuf->AllocVa, pDmaBuf->AllocSize);
 
-			// Write RxD buffer address & allocated buffer length
+			/* Write RxD buffer address & allocated buffer length */
 			pRxD = (PRXD_STRUC) pAd->RxRing.Cell[index].AllocVa;
 			pRxD->SDP0 =
 			    RTMP_GetPhysicalAddressLow(pDmaBuf->AllocPa);
@@ -333,12 +333,12 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 	}
 
 	if (Status != NDIS_STATUS_SUCCESS) {
-		// Log error inforamtion
+		/* Log error inforamtion */
 		NdisWriteErrorLogEntry(pAd->AdapterHandle,
 				       NDIS_ERROR_CODE_OUT_OF_RESOURCES,
 				       1, ErrorValue);
 	}
-	// Following code segment get from original func:NICInitTxRxRingAndBacklogQueue(), now should integrate it to here.
+	/* Following code segment get from original func:NICInitTxRxRingAndBacklogQueue(), now should integrate it to here. */
 	{
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("--> NICInitTxRxRingAndBacklogQueue\n"));
@@ -351,21 +351,21 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 		RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
 */
 
-		// Initialize all transmit related software queues
+		/* Initialize all transmit related software queues */
 		for (index = 0; index < NUM_OF_TX_RING; index++) {
 			InitializeQueueHeader(&pAd->TxSwQueue[index]);
-			// Init TX rings index pointer
+			/* Init TX rings index pointer */
 			pAd->TxRing[index].TxSwFreeIdx = 0;
 			pAd->TxRing[index].TxCpuIdx = 0;
-			//RTMP_IO_WRITE32(pAd, (TX_CTX_IDX0 + i * 0x10) ,  pAd->TxRing[i].TX_CTX_IDX);
+			/*RTMP_IO_WRITE32(pAd, (TX_CTX_IDX0 + i * 0x10) ,  pAd->TxRing[i].TX_CTX_IDX); */
 		}
 
-		// Init RX Ring index pointer
+		/* Init RX Ring index pointer */
 		pAd->RxRing.RxSwReadIdx = 0;
 		pAd->RxRing.RxCpuIdx = RX_RING_SIZE - 1;
-		//RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RX_CRX_IDX0);
+		/*RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RX_CRX_IDX0); */
 
-		// init MGMT ring index pointer
+		/* init MGMT ring index pointer */
 		pAd->MgmtRing.TxSwFreeIdx = 0;
 		pAd->MgmtRing.TxCpuIdx = 0;
 
@@ -409,7 +409,7 @@ VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 	int i;
 	PRTMP_TX_RING pTxRing;
 	unsigned long IrqFlags;
-	//UINT32                        RxSwReadIdx;
+	/*UINT32                        RxSwReadIdx; */
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("RTMPRingCleanUp(RingIdx=%d, Pending-NDIS=%ld)\n", RingType,
@@ -423,13 +423,13 @@ VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 		pTxRing = &pAd->TxRing[RingType];
 
 		RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-		// We have to clean all descriptors in case some error happened with reset
-		for (i = 0; i < TX_RING_SIZE; i++)	// We have to scan all TX ring
+		/* We have to clean all descriptors in case some error happened with reset */
+		for (i = 0; i < TX_RING_SIZE; i++)	/* We have to scan all TX ring */
 		{
 			pTxD = (PTXD_STRUC) pTxRing->Cell[i].AllocVa;
 
 			pPacket = (PNDIS_PACKET) pTxRing->Cell[i].pNdisPacket;
-			// release scatter-and-gather NDIS_PACKET
+			/* release scatter-and-gather NDIS_PACKET */
 			if (pPacket) {
 				RELEASE_NDIS_PACKET(pAd, pPacket,
 						    NDIS_STATUS_FAILURE);
@@ -438,7 +438,7 @@ VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 
 			pPacket =
 			    (PNDIS_PACKET) pTxRing->Cell[i].pNextNdisPacket;
-			// release scatter-and-gather NDIS_PACKET
+			/* release scatter-and-gather NDIS_PACKET */
 			if (pPacket) {
 				RELEASE_NDIS_PACKET(pAd, pPacket,
 						    NDIS_STATUS_FAILURE);
@@ -467,7 +467,7 @@ VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 		break;
 
 	case QID_MGMT:
-		// We have to clean all descriptors in case some error happened with reset
+		/* We have to clean all descriptors in case some error happened with reset */
 		NdisAcquireSpinLock(&pAd->MgmtRingLock);
 
 		for (i = 0; i < MGMT_RING_SIZE; i++) {
@@ -475,7 +475,7 @@ VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 
 			pPacket =
 			    (PNDIS_PACKET) pAd->MgmtRing.Cell[i].pNdisPacket;
-			// rlease scatter-and-gather NDIS_PACKET
+			/* rlease scatter-and-gather NDIS_PACKET */
 			if (pPacket) {
 				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr0,
 						 pTxD->SDLen0,
@@ -488,7 +488,7 @@ VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 			pPacket =
 			    (PNDIS_PACKET) pAd->MgmtRing.Cell[i].
 			    pNextNdisPacket;
-			// release scatter-and-gather NDIS_PACKET
+			/* release scatter-and-gather NDIS_PACKET */
 			if (pPacket) {
 				PCI_UNMAP_SINGLE(pAd, pTxD->SDPtr1,
 						 pTxD->SDLen1,
@@ -510,7 +510,7 @@ VOID RTMPRingCleanUp(IN PRTMP_ADAPTER pAd, IN UCHAR RingType)
 		break;
 
 	case QID_RX:
-		// We have to clean all descriptors in case some error happened with reset
+		/* We have to clean all descriptors in case some error happened with reset */
 		NdisAcquireSpinLock(&pAd->RxRingLock);
 
 		for (i = 0; i < RX_RING_SIZE; i++) {
@@ -541,11 +541,11 @@ VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 	PNDIS_PACKET pPacket;
 	unsigned int IrqFlags;
 
-	//POS_COOKIE pObj =(POS_COOKIE) pAd->OS_Cookie;
+	/*POS_COOKIE pObj =(POS_COOKIE) pAd->OS_Cookie; */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPFreeTxRxRingMemory\n"));
 
-	// Free TxSwQueue Packet
+	/* Free TxSwQueue Packet */
 	for (index = 0; index < NUM_OF_TX_RING; index++) {
 		PQUEUE_ENTRY pEntry;
 		PNDIS_PACKET pPacket;
@@ -561,7 +561,7 @@ VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
 	}
 
-	// Free Tx Ring Packet
+	/* Free Tx Ring Packet */
 	for (index = 0; index < NUM_OF_TX_RING; index++) {
 		pTxRing = &pAd->TxRing[index];
 
@@ -576,7 +576,7 @@ VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 				RELEASE_NDIS_PACKET(pAd, pPacket,
 						    NDIS_STATUS_SUCCESS);
 			}
-			//Always assign pNdisPacket as NULL after clear
+			/*Always assign pNdisPacket as NULL after clear */
 			pTxRing->Cell[j].pNdisPacket = NULL;
 
 			pPacket = pTxRing->Cell[j].pNextNdisPacket;
@@ -588,7 +588,7 @@ VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 				RELEASE_NDIS_PACKET(pAd, pPacket,
 						    NDIS_STATUS_SUCCESS);
 			}
-			//Always assign pNextNdisPacket as NULL after clear
+			/*Always assign pNextNdisPacket as NULL after clear */
 			pTxRing->Cell[pTxRing->TxSwFreeIdx].pNextNdisPacket =
 			    NULL;
 
@@ -729,7 +729,7 @@ BOOLEAN AsicCheckCommanOk(IN PRTMP_ADAPTER pAd, IN UCHAR Command)
 	i = 0;
 	do {
 		RTMP_IO_READ32(pAd, H2M_MAILBOX_CID, &CID);
-		// Find where the command is. Because this is randomly specified by firmware.
+		/* Find where the command is. Because this is randomly specified by firmware. */
 		if ((CID & CID0MASK) == Command) {
 			ThisCIDMask = CID0MASK;
 			break;
@@ -748,12 +748,12 @@ BOOLEAN AsicCheckCommanOk(IN PRTMP_ADAPTER pAd, IN UCHAR Command)
 		i++;
 	} while (i < 200);
 
-	// Get CommandStatus Value
+	/* Get CommandStatus Value */
 	RTMP_IO_READ32(pAd, H2M_MAILBOX_STATUS, &CmdStatus);
 
-	// This command's status is at the same position as command. So AND command position's bitmask to read status.
+	/* This command's status is at the same position as command. So AND command position's bitmask to read status. */
 	if (i < 200) {
-		// If Status is 1, the comamnd is success.
+		/* If Status is 1, the comamnd is success. */
 		if (((CmdStatus & ThisCIDMask) == 0x1)
 		    || ((CmdStatus & ThisCIDMask) == 0x100)
 		    || ((CmdStatus & ThisCIDMask) == 0x10000)
@@ -773,7 +773,7 @@ BOOLEAN AsicCheckCommanOk(IN PRTMP_ADAPTER pAd, IN UCHAR Command)
 			 ("--> AsicCheckCommanFail2 Timeout Command = %d, CmdStatus= 0x%x \n",
 			  Command, CmdStatus));
 	}
-	// Clear Command and Status.
+	/* Clear Command and Status. */
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CID, 0xffffffff);
 
@@ -810,10 +810,10 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 		return;
 	}
 
-	//if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE)
-	//      || ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL)
-	//              || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP))
-	//      )
+	/*if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE) */
+	/*      || ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL) */
+	/*              || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP)) */
+	/*      ) */
 	if (bBcnReq == FALSE) {
 		/* when the ra interface is down, do not send its beacon frame */
 		/* clear all zero */
@@ -822,7 +822,7 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 					0x00);
 	} else {
 		ptr = (PUCHAR) & pAd->BeaconTxWI;
-		for (i = 0; i < TXWI_SIZE; i += 4)	// 16-byte TXWI field
+		for (i = 0; i < TXWI_SIZE; i += 4)	/* 16-byte TXWI field */
 		{
 			UINT32 longptr =
 			    *ptr + (*(ptr + 1) << 8) + (*(ptr + 2) << 16) +
@@ -832,7 +832,7 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 			ptr += 4;
 		}
 
-		// Update CapabilityInfo in Beacon
+		/* Update CapabilityInfo in Beacon */
 		for (i = CapInfoPos; i < (CapInfoPos + 2); i++) {
 			RTMP_IO_WRITE8(pAd,
 				       pAd->BeaconOffset[bcn_idx] + TXWI_SIZE +
@@ -871,7 +871,7 @@ VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
 	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
-		// Support PCIe Advance Power Save
+		/* Support PCIe Advance Power Save */
 		if (bFromTx == TRUE && (pAd->Mlme.bPsPollTimerRunning == TRUE)) {
 			pAd->Mlme.bPsPollTimerRunning = FALSE;
 			RTMPPCIeLinkCtrlValueRestore(pAd, RESTORE_WAKEUP);
@@ -885,7 +885,7 @@ VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 
 		if (RT28xxPciAsicRadioOn(pAd, DOT11POWERSAVE)) {
 #ifdef PCIE_PS_SUPPORT
-			// add by johnli, RF power sequence setup, load RF normal operation-mode setup
+			/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
 			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 			    && IS_VERSION_AFTER_F(pAd)) {
 				RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
@@ -894,16 +894,16 @@ VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 					pChipOps->
 					    AsicReverseRfFromSleepMode(pAd);
 			} else
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 			{
-				// end johnli
-				// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
+				/* end johnli */
+				/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
 				if (INFRA_ON(pAd)
 				    && (pAd->CommonCfg.CentralChannel !=
 					pAd->CommonCfg.Channel)
 				    && (pAd->MlmeAux.HtCapability.HtCapInfo.
 					ChannelWidth == BW_40)) {
-					// Must using 40MHz.
+					/* Must using 40MHz. */
 					AsicSwitchChannel(pAd,
 							  pAd->CommonCfg.
 							  CentralChannel,
@@ -912,7 +912,7 @@ VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 							pAd->CommonCfg.
 							CentralChannel);
 				} else {
-					// Must using 20MHz.
+					/* Must using 20MHz. */
 					AsicSwitchChannel(pAd,
 							  pAd->CommonCfg.
 							  Channel, FALSE);
@@ -922,8 +922,8 @@ VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 			}
 		}
 #ifdef PCIE_PS_SUPPORT
-		// 3090 MCU Wakeup command needs more time to be stable.
-		// Before stable, don't issue other MCU command to prevent from firmware error.
+		/* 3090 MCU Wakeup command needs more time to be stable. */
+		/* Before stable, don't issue other MCU command to prevent from firmware error. */
 		if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 		     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
 		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
@@ -934,9 +934,9 @@ VOID RT28xxPciStaAsicForceWakeup(IN PRTMP_ADAPTER pAd, IN BOOLEAN bFromTx)
 			pAd->brt30xxBanMcuCmd = FALSE;
 			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
 		}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 	} else {
-		// PCI, 2860-PCIe
+		/* PCI, 2860-PCIe */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("<==RT28xxPciStaAsicForceWakeup::Original PCI Power Saving\n"));
 		AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
@@ -968,8 +968,8 @@ VOID RT28xxPciStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
 		}
 
 		NdisGetSystemUpTime(&Now);
-		// If last send NULL fram time is too close to this receiving beacon (within 8ms), don't go to sleep for this DTM.
-		// Because Some AP can't queuing outgoing frames immediately.
+		/* If last send NULL fram time is too close to this receiving beacon (within 8ms), don't go to sleep for this DTM. */
+		/* Because Some AP can't queuing outgoing frames immediately. */
 		if (((pAd->Mlme.LastSendNULLpsmTime + 8) >= Now)
 		    && (pAd->Mlme.LastSendNULLpsmTime <= Now)) {
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -995,11 +995,11 @@ VOID RT28xxPciStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
 			OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
 	} else {
 		AUTO_WAKEUP_STRUC AutoWakeupCfg;
-		// we have decided to SLEEP, so at least do it for a BEACON period.
+		/* we have decided to SLEEP, so at least do it for a BEACON period. */
 		if (TbttNumToNextWakeUp == 0)
 			TbttNumToNextWakeUp = 1;
 
-		//RTMP_IO_WRITE32(pAd, INT_MASK_CSR, AutoWakeupInt);
+		/*RTMP_IO_WRITE32(pAd, INT_MASK_CSR, AutoWakeupInt); */
 
 		AutoWakeupCfg.word = 0;
 		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
@@ -1007,7 +1007,7 @@ VOID RT28xxPciStaAsicSleepThenAutoWakeup(IN PRTMP_ADAPTER pAd,
 		AutoWakeupCfg.field.EnableAutoWakeup = 1;
 		AutoWakeupCfg.field.AutoLeadTime = 5;
 		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-		AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x00);	// send POWER-SAVE command to MCU. Timeout 40us.
+		AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x00);	/* send POWER-SAVE command to MCU. Timeout 40us. */
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_DOZE);
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("<-- %s, TbttNumToNextWakeUp=%d \n", __func__,
@@ -1031,8 +1031,8 @@ VOID PsPollWakeExec(IN PVOID SystemSpecific1,
 	pAd->Mlme.bPsPollTimerRunning = FALSE;
 	RTMP_INT_UNLOCK(&pAd->irq_lock, flags);
 #ifdef PCIE_PS_SUPPORT
-	// For rt30xx power solution 3, Use software timer to wake up in psm. So call
-	// AsicForceWakeup here instead of handling twakeup interrupt.
+	/* For rt30xx power solution 3, Use software timer to wake up in psm. So call */
+	/* AsicForceWakeup here instead of handling twakeup interrupt. */
 	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 	     && IS_VERSION_AFTER_F(pAd))
 	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
@@ -1041,7 +1041,7 @@ VOID PsPollWakeExec(IN PVOID SystemSpecific1,
 			 ("<--PsPollWakeExec::3090 calls AsicForceWakeup(pAd, DOT11POWERSAVE) in advance \n"));
 		AsicForceWakeup(pAd, DOT11POWERSAVE);
 	}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 }
 
 VOID RadioOnExec(IN PVOID SystemSpecific1,
@@ -1056,12 +1056,12 @@ VOID RadioOnExec(IN PVOID SystemSpecific1,
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("-->RadioOnExec() return on fOP_STATUS_DOZE == TRUE; \n"));
-//KH Debug: Add the compile flag "RT2860 and condition
+/*KH Debug: Add the compile flag "RT2860 and condition */
 #ifdef RTMP_PCI_SUPPORT
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
 		    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
 			RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-#endif // RTMP_PCI_SUPPORT //
+#endif /* RTMP_PCI_SUPPORT // */
 		return;
 	}
 
@@ -1072,17 +1072,17 @@ VOID RadioOnExec(IN PVOID SystemSpecific1,
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
 		    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
 			RTMPSetTimer(&pAd->Mlme.RadioOnOffTimer, 10);
-#endif // RTMP_PCI_SUPPORT //
+#endif /* RTMP_PCI_SUPPORT // */
 		return;
 	}
-//KH Debug: need to check. I add the compile flag "CONFIG_STA_SUPPORT" to enclose the following codes.
+/*KH Debug: need to check. I add the compile flag "CONFIG_STA_SUPPORT" to enclose the following codes. */
 #ifdef RTMP_PCI_SUPPORT
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
 	    && pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
 		pAd->Mlme.bPsPollTimerRunning = FALSE;
 		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
 	}
-#endif // RTMP_PCI_SUPPORT //
+#endif /* RTMP_PCI_SUPPORT // */
 	if (pAd->StaCfg.bRadio == TRUE) {
 		pAd->bPCIclkOff = FALSE;
 		RTMPRingCleanUp(pAd, QID_AC_BK);
@@ -1092,42 +1092,42 @@ VOID RadioOnExec(IN PVOID SystemSpecific1,
 		RTMPRingCleanUp(pAd, QID_MGMT);
 		RTMPRingCleanUp(pAd, QID_RX);
 
-		// 2. Send wake up command.
+		/* 2. Send wake up command. */
 		AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x02);
-		// 2-1. wait command ok.
+		/* 2-1. wait command ok. */
 		AsicCheckCommanOk(pAd, PowerWakeCID);
 
-		// When PCI clock is off, don't want to service interrupt. So when back to clock on, enable interrupt.
-		//RTMP_IO_WRITE32(pAd, INT_MASK_CSR, (DELAYINTMASK|RxINT));
+		/* When PCI clock is off, don't want to service interrupt. So when back to clock on, enable interrupt. */
+		/*RTMP_IO_WRITE32(pAd, INT_MASK_CSR, (DELAYINTMASK|RxINT)); */
 		RTMP_ASIC_INTERRUPT_ENABLE(pAd);
 
-		// 3. Enable Tx DMA.
+		/* 3. Enable Tx DMA. */
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &DmaCfg.word);
 		DmaCfg.field.EnableTxDMA = 1;
 		RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, DmaCfg.word);
 
-		// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
+		/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
 		if (INFRA_ON(pAd)
 		    && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
 		    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth ==
 			BW_40)) {
-			// Must using 40MHz.
+			/* Must using 40MHz. */
 			AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel,
 					  FALSE);
 			AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
 		} else {
-			// Must using 20MHz.
+			/* Must using 20MHz. */
 			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
 		}
 
-//KH Debug:The following codes should be enclosed by RT3090 compile flag
+/*KH Debug:The following codes should be enclosed by RT3090 compile flag */
 		if (pChipOps->AsicReverseRfFromSleepMode)
 			pChipOps->AsicReverseRfFromSleepMode(pAd);
 
 #ifdef PCIE_PS_SUPPORT
-// 3090 MCU Wakeup command needs more time to be stable.
-// Before stable, don't issue other MCU command to prevent from firmware error.
+/* 3090 MCU Wakeup command needs more time to be stable. */
+/* Before stable, don't issue other MCU command to prevent from firmware error. */
 		if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 		    && IS_VERSION_AFTER_F(pAd)
 		    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
@@ -1136,12 +1136,12 @@ VOID RadioOnExec(IN PVOID SystemSpecific1,
 			pAd->brt30xxBanMcuCmd = FALSE;
 			RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
 		}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 
-		// Clear Radio off flag
+		/* Clear Radio off flag */
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
-		// Set LED
+		/* Set LED */
 		RTMPSetLED(pAd, LED_RADIO_ON);
 
 		if (pAd->StaCfg.Psm == PWR_ACTIVE) {
@@ -1166,9 +1166,9 @@ VOID RadioOnExec(IN PVOID SystemSpecific1,
  */
 BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 {
-	//WPDMA_GLO_CFG_STRUC       DmaCfg;
+	/*WPDMA_GLO_CFG_STRUC       DmaCfg; */
 	BOOLEAN Cancelled;
-	//UINT32                        MACValue;
+	/*UINT32                        MACValue; */
 
 	if (pAd->OpMode == OPMODE_AP && Level == DOT11POWERSAVE)
 		return FALSE;
@@ -1181,8 +1181,8 @@ BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 		if ((pAd->StaCfg.PSControl.field.EnableNewPS == TRUE &&
 		     (Level == GUIRADIO_OFF || Level == GUI_IDLE_POWER_SAVE)) ||
 		    RTMP_TEST_PSFLAG(pAd, fRTMP_PS_SET_PCI_CLK_OFF_COMMAND)) {
-			// Some chips don't need to delay 6ms, so copy RTMPPCIePowerLinkCtrlRestore
-			// return condition here.
+			/* Some chips don't need to delay 6ms, so copy RTMPPCIePowerLinkCtrlRestore */
+			/* return condition here. */
 			/*
 			   if (((pAd->MACVersion&0xffff0000) != 0x28600000)
 			   && ((pAd->DeviceID == NIC2860_PCIe_DEVICE_ID)
@@ -1191,7 +1191,7 @@ BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 			{
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("RT28xxPciAsicRadioOn ()\n"));
-				// 1. Set PCI Link Control in Configuration Space.
+				/* 1. Set PCI Link Control in Configuration Space. */
 				RTMPPCIeLinkCtrlValueRestore(pAd,
 							     RESTORE_WAKEUP);
 				RTMPusecDelay(6000);
@@ -1204,16 +1204,16 @@ BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 	      && IS_VERSION_AFTER_F(pAd)
 	      && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
 	      && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE))))
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 	{
 		pAd->bPCIclkOff = FALSE;
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("PSM :309xbPCIclkOff == %d\n", pAd->bPCIclkOff));
 	}
-	// 2. Send wake up command.
+	/* 2. Send wake up command. */
 	AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x02);
 	pAd->bPCIclkOff = FALSE;
-	// 2-1. wait command ok.
+	/* 2-1. wait command ok. */
 	AsicCheckCommanOk(pAd, PowerWakeCID);
 	RTMP_ASIC_INTERRUPT_ENABLE(pAd);
 
@@ -1221,14 +1221,14 @@ BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 	if (Level == GUI_IDLE_POWER_SAVE) {
 #ifdef  PCIE_PS_SUPPORT
 
-		// add by johnli, RF power sequence setup, load RF normal operation-mode setup
+		/* add by johnli, RF power sequence setup, load RF normal operation-mode setup */
 		if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
 			RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 
 			if (pChipOps->AsicReverseRfFromSleepMode)
 				pChipOps->AsicReverseRfFromSleepMode(pAd);
-			// 3090 MCU Wakeup command needs more time to be stable.
-			// Before stable, don't issue other MCU command to prevent from firmware error.
+			/* 3090 MCU Wakeup command needs more time to be stable. */
+			/* Before stable, don't issue other MCU command to prevent from firmware error. */
 			if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 			    && IS_VERSION_AFTER_F(pAd)
 			    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode ==
@@ -1240,17 +1240,17 @@ BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 				RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
 			}
 		} else
-			// end johnli
-#endif // PCIE_PS_SUPPORT //
+			/* end johnli */
+#endif /* PCIE_PS_SUPPORT // */
 		{
-			// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
+			/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
 			{
 				if (INFRA_ON(pAd)
 				    && (pAd->CommonCfg.CentralChannel !=
 					pAd->CommonCfg.Channel)
 				    && (pAd->MlmeAux.HtCapability.HtCapInfo.
 					ChannelWidth == BW_40)) {
-					// Must using 40MHz.
+					/* Must using 40MHz. */
 					AsicSwitchChannel(pAd,
 							  pAd->CommonCfg.
 							  CentralChannel,
@@ -1259,7 +1259,7 @@ BOOLEAN RT28xxPciAsicRadioOn(IN PRTMP_ADAPTER pAd, IN UCHAR Level)
 							pAd->CommonCfg.
 							CentralChannel);
 				} else {
-					// Must using 20MHz.
+					/* Must using 20MHz. */
 					AsicSwitchChannel(pAd,
 							  pAd->CommonCfg.
 							  Channel, FALSE);
@@ -1304,7 +1304,7 @@ BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
 	if (pAd->OpMode == OPMODE_AP && Level == DOT11POWERSAVE)
 		return FALSE;
 
-	// Check Rx DMA busy status, if more than half is occupied, give up this radio off.
+	/* Check Rx DMA busy status, if more than half is occupied, give up this radio off. */
 	RTMP_IO_READ32(pAd, RX_DRX_IDX, &RxDmaIdx);
 	RTMP_IO_READ32(pAd, RX_CRX_IDX, &RxCpuIdx);
 	if ((RxDmaIdx > RxCpuIdx) && ((RxDmaIdx - RxCpuIdx) > RX_RING_SIZE / 3)) {
@@ -1319,8 +1319,8 @@ BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
 			  RxCpuIdx, RxDmaIdx));
 		return FALSE;
 	}
-	// Once go into this function, disable tx because don't want too many packets in queue to prevent HW stops.
-	//pAd->bPCIclkOffDisableTx = TRUE;
+	/* Once go into this function, disable tx because don't want too many packets in queue to prevent HW stops. */
+	/*pAd->bPCIclkOffDisableTx = TRUE; */
 	RTMP_SET_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)
 	    && pAd->OpMode == OPMODE_STA
@@ -1331,15 +1331,15 @@ BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
 		if (Level == DOT11POWERSAVE) {
 			RTMP_IO_READ32(pAd, TBTT_TIMER, &TbTTTime);
 			TbTTTime &= 0x1ffff;
-			// 00. check if need to do sleep in this DTIM period.   If next beacon will arrive within 30ms , ...doesn't necessarily sleep.
-			// TbTTTime uint = 64us, LEAD_TIME unit = 1024us, PsPollTime unit = 1ms
+			/* 00. check if need to do sleep in this DTIM period.   If next beacon will arrive within 30ms , ...doesn't necessarily sleep. */
+			/* TbTTTime uint = 64us, LEAD_TIME unit = 1024us, PsPollTime unit = 1ms */
 			if (((64 * TbTTTime) < ((LEAD_TIME * 1024) + 40000))
 			    && (TbttNumToNextWakeUp == 0)) {
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("TbTTTime = 0x%x , give up this sleep. \n",
 					  TbTTTime));
 				OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-				//pAd->bPCIclkOffDisableTx = FALSE;
+				/*pAd->bPCIclkOffDisableTx = FALSE; */
 				RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
 				return FALSE;
 			} else {
@@ -1355,7 +1355,7 @@ BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
 					EnableNewPS == TRUE)) {
 					PsPollTime -= 5;
 				} else
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 					PsPollTime -= 3;
 
 				BeaconPeriodTime =
@@ -1379,52 +1379,52 @@ BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
 
-	// Set to 1R.
+	/* Set to 1R. */
 	if (pAd->Antenna.field.RxPath > 1 && pAd->OpMode == OPMODE_STA) {
 		tempBBP_R3 = (pAd->StaCfg.BBPR3 & 0xE7);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, tempBBP_R3);
 	}
-	// In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again.
+	/* In Radio Off, we turn off RF clk, So now need to call ASICSwitchChannel again. */
 	if ((INFRA_ON(pAd) || pAd->OpMode == OPMODE_AP)
 	    && (pAd->CommonCfg.CentralChannel != pAd->CommonCfg.Channel)
 	    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)) {
-		// Must using 40MHz.
+		/* Must using 40MHz. */
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.CentralChannel);
 	} else {
-		// Must using 20MHz.
+		/* Must using 20MHz. */
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
 	}
 
 	if (Level != RTMP_HALT) {
-		// Change Interrupt bitmask.
-		// When PCI clock is off, don't want to service interrupt.
+		/* Change Interrupt bitmask. */
+		/* When PCI clock is off, don't want to service interrupt. */
 		RTMP_IO_WRITE32(pAd, INT_MASK_CSR, AutoWakeupInt);
 	} else {
 		RTMP_ASIC_INTERRUPT_DISABLE(pAd);
 	}
 
 	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
-	//  2. Send Sleep command
+	/*  2. Send Sleep command */
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_STATUS, 0xffffffff);
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CID, 0xffffffff);
-	// send POWER-SAVE command to MCU. high-byte = 1 save power as much as possible. high byte = 0 save less power
+	/* send POWER-SAVE command to MCU. high-byte = 1 save power as much as possible. high byte = 0 save less power */
 	AsicSendCommandToMcu(pAd, 0x30, PowerSafeCID, 0xff, 0x1);
-	//  2-1. Wait command success
-	// Status = 1 : success, Status = 2, already sleep, Status = 3, Maybe MAC is busy so can't finish this task.
+	/*  2-1. Wait command success */
+	/* Status = 1 : success, Status = 2, already sleep, Status = 3, Maybe MAC is busy so can't finish this task. */
 	brc = AsicCheckCommanOk(pAd, PowerSafeCID);
 
-	//  3. After 0x30 command is ok, send radio off command. lowbyte = 0 for power safe.
-	// If 0x30 command is not ok this time, we can ignore 0x35 command. It will make sure not cause firmware'r problem.
+	/*  3. After 0x30 command is ok, send radio off command. lowbyte = 0 for power safe. */
+	/* If 0x30 command is not ok this time, we can ignore 0x35 command. It will make sure not cause firmware'r problem. */
 	if ((Level == DOT11POWERSAVE) && (brc == TRUE)) {
-		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 0, 0x00);	// lowbyte = 0 means to do power safe, NOT turn off radio.
-		//  3-1. Wait command success
+		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 0, 0x00);	/* lowbyte = 0 means to do power safe, NOT turn off radio. */
+		/*  3-1. Wait command success */
 		AsicCheckCommanOk(pAd, PowerRadioOffCID);
 	} else if (brc == TRUE) {
-		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 1, 0x00);	// lowbyte = 0 means to do power safe, NOT turn off radio.
-		//  3-1. Wait command success
+		AsicSendCommandToMcu(pAd, 0x35, PowerRadioOffCID, 1, 0x00);	/* lowbyte = 0 means to do power safe, NOT turn off radio. */
+		/*  3-1. Wait command success */
 		AsicCheckCommanOk(pAd, PowerRadioOffCID);
 	}
-	// 1. Wait DMA not busy
+	/* 1. Wait DMA not busy */
 	i = 0;
 	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &DmaCfg.word);
@@ -1446,10 +1446,10 @@ BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
 	   pAd->CheckDmaBusyCount = 0;
 	   }
 	 */
-//KH Debug:My original codes have the follwoing codes, but currecnt codes do not have it.
-// Disable for stability. If PCIE Link Control is modified for advance power save, re-covery this code segment.
+/*KH Debug:My original codes have the follwoing codes, but currecnt codes do not have it. */
+/* Disable for stability. If PCIE Link Control is modified for advance power save, re-covery this code segment. */
 	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0x1280);
-//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_CLKSELECT_40MHZ);
+/*OPSTATUS_SET_FLAG(pAd, fOP_STATUS_CLKSELECT_40MHZ); */
 
 #ifdef PCIE_PS_SUPPORT
 	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
@@ -1460,39 +1460,39 @@ BOOLEAN RT28xxPciAsicRadioOff(IN PRTMP_ADAPTER pAd,
 			 ("RT28xxPciAsicRadioOff::3090 return to skip the following TbttNumToNextWakeUp setting for 279x\n"));
 		pAd->bPCIclkOff = TRUE;
 		RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
-		// For this case, doesn't need to below actions, so return here.
+		/* For this case, doesn't need to below actions, so return here. */
 		return brc;
 	}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 
 	if (Level == DOT11POWERSAVE) {
 		AUTO_WAKEUP_STRUC AutoWakeupCfg;
-		//RTMPSetTimer(&pAd->Mlme.PsPollTimer, 90);
+		/*RTMPSetTimer(&pAd->Mlme.PsPollTimer, 90); */
 
-		// we have decided to SLEEP, so at least do it for a BEACON period.
+		/* we have decided to SLEEP, so at least do it for a BEACON period. */
 		if (TbttNumToNextWakeUp == 0)
 			TbttNumToNextWakeUp = 1;
 
 		AutoWakeupCfg.word = 0;
 		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
 
-		// 1. Set auto wake up timer.
+		/* 1. Set auto wake up timer. */
 		AutoWakeupCfg.field.NumofSleepingTbtt = TbttNumToNextWakeUp - 1;
 		AutoWakeupCfg.field.EnableAutoWakeup = 1;
 		AutoWakeupCfg.field.AutoLeadTime = LEAD_TIME;
 		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
 	}
-	//  4-1. If it's to disable our device. Need to restore PCI Configuration Space to its original value.
+	/*  4-1. If it's to disable our device. Need to restore PCI Configuration Space to its original value. */
 	if (Level == RTMP_HALT && pAd->OpMode == OPMODE_STA) {
 		if ((brc == TRUE) && (i < 50))
 			RTMPPCIeLinkCtrlSetting(pAd, 1);
 	}
-	//  4. Set PCI configuration Space Link Comtrol fields.  Only Radio Off needs to call this function
+	/*  4. Set PCI configuration Space Link Comtrol fields.  Only Radio Off needs to call this function */
 	else if (pAd->OpMode == OPMODE_STA) {
 		if ((brc == TRUE) && (i < 50))
 			RTMPPCIeLinkCtrlSetting(pAd, 3);
 	}
-	//pAd->bPCIclkOffDisableTx = FALSE;
+	/*pAd->bPCIclkOffDisableTx = FALSE; */
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_DISABLE_TX);
 	return TRUE;
 }
@@ -1511,7 +1511,7 @@ VOID RT28xxPciMlmeRadioOn(IN PRTMP_ADAPTER pAd)
 					    || pAd->StaCfg.PSControl.field.
 					    EnableNewPS == FALSE))) {
 		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
-		//NICResetFromError(pAd);
+		/*NICResetFromError(pAd); */
 
 		RTMPRingCleanUp(pAd, QID_AC_BK);
 		RTMPRingCleanUp(pAd, QID_AC_BE);
@@ -1520,15 +1520,15 @@ VOID RT28xxPciMlmeRadioOn(IN PRTMP_ADAPTER pAd)
 		RTMPRingCleanUp(pAd, QID_MGMT);
 		RTMPRingCleanUp(pAd, QID_RX);
 
-		// Enable Tx/Rx
+		/* Enable Tx/Rx */
 		RTMPEnableRxTx(pAd);
 
-		// Clear Radio off flag
+		/* Clear Radio off flag */
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
 
-		// Set LED
+		/* Set LED */
 		RTMPSetLED(pAd, LED_RADIO_ON);
 	}
 
@@ -1553,7 +1553,7 @@ VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 		return;
 
-	// Link down first if any association exists
+	/* Link down first if any association exists */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		if (INFRA_ON(pAd) || ADHOC_ON(pAd)) {
 			MLME_DISASSOC_REQ_STRUCT DisReq;
@@ -1584,7 +1584,7 @@ VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 
 	DBGPRINT(RT_DEBUG_TRACE, ("%s===>\n", __func__));
 
-	// Set Radio off flag
+	/* Set Radio off flag */
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
 	{
@@ -1597,13 +1597,13 @@ VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 				RTMP_CLEAR_FLAG(pAd,
 						fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
 			}
-			// If during power safe mode.
+			/* If during power safe mode. */
 			if (pAd->StaCfg.bRadio == TRUE) {
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("-->MlmeRadioOff() return on bRadio == TRUE; \n"));
 				return;
 			}
-			// Always radio on since the NIC needs to set the MCU command (LED_RADIO_OFF).
+			/* Always radio on since the NIC needs to set the MCU command (LED_RADIO_OFF). */
 			if (IDLE_ON(pAd) &&
 			    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)))
 			{
@@ -1618,12 +1618,12 @@ VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 						&Cancelled);
 			}
 		}
-		// Link down first if any association exists
+		/* Link down first if any association exists */
 		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
 			LinkDown(pAd, FALSE);
 		RTMPusecDelay(10000);
-		//==========================================
-		// Clean up old bss table
+		/*========================================== */
+		/* Clean up old bss table */
 		BssTableInit(&pAd->ScanTab);
 
 		/*
@@ -1635,12 +1635,12 @@ VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 		 */
 	}
 
-	// Set LED.Move to here for fixing LED bug. This flag must be called after LinkDown
+	/* Set LED.Move to here for fixing LED bug. This flag must be called after LinkDown */
 	RTMPSetLED(pAd, LED_RADIO_OFF);
 
-//KH Debug:All PCIe devices need to use timer to execute radio off function, or the PCIe&&EnableNewPS needs.
-//KH Ans:It is right, because only when the PCIe and EnableNewPs is true, we need to delay the RadioOffTimer
-//to avoid the deadlock with PCIe Power saving function.
+/*KH Debug:All PCIe devices need to use timer to execute radio off function, or the PCIe&&EnableNewPS needs. */
+/*KH Ans:It is right, because only when the PCIe and EnableNewPs is true, we need to delay the RadioOffTimer */
+/*to avoid the deadlock with PCIe Power saving function. */
 	if (pAd->OpMode == OPMODE_STA &&
 	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE) &&
 	    pAd->StaCfg.PSControl.field.EnableNewPS == TRUE) {
@@ -1658,4 +1658,4 @@ VOID RT28xxPciMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 */
 }
 
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
diff --git a/drivers/staging/rt2860/common/cmm_mac_usb.c b/drivers/staging/rt2860/common/cmm_mac_usb.c
index e537455..70e47db 100644
--- a/drivers/staging/rt2860/common/cmm_mac_usb.c
+++ b/drivers/staging/rt2860/common/cmm_mac_usb.c
@@ -57,22 +57,22 @@ NDIS_STATUS NICInitRecv(IN PRTMP_ADAPTER pAd)
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitRecv\n"));
 	pObj = pObj;
 
-	//InterlockedExchange(&pAd->PendingRx, 0);
+	/*InterlockedExchange(&pAd->PendingRx, 0); */
 	pAd->PendingRx = 0;
-	pAd->NextRxBulkInReadIndex = 0;	// Next Rx Read index
-	pAd->NextRxBulkInIndex = 0;	//RX_RING_SIZE -1; // Rx Bulk pointer
+	pAd->NextRxBulkInReadIndex = 0;	/* Next Rx Read index */
+	pAd->NextRxBulkInIndex = 0;	/*RX_RING_SIZE -1; // Rx Bulk pointer */
 	pAd->NextRxBulkInPosition = 0;
 
 	for (i = 0; i < (RX_RING_SIZE); i++) {
 		PRX_CONTEXT pRxContext = &(pAd->RxContext[i]);
 
-		//Allocate URB
+		/*Allocate URB */
 		pRxContext->pUrb = RTUSB_ALLOC_URB(0);
 		if (pRxContext->pUrb == NULL) {
 			Status = NDIS_STATUS_RESOURCES;
 			goto out1;
 		}
-		// Allocate transfer buffer
+		/* Allocate transfer buffer */
 		pRxContext->TransferBuffer =
 		    RTUSB_URB_ALLOC_BUFFER(pObj->pUsb_Dev, MAX_RXBULK_SIZE,
 					   &pRxContext->data_dma);
@@ -88,7 +88,7 @@ NDIS_STATUS NICInitRecv(IN PRTMP_ADAPTER pAd)
 		pRxContext->InUse = FALSE;
 		pRxContext->IRPPending = FALSE;
 		pRxContext->Readable = FALSE;
-		//pRxContext->ReorderInUse = FALSE;
+		/*pRxContext->ReorderInUse = FALSE; */
 		pRxContext->bRxHandling = FALSE;
 		pRxContext->BulkInOffset = 0;
 	}
@@ -165,44 +165,44 @@ NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 	PTX_CONTEXT pPsPollContext = &(pAd->PsPollContext);
 	PTX_CONTEXT pRTSContext = &(pAd->RTSContext);
 	PTX_CONTEXT pMLMEContext = NULL;
-//      PHT_TX_CONTEXT  pHTTXContext = NULL;
+/*      PHT_TX_CONTEXT  pHTTXContext = NULL; */
 	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
 	PVOID RingBaseVa;
-//      RTMP_TX_RING    *pTxRing;
+/*      RTMP_TX_RING    *pTxRing; */
 	RTMP_MGMT_RING *pMgmtRing;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitTransmit\n"));
 	pObj = pObj;
 
-	// Init 4 set of Tx parameters
+	/* Init 4 set of Tx parameters */
 	for (acidx = 0; acidx < NUM_OF_TX_RING; acidx++) {
-		// Initialize all Transmit releated queues
+		/* Initialize all Transmit releated queues */
 		InitializeQueueHeader(&pAd->TxSwQueue[acidx]);
 
-		// Next Local tx ring pointer waiting for buck out
+		/* Next Local tx ring pointer waiting for buck out */
 		pAd->NextBulkOutIndex[acidx] = acidx;
-		pAd->BulkOutPending[acidx] = FALSE;	// Buck Out control flag
-		//pAd->DataBulkDoneIdx[acidx] = 0;
+		pAd->BulkOutPending[acidx] = FALSE;	/* Buck Out control flag */
+		/*pAd->DataBulkDoneIdx[acidx] = 0; */
 	}
 
-	//pAd->NextMLMEIndex    = 0;
-	//pAd->PushMgmtIndex    = 0;
-	//pAd->PopMgmtIndex     = 0;
-	//InterlockedExchange(&pAd->MgmtQueueSize, 0);
-	//InterlockedExchange(&pAd->TxCount, 0);
+	/*pAd->NextMLMEIndex    = 0; */
+	/*pAd->PushMgmtIndex    = 0; */
+	/*pAd->PopMgmtIndex     = 0; */
+	/*InterlockedExchange(&pAd->MgmtQueueSize, 0); */
+	/*InterlockedExchange(&pAd->TxCount, 0); */
 
-	//pAd->PrioRingFirstIndex       = 0;
-	//pAd->PrioRingTxCnt            = 0;
+	/*pAd->PrioRingFirstIndex       = 0; */
+	/*pAd->PrioRingTxCnt            = 0; */
 
 	do {
-		//
-		// TX_RING_SIZE, 4 ACs
-		//
+		/* */
+		/* TX_RING_SIZE, 4 ACs */
+		/* */
 		for (acidx = 0; acidx < 4; acidx++) {
 			PHT_TX_CONTEXT pHTTXContext = &(pAd->TxContext[acidx]);
 
 			NdisZeroMemory(pHTTXContext, sizeof(HT_TX_CONTEXT));
-			//Allocate URB
+			/*Allocate URB */
 			LM_USB_ALLOC(pObj, pHTTXContext, PHTTX_BUFFER,
 				     sizeof(HTTX_BUFFER), Status,
 				     ("<-- ERROR in Alloc TX TxContext[%d] urb!! \n",
@@ -226,11 +226,11 @@ NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 			pAd->BulkOutPending[acidx] = FALSE;
 		}
 
-		//
-		// MGMT_RING_SIZE
-		//
+		/* */
+		/* MGMT_RING_SIZE */
+		/* */
 
-		// Allocate MGMT ring descriptor's memory
+		/* Allocate MGMT ring descriptor's memory */
 		pAd->MgmtDescRing.AllocSize =
 		    MGMT_RING_SIZE * sizeof(TX_CONTEXT);
 		os_alloc_mem(pAd, (PUCHAR *) (&pAd->MgmtDescRing.AllocVa),
@@ -244,16 +244,16 @@ NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 			       pAd->MgmtDescRing.AllocSize);
 		RingBaseVa = pAd->MgmtDescRing.AllocVa;
 
-		// Initialize MGMT Ring and associated buffer memory
+		/* Initialize MGMT Ring and associated buffer memory */
 		pMgmtRing = &pAd->MgmtRing;
 		for (i = 0; i < MGMT_RING_SIZE; i++) {
-			// link the pre-allocated Mgmt buffer to MgmtRing.Cell
+			/* link the pre-allocated Mgmt buffer to MgmtRing.Cell */
 			pMgmtRing->Cell[i].AllocSize = sizeof(TX_CONTEXT);
 			pMgmtRing->Cell[i].AllocVa = RingBaseVa;
 			pMgmtRing->Cell[i].pNdisPacket = NULL;
 			pMgmtRing->Cell[i].pNextNdisPacket = NULL;
 
-			//Allocate URB for MLMEContext
+			/*Allocate URB for MLMEContext */
 			pMLMEContext =
 			    (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
 			pMLMEContext->pUrb = RTUSB_ALLOC_URB(0);
@@ -273,27 +273,27 @@ NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 			pMLMEContext->BulkOutSize = 0;
 			pMLMEContext->SelfIdx = i;
 
-			// Offset to next ring descriptor address
+			/* Offset to next ring descriptor address */
 			RingBaseVa = (PUCHAR) RingBaseVa + sizeof(TX_CONTEXT);
 		}
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("MGMT Ring: total %d entry allocated\n", i));
 
-		//pAd->MgmtRing.TxSwFreeIdx = (MGMT_RING_SIZE - 1);
+		/*pAd->MgmtRing.TxSwFreeIdx = (MGMT_RING_SIZE - 1); */
 		pAd->MgmtRing.TxSwFreeIdx = MGMT_RING_SIZE;
 		pAd->MgmtRing.TxCpuIdx = 0;
 		pAd->MgmtRing.TxDmaIdx = 0;
 
-		//
-		// BEACON_RING_SIZE
-		//
-		for (i = 0; i < BEACON_RING_SIZE; i++)	// 2
+		/* */
+		/* BEACON_RING_SIZE */
+		/* */
+		for (i = 0; i < BEACON_RING_SIZE; i++)	/* 2 */
 		{
 			PTX_CONTEXT pBeaconContext = &(pAd->BeaconContext[i]);
 
 			NdisZeroMemory(pBeaconContext, sizeof(TX_CONTEXT));
 
-			//Allocate URB
+			/*Allocate URB */
 			LM_USB_ALLOC(pObj, pBeaconContext, PTX_BUFFER,
 				     sizeof(TX_BUFFER), Status,
 				     ("<-- ERROR in Alloc TX BeaconContext[%d] urb!! \n",
@@ -307,12 +307,12 @@ NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 			pBeaconContext->IRPPending = FALSE;
 		}
 
-		//
-		// NullContext
-		//
+		/* */
+		/* NullContext */
+		/* */
 		NdisZeroMemory(pNullContext, sizeof(TX_CONTEXT));
 
-		//Allocate URB
+		/*Allocate URB */
 		LM_USB_ALLOC(pObj, pNullContext, PTX_BUFFER, sizeof(TX_BUFFER),
 			     Status,
 			     ("<-- ERROR in Alloc TX NullContext urb!! \n"),
@@ -325,12 +325,12 @@ NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 		pNullContext->InUse = FALSE;
 		pNullContext->IRPPending = FALSE;
 
-		//
-		// RTSContext
-		//
+		/* */
+		/* RTSContext */
+		/* */
 		NdisZeroMemory(pRTSContext, sizeof(TX_CONTEXT));
 
-		//Allocate URB
+		/*Allocate URB */
 		LM_USB_ALLOC(pObj, pRTSContext, PTX_BUFFER, sizeof(TX_BUFFER),
 			     Status,
 			     ("<-- ERROR in Alloc TX RTSContext urb!! \n"),
@@ -343,11 +343,11 @@ NDIS_STATUS NICInitTransmit(IN PRTMP_ADAPTER pAd)
 		pRTSContext->InUse = FALSE;
 		pRTSContext->IRPPending = FALSE;
 
-		//
-		// PsPollContext
-		//
-		//NdisZeroMemory(pPsPollContext, sizeof(TX_CONTEXT));
-		//Allocate URB
+		/* */
+		/* PsPollContext */
+		/* */
+		/*NdisZeroMemory(pPsPollContext, sizeof(TX_CONTEXT)); */
+		/*Allocate URB */
 		LM_USB_ALLOC(pObj, pPsPollContext, PTX_BUFFER,
 			     sizeof(TX_BUFFER), Status,
 			     ("<-- ERROR in Alloc TX PsPollContext urb!! \n"),
@@ -407,7 +407,7 @@ out1:
 			LM_URB_FREE(pObj, pTxContext, sizeof(HTTX_BUFFER));
 	}
 
-	// Here we didn't have any pre-allocated memory need to free.
+	/* Here we didn't have any pre-allocated memory need to free. */
 
 	return Status;
 }
@@ -430,21 +430,21 @@ Note:
 */
 NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 {
-//      COUNTER_802_11  pCounter = &pAd->WlanCounters;
+/*      COUNTER_802_11  pCounter = &pAd->WlanCounters; */
 	NDIS_STATUS Status;
 	INT num;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RTMPAllocTxRxRingMemory\n"));
 
 	do {
-		// Init the CmdQ and CmdQLock
+		/* Init the CmdQ and CmdQLock */
 		NdisAllocateSpinLock(&pAd->CmdQLock);
 		NdisAcquireSpinLock(&pAd->CmdQLock);
 		RTUSBInitializeCmdQ(&pAd->CmdQ);
 		NdisReleaseSpinLock(&pAd->CmdQLock);
 
 		NdisAllocateSpinLock(&pAd->MLMEBulkOutLock);
-		//NdisAllocateSpinLock(&pAd->MLMEWaitQueueLock);
+		/*NdisAllocateSpinLock(&pAd->MLMEWaitQueueLock); */
 		NdisAllocateSpinLock(&pAd->BulkOutLock[0]);
 		NdisAllocateSpinLock(&pAd->BulkOutLock[1]);
 		NdisAllocateSpinLock(&pAd->BulkOutLock[2]);
@@ -457,31 +457,31 @@ NDIS_STATUS RTMPAllocTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 			NdisAllocateSpinLock(&pAd->TxContextQueueLock[num]);
 		}
 
-//              NdisAllocateSpinLock(&pAd->MemLock);    // Not used in RT28XX
+/*              NdisAllocateSpinLock(&pAd->MemLock);    // Not used in RT28XX */
 
-//              NdisAllocateSpinLock(&pAd->MacTabLock); // init it in UserCfgInit()
-//              NdisAllocateSpinLock(&pAd->BATabLock); // init it in BATableInit()
+/*              NdisAllocateSpinLock(&pAd->MacTabLock); // init it in UserCfgInit() */
+/*              NdisAllocateSpinLock(&pAd->BATabLock); // init it in BATableInit() */
 
-//              for(num=0; num<MAX_LEN_OF_BA_REC_TABLE; num++)
-//              {
-//                      NdisAllocateSpinLock(&pAd->BATable.BARecEntry[num].RxReRingLock);
-//              }
+/*              for(num=0; num<MAX_LEN_OF_BA_REC_TABLE; num++) */
+/*              { */
+/*                      NdisAllocateSpinLock(&pAd->BATable.BARecEntry[num].RxReRingLock); */
+/*              } */
 
-		//
-		// Init Mac Table
-		//
-//              MacTableInitialize(pAd);
+		/* */
+		/* Init Mac Table */
+		/* */
+/*              MacTableInitialize(pAd); */
 
-		//
-		// Init send data structures and related parameters
-		//
+		/* */
+		/* Init send data structures and related parameters */
+		/* */
 		Status = NICInitTransmit(pAd);
 		if (Status != NDIS_STATUS_SUCCESS)
 			break;
 
-		//
-		// Init receive data structures and related parameters
-		//
+		/* */
+		/* Init receive data structures and related parameters */
+		/* */
 		Status = NICInitRecv(pAd);
 		if (Status != NDIS_STATUS_SUCCESS)
 			break;
@@ -536,42 +536,42 @@ VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 	PTX_CONTEXT pNullContext = &pAd->NullContext;
 	PTX_CONTEXT pPsPollContext = &pAd->PsPollContext;
 	PTX_CONTEXT pRTSContext = &pAd->RTSContext;
-//      PHT_TX_CONTEXT          pHTTXContext;
-	//PRTMP_REORDERBUF      pReorderBuf;
+/*      PHT_TX_CONTEXT          pHTTXContext; */
+	/*PRTMP_REORDERBUF      pReorderBuf; */
 	POS_COOKIE pObj = (POS_COOKIE) pAd->OS_Cookie;
-//      RTMP_TX_RING            *pTxRing;
+/*      RTMP_TX_RING            *pTxRing; */
 
 	DBGPRINT(RT_DEBUG_ERROR, ("---> RTMPFreeTxRxRingMemory\n"));
 	pObj = pObj;
 
-	// Free all resources for the RECEIVE buffer queue.
+	/* Free all resources for the RECEIVE buffer queue. */
 	for (i = 0; i < (RX_RING_SIZE); i++) {
 		PRX_CONTEXT pRxContext = &(pAd->RxContext[i]);
 		if (pRxContext)
 			LM_URB_FREE(pObj, pRxContext, MAX_RXBULK_SIZE);
 	}
 
-	// Free PsPoll frame resource
+	/* Free PsPoll frame resource */
 	LM_URB_FREE(pObj, pPsPollContext, sizeof(TX_BUFFER));
 
-	// Free NULL frame resource
+	/* Free NULL frame resource */
 	LM_URB_FREE(pObj, pNullContext, sizeof(TX_BUFFER));
 
-	// Free RTS frame resource
+	/* Free RTS frame resource */
 	LM_URB_FREE(pObj, pRTSContext, sizeof(TX_BUFFER));
 
-	// Free beacon frame resource
+	/* Free beacon frame resource */
 	for (i = 0; i < BEACON_RING_SIZE; i++) {
 		PTX_CONTEXT pBeaconContext = &(pAd->BeaconContext[i]);
 		if (pBeaconContext)
 			LM_URB_FREE(pObj, pBeaconContext, sizeof(TX_BUFFER));
 	}
 
-	// Free mgmt frame resource
+	/* Free mgmt frame resource */
 	for (i = 0; i < MGMT_RING_SIZE; i++) {
 		PTX_CONTEXT pMLMEContext =
 		    (PTX_CONTEXT) pAd->MgmtRing.Cell[i].AllocVa;
-		//LM_URB_FREE(pObj, pMLMEContext, sizeof(TX_BUFFER));
+		/*LM_URB_FREE(pObj, pMLMEContext, sizeof(TX_BUFFER)); */
 		if (NULL != pAd->MgmtRing.Cell[i].pNdisPacket) {
 			RTMPFreeNdisPacket(pAd,
 					   pAd->MgmtRing.Cell[i].pNdisPacket);
@@ -590,7 +590,7 @@ VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 	if (pAd->MgmtDescRing.AllocVa)
 		os_free_mem(pAd, pAd->MgmtDescRing.AllocVa);
 
-	// Free Tx frame resource
+	/* Free Tx frame resource */
 	for (acidx = 0; acidx < 4; acidx++) {
 		PHT_TX_CONTEXT pHTTXContext = &(pAd->TxContext[acidx]);
 		if (pHTTXContext)
@@ -609,15 +609,15 @@ VOID RTMPFreeTxRxRingMemory(IN PRTMP_ADAPTER pAd)
 	NdisFreeSpinLock(&pAd->MLMEBulkOutLock);
 
 	NdisFreeSpinLock(&pAd->CmdQLock);
-	// Clear all pending bulk-out request flags.
+	/* Clear all pending bulk-out request flags. */
 	RTUSB_CLEAR_BULK_FLAG(pAd, 0xffffffff);
 
-//      NdisFreeSpinLock(&pAd->MacTabLock);
+/*      NdisFreeSpinLock(&pAd->MacTabLock); */
 
-//      for(i=0; i<MAX_LEN_OF_BA_REC_TABLE; i++)
-//      {
-//              NdisFreeSpinLock(&pAd->BATable.BARecEntry[i].RxReRingLock);
-//      }
+/*      for(i=0; i<MAX_LEN_OF_BA_REC_TABLE; i++) */
+/*      { */
+/*              NdisFreeSpinLock(&pAd->BATable.BARecEntry[i].RxReRingLock); */
+/*      } */
 
 	DBGPRINT(RT_DEBUG_ERROR, ("<--- RTMPFreeTxRxRingMemory\n"));
 }
@@ -643,7 +643,7 @@ NDIS_STATUS RTUSBWriteHWMACAddress(IN PRTMP_ADAPTER pAd)
 	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
 	LARGE_INTEGER NOW;
 
-	// initialize the random number generator
+	/* initialize the random number generator */
 	RTMP_GetCurrentSystemTime(&NOW);
 
 	if (pAd->bLocalAdminMAC != TRUE) {
@@ -654,7 +654,7 @@ NDIS_STATUS RTUSBWriteHWMACAddress(IN PRTMP_ADAPTER pAd)
 		pAd->CurrentAddress[4] = pAd->PermanentAddress[4];
 		pAd->CurrentAddress[5] = pAd->PermanentAddress[5];
 	}
-	// Write New MAC address to MAC_CSR2 & MAC_CSR3 & let ASIC know our new MAC
+	/* Write New MAC address to MAC_CSR2 & MAC_CSR3 & let ASIC know our new MAC */
 	StaMacReg0.field.Byte0 = pAd->CurrentAddress[0];
 	StaMacReg0.field.Byte1 = pAd->CurrentAddress[1];
 	StaMacReg0.field.Byte2 = pAd->CurrentAddress[2];
@@ -689,7 +689,7 @@ Note:
 */
 VOID RT28XXDMADisable(IN RTMP_ADAPTER * pAd)
 {
-	// no use
+	/* no use */
 }
 
 /*
@@ -776,7 +776,7 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 	UINT i, padding;
 	BEACON_SYNC_STRUCT *pBeaconSync = pAd->CommonCfg.pBeaconSync;
 	UINT32 longValue;
-//      USHORT                  shortValue;
+/*      USHORT                  shortValue; */
 	BOOLEAN bBcnReq = FALSE;
 	UCHAR bcn_idx = 0;
 
@@ -789,9 +789,9 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 		DBGPRINT(RT_DEBUG_ERROR, ("pBeaconSync is NULL!\n"));
 		return;
 	}
-	//if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE) ||
-	//      ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL) || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP))
-	//      )
+	/*if ((pAd->WdsTab.Mode == WDS_BRIDGE_MODE) || */
+	/*      ((pAd->ApCfg.MBSSID[apidx].MSSIDDev == NULL) || !(pAd->ApCfg.MBSSID[apidx].MSSIDDev->flags & IFF_UP)) */
+	/*      ) */
 	if (bBcnReq == FALSE) {
 		/* when the ra interface is down, do not send its beacon frame */
 		/* clear all zero */
@@ -804,7 +804,7 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 		NdisZeroMemory(pBeaconSync->BeaconTxWI[bcn_idx], TXWI_SIZE);
 	} else {
 		ptr = (PUCHAR) & pAd->BeaconTxWI;
-		if (NdisEqualMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWI_SIZE) == FALSE) {	// If BeaconTxWI changed, we need to rewrite the TxWI for the Beacon frames.
+		if (NdisEqualMemory(pBeaconSync->BeaconTxWI[bcn_idx], &pAd->BeaconTxWI, TXWI_SIZE) == FALSE) {	/* If BeaconTxWI changed, we need to rewrite the TxWI for the Beacon frames. */
 			pBeaconSync->BeaconBitMap &=
 			    (~(BEACON_BITMAP_MASK & (1 << bcn_idx)));
 			NdisMoveMemory(pBeaconSync->BeaconTxWI[bcn_idx],
@@ -813,7 +813,7 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 
 		if ((pBeaconSync->BeaconBitMap & (1 << bcn_idx)) !=
 		    (1 << bcn_idx)) {
-			for (i = 0; i < TXWI_SIZE; i += 4)	// 16-byte TXWI field
+			for (i = 0; i < TXWI_SIZE; i += 4)	/* 16-byte TXWI field */
 			{
 				longValue =
 				    *ptr + (*(ptr + 1) << 8) +
@@ -832,8 +832,8 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 		for (i = 0; i < FrameLen /*HW_BEACON_OFFSET */ ; i += 2) {
 			if (NdisEqualMemory(ptr, pBeaconFrame, 2) == FALSE) {
 				NdisMoveMemory(ptr, pBeaconFrame, 2);
-				//shortValue = *ptr + (*(ptr+1)<<8);
-				//RTMP_IO_WRITE8(pAd, pAd->BeaconOffset[bcn_idx] + TXWI_SIZE + i, shortValue);
+				/*shortValue = *ptr + (*(ptr+1)<<8); */
+				/*RTMP_IO_WRITE8(pAd, pAd->BeaconOffset[bcn_idx] + TXWI_SIZE + i, shortValue); */
 				RTUSBMultiWrite(pAd,
 						pAd->BeaconOffset[bcn_idx] +
 						TXWI_SIZE + i, ptr, 2);
@@ -844,7 +844,7 @@ VOID RT28xx_UpdateBeaconToAsic(IN RTMP_ADAPTER * pAd,
 
 		pBeaconSync->BeaconBitMap |= (1 << bcn_idx);
 
-		// For AP interface, set the DtimBitOn so that we can send Bcast/Mcast frame out after this beacon frame.
+		/* For AP interface, set the DtimBitOn so that we can send Bcast/Mcast frame out after this beacon frame. */
 	}
 
 }
@@ -887,7 +887,7 @@ VOID RTUSBBssBeaconStart(IN RTMP_ADAPTER * pAd)
 {
 	int apidx;
 	BEACON_SYNC_STRUCT *pBeaconSync;
-//      LARGE_INTEGER   tsfTime, deltaTime;
+/*      LARGE_INTEGER   tsfTime, deltaTime; */
 
 	pBeaconSync = pAd->CommonCfg.pBeaconSync;
 	if (pBeaconSync && pBeaconSync->EnableBeacon) {
@@ -936,7 +936,7 @@ VOID RTUSBBssBeaconInit(IN RTMP_ADAPTER * pAd)
 
 	os_alloc_mem(pAd, (PUCHAR *) (&pAd->CommonCfg.pBeaconSync),
 		     sizeof(BEACON_SYNC_STRUCT));
-	//NdisAllocMemory(pAd->CommonCfg.pBeaconSync, sizeof(BEACON_SYNC_STRUCT), MEM_ALLOC_FLAG);
+	/*NdisAllocMemory(pAd->CommonCfg.pBeaconSync, sizeof(BEACON_SYNC_STRUCT), MEM_ALLOC_FLAG); */
 	if (pAd->CommonCfg.pBeaconSync) {
 		pBeaconSync = pAd->CommonCfg.pBeaconSync;
 		NdisZeroMemory(pBeaconSync, sizeof(BEACON_SYNC_STRUCT));
@@ -949,7 +949,7 @@ VOID RTUSBBssBeaconInit(IN RTMP_ADAPTER * pAd)
 		}
 		pBeaconSync->BeaconBitMap = 0;
 
-		//RTMPInitTimer(pAd, &pAd->CommonCfg.BeaconUpdateTimer, GET_TIMER_FUNCTION(BeaconUpdateExec), pAd, TRUE);
+		/*RTMPInitTimer(pAd, &pAd->CommonCfg.BeaconUpdateTimer, GET_TIMER_FUNCTION(BeaconUpdateExec), pAd, TRUE); */
 		pBeaconSync->EnableBeacon = TRUE;
 	}
 }
@@ -1002,9 +1002,9 @@ VOID BeaconUpdateExec(IN PVOID SystemSpecific1,
 		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
 	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) FunctionContext;
-	LARGE_INTEGER tsfTime_a;	//, tsfTime_b, deltaTime_exp, deltaTime_ab;
+	LARGE_INTEGER tsfTime_a;	/*, tsfTime_b, deltaTime_exp, deltaTime_ab; */
 	UINT32 delta, delta2MS, period2US, remain, remain_low, remain_high;
-//      BOOLEAN                 positive;
+/*      BOOLEAN                 positive; */
 
 	if (pAd->CommonCfg.IsUpdateBeacon == TRUE) {
 		ReSyncBeaconTime(pAd);
@@ -1014,7 +1014,7 @@ VOID BeaconUpdateExec(IN PVOID SystemSpecific1,
 	RTMP_IO_READ32(pAd, TSF_TIMER_DW0, &tsfTime_a.u.LowPart);
 	RTMP_IO_READ32(pAd, TSF_TIMER_DW1, &tsfTime_a.u.HighPart);
 
-	//positive=getDeltaTime(tsfTime_a, expectedTime, &deltaTime_exp);
+	/*positive=getDeltaTime(tsfTime_a, expectedTime, &deltaTime_exp); */
 	period2US = (pAd->CommonCfg.BeaconPeriod << 10);
 	remain_high = pAd->CommonCfg.BeaconRemain * tsfTime_a.u.HighPart;
 	remain_low = tsfTime_a.u.LowPart % (pAd->CommonCfg.BeaconPeriod << 10);
@@ -1051,20 +1051,20 @@ VOID RT28xxUsbMlmeRadioOn(IN PRTMP_ADAPTER pAd)
 		AsicSendCommandToMcu(pAd, 0x31, 0xff, 0x00, 0x02);
 		RTMPusecDelay(10000);
 	}
-	//NICResetFromError(pAd);
+	/*NICResetFromError(pAd); */
 
-	// Enable Tx/Rx
+	/* Enable Tx/Rx */
 	RTMPEnableRxTx(pAd);
 
 	if (pChipOps->AsicReverseRfFromSleepMode)
 		pChipOps->AsicReverseRfFromSleepMode(pAd);
 
-	// Clear Radio off flag
+	/* Clear Radio off flag */
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
 	RTUSBBulkReceive(pAd);
 
-	// Set LED
+	/* Set LED */
 	RTMPSetLED(pAd, LED_RADIO_ON);
 }
 
@@ -1078,11 +1078,11 @@ VOID RT28xxUsbMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 		return;
 
-	// Clear PMKID cache.
+	/* Clear PMKID cache. */
 	pAd->StaCfg.SavedPMKNum = 0;
 	RTMPZeroMemory(pAd->StaCfg.SavedPMK, (PMKID_NO * sizeof(BSSID_INFO)));
 
-	// Link down first if any association exists
+	/* Link down first if any association exists */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		if (INFRA_ON(pAd) || ADHOC_ON(pAd)) {
 			MLME_DISASSOC_REQ_STRUCT DisReq;
@@ -1110,38 +1110,38 @@ VOID RT28xxUsbMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 			}
 		}
 	}
-	// Set Radio off flag
+	/* Set Radio off flag */
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 
 	{
-		// Link down first if any association exists
+		/* Link down first if any association exists */
 		if (INFRA_ON(pAd) || ADHOC_ON(pAd))
 			LinkDown(pAd, FALSE);
 		RTMPusecDelay(10000);
 
-		//==========================================
-		// Clean up old bss table
+		/*========================================== */
+		/* Clean up old bss table */
 		BssTableInit(&pAd->ScanTab);
 	}
 
-	// Set LED
+	/* Set LED */
 	RTMPSetLED(pAd, LED_RADIO_OFF);
 
 	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
-		// Must using 40MHz.
+		/* Must using 40MHz. */
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.CentralChannel);
 	} else {
-		// Must using 20MHz.
+		/* Must using 20MHz. */
 		AsicTurnOffRFClk(pAd, pAd->CommonCfg.Channel);
 	}
 
-	// Disable Tx/Rx DMA
-	RTUSBReadMACRegister(pAd, WPDMA_GLO_CFG, &GloCfg.word);	// disable DMA
+	/* Disable Tx/Rx DMA */
+	RTUSBReadMACRegister(pAd, WPDMA_GLO_CFG, &GloCfg.word);	/* disable DMA */
 	GloCfg.field.EnableTxDMA = 0;
 	GloCfg.field.EnableRxDMA = 0;
-	RTUSBWriteMACRegister(pAd, WPDMA_GLO_CFG, GloCfg.word);	// abort all TX rings
+	RTUSBWriteMACRegister(pAd, WPDMA_GLO_CFG, GloCfg.word);	/* abort all TX rings */
 
-	// Waiting for DMA idle
+	/* Waiting for DMA idle */
 	i = 0;
 	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
@@ -1152,7 +1152,7 @@ VOID RT28xxUsbMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 		RTMPusecDelay(1000);
 	} while (i++ < 100);
 
-	// Disable MAC Tx/Rx
+	/* Disable MAC Tx/Rx */
 	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
 	Value &= (0xfffffff3);
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
@@ -1162,4 +1162,4 @@ VOID RT28xxUsbMlmeRadioOFF(IN PRTMP_ADAPTER pAd)
 	}
 }
 
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
diff --git a/drivers/staging/rt2860/common/cmm_sanity.c b/drivers/staging/rt2860/common/cmm_sanity.c
index 92c44c7..bd12025 100644
--- a/drivers/staging/rt2860/common/cmm_sanity.c
+++ b/drivers/staging/rt2860/common/cmm_sanity.c
@@ -144,7 +144,7 @@ BOOLEAN PeerAddBAReqActionSanity(IN PRTMP_ADAPTER pAd,
 			  MsgLen));
 		return FALSE;
 	}
-	// we support immediate BA.
+	/* we support immediate BA. */
 	*(USHORT *) (&pAddFrame->BaParm) =
 	    cpu2le16(*(USHORT *) (&pAddFrame->BaParm));
 	pAddFrame->TimeOutValue = cpu2le16(pAddFrame->TimeOutValue);
@@ -160,7 +160,7 @@ BOOLEAN PeerAddBAReqActionSanity(IN PRTMP_ADAPTER pAd,
 			  pAddFrame->BaParm.AMSDUSupported));
 		return FALSE;
 	}
-	// we support immediate BA.
+	/* we support immediate BA. */
 	if (pAddFrame->BaParm.TID & 0xfff0) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("PeerAddBAReqActionSanity: ADDBA Request incorrect TID = %d\n",
@@ -183,7 +183,7 @@ BOOLEAN PeerAddBARspActionSanity(IN PRTMP_ADAPTER pAd,
 			  MsgLen));
 		return FALSE;
 	}
-	// we support immediate BA.
+	/* we support immediate BA. */
 	*(USHORT *) (&pAddFrame->BaParm) =
 	    cpu2le16(*(USHORT *) (&pAddFrame->BaParm));
 	pAddFrame->StatusCode = cpu2le16(pAddFrame->StatusCode);
@@ -195,7 +195,7 @@ BOOLEAN PeerAddBARspActionSanity(IN PRTMP_ADAPTER pAd,
 			  pAddFrame->BaParm.BAPolicy));
 		return FALSE;
 	}
-	// we support immediate BA.
+	/* we support immediate BA. */
 	if (pAddFrame->BaParm.TID & 0xfff0) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("PeerAddBARspActionSanity: ADDBA Response incorrect TID = %d\n",
@@ -209,7 +209,7 @@ BOOLEAN PeerAddBARspActionSanity(IN PRTMP_ADAPTER pAd,
 BOOLEAN PeerDelBAActionSanity(IN PRTMP_ADAPTER pAd,
 			      IN UCHAR Wcid, IN VOID * pMsg, IN ULONG MsgLen)
 {
-	//PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg;
+	/*PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg; */
 	PFRAME_DELBA_REQ pDelFrame;
 	if (MsgLen != (sizeof(FRAME_DELBA_REQ)))
 		return FALSE;
@@ -240,7 +240,7 @@ BOOLEAN PeerDelBAActionSanity(IN PRTMP_ADAPTER pAd,
 
     ==========================================================================
  */
-BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULONG MsgLen, IN UCHAR MsgChannel, OUT PUCHAR pAddr2, OUT PUCHAR pBssid, OUT CHAR Ssid[], OUT UCHAR * pSsidLen, OUT UCHAR * pBssType, OUT USHORT * pBeaconPeriod, OUT UCHAR * pChannel, OUT UCHAR * pNewChannel, OUT LARGE_INTEGER * pTimestamp, OUT CF_PARM * pCfParm, OUT USHORT * pAtimWin, OUT USHORT * pCapabilityInfo, OUT UCHAR * pErp, OUT UCHAR * pDtimCount, OUT UCHAR * pDtimPeriod, OUT UCHAR * pBcastFlag, OUT UCHAR * pMessageToMe, OUT UCHAR SupRate[], OUT UCHAR * pSupRateLen, OUT UCHAR ExtRate[], OUT UCHAR * pExtRateLen, OUT UCHAR * pCkipFlag, OUT UCHAR * pAironetCellPowerLimit, OUT PEDCA_PARM pEdcaParm, OUT PQBSS_LOAD_PARM pQbssLoad, OUT PQOS_CAPABILITY_PARM pQosCapability, OUT ULONG * pRalinkIe, OUT UCHAR * pHtCapabilityLen, OUT UCHAR * pPreNHtCapabilityLen, OUT HT_CAPABILITY_IE * pHtCapability, OUT UCHAR * AddHtInfoLen, OUT ADD_HT_INFO_IE * AddHtInfo, OUT UCHAR * NewExtChannelOffset,	// Ht extension channel offset(above or below)
+BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULONG MsgLen, IN UCHAR MsgChannel, OUT PUCHAR pAddr2, OUT PUCHAR pBssid, OUT CHAR Ssid[], OUT UCHAR * pSsidLen, OUT UCHAR * pBssType, OUT USHORT * pBeaconPeriod, OUT UCHAR * pChannel, OUT UCHAR * pNewChannel, OUT LARGE_INTEGER * pTimestamp, OUT CF_PARM * pCfParm, OUT USHORT * pAtimWin, OUT USHORT * pCapabilityInfo, OUT UCHAR * pErp, OUT UCHAR * pDtimCount, OUT UCHAR * pDtimPeriod, OUT UCHAR * pBcastFlag, OUT UCHAR * pMessageToMe, OUT UCHAR SupRate[], OUT UCHAR * pSupRateLen, OUT UCHAR ExtRate[], OUT UCHAR * pExtRateLen, OUT UCHAR * pCkipFlag, OUT UCHAR * pAironetCellPowerLimit, OUT PEDCA_PARM pEdcaParm, OUT PQBSS_LOAD_PARM pQbssLoad, OUT PQOS_CAPABILITY_PARM pQosCapability, OUT ULONG * pRalinkIe, OUT UCHAR * pHtCapabilityLen, OUT UCHAR * pPreNHtCapabilityLen, OUT HT_CAPABILITY_IE * pHtCapability, OUT UCHAR * AddHtInfoLen, OUT ADD_HT_INFO_IE * AddHtInfo, OUT UCHAR * NewExtChannelOffset,	/* Ht extension channel offset(above or below) */
 				    OUT USHORT * LengthVIE,
 				    OUT PNDIS_802_11_VARIABLE_IEs pVIE)
 {
@@ -250,16 +250,16 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 	PEID_STRUCT pEid;
 	UCHAR SubType;
 	UCHAR Sanity;
-	//UCHAR                             ECWMin, ECWMax;
-	//MAC_CSR9_STRUC            Csr9;
+	/*UCHAR                             ECWMin, ECWMax; */
+	/*MAC_CSR9_STRUC            Csr9; */
 	ULONG Length = 0;
 
-	// For some 11a AP which didn't have DS_IE, we use two conditions to decide the channel
-	//      1. If the AP is 11n enabled, then check the control channel.
-	//      2. If the AP didn't have any info about channel, use the channel we received this frame as the channel. (May inaccuracy!!)
+	/* For some 11a AP which didn't have DS_IE, we use two conditions to decide the channel */
+	/*      1. If the AP is 11n enabled, then check the control channel. */
+	/*      2. If the AP didn't have any info about channel, use the channel we received this frame as the channel. (May inaccuracy!!) */
 	UCHAR CtrlChannel = 0;
 
-	// Add for 3 necessary EID field check
+	/* Add for 3 necessary EID field check */
 	Sanity = 0;
 
 	*pAtimWin = 0;
@@ -269,34 +269,34 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 	*pBcastFlag = 0;
 	*pMessageToMe = 0;
 	*pExtRateLen = 0;
-	*pCkipFlag = 0;		// Default of CkipFlag is 0
-	*pAironetCellPowerLimit = 0xFF;	// Default of AironetCellPowerLimit is 0xFF
-	*LengthVIE = 0;		// Set the length of VIE to init value 0
-	*pHtCapabilityLen = 0;	// Set the length of VIE to init value 0
+	*pCkipFlag = 0;		/* Default of CkipFlag is 0 */
+	*pAironetCellPowerLimit = 0xFF;	/* Default of AironetCellPowerLimit is 0xFF */
+	*LengthVIE = 0;		/* Set the length of VIE to init value 0 */
+	*pHtCapabilityLen = 0;	/* Set the length of VIE to init value 0 */
 	if (pAd->OpMode == OPMODE_STA)
-		*pPreNHtCapabilityLen = 0;	// Set the length of VIE to init value 0
-	*AddHtInfoLen = 0;	// Set the length of VIE to init value 0
+		*pPreNHtCapabilityLen = 0;	/* Set the length of VIE to init value 0 */
+	*AddHtInfoLen = 0;	/* Set the length of VIE to init value 0 */
 	*pRalinkIe = 0;
 	*pNewChannel = 0;
-	*NewExtChannelOffset = 0xff;	//Default 0xff means no such IE
-	pCfParm->bValid = FALSE;	// default: no IE_CF found
-	pQbssLoad->bValid = FALSE;	// default: no IE_QBSS_LOAD found
-	pEdcaParm->bValid = FALSE;	// default: no IE_EDCA_PARAMETER found
-	pQosCapability->bValid = FALSE;	// default: no IE_QOS_CAPABILITY found
+	*NewExtChannelOffset = 0xff;	/*Default 0xff means no such IE */
+	pCfParm->bValid = FALSE;	/* default: no IE_CF found */
+	pQbssLoad->bValid = FALSE;	/* default: no IE_QBSS_LOAD found */
+	pEdcaParm->bValid = FALSE;	/* default: no IE_EDCA_PARAMETER found */
+	pQosCapability->bValid = FALSE;	/* default: no IE_QOS_CAPABILITY found */
 
 	pFrame = (PFRAME_802_11) Msg;
 
-	// get subtype from header
+	/* get subtype from header */
 	SubType = (UCHAR) pFrame->Hdr.FC.SubType;
 
-	// get Addr2 and BSSID from header
+	/* get Addr2 and BSSID from header */
 	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
 	COPY_MAC_ADDR(pBssid, pFrame->Hdr.Addr3);
 
 	Ptr = pFrame->Octet;
 	Length += LENGTH_802_11;
 
-	// get timestamp from payload and advance the pointer
+	/* get timestamp from payload and advance the pointer */
 	NdisMoveMemory(pTimestamp, Ptr, TIMESTAMP_LEN);
 
 	pTimestamp->u.LowPart = cpu2le32(pTimestamp->u.LowPart);
@@ -305,12 +305,12 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 	Ptr += TIMESTAMP_LEN;
 	Length += TIMESTAMP_LEN;
 
-	// get beacon interval from payload and advance the pointer
+	/* get beacon interval from payload and advance the pointer */
 	NdisMoveMemory(pBeaconPeriod, Ptr, 2);
 	Ptr += 2;
 	Length += 2;
 
-	// get capability info from payload and advance the pointer
+	/* get capability info from payload and advance the pointer */
 	NdisMoveMemory(pCapabilityInfo, Ptr, 2);
 	Ptr += 2;
 	Length += 2;
@@ -322,11 +322,11 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 
 	pEid = (PEID_STRUCT) Ptr;
 
-	// get variable fields from payload and advance the pointer
+	/* get variable fields from payload and advance the pointer */
 	while ((Length + 2 + pEid->Len) <= MsgLen) {
-		//
-		// Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow.
-		//
+		/* */
+		/* Secure copy VIE to VarIE[MAX_VIE_LEN] didn't overflow. */
+		/* */
 		if ((*LengthVIE + pEid->Len + 2) >= MAX_VIE_LEN) {
 			DBGPRINT(RT_DEBUG_WARN,
 				 ("PeerBeaconAndProbeRspSanity - Variable IEs out of resource [len(=%d) > MAX_VIE_LEN(=%d)]\n",
@@ -336,7 +336,7 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 
 		switch (pEid->Eid) {
 		case IE_SSID:
-			// Already has one SSID EID in this beacon, ignore the second one
+			/* Already has one SSID EID in this beacon, ignore the second one */
 			if (Sanity & 0x1)
 				break;
 			if (pEid->Len <= MAX_LEN_OF_SSID) {
@@ -357,11 +357,11 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 				NdisMoveMemory(SupRate, pEid->Octet, pEid->Len);
 				*pSupRateLen = pEid->Len;
 
-				// TODO: 2004-09-14 not a good design here, cause it exclude extra rates
-				// from ScanTab. We should report as is. And filter out unsupported
-				// rates in MlmeAux.
-				// Check against the supported rates
-				// RTMPCheckRates(pAd, SupRate, pSupRateLen);
+				/* TODO: 2004-09-14 not a good design here, cause it exclude extra rates */
+				/* from ScanTab. We should report as is. And filter out unsupported */
+				/* rates in MlmeAux. */
+				/* Check against the supported rates */
+				/* RTMPCheckRates(pAd, SupRate, pSupRateLen); */
 			} else {
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("PeerBeaconAndProbeRspSanity - wrong IE_SUPP_RATES (len=%d)\n",
@@ -371,11 +371,11 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 			break;
 
 		case IE_HT_CAP:
-			if (pEid->Len >= SIZE_HT_CAP_IE)	//Note: allow extension.!!
+			if (pEid->Len >= SIZE_HT_CAP_IE)	/*Note: allow extension.!! */
 			{
 				NdisMoveMemory(pHtCapability, pEid->Octet,
 					       sizeof(HT_CAPABILITY_IE));
-				*pHtCapabilityLen = SIZE_HT_CAP_IE;	// Nnow we only support 26 bytes.
+				*pHtCapabilityLen = SIZE_HT_CAP_IE;	/* Nnow we only support 26 bytes. */
 
 				*(USHORT *) (&pHtCapability->HtCapInfo) =
 				    cpu2le16(*(USHORT *)
@@ -385,7 +385,7 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 					     (&pHtCapability->ExtHtCapInfo));
 
 				{
-					*pPreNHtCapabilityLen = 0;	// Nnow we only support 26 bytes.
+					*pPreNHtCapabilityLen = 0;	/* Nnow we only support 26 bytes. */
 
 					Ptr = (PUCHAR) pVIE;
 					NdisMoveMemory(Ptr + *LengthVIE,
@@ -402,8 +402,8 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 			break;
 		case IE_ADD_HT:
 			if (pEid->Len >= sizeof(ADD_HT_INFO_IE)) {
-				// This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only
-				// copy first sizeof(ADD_HT_INFO_IE)
+				/* This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only */
+				/* copy first sizeof(ADD_HT_INFO_IE) */
 				NdisMoveMemory(AddHtInfo, pEid->Octet,
 					       sizeof(ADD_HT_INFO_IE));
 				*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
@@ -500,17 +500,17 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 			break;
 		case IE_CHANNEL_SWITCH_ANNOUNCEMENT:
 			if (pEid->Len == 3) {
-				*pNewChannel = pEid->Octet[1];	//extract new channel number
+				*pNewChannel = pEid->Octet[1];	/*extract new channel number */
 			}
 			break;
 
-			// New for WPA
-			// CCX v2 has the same IE, we need to parse that too
-			// Wifi WMM use the same IE vale, need to parse that too
-			// case IE_WPA:
+			/* New for WPA */
+			/* CCX v2 has the same IE, we need to parse that too */
+			/* Wifi WMM use the same IE vale, need to parse that too */
+			/* case IE_WPA: */
 		case IE_VENDOR_SPECIFIC:
-			// Check Broadcom/Atheros 802.11n OUI version, for HT Capability IE.
-			// This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
+			/* Check Broadcom/Atheros 802.11n OUI version, for HT Capability IE. */
+			/* This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan. */
 			/*if (NdisEqualMemory(pEid->Octet, BROADCOM_OUI, 3) && (pEid->Len >= 4))
 			   {
 			   if ((pEid->Octet[3] == OUI_BROADCOM_HT) && (pEid->Len >= 30))
@@ -529,19 +529,19 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 			   }
 			   }
 			 */
-			// Check the OUI version, filter out non-standard usage
+			/* Check the OUI version, filter out non-standard usage */
 			if (NdisEqualMemory(pEid->Octet, RALINK_OUI, 3)
 			    && (pEid->Len == 7)) {
-				//*pRalinkIe = pEid->Octet[3];
+				/**pRalinkIe = pEid->Octet[3]; */
 				if (pEid->Octet[3] != 0)
 					*pRalinkIe = pEid->Octet[3];
 				else
-					*pRalinkIe = 0xf0000000;	// Set to non-zero value (can't set bit0-2) to represent this is Ralink Chip. So at linkup, we will set ralinkchip flag.
+					*pRalinkIe = 0xf0000000;	/* Set to non-zero value (can't set bit0-2) to represent this is Ralink Chip. So at linkup, we will set ralinkchip flag. */
 			}
-			// This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan.
+			/* This HT IE is before IEEE draft set HT IE value.2006-09-28 by Jan. */
 
-			// Other vendors had production before IE_HT_CAP value is assigned. To backward support those old-firmware AP,
-			// Check broadcom-defiend pre-802.11nD1.0 OUI for HT related IE, including HT Capatilities IE and HT Information IE
+			/* Other vendors had production before IE_HT_CAP value is assigned. To backward support those old-firmware AP, */
+			/* Check broadcom-defiend pre-802.11nD1.0 OUI for HT related IE, including HT Capatilities IE and HT Information IE */
 			else if ((*pHtCapabilityLen == 0)
 				 && NdisEqualMemory(pEid->Octet, PRE_N_HT_OUI,
 						    3) && (pEid->Len >= 4)
@@ -564,7 +564,7 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 					*AddHtInfoLen = SIZE_ADD_HT_INFO_IE;
 				}
 			} else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4)) {
-				// Copy to pVIE which will report to microsoft bssid list.
+				/* Copy to pVIE which will report to microsoft bssid list. */
 				Ptr = (PUCHAR) pVIE;
 				NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid,
 					       pEid->Len + 2);
@@ -575,39 +575,39 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 				PUCHAR ptr;
 				int i;
 
-				// parsing EDCA parameters
+				/* parsing EDCA parameters */
 				pEdcaParm->bValid = TRUE;
-				pEdcaParm->bQAck = FALSE;	// pEid->Octet[0] & 0x10;
-				pEdcaParm->bQueueRequest = FALSE;	// pEid->Octet[0] & 0x20;
-				pEdcaParm->bTxopRequest = FALSE;	// pEid->Octet[0] & 0x40;
+				pEdcaParm->bQAck = FALSE;	/* pEid->Octet[0] & 0x10; */
+				pEdcaParm->bQueueRequest = FALSE;	/* pEid->Octet[0] & 0x20; */
+				pEdcaParm->bTxopRequest = FALSE;	/* pEid->Octet[0] & 0x40; */
 				pEdcaParm->EdcaUpdateCount =
 				    pEid->Octet[6] & 0x0f;
 				pEdcaParm->bAPSDCapable =
 				    (pEid->Octet[6] & 0x80) ? 1 : 0;
 				ptr = &pEid->Octet[8];
 				for (i = 0; i < 4; i++) {
-					UCHAR aci = (*ptr & 0x60) >> 5;	// b5~6 is AC INDEX
-					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	// b5 is ACM
-					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	// b0~3 is AIFSN
-					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	// b0~4 is Cwmin
-					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	// b5~8 is Cwmax
-					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	// in unit of 32-us
-					ptr += 4;	// point to next AC
+					UCHAR aci = (*ptr & 0x60) >> 5;	/* b5~6 is AC INDEX */
+					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	/* b5 is ACM */
+					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	/* b0~3 is AIFSN */
+					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	/* b0~4 is Cwmin */
+					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	/* b5~8 is Cwmax */
+					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	/* in unit of 32-us */
+					ptr += 4;	/* point to next AC */
 				}
 			} else
 			    if (NdisEqualMemory(pEid->Octet, WME_INFO_ELEM, 6)
 				&& (pEid->Len == 7)) {
-				// parsing EDCA parameters
+				/* parsing EDCA parameters */
 				pEdcaParm->bValid = TRUE;
-				pEdcaParm->bQAck = FALSE;	// pEid->Octet[0] & 0x10;
-				pEdcaParm->bQueueRequest = FALSE;	// pEid->Octet[0] & 0x20;
-				pEdcaParm->bTxopRequest = FALSE;	// pEid->Octet[0] & 0x40;
+				pEdcaParm->bQAck = FALSE;	/* pEid->Octet[0] & 0x10; */
+				pEdcaParm->bQueueRequest = FALSE;	/* pEid->Octet[0] & 0x20; */
+				pEdcaParm->bTxopRequest = FALSE;	/* pEid->Octet[0] & 0x40; */
 				pEdcaParm->EdcaUpdateCount =
 				    pEid->Octet[6] & 0x0f;
 				pEdcaParm->bAPSDCapable =
 				    (pEid->Octet[6] & 0x80) ? 1 : 0;
 
-				// use default EDCA parameter
+				/* use default EDCA parameter */
 				pEdcaParm->bACM[QID_AC_BE] = 0;
 				pEdcaParm->Aifsn[QID_AC_BE] = 3;
 				pEdcaParm->Cwmin[QID_AC_BE] = CW_MIN_IN_BITS;
@@ -625,7 +625,7 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 				pEdcaParm->Cwmin[QID_AC_VI] =
 				    CW_MIN_IN_BITS - 1;
 				pEdcaParm->Cwmax[QID_AC_VI] = CW_MAX_IN_BITS;
-				pEdcaParm->Txop[QID_AC_VI] = 96;	// AC_VI: 96*32us ~= 3ms
+				pEdcaParm->Txop[QID_AC_VI] = 96;	/* AC_VI: 96*32us ~= 3ms */
 
 				pEdcaParm->bACM[QID_AC_VO] = 0;
 				pEdcaParm->Aifsn[QID_AC_VO] = 2;
@@ -633,7 +633,7 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 				    CW_MIN_IN_BITS - 2;
 				pEdcaParm->Cwmax[QID_AC_VO] =
 				    CW_MAX_IN_BITS - 1;
-				pEdcaParm->Txop[QID_AC_VO] = 48;	// AC_VO: 48*32us ~= 1.5ms
+				pEdcaParm->Txop[QID_AC_VO] = 48;	/* AC_VO: 48*32us ~= 1.5ms */
 			}
 
 			break;
@@ -643,11 +643,11 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 				NdisMoveMemory(ExtRate, pEid->Octet, pEid->Len);
 				*pExtRateLen = pEid->Len;
 
-				// TODO: 2004-09-14 not a good design here, cause it exclude extra rates
-				// from ScanTab. We should report as is. And filter out unsupported
-				// rates in MlmeAux.
-				// Check against the supported rates
-				// RTMPCheckRates(pAd, ExtRate, pExtRateLen);
+				/* TODO: 2004-09-14 not a good design here, cause it exclude extra rates */
+				/* from ScanTab. We should report as is. And filter out unsupported */
+				/* rates in MlmeAux. */
+				/* Check against the supported rates */
+				/* RTMPCheckRates(pAd, ExtRate, pExtRateLen); */
 			}
 			break;
 
@@ -658,32 +658,32 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 			break;
 
 		case IE_AIRONET_CKIP:
-			// 0. Check Aironet IE length, it must be larger or equal to 28
-			// Cisco AP350 used length as 28
-			// Cisco AP12XX used length as 30
+			/* 0. Check Aironet IE length, it must be larger or equal to 28 */
+			/* Cisco AP350 used length as 28 */
+			/* Cisco AP12XX used length as 30 */
 			if (pEid->Len < (CKIP_NEGOTIATION_LENGTH - 2))
 				break;
 
-			// 1. Copy CKIP flag byte to buffer for process
+			/* 1. Copy CKIP flag byte to buffer for process */
 			*pCkipFlag = *(pEid->Octet + 8);
 			break;
 
 		case IE_AP_TX_POWER:
-			// AP Control of Client Transmit Power
-			//0. Check Aironet IE length, it must be 6
+			/* AP Control of Client Transmit Power */
+			/*0. Check Aironet IE length, it must be 6 */
 			if (pEid->Len != 0x06)
 				break;
 
-			// Get cell power limit in dBm
+			/* Get cell power limit in dBm */
 			if (NdisEqualMemory(pEid->Octet, CISCO_OUI, 3) == 1)
 				*pAironetCellPowerLimit = *(pEid->Octet + 4);
 			break;
 
-			// WPA2 & 802.11i RSN
+			/* WPA2 & 802.11i RSN */
 		case IE_RSN:
-			// There is no OUI for version anymore, check the group cipher OUI before copying
+			/* There is no OUI for version anymore, check the group cipher OUI before copying */
 			if (RTMPEqualMemory(pEid->Octet + 2, RSN_OUI, 3)) {
-				// Copy to pVIE which will report to microsoft bssid list.
+				/* Copy to pVIE which will report to microsoft bssid list. */
 				Ptr = (PUCHAR) pVIE;
 				NdisMoveMemory(Ptr + *LengthVIE, &pEid->Eid,
 					       pEid->Len + 2);
@@ -695,11 +695,11 @@ BOOLEAN PeerBeaconAndProbeRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * Msg, IN ULON
 			break;
 		}
 
-		Length = Length + 2 + pEid->Len;	// Eid[1] + Len[1]+ content[Len]
+		Length = Length + 2 + pEid->Len;	/* Eid[1] + Len[1]+ content[Len] */
 		pEid = (PEID_STRUCT) ((UCHAR *) pEid + 2 + pEid->Len);
 	}
 
-	// For some 11a AP. it did not have the channel EID, patch here
+	/* For some 11a AP. it did not have the channel EID, patch here */
 	{
 		UCHAR LatchRfChannel = MsgChannel;
 		if ((pAd->LatchRfRegs.Channel > 14) && ((Sanity & 0x4) == 0)) {
@@ -756,7 +756,7 @@ BOOLEAN MlmeScanReqSanity(IN PRTMP_ADAPTER pAd,
 	}
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 UCHAR ChannelSanity(IN PRTMP_ADAPTER pAd, IN UCHAR channel)
 {
 	int i;
@@ -897,9 +897,9 @@ BOOLEAN MlmeAssocReqSanity(IN PRTMP_ADAPTER pAd,
 	MLME_ASSOC_REQ_STRUCT *pInfo;
 
 	pInfo = (MLME_ASSOC_REQ_STRUCT *) Msg;
-	*pTimeout = pInfo->Timeout;	// timeout
-	COPY_MAC_ADDR(pApAddr, pInfo->Addr);	// AP address
-	*pCapabilityInfo = pInfo->CapabilityInfo;	// capability info
+	*pTimeout = pInfo->Timeout;	/* timeout */
+	COPY_MAC_ADDR(pApAddr, pInfo->Addr);	/* AP address */
+	*pCapabilityInfo = pInfo->CapabilityInfo;	/* capability info */
 	*pListenIntv = pInfo->ListenIntv;
 
 	return TRUE;
@@ -954,36 +954,36 @@ NDIS_802_11_NETWORK_TYPE NetworkTypeInUseSanity(IN PBSS_ENTRY pBss)
 	NetWorkType = Ndis802_11DS;
 
 	if (pBss->Channel <= 14) {
-		//
-		// First check support Rate.
-		//
+		/* */
+		/* First check support Rate. */
+		/* */
 		for (i = 0; i < pBss->SupRateLen; i++) {
-			rate = pBss->SupRate[i] & 0x7f;	// Mask out basic rate set bit
+			rate = pBss->SupRate[i] & 0x7f;	/* Mask out basic rate set bit */
 			if ((rate == 2) || (rate == 4) || (rate == 11)
 			    || (rate == 22)) {
 				continue;
 			} else {
-				//
-				// Otherwise (even rate > 108) means Ndis802_11OFDM24
-				//
+				/* */
+				/* Otherwise (even rate > 108) means Ndis802_11OFDM24 */
+				/* */
 				NetWorkType = Ndis802_11OFDM24;
 				break;
 			}
 		}
 
-		//
-		// Second check Extend Rate.
-		//
+		/* */
+		/* Second check Extend Rate. */
+		/* */
 		if (NetWorkType != Ndis802_11OFDM24) {
 			for (i = 0; i < pBss->ExtRateLen; i++) {
-				rate = pBss->SupRate[i] & 0x7f;	// Mask out basic rate set bit
+				rate = pBss->SupRate[i] & 0x7f;	/* Mask out basic rate set bit */
 				if ((rate == 2) || (rate == 4) || (rate == 11)
 				    || (rate == 22)) {
 					continue;
 				} else {
-					//
-					// Otherwise (even rate > 108) means Ndis802_11OFDM24
-					//
+					/* */
+					/* Otherwise (even rate > 108) means Ndis802_11OFDM24 */
+					/* */
 					NetWorkType = Ndis802_11OFDM24;
 					break;
 				}
@@ -1033,22 +1033,22 @@ BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
 
 	*((USHORT *) & EapolKeyInfo) = cpu2le16(*((USHORT *) & EapolKeyInfo));
 
-	// Choose WPA2 or not
+	/* Choose WPA2 or not */
 	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
 	    || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
 		bWPA2 = TRUE;
 
-	// 0. Check MsgType
+	/* 0. Check MsgType */
 	if ((MsgType > EAPOL_GROUP_MSG_2) || (MsgType < EAPOL_PAIR_MSG_1)) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("The message type is invalid(%d)! \n", MsgType));
 		return FALSE;
 	}
-	// 1. Replay counter check
-	if (MsgType == EAPOL_PAIR_MSG_1 || MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1)	// For supplicant
+	/* 1. Replay counter check */
+	if (MsgType == EAPOL_PAIR_MSG_1 || MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1)	/* For supplicant */
 	{
-		// First validate replay counter, only accept message with larger replay counter.
-		// Let equal pass, some AP start with all zero replay counter
+		/* First validate replay counter, only accept message with larger replay counter. */
+		/* Let equal pass, some AP start with all zero replay counter */
 		UCHAR ZeroReplay[LEN_KEY_DESC_REPLAY];
 
 		NdisZeroMemory(ZeroReplay, LEN_KEY_DESC_REPLAY);
@@ -1061,18 +1061,18 @@ BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
 		      LEN_KEY_DESC_REPLAY) != 0)) {
 			bReplayDiff = TRUE;
 		}
-	} else if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)	// For authenticator
+	} else if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)	/* For authenticator */
 	{
-		// check Replay Counter coresponds to MSG from authenticator, otherwise discard
+		/* check Replay Counter coresponds to MSG from authenticator, otherwise discard */
 		if (!NdisEqualMemory
 		    (pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
 		     LEN_KEY_DESC_REPLAY)) {
 			bReplayDiff = TRUE;
 		}
 	}
-	// Replay Counter different condition
+	/* Replay Counter different condition */
 	if (bReplayDiff) {
-		// send wireless event - for replay counter different
+		/* send wireless event - for replay counter different */
 		if (pAd->CommonCfg.bWirelessEvent)
 			RTMPSendWirelessEvent(pAd,
 					      IW_REPLAY_COUNTER_DIFF_EVENT_FLAG,
@@ -1094,20 +1094,20 @@ BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
 			 LEN_KEY_DESC_REPLAY);
 		return FALSE;
 	}
-	// 2. Verify MIC except Pairwise Msg1
+	/* 2. Verify MIC except Pairwise Msg1 */
 	if (MsgType != EAPOL_PAIR_MSG_1) {
 		UCHAR rcvd_mic[LEN_KEY_DESC_MIC];
 
-		// Record the received MIC for check later
+		/* Record the received MIC for check later */
 		NdisMoveMemory(rcvd_mic, pMsg->KeyDesc.KeyMic,
 			       LEN_KEY_DESC_MIC);
 		NdisZeroMemory(pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
 
-		if (EapolKeyInfo.KeyDescVer == DESC_TYPE_TKIP)	// TKIP
+		if (EapolKeyInfo.KeyDescVer == DESC_TYPE_TKIP)	/* TKIP */
 		{
 			HMAC_MD5(pEntry->PTK, LEN_EAP_MICK, (PUCHAR) pMsg,
 				 MsgLen, mic, MD5_DIGEST_SIZE);
-		} else if (EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)	// AES
+		} else if (EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)	/* AES */
 		{
 			HMAC_SHA1(pEntry->PTK, LEN_EAP_MICK, (PUCHAR) pMsg,
 				  MsgLen, digest, SHA1_DIGEST_SIZE);
@@ -1115,7 +1115,7 @@ BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
 		}
 
 		if (!NdisEqualMemory(rcvd_mic, mic, LEN_KEY_DESC_MIC)) {
-			// send wireless event - for MIC different
+			/* send wireless event - for MIC different */
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd,
 						      IW_MIC_DIFF_EVENT_FLAG,
@@ -1138,16 +1138,16 @@ BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
 			return FALSE;
 		}
 	}
-	// 1. Decrypt the Key Data field if GTK is included.
-	// 2. Extract the context of the Key Data field if it exist.
-	// The field in pairwise_msg_2_WPA1(WPA2) & pairwise_msg_3_WPA1 is clear.
-	// The field in group_msg_1_WPA1(WPA2) & pairwise_msg_3_WPA2 is encrypted.
+	/* 1. Decrypt the Key Data field if GTK is included. */
+	/* 2. Extract the context of the Key Data field if it exist. */
+	/* The field in pairwise_msg_2_WPA1(WPA2) & pairwise_msg_3_WPA1 is clear. */
+	/* The field in group_msg_1_WPA1(WPA2) & pairwise_msg_3_WPA2 is encrypted. */
 	if (CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.KeyDataLen) > 0) {
-		// Decrypt this field
+		/* Decrypt this field */
 		if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2)
 		    || (MsgType == EAPOL_GROUP_MSG_1)) {
 			if ((EapolKeyInfo.KeyDescVer == DESC_TYPE_AES)) {
-				// AES
+				/* AES */
 				AES_GTK_KEY_UNWRAP(&pEntry->PTK[16], KEYDATA,
 						   CONV_ARRARY_TO_UINT16(pMsg->
 									 KeyDesc.
@@ -1156,17 +1156,17 @@ BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
 			} else {
 				INT i;
 				UCHAR Key[32];
-				// Decrypt TKIP GTK
-				// Construct 32 bytes RC4 Key
+				/* Decrypt TKIP GTK */
+				/* Construct 32 bytes RC4 Key */
 				NdisMoveMemory(Key, pMsg->KeyDesc.KeyIv, 16);
 				NdisMoveMemory(&Key[16], &pEntry->PTK[16], 16);
 				ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, Key,
 					     32);
-				//discard first 256 bytes
+				/*discard first 256 bytes */
 				for (i = 0; i < 256; i++)
 					ARCFOUR_BYTE(&pAd->PrivateInfo.
 						     WEPCONTEXT);
-				// Decrypt GTK. Becareful, there is no ICV to check the result is correct or not
+				/* Decrypt GTK. Becareful, there is no ICV to check the result is correct or not */
 				ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT,
 						KEYDATA, pMsg->KeyDesc.KeyData,
 						CONV_ARRARY_TO_UINT16(pMsg->
@@ -1187,10 +1187,10 @@ BOOLEAN PeerWpaMessageSanity(IN PRTMP_ADAPTER pAd,
 			return TRUE;
 		}
 
-		// Parse Key Data field to
-		// 1. verify RSN IE for pairwise_msg_2_WPA1(WPA2) ,pairwise_msg_3_WPA1(WPA2)
-		// 2. verify KDE format for pairwise_msg_3_WPA2, group_msg_1_WPA2
-		// 3. update shared key for pairwise_msg_3_WPA2, group_msg_1_WPA1(WPA2)
+		/* Parse Key Data field to */
+		/* 1. verify RSN IE for pairwise_msg_2_WPA1(WPA2) ,pairwise_msg_3_WPA1(WPA2) */
+		/* 2. verify KDE format for pairwise_msg_3_WPA2, group_msg_1_WPA2 */
+		/* 3. update shared key for pairwise_msg_3_WPA2, group_msg_1_WPA1(WPA2) */
 		if (!RTMPParseEapolKeyData(pAd, KEYDATA,
 					   CONV_ARRARY_TO_UINT16(pMsg->KeyDesc.
 								 KeyDataLen),
diff --git a/drivers/staging/rt2860/common/cmm_sync.c b/drivers/staging/rt2860/common/cmm_sync.c
index 9934a1b..c29e087 100644
--- a/drivers/staging/rt2860/common/cmm_sync.c
+++ b/drivers/staging/rt2860/common/cmm_sync.c
@@ -36,27 +36,27 @@
 */
 #include "../rt_config.h"
 
-// 2.4 Ghz channel plan index in the TxPower arrays.
-#define	BG_BAND_REGION_0_START	0	// 1,2,3,4,5,6,7,8,9,10,11
+/* 2.4 Ghz channel plan index in the TxPower arrays. */
+#define	BG_BAND_REGION_0_START	0	/* 1,2,3,4,5,6,7,8,9,10,11 */
 #define	BG_BAND_REGION_0_SIZE	11
-#define	BG_BAND_REGION_1_START	0	// 1,2,3,4,5,6,7,8,9,10,11,12,13
+#define	BG_BAND_REGION_1_START	0	/* 1,2,3,4,5,6,7,8,9,10,11,12,13 */
 #define	BG_BAND_REGION_1_SIZE	13
-#define	BG_BAND_REGION_2_START	9	// 10,11
+#define	BG_BAND_REGION_2_START	9	/* 10,11 */
 #define	BG_BAND_REGION_2_SIZE	2
-#define	BG_BAND_REGION_3_START	9	// 10,11,12,13
+#define	BG_BAND_REGION_3_START	9	/* 10,11,12,13 */
 #define	BG_BAND_REGION_3_SIZE	4
-#define	BG_BAND_REGION_4_START	13	// 14
+#define	BG_BAND_REGION_4_START	13	/* 14 */
 #define	BG_BAND_REGION_4_SIZE	1
-#define	BG_BAND_REGION_5_START	0	// 1,2,3,4,5,6,7,8,9,10,11,12,13,14
+#define	BG_BAND_REGION_5_START	0	/* 1,2,3,4,5,6,7,8,9,10,11,12,13,14 */
 #define	BG_BAND_REGION_5_SIZE	14
-#define	BG_BAND_REGION_6_START	2	// 3,4,5,6,7,8,9
+#define	BG_BAND_REGION_6_START	2	/* 3,4,5,6,7,8,9 */
 #define	BG_BAND_REGION_6_SIZE	7
-#define	BG_BAND_REGION_7_START	4	// 5,6,7,8,9,10,11,12,13
+#define	BG_BAND_REGION_7_START	4	/* 5,6,7,8,9,10,11,12,13 */
 #define	BG_BAND_REGION_7_SIZE	9
-#define	BG_BAND_REGION_31_START	0	// 1,2,3,4,5,6,7,8,9,10,11,12,13,14
+#define	BG_BAND_REGION_31_START	0	/* 1,2,3,4,5,6,7,8,9,10,11,12,13,14 */
 #define	BG_BAND_REGION_31_SIZE	14
 
-// 5 Ghz channel plan index in the TxPower arrays.
+/* 5 Ghz channel plan index in the TxPower arrays. */
 UCHAR A_BAND_REGION_0_CHANNEL_LIST[] =
     { 36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165 };
 UCHAR A_BAND_REGION_1_CHANNEL_LIST[] =
@@ -90,7 +90,7 @@ UCHAR A_BAND_REGION_14_CHANNEL_LIST[] =
 153, 157, 161, 165 };
 UCHAR A_BAND_REGION_15_CHANNEL_LIST[] = { 149, 153, 157, 161, 165, 169, 173 };
 
-//BaSizeArray follows the 802.11n definition as MaxRxFactor.  2^(13+factor) bytes. When factor =0, it's about Ba buffer size =8.
+/*BaSizeArray follows the 802.11n definition as MaxRxFactor.  2^(13+factor) bytes. When factor =0, it's about Ba buffer size =8. */
 UCHAR BaSizeArray[4] = { 8, 16, 32, 64 };
 
 /*
@@ -113,76 +113,76 @@ VOID BuildChannelList(IN PRTMP_ADAPTER pAd)
 	NdisZeroMemory(pAd->ChannelList,
 		       MAX_NUM_OF_CHANNELS * sizeof(CHANNEL_TX_POWER));
 
-	// if not 11a-only mode, channel list starts from 2.4Ghz band
+	/* if not 11a-only mode, channel list starts from 2.4Ghz band */
 	if ((pAd->CommonCfg.PhyMode != PHY_11A)
 	    && (pAd->CommonCfg.PhyMode != PHY_11AN_MIXED)
 	    && (pAd->CommonCfg.PhyMode != PHY_11N_5G)
 	    ) {
 		switch (pAd->CommonCfg.CountryRegion & 0x7f) {
-		case REGION_0_BG_BAND:	// 1 -11
+		case REGION_0_BG_BAND:	/* 1 -11 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_0_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_0_SIZE);
 			index += BG_BAND_REGION_0_SIZE;
 			break;
-		case REGION_1_BG_BAND:	// 1 - 13
+		case REGION_1_BG_BAND:	/* 1 - 13 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_1_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_1_SIZE);
 			index += BG_BAND_REGION_1_SIZE;
 			break;
-		case REGION_2_BG_BAND:	// 10 - 11
+		case REGION_2_BG_BAND:	/* 10 - 11 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_2_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_2_SIZE);
 			index += BG_BAND_REGION_2_SIZE;
 			break;
-		case REGION_3_BG_BAND:	// 10 - 13
+		case REGION_3_BG_BAND:	/* 10 - 13 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_3_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_3_SIZE);
 			index += BG_BAND_REGION_3_SIZE;
 			break;
-		case REGION_4_BG_BAND:	// 14
+		case REGION_4_BG_BAND:	/* 14 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_4_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_4_SIZE);
 			index += BG_BAND_REGION_4_SIZE;
 			break;
-		case REGION_5_BG_BAND:	// 1 - 14
+		case REGION_5_BG_BAND:	/* 1 - 14 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_5_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_5_SIZE);
 			index += BG_BAND_REGION_5_SIZE;
 			break;
-		case REGION_6_BG_BAND:	// 3 - 9
+		case REGION_6_BG_BAND:	/* 3 - 9 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_6_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_6_SIZE);
 			index += BG_BAND_REGION_6_SIZE;
 			break;
-		case REGION_7_BG_BAND:	// 5 - 13
+		case REGION_7_BG_BAND:	/* 5 - 13 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_7_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_7_SIZE);
 			index += BG_BAND_REGION_7_SIZE;
 			break;
-		case REGION_31_BG_BAND:	// 1 - 14
+		case REGION_31_BG_BAND:	/* 1 - 14 */
 			NdisMoveMemory(&pAd->ChannelList[index],
 				       &pAd->TxPower[BG_BAND_REGION_31_START],
 				       sizeof(CHANNEL_TX_POWER) *
 				       BG_BAND_REGION_31_SIZE);
 			index += BG_BAND_REGION_31_SIZE;
 			break;
-		default:	// Error. should never happen
+		default:	/* Error. should never happen */
 			break;
 		}
 		for (i = 0; i < index; i++)
@@ -295,7 +295,7 @@ VOID BuildChannelList(IN PRTMP_ADAPTER pAd)
 			    sizeof(UCHAR);
 			pChannelList = A_BAND_REGION_15_CHANNEL_LIST;
 			break;
-		default:	// Error. should never happen
+		default:	/* Error. should never happen */
 			DBGPRINT(RT_DEBUG_WARN,
 				 ("countryregion=%d not support",
 				  pAd->CommonCfg.CountryRegionForABand));
@@ -411,12 +411,12 @@ UCHAR NextChannel(IN PRTMP_ADAPTER pAd, IN UCHAR channel)
 VOID ChangeToCellPowerLimit(IN PRTMP_ADAPTER pAd,
 			    IN UCHAR AironetCellPowerLimit)
 {
-	//valud 0xFF means that hasn't found power limit information
-	//from the AP's Beacon/Probe response.
+	/*valud 0xFF means that hasn't found power limit information */
+	/*from the AP's Beacon/Probe response. */
 	if (AironetCellPowerLimit == 0xFF)
 		return;
 
-	if (AironetCellPowerLimit < 6)	//Used Lowest Power Percentage.
+	if (AironetCellPowerLimit < 6)	/*Used Lowest Power Percentage. */
 		pAd->CommonCfg.TxPowerPercentage = 6;
 	else if (AironetCellPowerLimit < 9)
 		pAd->CommonCfg.TxPowerPercentage = 10;
@@ -427,7 +427,7 @@ VOID ChangeToCellPowerLimit(IN PRTMP_ADAPTER pAd,
 	else if (AironetCellPowerLimit < 15)
 		pAd->CommonCfg.TxPowerPercentage = 75;
 	else
-		pAd->CommonCfg.TxPowerPercentage = 100;	//else used maximum
+		pAd->CommonCfg.TxPowerPercentage = 100;	/*else used maximum */
 
 	if (pAd->CommonCfg.TxPowerPercentage > pAd->CommonCfg.TxPowerDefault)
 		pAd->CommonCfg.TxPowerPercentage =
@@ -439,7 +439,7 @@ CHAR ConvertToRssi(IN PRTMP_ADAPTER pAd, IN CHAR Rssi, IN UCHAR RssiNumber)
 {
 	UCHAR RssiOffset, LNAGain;
 
-	// Rssi equals to zero should be an invalid value
+	/* Rssi equals to zero should be an invalid value */
 	if (Rssi == 0)
 		return -99;
 
@@ -510,11 +510,11 @@ VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 		}
 
 		{
-			//
-			// To prevent data lost.
-			// Send an NULL data with turned PSM bit on to current associated AP before SCAN progress.
-			// Now, we need to send an NULL data with turned PSM bit off to AP, when scan progress done
-			//
+			/* */
+			/* To prevent data lost. */
+			/* Send an NULL data with turned PSM bit on to current associated AP before SCAN progress. */
+			/* Now, we need to send an NULL data with turned PSM bit off to AP, when scan progress done */
+			/* */
 			if (OPSTATUS_TEST_FLAG
 			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
 			    && (INFRA_ON(pAd))) {
@@ -532,7 +532,7 @@ VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 					pHdr80211->FC.PwrMgmt =
 					    (pAd->StaCfg.Psm == PWR_SAVE);
 
-					// Send using priority queue
+					/* Send using priority queue */
 					MiniportMMRequest(pAd, 0, pOutBuffer,
 							  sizeof
 							  (HEADER_802_11));
@@ -557,14 +557,14 @@ VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 		MlmeCntlConfirm(pAd, MT2_SCAN_CONF, MLME_FAIL_NO_RESOURCE);
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	else {
 		{
-			// BBP and RF are not accessible in PS mode, we has to wake them up first
+			/* BBP and RF are not accessible in PS mode, we has to wake them up first */
 			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 				AsicForceWakeup(pAd, TRUE);
 
-			// leave PSM during scanning. otherwise we may lost ProbeRsp & BEACON
+			/* leave PSM during scanning. otherwise we may lost ProbeRsp & BEACON */
 			if (pAd->StaCfg.Psm == PWR_SAVE)
 				RTMP_SET_PSM_BIT(pAd, PWR_ACTIVE);
 		}
@@ -584,18 +584,18 @@ VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 			}
 		}
 
-		//Global country domain(ch1-11:active scan, ch12-14 passive scan)
+		/*Global country domain(ch1-11:active scan, ch12-14 passive scan) */
 		if ((pAd->MlmeAux.Channel <= 14) && (pAd->MlmeAux.Channel >= 12)
 		    && ((pAd->CommonCfg.CountryRegion & 0x7f) ==
 			REGION_31_BG_BAND)) {
 			ScanType = SCAN_PASSIVE;
 		}
-		// We need to shorten active scan time in order for WZC connect issue
-		// Chnage the channel scan time for CISCO stuff based on its IAPP announcement
+		/* We need to shorten active scan time in order for WZC connect issue */
+		/* Chnage the channel scan time for CISCO stuff based on its IAPP announcement */
 		if (ScanType == FAST_SCAN_ACTIVE)
 			RTMPSetTimer(&pAd->MlmeAux.ScanTimer,
 				     FAST_ACTIVE_SCAN_TIME);
-		else		// must be SCAN_PASSIVE or SCAN_ACTIVE
+		else		/* must be SCAN_PASSIVE or SCAN_ACTIVE */
 		{
 			if ((pAd->CommonCfg.PhyMode == PHY_11ABG_MIXED)
 			    || (pAd->CommonCfg.PhyMode == PHY_11ABGN_MIXED)
@@ -615,7 +615,7 @@ VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 		if ((ScanType == SCAN_ACTIVE)
 		    || (ScanType == FAST_SCAN_ACTIVE)
 		    ) {
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 			if (NStatus != NDIS_STATUS_SUCCESS) {
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("SYNC - ScanNextChannel() allocate memory fail\n"));
@@ -631,7 +631,7 @@ VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 
 				return;
 			}
-			// There is no need to send broadcast probe request if active scan is in effect.
+			/* There is no need to send broadcast probe request if active scan is in effect. */
 			if ((ScanType == SCAN_ACTIVE)
 			    || (ScanType == FAST_SCAN_ACTIVE)
 			    )
@@ -694,7 +694,7 @@ VOID ScanNextChannel(IN PRTMP_ADAPTER pAd)
 			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 			MlmeFreeMemory(pAd, pOutBuffer);
 		}
-		// For SCAN_CISCO_PASSIVE, do nothing and silently wait for beacon or other probe reponse
+		/* For SCAN_CISCO_PASSIVE, do nothing and silently wait for beacon or other probe reponse */
 
 		pAd->Mlme.SyncMachine.CurrState = SCAN_LISTEN;
 	}
diff --git a/drivers/staging/rt2860/common/cmm_tkip.c b/drivers/staging/rt2860/common/cmm_tkip.c
index b93c3fa..97f0543 100644
--- a/drivers/staging/rt2860/common/cmm_tkip.c
+++ b/drivers/staging/rt2860/common/cmm_tkip.c
@@ -37,7 +37,7 @@
 
 #include	"../rt_config.h"
 
-// Rotation functions on 32 bit values
+/* Rotation functions on 32 bit values */
 #define ROL32( A, n ) \
 	( ((A) << (n)) | ( ((A)>>(32-(n))) & ( (1UL << (n)) - 1 ) ) )
 #define ROR32( A, n ) ROL32( (A), 32-(n) )
@@ -112,9 +112,9 @@ UINT Tkip_Sbox_Upper[256] = {
 	0x82, 0x29, 0x5A, 0x1E, 0x7B, 0xA8, 0x6D, 0x2C
 };
 
-//
-// Expanded IV for TKIP function.
-//
+/* */
+/* Expanded IV for TKIP function. */
+/* */
 typedef struct PACKED _IV_CONTROL_ {
 	union PACKED {
 		struct PACKED {
@@ -216,10 +216,10 @@ VOID RTMPTkipPutUInt32(IN OUT PUCHAR pDst, IN ULONG val)
 */
 VOID RTMPTkipSetMICKey(IN PTKIP_KEY_INFO pTkip, IN PUCHAR pMICKey)
 {
-	// Set the key
+	/* Set the key */
 	pTkip->K0 = RTMPTkipGetUInt32(pMICKey);
 	pTkip->K1 = RTMPTkipGetUInt32(pMICKey + 4);
-	// and reset the message
+	/* and reset the message */
 	pTkip->L = pTkip->K0;
 	pTkip->R = pTkip->K1;
 	pTkip->nBytesInM = 0;
@@ -247,10 +247,10 @@ VOID RTMPTkipSetMICKey(IN PTKIP_KEY_INFO pTkip, IN PUCHAR pMICKey)
 */
 VOID RTMPTkipAppendByte(IN PTKIP_KEY_INFO pTkip, IN UCHAR uChar)
 {
-	// Append the byte to our word-sized buffer
+	/* Append the byte to our word-sized buffer */
 	pTkip->M |= (uChar << (8 * pTkip->nBytesInM));
 	pTkip->nBytesInM++;
-	// Process the word if it is full.
+	/* Process the word if it is full. */
 	if (pTkip->nBytesInM >= 4) {
 		pTkip->L ^= pTkip->M;
 		pTkip->R ^= ROL32(pTkip->L, 17);
@@ -263,7 +263,7 @@ VOID RTMPTkipAppendByte(IN PTKIP_KEY_INFO pTkip, IN UCHAR uChar)
 		pTkip->L += pTkip->R;
 		pTkip->R ^= ROR32(pTkip->L, 2);
 		pTkip->L += pTkip->R;
-		// Clear the buffer
+		/* Clear the buffer */
 		pTkip->M = 0;
 		pTkip->nBytesInM = 0;
 	}
@@ -291,7 +291,7 @@ VOID RTMPTkipAppendByte(IN PTKIP_KEY_INFO pTkip, IN UCHAR uChar)
 */
 VOID RTMPTkipAppend(IN PTKIP_KEY_INFO pTkip, IN PUCHAR pSrc, IN UINT nBytes)
 {
-	// This is simple
+	/* This is simple */
 	while (nBytes > 0) {
 		RTMPTkipAppendByte(pTkip, *pSrc++);
 		nBytes--;
@@ -318,17 +318,17 @@ VOID RTMPTkipAppend(IN PTKIP_KEY_INFO pTkip, IN PUCHAR pSrc, IN UINT nBytes)
 */
 VOID RTMPTkipGetMIC(IN PTKIP_KEY_INFO pTkip)
 {
-	// Append the minimum padding
+	/* Append the minimum padding */
 	RTMPTkipAppendByte(pTkip, 0x5a);
 	RTMPTkipAppendByte(pTkip, 0);
 	RTMPTkipAppendByte(pTkip, 0);
 	RTMPTkipAppendByte(pTkip, 0);
 	RTMPTkipAppendByte(pTkip, 0);
-	// and then zeroes until the length is a multiple of 4
+	/* and then zeroes until the length is a multiple of 4 */
 	while (pTkip->nBytesInM != 0) {
 		RTMPTkipAppendByte(pTkip, 0);
 	}
-	// The appendByte function has already computed the result.
+	/* The appendByte function has already computed the result. */
 	RTMPTkipPutUInt32(pTkip->MIC, pTkip->L);
 	RTMPTkipPutUInt32(pTkip->MIC + 4, pTkip->R);
 }
@@ -364,15 +364,15 @@ VOID RTMPInitTkipEngine(IN PRTMP_ADAPTER pAd,
 {
 	TKIP_IV tkipIv;
 
-	// Prepare 8 bytes TKIP encapsulation for MPDU
+	/* Prepare 8 bytes TKIP encapsulation for MPDU */
 	NdisZeroMemory(&tkipIv, sizeof(TKIP_IV));
 	tkipIv.IV16.field.rc0 = *(pTSC + 1);
 	tkipIv.IV16.field.rc1 = (tkipIv.IV16.field.rc0 | 0x20) & 0x7f;
 	tkipIv.IV16.field.rc2 = *pTSC;
-	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;	// 0: non-extended IV, 1: an extended IV
+	tkipIv.IV16.field.CONTROL.field.ExtIV = 1;	/* 0: non-extended IV, 1: an extended IV */
 	tkipIv.IV16.field.CONTROL.field.KeyID = KeyId;
-//      tkipIv.IV32 = *(PULONG)(pTSC + 2);
-	NdisMoveMemory(&tkipIv.IV32, (pTSC + 2), 4);	// Copy IV
+/*      tkipIv.IV32 = *(PULONG)(pTSC + 2); */
+	NdisMoveMemory(&tkipIv.IV32, (pTSC + 2), 4);	/* Copy IV */
 
 	*pIV16 = tkipIv.IV16.word;
 	*pIV32 = tkipIv.IV32;
@@ -406,13 +406,13 @@ VOID RTMPInitMICEngine(IN PRTMP_ADAPTER pAd,
 {
 	ULONG Priority = UserPriority;
 
-	// Init MIC value calculation
+	/* Init MIC value calculation */
 	RTMPTkipSetMICKey(&pAd->PrivateInfo.Tx, pMICKey);
-	// DA
+	/* DA */
 	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pDA, MAC_ADDR_LEN);
-	// SA
+	/* SA */
 	RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSA, MAC_ADDR_LEN);
-	// Priority + 3 bytes of 0
+	/* Priority + 3 bytes of 0 */
 	RTMPTkipAppend(&pAd->PrivateInfo.Tx, (PUCHAR) & Priority, 4);
 }
 
@@ -450,28 +450,28 @@ BOOLEAN RTMPTkipCompareMICValue(IN PRTMP_ADAPTER pAd,
 	UCHAR OldMic[8];
 	ULONG Priority = UserPriority;
 
-	// Init MIC value calculation
+	/* Init MIC value calculation */
 	RTMPTkipSetMICKey(&pAd->PrivateInfo.Rx, pMICKey);
-	// DA
+	/* DA */
 	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pDA, MAC_ADDR_LEN);
-	// SA
+	/* SA */
 	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSA, MAC_ADDR_LEN);
-	// Priority + 3 bytes of 0
+	/* Priority + 3 bytes of 0 */
 	RTMPTkipAppend(&pAd->PrivateInfo.Rx, (PUCHAR) & Priority, 4);
 
-	// Calculate MIC value from plain text data
+	/* Calculate MIC value from plain text data */
 	RTMPTkipAppend(&pAd->PrivateInfo.Rx, pSrc, Len);
 
-	// Get MIC valude from received frame
+	/* Get MIC valude from received frame */
 	NdisMoveMemory(OldMic, pSrc + Len, 8);
 
-	// Get MIC value from decrypted plain data
+	/* Get MIC value from decrypted plain data */
 	RTMPTkipGetMIC(&pAd->PrivateInfo.Rx);
 
-	// Move MIC value from MSDU, this steps should move to data path.
-	// Since the MIC value might cross MPDUs.
+	/* Move MIC value from MSDU, this steps should move to data path. */
+	/* Since the MIC value might cross MPDUs. */
 	if (!NdisEqualMemory(pAd->PrivateInfo.Rx.MIC, OldMic, 8)) {
-		DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTMPTkipCompareMICValue(): TKIP MIC Error !\n"));	//MIC error.
+		DBGPRINT_RAW(RT_DEBUG_ERROR, ("RTMPTkipCompareMICValue(): TKIP MIC Error !\n"));	/*MIC error. */
 
 		return (FALSE);
 	}
@@ -517,7 +517,7 @@ VOID RTMPCalculateMICValue(IN PRTMP_ADAPTER pAd,
 	UserPriority = RTMP_GET_PACKET_UP(pPacket);
 	pSrc = pSrcBufVA;
 
-	// determine if this is a vlan packet
+	/* determine if this is a vlan packet */
 	if (((*(pSrc + 12) << 8) + *(pSrc + 13)) == 0x8100)
 		vlan_offset = 4;
 
@@ -528,9 +528,9 @@ VOID RTMPCalculateMICValue(IN PRTMP_ADAPTER pAd,
 	}
 
 	if (pEncap != NULL) {
-		// LLC encapsulation
+		/* LLC encapsulation */
 		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pEncap, 6);
-		// Protocol Type
+		/* Protocol Type */
 		RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc + 12 + vlan_offset,
 			       2);
 	}
@@ -541,11 +541,11 @@ VOID RTMPCalculateMICValue(IN PRTMP_ADAPTER pAd,
 			RTMPTkipAppend(&pAd->PrivateInfo.Tx, pSrc, SrcBufLen);
 		}
 
-		break;		// No need handle next packet
+		break;		/* No need handle next packet */
 
-	} while (TRUE);		// End of copying payload
+	} while (TRUE);		/* End of copying payload */
 
-	// Compute the final MIC Value
+	/* Compute the final MIC Value */
 	RTMPTkipGetMIC(&pAd->PrivateInfo.Tx);
 }
 
@@ -694,10 +694,10 @@ VOID RTMPTkipMixKey(UCHAR * key, UCHAR * ta, ULONG pnl,	/* Least significant 16
 	rc4key[15] = (ppk5 >> 8) % 256;
 }
 
-//
-// TRUE: Success!
-// FALSE: Decrypt Error!
-//
+/* */
+/* TRUE: Success! */
+/* FALSE: Decrypt Error! */
+/* */
 BOOLEAN RTMPSoftDecryptTKIP(IN PRTMP_ADAPTER pAd,
 			    IN PUCHAR pData,
 			    IN ULONG DataByteCnt,
@@ -721,7 +721,7 @@ BOOLEAN RTMPSoftDecryptTKIP(IN PRTMP_ADAPTER pAd,
 	UCHAR DA[MAC_ADDR_LEN];
 	UCHAR SA[MAC_ADDR_LEN];
 	UCHAR RC4Key[16];
-	UINT p1k[5];		//for mix_key;
+	UINT p1k[5];		/*for mix_key; */
 	ULONG pnl;		/* Least significant 16 bits of PN */
 	ULONG pnh;		/* Most significant 32 bits of PN */
 	UINT num_blocks;
@@ -778,7 +778,7 @@ BOOLEAN RTMPSoftDecryptTKIP(IN PRTMP_ADAPTER pAd,
 	if (to_ds == 0 && from_ds == 1) {
 		NdisMoveMemory(DA, pData + 4, MAC_ADDR_LEN);
 		NdisMoveMemory(SA, pData + 16, MAC_ADDR_LEN);
-		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);	//BSSID
+		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);	/*BSSID */
 	} else if (to_ds == 0 && from_ds == 0) {
 		NdisMoveMemory(TA, pData + 10, MAC_ADDR_LEN);
 		NdisMoveMemory(DA, pData + 4, MAC_ADDR_LEN);
@@ -806,11 +806,11 @@ BOOLEAN RTMPSoftDecryptTKIP(IN PRTMP_ADAPTER pAd,
 	ARCFOUR_DECRYPT(&ArcFourContext, pData + HeaderLen,
 			pData + HeaderLen + 8, DataByteCnt - HeaderLen - 8);
 	NdisMoveMemory(&trailfcs, pData + DataByteCnt - 8 - 4, 4);
-	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 4);	//Skip IV+EIV 8 bytes & Skip last 4 bytes(FCS).
+	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pData + HeaderLen, DataByteCnt - HeaderLen - 8 - 4);	/*Skip IV+EIV 8 bytes & Skip last 4 bytes(FCS). */
 	crc32 ^= 0xffffffff;	/* complement */
 
 	if (crc32 != cpu2le32(trailfcs)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("RTMPSoftDecryptTKIP, WEP Data ICV Error !\n"));	//ICV error.
+		DBGPRINT(RT_DEBUG_TRACE, ("RTMPSoftDecryptTKIP, WEP Data ICV Error !\n"));	/*ICV error. */
 
 		return (FALSE);
 	}
@@ -824,10 +824,10 @@ BOOLEAN RTMPSoftDecryptTKIP(IN PRTMP_ADAPTER pAd,
 	NdisMoveMemory(MIC, pAd->PrivateInfo.Tx.MIC, 8);
 
 	if (!NdisEqualMemory(MIC, TrailMIC, 8)) {
-		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptTKIP, WEP Data MIC Error !\n"));	//MIC error.
-		//RTMPReportMicError(pAd, &pWpaKey[KeyID]);     // marked by AlbertY @ 20060630
+		DBGPRINT(RT_DEBUG_ERROR, ("RTMPSoftDecryptTKIP, WEP Data MIC Error !\n"));	/*MIC error. */
+		/*RTMPReportMicError(pAd, &pWpaKey[KeyID]);     // marked by AlbertY @ 20060630 */
 		return (FALSE);
 	}
-	//DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP Decript done!!\n");
+	/*DBGPRINT(RT_DEBUG_TRACE, "RTMPSoftDecryptTKIP Decript done!!\n"); */
 	return TRUE;
 }
diff --git a/drivers/staging/rt2860/common/cmm_wep.c b/drivers/staging/rt2860/common/cmm_wep.c
index 4f407e9..db40139 100644
--- a/drivers/staging/rt2860/common/cmm_wep.c
+++ b/drivers/staging/rt2860/common/cmm_wep.c
@@ -141,25 +141,25 @@ VOID RTMPInitWepEngine(IN PRTMP_ADAPTER pAd,
 {
 	UINT i;
 	UCHAR WEPKEY[] = {
-		//IV
+		/*IV */
 		0x00, 0x11, 0x22,
-		//WEP KEY
+		/*WEP KEY */
 		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
 		    0xAA, 0xBB, 0xCC
 	};
 
-	pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	//Init crc32.
+	pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	/*Init crc32. */
 
 	{
 		NdisMoveMemory(WEPKEY + 3, pKey, KeyLen);
 
 		for (i = 0; i < 3; i++)
-			WEPKEY[i] = RandomByte(pAd);	//Call mlme RandomByte() function.
-		ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY, KeyLen + 3);	//INIT SBOX, KEYLEN+3(IV)
+			WEPKEY[i] = RandomByte(pAd);	/*Call mlme RandomByte() function. */
+		ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, WEPKEY, KeyLen + 3);	/*INIT SBOX, KEYLEN+3(IV) */
 
-		NdisMoveMemory(pDest, WEPKEY, 3);	//Append Init Vector
+		NdisMoveMemory(pDest, WEPKEY, 3);	/*Append Init Vector */
 	}
-	*(pDest + 3) = (KeyId << 6);	//Append KEYID
+	*(pDest + 3) = (KeyId << 6);	/*Append KEYID */
 
 }
 
@@ -219,16 +219,16 @@ BOOLEAN RTMPSoftDecryptWEP(IN PRTMP_ADAPTER pAd,
 	UINT crc32;
 	UCHAR KeyIdx;
 	UCHAR WEPKEY[] = {
-		//IV
+		/*IV */
 		0x00, 0x11, 0x22,
-		//WEP KEY
+		/*WEP KEY */
 		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
 		    0xAA, 0xBB, 0xCC
 	};
 	UCHAR *pPayload = (UCHAR *) pData + LENGTH_802_11;
 	ULONG payload_len = DataByteCnt - LENGTH_802_11;
 
-	NdisMoveMemory(WEPKEY, pPayload, 3);	//Get WEP IV
+	NdisMoveMemory(WEPKEY, pPayload, 3);	/*Get WEP IV */
 
 	KeyIdx = (*(pPayload + 3) & 0xc0) >> 6;
 	if (pGroupKey[KeyIdx].KeyLen == 0)
@@ -241,11 +241,11 @@ BOOLEAN RTMPSoftDecryptWEP(IN PRTMP_ADAPTER pAd,
 	ARCFOUR_DECRYPT(&pAd->PrivateInfo.WEPCONTEXT, pPayload, pPayload + 4,
 			payload_len - 4);
 	NdisMoveMemory(&trailfcs, pPayload + payload_len - 8, 4);
-	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pPayload, payload_len - 8);	//Skip last 4 bytes(FCS).
+	crc32 = RTMP_CALC_FCS32(PPPINITFCS32, pPayload, payload_len - 8);	/*Skip last 4 bytes(FCS). */
 	crc32 ^= 0xffffffff;	/* complement */
 
 	if (crc32 != cpu2le32(trailfcs)) {
-		DBGPRINT(RT_DEBUG_TRACE, ("! WEP Data CRC Error !\n"));	//CRC error.
+		DBGPRINT(RT_DEBUG_TRACE, ("! WEP Data CRC Error !\n"));	/*CRC error. */
 		return (FALSE);
 	}
 	return (TRUE);
@@ -411,7 +411,7 @@ VOID WPAARCFOUR_ENCRYPT(IN PARCFOURCONTEXT Ctx,
 			IN PUCHAR pDest, IN PUCHAR pSrc, IN UINT Len)
 {
 	UINT i;
-	//discard first 256 bytes
+	/*discard first 256 bytes */
 	for (i = 0; i < 256; i++)
 		ARCFOUR_BYTE(Ctx);
 
diff --git a/drivers/staging/rt2860/common/cmm_wpa.c b/drivers/staging/rt2860/common/cmm_wpa.c
index 4d070af..6940d77 100644
--- a/drivers/staging/rt2860/common/cmm_wpa.c
+++ b/drivers/staging/rt2860/common/cmm_wpa.c
@@ -36,7 +36,7 @@
 	Paul Lin	03-11-28		Modify for supplicant
 */
 #include "../rt_config.h"
-// WPA OUI
+/* WPA OUI */
 UCHAR OUI_WPA_NONE_AKM[4] = { 0x00, 0x50, 0xF2, 0x00 };
 UCHAR OUI_WPA_VERSION[4] = { 0x00, 0x50, 0xF2, 0x01 };
 UCHAR OUI_WPA_WEP40[4] = { 0x00, 0x50, 0xF2, 0x01 };
@@ -46,7 +46,7 @@ UCHAR OUI_WPA_WEP104[4] = { 0x00, 0x50, 0xF2, 0x05 };
 UCHAR OUI_WPA_8021X_AKM[4] = { 0x00, 0x50, 0xF2, 0x01 };
 UCHAR OUI_WPA_PSK_AKM[4] = { 0x00, 0x50, 0xF2, 0x02 };
 
-// WPA2 OUI
+/* WPA2 OUI */
 UCHAR OUI_WPA2_WEP40[4] = { 0x00, 0x0F, 0xAC, 0x01 };
 UCHAR OUI_WPA2_TKIP[4] = { 0x00, 0x0F, 0xAC, 0x02 };
 UCHAR OUI_WPA2_CCMP[4] = { 0x00, 0x0F, 0xAC, 0x04 };
@@ -143,7 +143,7 @@ VOID WpaEAPOLStartAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	pHeader = (PHEADER_802_11) Elem->Msg;
 
-	//For normaol PSK, we enqueue an EAPOL-Start command to trigger the process.
+	/*For normaol PSK, we enqueue an EAPOL-Start command to trigger the process. */
 	if (Elem->MsgLen == 6)
 		pEntry = MacTableLookup(pAd, Elem->Msg);
 	else {
@@ -232,41 +232,41 @@ VOID WpaEAPOLKeyAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				 ("Key descripter does not match with WPA rule\n"));
 			break;
 		}
-		// The value 1 shall be used for all EAPOL-Key frames to and from a STA when
-		// neither the group nor pairwise ciphers are CCMP for Key Descriptor 1.
+		/* The value 1 shall be used for all EAPOL-Key frames to and from a STA when */
+		/* neither the group nor pairwise ciphers are CCMP for Key Descriptor 1. */
 		if ((pEntry->WepStatus == Ndis802_11Encryption2Enabled)
 		    && (peerKeyInfo.KeyDescVer != DESC_TYPE_TKIP)) {
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("Key descripter version not match(TKIP) \n"));
 			break;
 		}
-		// The value 2 shall be used for all EAPOL-Key frames to and from a STA when
-		// either the pairwise or the group cipher is AES-CCMP for Key Descriptor 2.
+		/* The value 2 shall be used for all EAPOL-Key frames to and from a STA when */
+		/* either the pairwise or the group cipher is AES-CCMP for Key Descriptor 2. */
 		else if ((pEntry->WepStatus == Ndis802_11Encryption3Enabled)
 			 && (peerKeyInfo.KeyDescVer != DESC_TYPE_AES)) {
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("Key descripter version not match(AES) \n"));
 			break;
 		}
-		// Check if this STA is in class 3 state and the WPA state is started
+		/* Check if this STA is in class 3 state and the WPA state is started */
 		if ((pEntry->Sst == SST_ASSOC)
 		    && (pEntry->WpaState >= AS_INITPSK)) {
-			// Check the Key Ack (bit 7) of the Key Information to determine the Authenticator
-			// or not.
-			// An EAPOL-Key frame that is sent by the Supplicant in response to an EAPOL-
-			// Key frame from the Authenticator must not have the Ack bit set.
+			/* Check the Key Ack (bit 7) of the Key Information to determine the Authenticator */
+			/* or not. */
+			/* An EAPOL-Key frame that is sent by the Supplicant in response to an EAPOL- */
+			/* Key frame from the Authenticator must not have the Ack bit set. */
 			if (peerKeyInfo.KeyAck == 1) {
-				// The frame is snet by Authenticator.
-				// So the Supplicant side shall handle this.
+				/* The frame is snet by Authenticator. */
+				/* So the Supplicant side shall handle this. */
 
 				if ((peerKeyInfo.Secure == 0)
 				    && (peerKeyInfo.Request == 0)
 				    && (peerKeyInfo.Error == 0)
 				    && (peerKeyInfo.KeyType == PAIRWISEKEY)) {
-					// Process 1. the message 1 of 4-way HS in WPA or WPA2
-					//                        EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1)
-					//                 2. the message 3 of 4-way HS in WPA
-					//                        EAPOL-Key(0,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3)
+					/* Process 1. the message 1 of 4-way HS in WPA or WPA2 */
+					/*                        EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1) */
+					/*                 2. the message 3 of 4-way HS in WPA */
+					/*                        EAPOL-Key(0,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3) */
 					if (peerKeyInfo.KeyMic == 0)
 						PeerPairMsg1Action(pAd, pEntry,
 								   Elem);
@@ -277,10 +277,10 @@ VOID WpaEAPOLKeyAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					   && (peerKeyInfo.KeyMic == 1)
 					   && (peerKeyInfo.Request == 0)
 					   && (peerKeyInfo.Error == 0)) {
-					// Process 1. the message 3 of 4-way HS in WPA2
-					//                        EAPOL-Key(1,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3)
-					//                 2. the message 1 of group KS in WPA or WPA2
-					//                        EAPOL-Key(1,1,1,0,G,0,Key RSC,0, MIC,GTK[N])
+					/* Process 1. the message 3 of 4-way HS in WPA2 */
+					/*                        EAPOL-Key(1,1,1,1,P,0,KeyRSC,ANonce,MIC,DataKD_M3) */
+					/*                 2. the message 1 of group KS in WPA or WPA2 */
+					/*                        EAPOL-Key(1,1,1,0,G,0,Key RSC,0, MIC,GTK[N]) */
 					if (peerKeyInfo.KeyType == PAIRWISEKEY)
 						PeerPairMsg3Action(pAd, pEntry,
 								   Elem);
@@ -289,17 +289,17 @@ VOID WpaEAPOLKeyAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 								    Elem);
 				}
 			} else {
-				// The frame is snet by Supplicant.
-				// So the Authenticator side shall handle this.
+				/* The frame is snet by Supplicant. */
+				/* So the Authenticator side shall handle this. */
 				if ((peerKeyInfo.Request == 0) &&
 				    (peerKeyInfo.Error == 0) &&
 				    (peerKeyInfo.KeyMic == 1)) {
 					if (peerKeyInfo.Secure == 0
 					    && peerKeyInfo.KeyType ==
 					    PAIRWISEKEY) {
-						// EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,Data)
-						// Process 1. message 2 of 4-way HS in WPA or WPA2
-						//                 2. message 4 of 4-way HS in WPA
+						/* EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,Data) */
+						/* Process 1. message 2 of 4-way HS in WPA or WPA2 */
+						/*                 2. message 4 of 4-way HS in WPA */
 						if (CONV_ARRARY_TO_UINT16
 						    (pEapol_packet->KeyDesc.
 						     KeyDataLen) == 0) {
@@ -314,15 +314,15 @@ VOID WpaEAPOLKeyAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					} else if (peerKeyInfo.Secure == 1
 						   && peerKeyInfo.KeyType ==
 						   PAIRWISEKEY) {
-						// EAPOL-Key(1,1,0,0,P,0,0,0,MIC,0)
-						// Process message 4 of 4-way HS in WPA2
+						/* EAPOL-Key(1,1,0,0,P,0,0,0,MIC,0) */
+						/* Process message 4 of 4-way HS in WPA2 */
 						PeerPairMsg4Action(pAd, pEntry,
 								   Elem);
 					} else if (peerKeyInfo.Secure == 1
 						   && peerKeyInfo.KeyType ==
 						   GROUPKEY) {
-						// EAPOL-Key(1,1,0,0,G,0,0,0,MIC,0)
-						// Process message 2 of Group key HS in WPA or WPA2
+						/* EAPOL-Key(1,1,0,0,G,0,0,0,MIC,0) */
+						/* Process message 2 of Group key HS in WPA or WPA2 */
 						PeerGroupMsg2Action(pAd, pEntry,
 								    &Elem->
 								    Msg
@@ -370,7 +370,7 @@ VOID RTMPToWirelessSta(IN PRTMP_ADAPTER pAd,
 		return;
 
 	do {
-		// build a NDIS packet
+		/* build a NDIS packet */
 		Status =
 		    RTMPAllocateNdisPacket(pAd, &pPacket, pHeader802_3, HdrLen,
 					   pData, DataLen);
@@ -384,7 +384,7 @@ VOID RTMPToWirelessSta(IN PRTMP_ADAPTER pAd,
 		{
 			RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
 
-			RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket, MAIN_MBSSID);	// set a default value
+			RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket, MAIN_MBSSID);	/* set a default value */
 			if (pEntry->apidx != 0)
 				RTMP_SET_PACKET_NET_DEVICE_MBSSID(pPacket,
 								  pEntry->
@@ -395,16 +395,16 @@ VOID RTMPToWirelessSta(IN PRTMP_ADAPTER pAd,
 		}
 
 		{
-			// send out the packet
+			/* send out the packet */
 			Status = STASendPacket(pAd, pPacket);
 			if (Status == NDIS_STATUS_SUCCESS) {
 				UCHAR Index;
 
-				// Dequeue one frame from TxSwQueue0..3 queue and process it
-				// There are three place calling dequeue for TX ring.
-				// 1. Here, right after queueing the frame.
-				// 2. At the end of TxRingTxDone service routine.
-				// 3. Upon NDIS call RTMPSendPackets
+				/* Dequeue one frame from TxSwQueue0..3 queue and process it */
+				/* There are three place calling dequeue for TX ring. */
+				/* 1. Here, right after queueing the frame. */
+				/* 2. At the end of TxRingTxDone service routine. */
+				/* 3. Upon NDIS call RTMPSendPackets */
 				if ((!RTMP_TEST_FLAG
 				     (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
 				    &&
@@ -457,30 +457,30 @@ VOID WPAStart4WayHS(IN PRTMP_ADAPTER pAd,
 			 ("[ERROR]WPAStart4WayHS : No corresponding Authenticator.\n"));
 		return;
 	}
-	// Check the status
+	/* Check the status */
 	if ((pEntry->WpaState > AS_PTKSTART) || (pEntry->WpaState < AS_INITPMK)) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("[ERROR]WPAStart4WayHS : Not expect calling\n"));
 		return;
 	}
 
-	// Increment replay counter by 1
+	/* Increment replay counter by 1 */
 	ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
 
-	// Randomly generate ANonce
+	/* Randomly generate ANonce */
 	GenRandom(pAd, (UCHAR *) pBssid, pEntry->ANonce);
 
-	// Construct EAPoL message - Pairwise Msg 1
-	// EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1)
+	/* Construct EAPoL message - Pairwise Msg 1 */
+	/* EAPOL-Key(0,0,1,0,P,0,0,ANonce,0,DataKD_M1) */
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_1, 0,	// Default key index
-			  pEntry->ANonce, NULL,	// TxRSC
-			  NULL,	// GTK
-			  NULL,	// RSNIE
-			  0,	// RSNIE length
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_1, 0,	/* Default key index */
+			  pEntry->ANonce, NULL,	/* TxRSC */
+			  NULL,	/* GTK */
+			  NULL,	/* RSNIE */
+			  0,	/* RSNIE length */
 			  &EAPOLPKT);
 
-	// Make outgoing frame
+	/* Make outgoing frame */
 	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
 	RTMPToWirelessSta(pAd, pEntry, Header802_3,
 			  LENGTH_802_3, (PUCHAR) & EAPOLPKT,
@@ -488,10 +488,10 @@ VOID WPAStart4WayHS(IN PRTMP_ADAPTER pAd,
 			  (pEntry->PortSecured ==
 			   WPA_802_1X_PORT_SECURED) ? FALSE : TRUE);
 
-	// Trigger Retry Timer
+	/* Trigger Retry Timer */
 	RTMPModTimer(&pEntry->RetryTimer, TimeInterval);
 
-	// Update State
+	/* Update State */
 	pEntry->WpaState = AS_PTKSTART;
 
 	DBGPRINT(RT_DEBUG_TRACE,
@@ -548,50 +548,50 @@ VOID PeerPairMsg1Action(IN PRTMP_ADAPTER pAd,
 		rsnie_len = pAd->StaCfg.RSNIE_Len;
 	}
 
-	// Store the received frame
+	/* Store the received frame */
 	pMsg1 = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
-	// Sanity Check peer Pairwise message 1 - Replay Counter
+	/* Sanity Check peer Pairwise message 1 - Replay Counter */
 	if (PeerWpaMessageSanity(pAd, pMsg1, MsgLen, EAPOL_PAIR_MSG_1, pEntry)
 	    == FALSE)
 		return;
 
-	// Store Replay counter, it will use to verify message 3 and construct message 2
+	/* Store Replay counter, it will use to verify message 3 and construct message 2 */
 	NdisMoveMemory(pEntry->R_Counter, pMsg1->KeyDesc.ReplayCounter,
 		       LEN_KEY_DESC_REPLAY);
 
-	// Store ANonce
+	/* Store ANonce */
 	NdisMoveMemory(pEntry->ANonce, pMsg1->KeyDesc.KeyNonce,
 		       LEN_KEY_DESC_NONCE);
 
-	// Generate random SNonce
+	/* Generate random SNonce */
 	GenRandom(pAd, (UCHAR *) pCurrentAddr, pEntry->SNonce);
 
 	{
-		// Calculate PTK(ANonce, SNonce)
+		/* Calculate PTK(ANonce, SNonce) */
 		WpaDerivePTK(pAd,
 			     pmk_ptr,
 			     pEntry->ANonce,
 			     pEntry->Addr,
 			     pEntry->SNonce, pCurrentAddr, PTK, LEN_PTK);
 
-		// Save key to PTK entry
+		/* Save key to PTK entry */
 		NdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);
 	}
 
-	// Update WpaState
+	/* Update WpaState */
 	pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
 
-	// Construct EAPoL message - Pairwise Msg 2
-	//  EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,DataKD_M2)
+	/* Construct EAPoL message - Pairwise Msg 2 */
+	/*  EAPOL-Key(0,1,0,0,P,0,0,SNonce,MIC,DataKD_M2) */
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_2, 0,	// DefaultKeyIdx
-			  pEntry->SNonce, NULL,	// TxRsc
-			  NULL,	// GTK
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_2, 0,	/* DefaultKeyIdx */
+			  pEntry->SNonce, NULL,	/* TxRsc */
+			  NULL,	/* GTK */
 			  (UCHAR *) rsnie_ptr, rsnie_len, &EAPOLPKT);
 
-	// Make outgoing frame
+	/* Make outgoing frame */
 	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
 
 	RTMPToWirelessSta(pAd, pEntry,
@@ -638,46 +638,46 @@ VOID PeerPairMsg2Action(IN PRTMP_ADAPTER pAd,
 	     sizeof(KEY_DESCRIPTER) - MAX_LEN_OF_RSNIE - 2))
 		return;
 
-	// check Entry in valid State
+	/* check Entry in valid State */
 	if (pEntry->WpaState < AS_PTKSTART)
 		return;
 
-	// pointer to 802.11 header
+	/* pointer to 802.11 header */
 	pHeader = (PHEADER_802_11) Elem->Msg;
 
-	// skip 802.11_header(24-byte) and LLC_header(8)
+	/* skip 802.11_header(24-byte) and LLC_header(8) */
 	pMsg2 = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
-	// Store SNonce
+	/* Store SNonce */
 	NdisMoveMemory(pEntry->SNonce, pMsg2->KeyDesc.KeyNonce,
 		       LEN_KEY_DESC_NONCE);
 
 	{
-		// Derive PTK
-		WpaDerivePTK(pAd, (UCHAR *) pmk_ptr, pEntry->ANonce,	// ANONCE
-			     (UCHAR *) pBssid, pEntry->SNonce,	// SNONCE
+		/* Derive PTK */
+		WpaDerivePTK(pAd, (UCHAR *) pmk_ptr, pEntry->ANonce,	/* ANONCE */
+			     (UCHAR *) pBssid, pEntry->SNonce,	/* SNONCE */
 			     pEntry->Addr, PTK, LEN_PTK);
 
 		NdisMoveMemory(pEntry->PTK, PTK, LEN_PTK);
 	}
 
-	// Sanity Check peer Pairwise message 2 - Replay Counter, MIC, RSNIE
+	/* Sanity Check peer Pairwise message 2 - Replay Counter, MIC, RSNIE */
 	if (PeerWpaMessageSanity(pAd, pMsg2, MsgLen, EAPOL_PAIR_MSG_2, pEntry)
 	    == FALSE)
 		return;
 
 	do {
-		// delete retry timer
+		/* delete retry timer */
 		RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
 
-		// Change state
+		/* Change state */
 		pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
 
-		// Increment replay counter by 1
+		/* Increment replay counter by 1 */
 		ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
 
-		// Construct EAPoL message - Pairwise Msg 3
+		/* Construct EAPoL message - Pairwise Msg 3 */
 		NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
 		ConstructEapolMsg(pEntry,
 				  group_cipher,
@@ -688,7 +688,7 @@ VOID PeerPairMsg2Action(IN PRTMP_ADAPTER pAd,
 				  (UCHAR *) gtk_ptr,
 				  (UCHAR *) rsnie_ptr, rsnie_len, &EAPOLPKT);
 
-		// Make outgoing frame
+		/* Make outgoing frame */
 		MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
 		RTMPToWirelessSta(pAd, pEntry, Header802_3, LENGTH_802_3,
 				  (PUCHAR) & EAPOLPKT,
@@ -699,7 +699,7 @@ VOID PeerPairMsg2Action(IN PRTMP_ADAPTER pAd,
 		pEntry->ReTryCounter = PEER_MSG3_RETRY_TIMER_CTR;
 		RTMPSetTimer(&pEntry->RetryTimer, PEER_MSG3_RETRY_EXEC_INTV);
 
-		// Update State
+		/* Update State */
 		pEntry->WpaState = AS_PTKINIT_NEGOTIATING;
 	} while (FALSE);
 
@@ -751,38 +751,38 @@ VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
 
 	}
 
-	// Record 802.11 header & the received EAPOL packet Msg3
+	/* Record 802.11 header & the received EAPOL packet Msg3 */
 	pHeader = (PHEADER_802_11) Elem->Msg;
 	pMsg3 = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
-	// Sanity Check peer Pairwise message 3 - Replay Counter, MIC, RSNIE
+	/* Sanity Check peer Pairwise message 3 - Replay Counter, MIC, RSNIE */
 	if (PeerWpaMessageSanity(pAd, pMsg3, MsgLen, EAPOL_PAIR_MSG_3, pEntry)
 	    == FALSE)
 		return;
 
-	// Save Replay counter, it will use construct message 4
+	/* Save Replay counter, it will use construct message 4 */
 	NdisMoveMemory(pEntry->R_Counter, pMsg3->KeyDesc.ReplayCounter,
 		       LEN_KEY_DESC_REPLAY);
 
-	// Double check ANonce
+	/* Double check ANonce */
 	if (!NdisEqualMemory
 	    (pEntry->ANonce, pMsg3->KeyDesc.KeyNonce, LEN_KEY_DESC_NONCE)) {
 		return;
 	}
-	// Construct EAPoL message - Pairwise Msg 4
+	/* Construct EAPoL message - Pairwise Msg 4 */
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_4, 0,	// group key index not used in message 4
-			  NULL,	// Nonce not used in message 4
-			  NULL,	// TxRSC not used in message 4
-			  NULL,	// GTK not used in message 4
-			  NULL,	// RSN IE not used in message 4
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_PAIR_MSG_4, 0,	/* group key index not used in message 4 */
+			  NULL,	/* Nonce not used in message 4 */
+			  NULL,	/* TxRSC not used in message 4 */
+			  NULL,	/* GTK not used in message 4 */
+			  NULL,	/* RSN IE not used in message 4 */
 			  0, &EAPOLPKT);
 
-	// Update WpaState
+	/* Update WpaState */
 	pEntry->WpaState = AS_PTKINITDONE;
 
-	// Update pairwise key
+	/* Update pairwise key */
 	{
 		PCIPHER_KEY pSharedKey;
 
@@ -790,7 +790,7 @@ VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
 
 		NdisMoveMemory(pAd->StaCfg.PTK, pEntry->PTK, LEN_PTK);
 
-		// Prepare pair-wise key information into shared key table
+		/* Prepare pair-wise key information into shared key table */
 		NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 		pSharedKey->KeyLen = LEN_TKIP_EK;
 		NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32],
@@ -801,7 +801,7 @@ VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
 			       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK],
 			       LEN_TKIP_TXMICK);
 
-		// Decide its ChiperAlg
+		/* Decide its ChiperAlg */
 		if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
 			pSharedKey->CipherAlg = CIPHER_TKIP;
 		else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
@@ -809,7 +809,7 @@ VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
 		else
 			pSharedKey->CipherAlg = CIPHER_NONE;
 
-		// Update these related information to MAC_TABLE_ENTRY
+		/* Update these related information to MAC_TABLE_ENTRY */
 		pEntry = &pAd->MacTab.Content[BSSID_WCID];
 		NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32],
 			       LEN_TKIP_EK);
@@ -820,7 +820,7 @@ VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
 			       LEN_TKIP_TXMICK);
 		pEntry->PairwiseKey.CipherAlg = pSharedKey->CipherAlg;
 
-		// Update pairwise key information to ASIC Shared Key Table
+		/* Update pairwise key information to ASIC Shared Key Table */
 		AsicAddSharedKeyEntry(pAd,
 				      BSS0,
 				      0,
@@ -828,21 +828,21 @@ VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
 				      pSharedKey->Key,
 				      pSharedKey->TxMic, pSharedKey->RxMic);
 
-		// Update ASIC WCID attribute table and IVEIV table
+		/* Update ASIC WCID attribute table and IVEIV table */
 		RTMPAddWcidAttributeEntry(pAd,
 					  BSS0,
 					  0, pSharedKey->CipherAlg, pEntry);
 
 	}
 
-	// open 802.1x port control and privacy filter
+	/* open 802.1x port control and privacy filter */
 	if (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK ||
 	    pEntry->AuthMode == Ndis802_11AuthModeWPA2) {
 		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
 		pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
 
 		STA_PORT_SECURED(pAd);
-		// Indicate Connected for GUI
+		/* Indicate Connected for GUI */
 		pAd->IndicateMediaState = NdisMediaStateConnected;
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("PeerPairMsg3Action: AuthMode(%s) PairwiseCipher(%s) GroupCipher(%s) \n",
@@ -852,7 +852,7 @@ VOID PeerPairMsg3Action(IN PRTMP_ADAPTER pAd,
 	} else {
 	}
 
-	// Init 802.3 header and send out
+	/* Init 802.3 header and send out */
 	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
 	RTMPToWirelessSta(pAd, pEntry,
 			  Header802_3, sizeof(Header802_3),
@@ -894,23 +894,23 @@ VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
 		if (pEntry->WpaState < AS_PTKINIT_NEGOTIATING)
 			break;
 
-		// pointer to 802.11 header
+		/* pointer to 802.11 header */
 		pHeader = (PHEADER_802_11) Elem->Msg;
 
-		// skip 802.11_header(24-byte) and LLC_header(8)
+		/* skip 802.11_header(24-byte) and LLC_header(8) */
 		pMsg4 =
 		    (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 		MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
-		// Sanity Check peer Pairwise message 4 - Replay Counter, MIC
+		/* Sanity Check peer Pairwise message 4 - Replay Counter, MIC */
 		if (PeerWpaMessageSanity
 		    (pAd, pMsg4, MsgLen, EAPOL_PAIR_MSG_4, pEntry) == FALSE)
 			break;
 
-		// 3. uses the MLME.SETKEYS.request to configure PTK into MAC
+		/* 3. uses the MLME.SETKEYS.request to configure PTK into MAC */
 		NdisZeroMemory(&pEntry->PairwiseKey, sizeof(CIPHER_KEY));
 
-		// reset IVEIV in Asic
+		/* reset IVEIV in Asic */
 		AsicUpdateWCIDIVEIV(pAd, pEntry->Aid, 1, 0);
 
 		pEntry->PairwiseKey.KeyLen = LEN_TKIP_EK;
@@ -923,7 +923,7 @@ VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
 			       &pEntry->PTK[TKIP_AP_TXMICK_OFFSET],
 			       LEN_TKIP_TXMICK);
 
-		// Set pairwise key to Asic
+		/* Set pairwise key to Asic */
 		{
 			pEntry->PairwiseKey.CipherAlg = CIPHER_NONE;
 			if (pEntry->WepStatus == Ndis802_11Encryption2Enabled)
@@ -932,13 +932,13 @@ VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
 				 Ndis802_11Encryption3Enabled)
 				pEntry->PairwiseKey.CipherAlg = CIPHER_AES;
 
-			// Add Pair-wise key to Asic
+			/* Add Pair-wise key to Asic */
 			AsicAddPairwiseKeyEntry(pAd,
 						pEntry->Addr,
 						(UCHAR) pEntry->Aid,
 						&pEntry->PairwiseKey);
 
-			// update WCID attribute table and IVEIV table for this entry
+			/* update WCID attribute table and IVEIV table for this entry */
 			RTMPAddWcidAttributeEntry(pAd,
 						  pEntry->apidx,
 						  0,
@@ -946,7 +946,7 @@ VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
 						  pEntry);
 		}
 
-		// 4. upgrade state
+		/* 4. upgrade state */
 		pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
 		pEntry->WpaState = AS_PTKINITDONE;
 		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
@@ -956,7 +956,7 @@ VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
 			pEntry->GTKState = REKEY_ESTABLISHED;
 			RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
 
-			// send wireless event - for set key done WPA2
+			/* send wireless event - for set key done WPA2 */
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd,
 						      IW_SET_KEY_DONE_WPA2_EVENT_FLAG,
@@ -971,7 +971,7 @@ VOID PeerPairMsg4Action(IN PRTMP_ADAPTER pAd,
 				  GetEncryptType(pEntry->WepStatus),
 				  group_cipher, GetEncryptType(group_cipher)));
 		} else {
-			// 5. init Group 2-way handshake if necessary.
+			/* 5. init Group 2-way handshake if necessary. */
 			WPAStart2WayGroupHS(pAd, pEntry);
 
 			pEntry->ReTryCounter = GROUP_MSG1_RETRY_TIMER_CTR;
@@ -1007,10 +1007,10 @@ VOID WPAStart2WayGroupHS(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry)
 		return;
 
 	do {
-		// Increment replay counter by 1
+		/* Increment replay counter by 1 */
 		ADD_ONE_To_64BIT_VAR(pEntry->R_Counter);
 
-		// Construct EAPoL message - Group Msg 1
+		/* Construct EAPoL message - Group Msg 1 */
 		NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
 		ConstructEapolMsg(pEntry,
 				  group_cipher,
@@ -1019,7 +1019,7 @@ VOID WPAStart2WayGroupHS(IN PRTMP_ADAPTER pAd, IN MAC_TABLE_ENTRY * pEntry)
 				  (UCHAR *) gnonce_ptr,
 				  TxTsc, (UCHAR *) gtk_ptr, NULL, 0, &EAPOLPKT);
 
-		// Make outgoing frame
+		/* Make outgoing frame */
 		MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pBssid, EAPOL);
 		RTMPToWirelessSta(pAd, pEntry,
 				  Header802_3, LENGTH_802_3,
@@ -1075,36 +1075,36 @@ VOID PeerGroupMsg1Action(IN PRTMP_ADAPTER pAd,
 		default_key = pAd->StaCfg.DefaultKeyId;
 	}
 
-	// Process Group Message 1 frame. skip 802.11 header(24) & LLC_SNAP header(8)
+	/* Process Group Message 1 frame. skip 802.11 header(24) & LLC_SNAP header(8) */
 	pGroup = (PEAPOL_PACKET) & Elem->Msg[LENGTH_802_11 + LENGTH_802_1_H];
 	MsgLen = Elem->MsgLen - LENGTH_802_11 - LENGTH_802_1_H;
 
-	// Sanity Check peer group message 1 - Replay Counter, MIC, RSNIE
+	/* Sanity Check peer group message 1 - Replay Counter, MIC, RSNIE */
 	if (PeerWpaMessageSanity(pAd, pGroup, MsgLen, EAPOL_GROUP_MSG_1, pEntry)
 	    == FALSE)
 		return;
 
-	// delete retry timer
+	/* delete retry timer */
 	RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
 
-	// Save Replay counter, it will use to construct message 2
+	/* Save Replay counter, it will use to construct message 2 */
 	NdisMoveMemory(pEntry->R_Counter, pGroup->KeyDesc.ReplayCounter,
 		       LEN_KEY_DESC_REPLAY);
 
-	// Construct EAPoL message - Group Msg 2
+	/* Construct EAPoL message - Group Msg 2 */
 	NdisZeroMemory(&EAPOLPKT, sizeof(EAPOL_PACKET));
-	ConstructEapolMsg(pEntry, group_cipher, EAPOL_GROUP_MSG_2, default_key, NULL,	// Nonce not used
-			  NULL,	// TxRSC not used
-			  NULL,	// GTK not used
-			  NULL,	// RSN IE not used
+	ConstructEapolMsg(pEntry, group_cipher, EAPOL_GROUP_MSG_2, default_key, NULL,	/* Nonce not used */
+			  NULL,	/* TxRSC not used */
+			  NULL,	/* GTK not used */
+			  NULL,	/* RSN IE not used */
 			  0, &EAPOLPKT);
 
-	// open 802.1x port control and privacy filter
+	/* open 802.1x port control and privacy filter */
 	pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
 	pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
 
 	STA_PORT_SECURED(pAd);
-	// Indicate Connected for GUI
+	/* Indicate Connected for GUI */
 	pAd->IndicateMediaState = NdisMediaStateConnected;
 
 	DBGPRINT(RT_DEBUG_TRACE,
@@ -1113,7 +1113,7 @@ VOID PeerGroupMsg1Action(IN PRTMP_ADAPTER pAd,
 		  GetEncryptType(pEntry->WepStatus),
 		  GetEncryptType(group_cipher)));
 
-	// init header and Fill Packet and send Msg 2 to authenticator
+	/* init header and Fill Packet and send Msg 2 to authenticator */
 	MAKE_802_3_HEADER(Header802_3, pEntry->Addr, pCurrentAddr, EAPOL);
 	RTMPToWirelessSta(pAd, pEntry,
 			  Header802_3, sizeof(Header802_3),
@@ -1159,19 +1159,19 @@ VOID PeerGroupMsg2Action(IN PRTMP_ADAPTER pAd,
 		pMsg2 = (PEAPOL_PACKET) (pData + LENGTH_802_1_H);
 		Len = MsgLen - LENGTH_802_1_H;
 
-		// Sanity Check peer group message 2 - Replay Counter, MIC
+		/* Sanity Check peer group message 2 - Replay Counter, MIC */
 		if (PeerWpaMessageSanity
 		    (pAd, pMsg2, Len, EAPOL_GROUP_MSG_2, pEntry) == FALSE)
 			break;
 
-		// 3.  upgrade state
+		/* 3.  upgrade state */
 
 		RTMPCancelTimer(&pEntry->RetryTimer, &Cancelled);
 		pEntry->GTKState = REKEY_ESTABLISHED;
 
 		if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2)
 		    || (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK)) {
-			// send wireless event - for set key done WPA2
+			/* send wireless event - for set key done WPA2 */
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd,
 						      IW_SET_KEY_DONE_WPA2_EVENT_FLAG,
@@ -1186,7 +1186,7 @@ VOID PeerGroupMsg2Action(IN PRTMP_ADAPTER pAd,
 				  GetEncryptType(pEntry->WepStatus),
 				  group_cipher, GetEncryptType(group_cipher)));
 		} else {
-			// send wireless event - for set key done WPA
+			/* send wireless event - for set key done WPA */
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd,
 						      IW_SET_KEY_DONE_WPA1_EVENT_FLAG,
@@ -1288,36 +1288,36 @@ VOID PRF(IN UCHAR * key,
 	INT currentindex = 0;
 	INT total_len;
 
-	// Allocate memory for input
+	/* Allocate memory for input */
 	os_alloc_mem(NULL, (PUCHAR *) & input, 1024);
 
 	if (input == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR, ("!!!PRF: no memory!!!\n"));
 		return;
 	}
-	// Generate concatenation input
+	/* Generate concatenation input */
 	NdisMoveMemory(input, prefix, prefix_len);
 
-	// Concatenate a single octet containing 0
+	/* Concatenate a single octet containing 0 */
 	input[prefix_len] = 0;
 
-	// Concatenate specific data
+	/* Concatenate specific data */
 	NdisMoveMemory(&input[prefix_len + 1], data, data_len);
 	total_len = prefix_len + 1 + data_len;
 
-	// Concatenate a single octet containing 0
-	// This octet shall be update later
+	/* Concatenate a single octet containing 0 */
+	/* This octet shall be update later */
 	input[total_len] = 0;
 	total_len++;
 
-	// Iterate to calculate the result by hmac-sha-1
-	// Then concatenate to last result
+	/* Iterate to calculate the result by hmac-sha-1 */
+	/* Then concatenate to last result */
 	for (i = 0; i < (len + 19) / 20; i++) {
 		HMAC_SHA1(key, key_len, input, total_len, &output[currentindex],
 			  SHA1_DIGEST_SIZE);
 		currentindex += 20;
 
-		// update the last octet
+		/* update the last octet */
 		input[total_len - 1]++;
 	}
 	os_free_mem(NULL, input);
@@ -1342,14 +1342,14 @@ static void F(char *password, unsigned char *ssid, int ssidlength,
 	digest[ssidlength + 1] = (unsigned char)((count >> 16) & 0xff);
 	digest[ssidlength + 2] = (unsigned char)((count >> 8) & 0xff);
 	digest[ssidlength + 3] = (unsigned char)(count & 0xff);
-	HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest, ssidlength + 4, digest1, SHA1_DIGEST_SIZE);	// for WPA update
+	HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest, ssidlength + 4, digest1, SHA1_DIGEST_SIZE);	/* for WPA update */
 
 	/* output = U1 */
 	memcpy(output, digest1, SHA1_DIGEST_SIZE);
 
 	for (i = 1; i < iterations; i++) {
 		/* Un = PRF(P, Un-1) */
-		HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest1, SHA1_DIGEST_SIZE, digest, SHA1_DIGEST_SIZE);	// for WPA update
+		HMAC_SHA1((unsigned char *)password, (int)strlen(password), digest1, SHA1_DIGEST_SIZE, digest, SHA1_DIGEST_SIZE);	/* for WPA update */
 		memcpy(digest1, digest, SHA1_DIGEST_SIZE);
 
 		/* output = output xor Un */
@@ -1414,40 +1414,40 @@ VOID WpaDerivePTK(IN PRTMP_ADAPTER pAd,
 		'e', 'x', 'p', 'a', 'n', 's', 'i', 'o', 'n'
 	};
 
-	// initiate the concatenation input
+	/* initiate the concatenation input */
 	NdisZeroMemory(temp, sizeof(temp));
 	NdisZeroMemory(concatenation, 76);
 
-	// Get smaller address
+	/* Get smaller address */
 	if (RTMPCompareMemory(SA, AA, 6) == 1)
 		NdisMoveMemory(concatenation, AA, 6);
 	else
 		NdisMoveMemory(concatenation, SA, 6);
 	CurrPos += 6;
 
-	// Get larger address
+	/* Get larger address */
 	if (RTMPCompareMemory(SA, AA, 6) == 1)
 		NdisMoveMemory(&concatenation[CurrPos], SA, 6);
 	else
 		NdisMoveMemory(&concatenation[CurrPos], AA, 6);
 
-	// store the larger mac address for backward compatible of
-	// ralink proprietary STA-key issue
+	/* store the larger mac address for backward compatible of */
+	/* ralink proprietary STA-key issue */
 	NdisMoveMemory(temp, &concatenation[CurrPos], MAC_ADDR_LEN);
 	CurrPos += 6;
 
-	// Get smaller Nonce
+	/* Get smaller Nonce */
 	if (RTMPCompareMemory(ANonce, SNonce, 32) == 0)
-		NdisMoveMemory(&concatenation[CurrPos], temp, 32);	// patch for ralink proprietary STA-key issue
+		NdisMoveMemory(&concatenation[CurrPos], temp, 32);	/* patch for ralink proprietary STA-key issue */
 	else if (RTMPCompareMemory(ANonce, SNonce, 32) == 1)
 		NdisMoveMemory(&concatenation[CurrPos], SNonce, 32);
 	else
 		NdisMoveMemory(&concatenation[CurrPos], ANonce, 32);
 	CurrPos += 32;
 
-	// Get larger Nonce
+	/* Get larger Nonce */
 	if (RTMPCompareMemory(ANonce, SNonce, 32) == 0)
-		NdisMoveMemory(&concatenation[CurrPos], temp, 32);	// patch for ralink proprietary STA-key issue
+		NdisMoveMemory(&concatenation[CurrPos], temp, 32);	/* patch for ralink proprietary STA-key issue */
 	else if (RTMPCompareMemory(ANonce, SNonce, 32) == 1)
 		NdisMoveMemory(&concatenation[CurrPos], ANonce, 32);
 	else
@@ -1456,7 +1456,7 @@ VOID WpaDerivePTK(IN PRTMP_ADAPTER pAd,
 
 	hex_dump("concatenation=", concatenation, 76);
 
-	// Use PRF to generate PTK
+	/* Use PRF to generate PTK */
 	PRF(PMK, LEN_MASTER_KEY, Prefix, 22, concatenation, 76, output, len);
 
 }
@@ -1487,30 +1487,30 @@ VOID GenRandom(IN PRTMP_ADAPTER pAd, IN UCHAR * macAddr, OUT UCHAR * random)
 	UCHAR prefix[] =
 	    { 'I', 'n', 'i', 't', ' ', 'C', 'o', 'u', 'n', 't', 'e', 'r' };
 
-	// Zero the related information
+	/* Zero the related information */
 	NdisZeroMemory(result, 80);
 	NdisZeroMemory(local, 80);
 	NdisZeroMemory(KeyCounter, 32);
 
 	for (i = 0; i < 32; i++) {
-		// copy the local MAC address
+		/* copy the local MAC address */
 		COPY_MAC_ADDR(local, macAddr);
 		curr = MAC_ADDR_LEN;
 
-		// concatenate the current time
+		/* concatenate the current time */
 		NdisGetSystemUpTime(&CurrentTime);
 		NdisMoveMemory(&local[curr], &CurrentTime, sizeof(CurrentTime));
 		curr += sizeof(CurrentTime);
 
-		// concatenate the last result
+		/* concatenate the last result */
 		NdisMoveMemory(&local[curr], result, 32);
 		curr += 32;
 
-		// concatenate a variable
+		/* concatenate a variable */
 		NdisMoveMemory(&local[curr], &i, 2);
 		curr += 2;
 
-		// calculate the result
+		/* calculate the result */
 		PRF(KeyCounter, 32, prefix, 12, local, curr, result, 32);
 	}
 
@@ -1548,15 +1548,15 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 
 	*rsn_len = 0;
 
-	// decide WPA2 or WPA1
+	/* decide WPA2 or WPA1 */
 	if (ElementID == Wpa2Ie) {
 		RSNIE2 *pRsnie_cipher = (RSNIE2 *) pRsnIe;
 
-		// Assign the verson as 1
+		/* Assign the verson as 1 */
 		pRsnie_cipher->version = 1;
 
 		switch (WepStatus) {
-			// TKIP mode
+			/* TKIP mode */
 		case Ndis802_11Encryption2Enabled:
 			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
 			pRsnie_cipher->ucount = 1;
@@ -1565,7 +1565,7 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 			*rsn_len = sizeof(RSNIE2);
 			break;
 
-			// AES mode
+			/* AES mode */
 		case Ndis802_11Encryption3Enabled:
 			if (bMixCipher)
 				NdisMoveMemory(pRsnie_cipher->mcast,
@@ -1579,16 +1579,16 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 			*rsn_len = sizeof(RSNIE2);
 			break;
 
-			// TKIP-AES mix mode
+			/* TKIP-AES mix mode */
 		case Ndis802_11Encryption4Enabled:
 			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA2_TKIP, 4);
 
 			PairwiseCnt = 1;
-			// Insert WPA2 TKIP as the first pairwise cipher
+			/* Insert WPA2 TKIP as the first pairwise cipher */
 			if (MIX_CIPHER_WPA2_TKIP_ON(FlexibleCipher)) {
 				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
 					       OUI_WPA2_TKIP, 4);
-				// Insert WPA2 AES as the secondary pairwise cipher
+				/* Insert WPA2 AES as the secondary pairwise cipher */
 				if (MIX_CIPHER_WPA2_AES_ON(FlexibleCipher)) {
 					NdisMoveMemory(pRsnie_cipher->ucast[0].
 						       oui + 4, OUI_WPA2_CCMP,
@@ -1596,7 +1596,7 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 					PairwiseCnt = 2;
 				}
 			} else {
-				// Insert WPA2 AES as the first pairwise cipher
+				/* Insert WPA2 AES as the first pairwise cipher */
 				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
 					       OUI_WPA2_CCMP, 4);
 			}
@@ -1621,18 +1621,18 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 				break;
 			}
 		}
-		// swap for big-endian platform
+		/* swap for big-endian platform */
 		pRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);
 		pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
 	} else {
 		RSNIE *pRsnie_cipher = (RSNIE *) pRsnIe;
 
-		// Assign OUI and version
+		/* Assign OUI and version */
 		NdisMoveMemory(pRsnie_cipher->oui, OUI_WPA_VERSION, 4);
 		pRsnie_cipher->version = 1;
 
 		switch (WepStatus) {
-			// TKIP mode
+			/* TKIP mode */
 		case Ndis802_11Encryption2Enabled:
 			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
 			pRsnie_cipher->ucount = 1;
@@ -1641,7 +1641,7 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 			*rsn_len = sizeof(RSNIE);
 			break;
 
-			// AES mode
+			/* AES mode */
 		case Ndis802_11Encryption3Enabled:
 			if (bMixCipher)
 				NdisMoveMemory(pRsnie_cipher->mcast,
@@ -1655,16 +1655,16 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 			*rsn_len = sizeof(RSNIE);
 			break;
 
-			// TKIP-AES mix mode
+			/* TKIP-AES mix mode */
 		case Ndis802_11Encryption4Enabled:
 			NdisMoveMemory(pRsnie_cipher->mcast, OUI_WPA_TKIP, 4);
 
 			PairwiseCnt = 1;
-			// Insert WPA TKIP as the first pairwise cipher
+			/* Insert WPA TKIP as the first pairwise cipher */
 			if (MIX_CIPHER_WPA_TKIP_ON(FlexibleCipher)) {
 				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
 					       OUI_WPA_TKIP, 4);
-				// Insert WPA AES as the secondary pairwise cipher
+				/* Insert WPA AES as the secondary pairwise cipher */
 				if (MIX_CIPHER_WPA_AES_ON(FlexibleCipher)) {
 					NdisMoveMemory(pRsnie_cipher->ucast[0].
 						       oui + 4, OUI_WPA_CCMP,
@@ -1672,7 +1672,7 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 					PairwiseCnt = 2;
 				}
 			} else {
-				// Insert WPA AES as the first pairwise cipher
+				/* Insert WPA AES as the first pairwise cipher */
 				NdisMoveMemory(pRsnie_cipher->ucast[0].oui,
 					       OUI_WPA_CCMP, 4);
 			}
@@ -1697,7 +1697,7 @@ static VOID RTMPMakeRsnIeCipher(IN PRTMP_ADAPTER pAd,
 				break;
 			}
 		}
-		// swap for big-endian platform
+		/* swap for big-endian platform */
 		pRsnie_cipher->version = cpu2le16(pRsnie_cipher->version);
 		pRsnie_cipher->ucount = cpu2le16(pRsnie_cipher->ucount);
 	}
@@ -1729,11 +1729,11 @@ static VOID RTMPMakeRsnIeAKM(IN PRTMP_ADAPTER pAd,
 			     OUT PUCHAR pRsnIe, OUT UCHAR * rsn_len)
 {
 	RSNIE_AUTH *pRsnie_auth;
-	UCHAR AkmCnt = 1;	// default as 1
+	UCHAR AkmCnt = 1;	/* default as 1 */
 
 	pRsnie_auth = (RSNIE_AUTH *) (pRsnIe + (*rsn_len));
 
-	// decide WPA2 or WPA1
+	/* decide WPA2 or WPA1 */
 	if (ElementID == Wpa2Ie) {
 
 		switch (AuthMode) {
@@ -1780,7 +1780,7 @@ static VOID RTMPMakeRsnIeAKM(IN PRTMP_ADAPTER pAd,
 	pRsnie_auth->acount = AkmCnt;
 	pRsnie_auth->acount = cpu2le16(pRsnie_auth->acount);
 
-	// update current RSNIE length
+	/* update current RSNIE length */
 	(*rsn_len) += (sizeof(RSNIE_AUTH) + (4 * (AkmCnt - 1)));
 
 }
@@ -1810,7 +1810,7 @@ static VOID RTMPMakeRsnIeCap(IN PRTMP_ADAPTER pAd,
 {
 	RSN_CAPABILITIES *pRSN_Cap;
 
-	// it could be ignored in WPA1 mode
+	/* it could be ignored in WPA1 mode */
 	if (ElementID == WpaIe)
 		return;
 
@@ -1818,7 +1818,7 @@ static VOID RTMPMakeRsnIeCap(IN PRTMP_ADAPTER pAd,
 
 	pRSN_Cap->word = cpu2le16(pRSN_Cap->word);
 
-	(*rsn_len) += sizeof(RSN_CAPABILITIES);	// update current RSNIE length
+	(*rsn_len) += sizeof(RSN_CAPABILITIES);	/* update current RSNIE length */
 
 }
 
@@ -1843,13 +1843,13 @@ static VOID RTMPMakeRsnIeCap(IN PRTMP_ADAPTER pAd,
 VOID RTMPMakeRSNIE(IN PRTMP_ADAPTER pAd,
 		   IN UINT AuthMode, IN UINT WepStatus, IN UCHAR apidx)
 {
-	PUCHAR pRsnIe = NULL;	// primary RSNIE
-	UCHAR *rsnielen_cur_p = 0;	// the length of the primary RSNIE
-	UCHAR *rsnielen_ex_cur_p = 0;	// the length of the secondary RSNIE
+	PUCHAR pRsnIe = NULL;	/* primary RSNIE */
+	UCHAR *rsnielen_cur_p = 0;	/* the length of the primary RSNIE */
+	UCHAR *rsnielen_ex_cur_p = 0;	/* the length of the secondary RSNIE */
 	UCHAR PrimaryRsnie;
-	BOOLEAN bMixCipher = FALSE;	// indicate the pairwise and group cipher are different
+	BOOLEAN bMixCipher = FALSE;	/* indicate the pairwise and group cipher are different */
 	UCHAR p_offset;
-	WPA_MIX_PAIR_CIPHER FlexibleCipher = WPA_TKIPAES_WPA2_TKIPAES;	// it provide the more flexible cipher combination in WPA-WPA2 and TKIPAES mode
+	WPA_MIX_PAIR_CIPHER FlexibleCipher = WPA_TKIPAES_WPA2_TKIPAES;	/* it provide the more flexible cipher combination in WPA-WPA2 and TKIPAES mode */
 
 	rsnielen_cur_p = NULL;
 	rsnielen_ex_cur_p = NULL;
@@ -1861,8 +1861,8 @@ VOID RTMPMakeRSNIE(IN PRTMP_ADAPTER pAd,
 				if (AuthMode < Ndis802_11AuthModeWPA)
 					return;
 			} else {
-				// Support WPAPSK or WPA2PSK in STA-Infra mode
-				// Support WPANone in STA-Adhoc mode
+				/* Support WPAPSK or WPA2PSK in STA-Infra mode */
+				/* Support WPANone in STA-Adhoc mode */
 				if ((AuthMode != Ndis802_11AuthModeWPAPSK) &&
 				    (AuthMode != Ndis802_11AuthModeWPA2PSK) &&
 				    (AuthMode != Ndis802_11AuthModeWPANone)
@@ -1872,11 +1872,11 @@ VOID RTMPMakeRSNIE(IN PRTMP_ADAPTER pAd,
 
 			DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPMakeRSNIE(STA)\n"));
 
-			// Zero RSNIE context
+			/* Zero RSNIE context */
 			pAd->StaCfg.RSNIE_Len = 0;
 			NdisZeroMemory(pAd->StaCfg.RSN_IE, MAX_LEN_OF_RSNIE);
 
-			// Pointer to RSNIE
+			/* Pointer to RSNIE */
 			rsnielen_cur_p = &pAd->StaCfg.RSNIE_Len;
 			pRsnIe = pAd->StaCfg.RSN_IE;
 
@@ -1884,7 +1884,7 @@ VOID RTMPMakeRSNIE(IN PRTMP_ADAPTER pAd,
 		}
 	}
 
-	// indicate primary RSNIE as WPA or WPA2
+	/* indicate primary RSNIE as WPA or WPA2 */
 	if ((AuthMode == Ndis802_11AuthModeWPA) ||
 	    (AuthMode == Ndis802_11AuthModeWPAPSK) ||
 	    (AuthMode == Ndis802_11AuthModeWPANone) ||
@@ -1895,20 +1895,20 @@ VOID RTMPMakeRSNIE(IN PRTMP_ADAPTER pAd,
 		PrimaryRsnie = Wpa2Ie;
 
 	{
-		// Build the primary RSNIE
-		// 1. insert cipher suite
+		/* Build the primary RSNIE */
+		/* 1. insert cipher suite */
 		RTMPMakeRsnIeCipher(pAd, PrimaryRsnie, WepStatus, bMixCipher,
 				    FlexibleCipher, pRsnIe, &p_offset);
 
-		// 2. insert AKM
+		/* 2. insert AKM */
 		RTMPMakeRsnIeAKM(pAd, PrimaryRsnie, AuthMode, apidx, pRsnIe,
 				 &p_offset);
 
-		// 3. insert capability
+		/* 3. insert capability */
 		RTMPMakeRsnIeCap(pAd, PrimaryRsnie, apidx, pRsnIe, &p_offset);
 	}
 
-	// 4. update the RSNIE length
+	/* 4. update the RSNIE length */
 	*rsnielen_cur_p = p_offset;
 
 	hex_dump("The primary RSNIE", pRsnIe, (*rsnielen_cur_p));
@@ -1943,13 +1943,13 @@ BOOLEAN RTMPCheckWPAframe(IN PRTMP_ADAPTER pAd,
 	if (DataByteCount < (LENGTH_802_1_H + LENGTH_EAPOL_H))
 		return FALSE;
 
-	// Skip LLC header
+	/* Skip LLC header */
 	if (NdisEqualMemory(SNAP_802_1H, pData, 6) ||
-	    // Cisco 1200 AP may send packet with SNAP_BRIDGE_TUNNEL
+	    /* Cisco 1200 AP may send packet with SNAP_BRIDGE_TUNNEL */
 	    NdisEqualMemory(SNAP_BRIDGE_TUNNEL, pData, 6)) {
 		pData += 6;
 	}
-	// Skip 2-bytes EAPoL type
+	/* Skip 2-bytes EAPoL type */
 	if (NdisEqualMemory(EAPOL, pData, 2)) {
 		pData += 2;
 	} else
@@ -2060,7 +2060,7 @@ BOOLEAN RTMPCheckRSNIE(IN PRTMP_ADAPTER pAd,
 
 	while (len > sizeof(RSNIE2)) {
 		pEid = (PEID_STRUCT) pVIE;
-		// WPA RSN IE
+		/* WPA RSN IE */
 		if ((pEid->Eid == IE_WPA)
 		    && (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))) {
 			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA
@@ -2074,7 +2074,7 @@ BOOLEAN RTMPCheckRSNIE(IN PRTMP_ADAPTER pAd,
 
 			*Offset += (pEid->Len + 2);
 		}
-		// WPA2 RSN IE
+		/* WPA2 RSN IE */
 		else if ((pEid->Eid == IE_RSN)
 			 && (NdisEqualMemory(pEid->Octet + 2, RSN_OUI, 3))) {
 			if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2
@@ -2132,12 +2132,12 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 	UCHAR DefaultIdx = 0;
 	UCHAR skip_offset;
 
-	// Verify The RSN IE contained in pairewise_msg_2 && pairewise_msg_3 and skip it
+	/* Verify The RSN IE contained in pairewise_msg_2 && pairewise_msg_3 and skip it */
 	if (MsgType == EAPOL_PAIR_MSG_2 || MsgType == EAPOL_PAIR_MSG_3) {
-		// Check RSN IE whether it is WPA2/WPA2PSK
+		/* Check RSN IE whether it is WPA2/WPA2PSK */
 		if (!RTMPCheckRSNIE
 		    (pAd, pKeyData, KeyDataLen, pEntry, &skip_offset)) {
-			// send wireless event - for RSN IE different
+			/* send wireless event - for RSN IE different */
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd,
 						      IW_RSNIE_DIFF_EVENT_FLAG,
@@ -2156,7 +2156,7 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 			if (bWPA2 && MsgType == EAPOL_PAIR_MSG_3) {
 				WpaShowAllsuite(pMyKeyData, skip_offset);
 
-				// skip RSN IE
+				/* skip RSN IE */
 				pMyKeyData += skip_offset;
 				KeyDataLength -= skip_offset;
 				DBGPRINT(RT_DEBUG_TRACE,
@@ -2170,24 +2170,24 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("RTMPParseEapolKeyData ==> KeyDataLength %d without RSN_IE \n",
 		  KeyDataLength));
-	//hex_dump("remain data", pMyKeyData, KeyDataLength);
+	/*hex_dump("remain data", pMyKeyData, KeyDataLength); */
 
-	// Parse EKD format in pairwise_msg_3_WPA2 && group_msg_1_WPA2
+	/* Parse EKD format in pairwise_msg_3_WPA2 && group_msg_1_WPA2 */
 	if (bWPA2
 	    && (MsgType == EAPOL_PAIR_MSG_3 || MsgType == EAPOL_GROUP_MSG_1)) {
-		if (KeyDataLength >= 8)	// KDE format exclude GTK length
+		if (KeyDataLength >= 8)	/* KDE format exclude GTK length */
 		{
 			pKDE = (PKDE_ENCAP) pMyKeyData;
 
 			DefaultIdx = pKDE->GTKEncap.Kid;
 
-			// Sanity check - KED length
+			/* Sanity check - KED length */
 			if (KeyDataLength < (pKDE->Len + 2)) {
 				DBGPRINT(RT_DEBUG_ERROR,
 					 ("ERROR: The len from KDE is too short \n"));
 				return FALSE;
 			}
-			// Get GTK length - refer to IEEE 802.11i-2004 p.82
+			/* Get GTK length - refer to IEEE 802.11i-2004 p.82 */
 			GTKLEN = pKDE->Len - 6;
 			if (GTKLEN < LEN_AES_KEY) {
 				DBGPRINT(RT_DEBUG_ERROR,
@@ -2205,7 +2205,7 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("GTK in KDE format ,DefaultKeyID=%d, KeyLen=%d \n",
 			  DefaultIdx, GTKLEN));
-		// skip it
+		/* skip it */
 		pMyKeyData += 8;
 		KeyDataLength -= 8;
 
@@ -2214,7 +2214,7 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("GTK DefaultKeyID=%d \n", DefaultIdx));
 	}
-	// Sanity check - shared key index must be 1 ~ 3
+	/* Sanity check - shared key index must be 1 ~ 3 */
 	if (DefaultIdx < 1 || DefaultIdx > 3) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("ERROR: GTK Key index(%d) is invalid in %s %s \n",
@@ -2226,13 +2226,13 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 	{
 		PCIPHER_KEY pSharedKey;
 
-		// set key material, TxMic and RxMic
+		/* set key material, TxMic and RxMic */
 		NdisMoveMemory(pAd->StaCfg.GTK, pMyKeyData, 32);
 		pAd->StaCfg.DefaultKeyId = DefaultIdx;
 
 		pSharedKey = &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId];
 
-		// Prepare pair-wise key information into shared key table
+		/* Prepare pair-wise key information into shared key table */
 		NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 		pSharedKey->KeyLen = LEN_TKIP_EK;
 		NdisMoveMemory(pSharedKey->Key, pAd->StaCfg.GTK, LEN_TKIP_EK);
@@ -2241,7 +2241,7 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 		NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24],
 			       LEN_TKIP_TXMICK);
 
-		// Update Shared Key CipherAlg
+		/* Update Shared Key CipherAlg */
 		pSharedKey->CipherAlg = CIPHER_NONE;
 		if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
 			pSharedKey->CipherAlg = CIPHER_TKIP;
@@ -2254,7 +2254,7 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 			 Ndis802_11GroupWEP104Enabled)
 			pSharedKey->CipherAlg = CIPHER_WEP128;
 
-		// Update group key information to ASIC Shared Key Table
+		/* Update group key information to ASIC Shared Key Table */
 		AsicAddSharedKeyEntry(pAd,
 				      BSS0,
 				      pAd->StaCfg.DefaultKeyId,
@@ -2262,7 +2262,7 @@ BOOLEAN RTMPParseEapolKeyData(IN PRTMP_ADAPTER pAd,
 				      pSharedKey->Key,
 				      pSharedKey->TxMic, pSharedKey->RxMic);
 
-		// Update ASIC WCID attribute table and IVEIV table
+		/* Update ASIC WCID attribute table and IVEIV table */
 		RTMPAddWcidAttributeEntry(pAd,
 					  BSS0,
 					  pAd->StaCfg.DefaultKeyId,
@@ -2333,28 +2333,28 @@ VOID ConstructEapolMsg(IN PMAC_TABLE_ENTRY pEntry,
 	BOOLEAN bWPA2 = FALSE;
 	UCHAR KeyDescVer;
 
-	// Choose WPA2 or not
+	/* Choose WPA2 or not */
 	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) ||
 	    (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
 		bWPA2 = TRUE;
 
-	// Init Packet and Fill header
+	/* Init Packet and Fill header */
 	pMsg->ProVer = EAPOL_VER;
 	pMsg->ProType = EAPOLKey;
 
-	// Default 95 bytes, the EAPoL-Key descriptor exclude Key-data field
+	/* Default 95 bytes, the EAPoL-Key descriptor exclude Key-data field */
 	SET_UINT16_TO_ARRARY(pMsg->Body_Len, LEN_EAPOL_KEY_MSG);
 
-	// Fill in EAPoL descriptor
+	/* Fill in EAPoL descriptor */
 	if (bWPA2)
 		pMsg->KeyDesc.Type = WPA2_KEY_DESC;
 	else
 		pMsg->KeyDesc.Type = WPA1_KEY_DESC;
 
-	// Key Descriptor Version (bits 0-2) specifies the key descriptor version type
+	/* Key Descriptor Version (bits 0-2) specifies the key descriptor version type */
 	{
-		// Fill in Key information, refer to IEEE Std 802.11i-2004 page 78
-		// When either the pairwise or the group cipher is AES, the DESC_TYPE_AES(2) shall be used.
+		/* Fill in Key information, refer to IEEE Std 802.11i-2004 page 78 */
+		/* When either the pairwise or the group cipher is AES, the DESC_TYPE_AES(2) shall be used. */
 		KeyDescVer =
 		    (((pEntry->WepStatus == Ndis802_11Encryption3Enabled)
 		      || (GroupKeyWepStatus ==
@@ -2364,13 +2364,13 @@ VOID ConstructEapolMsg(IN PMAC_TABLE_ENTRY pEntry,
 
 	pMsg->KeyDesc.KeyInfo.KeyDescVer = KeyDescVer;
 
-	// Specify Key Type as Group(0) or Pairwise(1)
+	/* Specify Key Type as Group(0) or Pairwise(1) */
 	if (MsgType >= EAPOL_GROUP_MSG_1)
 		pMsg->KeyDesc.KeyInfo.KeyType = GROUPKEY;
 	else
 		pMsg->KeyDesc.KeyInfo.KeyType = PAIRWISEKEY;
 
-	// Specify Key Index, only group_msg1_WPA1
+	/* Specify Key Index, only group_msg1_WPA1 */
 	if (!bWPA2 && (MsgType >= EAPOL_GROUP_MSG_1))
 		pMsg->KeyDesc.KeyInfo.KeyIndex = DefaultKeyIdx;
 
@@ -2393,20 +2393,20 @@ VOID ConstructEapolMsg(IN PMAC_TABLE_ENTRY pEntry,
 		      (MsgType == EAPOL_GROUP_MSG_1))) {
 		pMsg->KeyDesc.KeyInfo.EKD_DL = 1;
 	}
-	// key Information element has done.
+	/* key Information element has done. */
 	*(USHORT *) (&pMsg->KeyDesc.KeyInfo) =
 	    cpu2le16(*(USHORT *) (&pMsg->KeyDesc.KeyInfo));
 
-	// Fill in Key Length
+	/* Fill in Key Length */
 	{
 		if (MsgType >= EAPOL_GROUP_MSG_1) {
-			// the length of group key cipher
+			/* the length of group key cipher */
 			pMsg->KeyDesc.KeyLength[1] =
 			    ((GroupKeyWepStatus ==
 			      Ndis802_11Encryption2Enabled) ? TKIP_GTK_LENGTH :
 			     LEN_AES_KEY);
 		} else {
-			// the length of pairwise key cipher
+			/* the length of pairwise key cipher */
 			pMsg->KeyDesc.KeyLength[1] =
 			    ((pEntry->WepStatus ==
 			      Ndis802_11Encryption2Enabled) ? LEN_TKIP_KEY :
@@ -2414,33 +2414,33 @@ VOID ConstructEapolMsg(IN PMAC_TABLE_ENTRY pEntry,
 		}
 	}
 
-	// Fill in replay counter
+	/* Fill in replay counter */
 	NdisMoveMemory(pMsg->KeyDesc.ReplayCounter, pEntry->R_Counter,
 		       LEN_KEY_DESC_REPLAY);
 
-	// Fill Key Nonce field
-	// ANonce : pairwise_msg1 & pairwise_msg3
-	// SNonce : pairwise_msg2
-	// GNonce : group_msg1_wpa1
+	/* Fill Key Nonce field */
+	/* ANonce : pairwise_msg1 & pairwise_msg3 */
+	/* SNonce : pairwise_msg2 */
+	/* GNonce : group_msg1_wpa1 */
 	if ((MsgType <= EAPOL_PAIR_MSG_3)
 	    || ((!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1))))
 		NdisMoveMemory(pMsg->KeyDesc.KeyNonce, KeyNonce,
 			       LEN_KEY_DESC_NONCE);
 
-	// Fill key IV - WPA2 as 0, WPA1 as random
+	/* Fill key IV - WPA2 as 0, WPA1 as random */
 	if (!bWPA2 && (MsgType == EAPOL_GROUP_MSG_1)) {
-		// Suggest IV be random number plus some number,
+		/* Suggest IV be random number plus some number, */
 		NdisMoveMemory(pMsg->KeyDesc.KeyIv, &KeyNonce[16],
 			       LEN_KEY_DESC_IV);
 		pMsg->KeyDesc.KeyIv[15] += 2;
 	}
-	// Fill Key RSC field
-	// It contains the RSC for the GTK being installed.
+	/* Fill Key RSC field */
+	/* It contains the RSC for the GTK being installed. */
 	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2)
 	    || (MsgType == EAPOL_GROUP_MSG_1)) {
 		NdisMoveMemory(pMsg->KeyDesc.KeyRsc, TxRSC, 6);
 	}
-	// Clear Key MIC field for MIC calculation later
+	/* Clear Key MIC field for MIC calculation later */
 	NdisZeroMemory(pMsg->KeyDesc.KeyMic, LEN_KEY_DESC_MIC);
 
 	ConstructEapolKeyData(pEntry,
@@ -2449,7 +2449,7 @@ VOID ConstructEapolMsg(IN PMAC_TABLE_ENTRY pEntry,
 			      MsgType,
 			      DefaultKeyIdx, GTK, RSNIE, RSNIE_Len, pMsg);
 
-	// Calculate MIC and fill in KeyMic Field except Pairwise Msg 1.
+	/* Calculate MIC and fill in KeyMic Field except Pairwise Msg 1. */
 	if (MsgType != EAPOL_PAIR_MSG_1) {
 		CalculateMIC(KeyDescVer, pEntry->PTK, pMsg);
 	}
@@ -2499,7 +2499,7 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 	PRTMP_ADAPTER pAd = pEntry->pAd;
 	BOOLEAN GTK_Included = FALSE;
 
-	// Choose WPA2 or not
+	/* Choose WPA2 or not */
 	if ((pEntry->AuthMode == Ndis802_11AuthModeWPA2) ||
 	    (pEntry->AuthMode == Ndis802_11AuthModeWPA2PSK))
 		bWPA2Capable = TRUE;
@@ -2508,7 +2508,7 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 	    MsgType == EAPOL_PAIR_MSG_4 || MsgType == EAPOL_GROUP_MSG_2)
 		return;
 
-	// allocate memory pool
+	/* allocate memory pool */
 	os_alloc_mem(NULL, (PUCHAR *) & mpool, 1500);
 
 	if (mpool == NULL)
@@ -2523,7 +2523,7 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 	SET_UINT16_TO_ARRARY(pMsg->KeyDesc.KeyDataLen, 0);
 	data_offset = 0;
 
-	// Encapsulate RSNIE in pairwise_msg2 & pairwise_msg3
+	/* Encapsulate RSNIE in pairwise_msg2 & pairwise_msg3 */
 	if (RSNIE_LEN
 	    && ((MsgType == EAPOL_PAIR_MSG_2)
 		|| (MsgType == EAPOL_PAIR_MSG_3))) {
@@ -2535,17 +2535,17 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 				RSNIE, RSNIE_LEN, pmkid_ptr, pmkid_len);
 	}
 
-	// Encapsulate KDE format in pairwise_msg3_WPA2 & group_msg1_WPA2
+	/* Encapsulate KDE format in pairwise_msg3_WPA2 & group_msg1_WPA2 */
 	if (bWPA2Capable
 	    && ((MsgType == EAPOL_PAIR_MSG_3)
 		|| (MsgType == EAPOL_GROUP_MSG_1))) {
-		// Key Data Encapsulation (KDE) format - 802.11i-2004  Figure-43w and Table-20h
+		/* Key Data Encapsulation (KDE) format - 802.11i-2004  Figure-43w and Table-20h */
 		Key_Data[data_offset + 0] = 0xDD;
 
 		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled) {
-			Key_Data[data_offset + 1] = 0x16;	// 4+2+16(OUI+DataType+DataField)
+			Key_Data[data_offset + 1] = 0x16;	/* 4+2+16(OUI+DataType+DataField) */
 		} else {
-			Key_Data[data_offset + 1] = 0x26;	// 4+2+32(OUI+DataType+DataField)
+			Key_Data[data_offset + 1] = 0x26;	/* 4+2+32(OUI+DataType+DataField) */
 		}
 
 		Key_Data[data_offset + 2] = 0x00;
@@ -2553,18 +2553,18 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 		Key_Data[data_offset + 4] = 0xAC;
 		Key_Data[data_offset + 5] = 0x01;
 
-		// GTK KDE format - 802.11i-2004  Figure-43x
+		/* GTK KDE format - 802.11i-2004  Figure-43x */
 		Key_Data[data_offset + 6] = (DefaultKeyIdx & 0x03);
-		Key_Data[data_offset + 7] = 0x00;	// Reserved Byte
+		Key_Data[data_offset + 7] = 0x00;	/* Reserved Byte */
 
 		data_offset += 8;
 	}
 
-	// Encapsulate GTK
-	// Only for pairwise_msg3_WPA2 and group_msg1
+	/* Encapsulate GTK */
+	/* Only for pairwise_msg3_WPA2 and group_msg1 */
 	if ((MsgType == EAPOL_PAIR_MSG_3 && bWPA2Capable)
 	    || (MsgType == EAPOL_GROUP_MSG_1)) {
-		// Fill in GTK
+		/* Fill in GTK */
 		if (GroupKeyWepStatus == Ndis802_11Encryption3Enabled) {
 			NdisMoveMemory(&Key_Data[data_offset], GTK,
 				       LEN_AES_KEY);
@@ -2578,23 +2578,23 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 		GTK_Included = TRUE;
 	}
 
-	// This whole key-data field shall be encrypted if a GTK is included.
-	// Encrypt the data material in key data field with KEK
+	/* This whole key-data field shall be encrypted if a GTK is included. */
+	/* Encrypt the data material in key data field with KEK */
 	if (GTK_Included) {
-		//hex_dump("GTK_Included", Key_Data, data_offset);
+		/*hex_dump("GTK_Included", Key_Data, data_offset); */
 
 		if ((keyDescVer == DESC_TYPE_AES)) {
 			UCHAR remainder = 0;
 			UCHAR pad_len = 0;
 
-			// Key Descriptor Version 2 or 3: AES key wrap, defined in IETF RFC 3394,
-			// shall be used to encrypt the Key Data field using the KEK field from
-			// the derived PTK.
+			/* Key Descriptor Version 2 or 3: AES key wrap, defined in IETF RFC 3394, */
+			/* shall be used to encrypt the Key Data field using the KEK field from */
+			/* the derived PTK. */
 
-			// If the Key Data field uses the NIST AES key wrap, then the Key Data field
-			// shall be padded before encrypting if the key data length is less than 16
-			// octets or if it is not a multiple of 8. The padding consists of appending
-			// a single octet 0xdd followed by zero or more 0x00 octets.
+			/* If the Key Data field uses the NIST AES key wrap, then the Key Data field */
+			/* shall be padded before encrypting if the key data length is less than 16 */
+			/* octets or if it is not a multiple of 8. The padding consists of appending */
+			/* a single octet 0xdd followed by zero or more 0x00 octets. */
 			if ((remainder = data_offset & 0x07) != 0) {
 				INT i;
 
@@ -2608,22 +2608,22 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 
 			AES_GTK_KEY_WRAP(&pEntry->PTK[16], Key_Data,
 					 data_offset, Rc4GTK);
-			// AES wrap function will grow 8 bytes in length
+			/* AES wrap function will grow 8 bytes in length */
 			data_offset += 8;
 		} else {
 			/*      Key Descriptor Version 1: ARC4 is used to encrypt the Key Data field
 			   using the KEK field from the derived PTK. */
 
-			// PREPARE Encrypted  "Key DATA" field.  (Encrypt GTK with RC4, usinf PTK[16]->[31] as Key, IV-field as IV)
-			// put TxTsc in Key RSC field
-			pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	//Init crc32.
+			/* PREPARE Encrypted  "Key DATA" field.  (Encrypt GTK with RC4, usinf PTK[16]->[31] as Key, IV-field as IV) */
+			/* put TxTsc in Key RSC field */
+			pAd->PrivateInfo.FCSCRC32 = PPPINITFCS32;	/*Init crc32. */
 
-			// ekey is the contanetion of IV-field, and PTK[16]->PTK[31]
+			/* ekey is the contanetion of IV-field, and PTK[16]->PTK[31] */
 			NdisMoveMemory(ekey, pMsg->KeyDesc.KeyIv,
 				       LEN_KEY_DESC_IV);
 			NdisMoveMemory(&ekey[LEN_KEY_DESC_IV], &pEntry->PTK[16],
 				       LEN_EAP_EK);
-			ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, ekey, sizeof(ekey));	//INIT SBOX, KEYLEN+3(IV)
+			ARCFOUR_INIT(&pAd->PrivateInfo.WEPCONTEXT, ekey, sizeof(ekey));	/*INIT SBOX, KEYLEN+3(IV) */
 			pAd->PrivateInfo.FCSCRC32 =
 			    RTMP_CALC_FCS32(pAd->PrivateInfo.FCSCRC32, Key_Data,
 					    data_offset);
@@ -2636,7 +2636,7 @@ VOID ConstructEapolKeyData(IN PMAC_TABLE_ENTRY pEntry,
 		NdisMoveMemory(pMsg->KeyDesc.KeyData, Key_Data, data_offset);
 	}
 
-	// Update key data length field and total body length
+	/* Update key data length field and total body length */
 	SET_UINT16_TO_ARRARY(pMsg->KeyDesc.KeyDataLen, data_offset);
 	INC_UINT16_TO_ARRARY(pMsg->Body_Len, data_offset);
 
@@ -2668,21 +2668,21 @@ static VOID CalculateMIC(IN UCHAR KeyDescVer,
 	UCHAR mic[LEN_KEY_DESC_MIC];
 	UCHAR digest[80];
 
-	// allocate memory for MIC calculation
+	/* allocate memory for MIC calculation */
 	os_alloc_mem(NULL, (PUCHAR *) & OutBuffer, 512);
 
 	if (OutBuffer == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR, ("!!!CalculateMIC: no memory!!!\n"));
 		return;
 	}
-	// make a frame for calculating MIC.
+	/* make a frame for calculating MIC. */
 	MakeOutgoingFrame(OutBuffer, &FrameLen,
 			  CONV_ARRARY_TO_UINT16(pMsg->Body_Len) + 4, pMsg,
 			  END_OF_ARGS);
 
 	NdisZeroMemory(mic, sizeof(mic));
 
-	// Calculate MIC
+	/* Calculate MIC */
 	if (KeyDescVer == DESC_TYPE_AES) {
 		HMAC_SHA1(PTK, LEN_EAP_MICK, OutBuffer, FrameLen, digest,
 			  SHA1_DIGEST_SIZE);
@@ -2692,7 +2692,7 @@ static VOID CalculateMIC(IN UCHAR KeyDescVer,
 			 MD5_DIGEST_SIZE);
 	}
 
-	// store the calculated MIC
+	/* store the calculated MIC */
 	NdisMoveMemory(pMsg->KeyDesc.KeyMic, mic, LEN_KEY_DESC_MIC);
 
 	os_free_mem(NULL, OutBuffer);
@@ -2721,52 +2721,52 @@ NDIS_STATUS RTMPSoftDecryptBroadCastData(IN PRTMP_ADAPTER pAd,
 {
 	PRXWI_STRUC pRxWI = pRxBlk->pRxWI;
 
-	// handle WEP decryption
+	/* handle WEP decryption */
 	if (GroupCipher == Ndis802_11Encryption1Enabled) {
 		if (RTMPSoftDecryptWEP
 		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount,
 		     pShard_key)) {
 
-			//Minus IV[4] & ICV[4]
+			/*Minus IV[4] & ICV[4] */
 			pRxWI->MPDUtotalByteCount -= 8;
 		} else {
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("ERROR : Software decrypt WEP data fails.\n"));
-			// give up this frame
+			/* give up this frame */
 			return NDIS_STATUS_FAILURE;
 		}
 	}
-	// handle TKIP decryption
+	/* handle TKIP decryption */
 	else if (GroupCipher == Ndis802_11Encryption2Enabled) {
 		if (RTMPSoftDecryptTKIP
 		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount, 0,
 		     pShard_key)) {
 
-			//Minus 8 bytes MIC, 8 bytes IV/EIV, 4 bytes ICV
+			/*Minus 8 bytes MIC, 8 bytes IV/EIV, 4 bytes ICV */
 			pRxWI->MPDUtotalByteCount -= 20;
 		} else {
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("ERROR : RTMPSoftDecryptTKIP Failed\n"));
-			// give up this frame
+			/* give up this frame */
 			return NDIS_STATUS_FAILURE;
 		}
 	}
-	// handle AES decryption
+	/* handle AES decryption */
 	else if (GroupCipher == Ndis802_11Encryption3Enabled) {
 		if (RTMPSoftDecryptAES
 		    (pAd, pRxBlk->pData, pRxWI->MPDUtotalByteCount,
 		     pShard_key)) {
 
-			//8 bytes MIC, 8 bytes IV/EIV (CCMP Header)
+			/*8 bytes MIC, 8 bytes IV/EIV (CCMP Header) */
 			pRxWI->MPDUtotalByteCount -= 16;
 		} else {
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("ERROR : RTMPSoftDecryptAES Failed\n"));
-			// give up this frame
+			/* give up this frame */
 			return NDIS_STATUS_FAILURE;
 		}
 	} else {
-		// give up this frame
+		/* give up this frame */
 		return NDIS_STATUS_FAILURE;
 	}
 
@@ -2786,18 +2786,18 @@ PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
 	BOOLEAN isWPA2 = FALSE;
 
 	pEid = (PEID_STRUCT) rsnie;
-	len = rsnie_len - 2;	// exclude IE and length
+	len = rsnie_len - 2;	/* exclude IE and length */
 	pBuf = (PUINT8) & pEid->Octet[0];
 
-	// set default value
+	/* set default value */
 	*count = 0;
 
-	// Check length
+	/* Check length */
 	if ((len <= 0) || (pEid->Len != len)) {
 		DBGPRINT_ERR(("%s : The length is invalid\n", __func__));
 		return NULL;
 	}
-	// Check WPA or WPA2
+	/* Check WPA or WPA2 */
 	if (pEid->Eid == IE_WPA) {
 		PRSNIE pRsnie = (PRSNIE) pBuf;
 		UINT16 ucount;
@@ -2807,18 +2807,18 @@ PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
 				      __func__));
 			return NULL;
 		}
-		// Get the count of pairwise cipher
+		/* Get the count of pairwise cipher */
 		ucount = cpu2le16(pRsnie->ucount);
 		if (ucount > 2) {
 			DBGPRINT_ERR(("%s : The count(%d) of pairwise cipher is invlaid\n", __func__, ucount));
 			return NULL;
 		}
-		// Get the group cipher
+		/* Get the group cipher */
 		if (type == GROUP_SUITE) {
 			*count = 1;
 			return pRsnie->mcast;
 		}
-		// Get the pairwise cipher suite
+		/* Get the pairwise cipher suite */
 		else if (type == PAIRWISE_SUITE) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("%s : The count of pairwise cipher is %d\n",
@@ -2840,18 +2840,18 @@ PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
 				      __func__));
 			return NULL;
 		}
-		// Get the count of pairwise cipher
+		/* Get the count of pairwise cipher */
 		ucount = cpu2le16(pRsnie->ucount);
 		if (ucount > 2) {
 			DBGPRINT_ERR(("%s : The count(%d) of pairwise cipher is invlaid\n", __func__, ucount));
 			return NULL;
 		}
-		// Get the group cipher
+		/* Get the group cipher */
 		if (type == GROUP_SUITE) {
 			*count = 1;
 			return pRsnie->mcast;
 		}
-		// Get the pairwise cipher suite
+		/* Get the pairwise cipher suite */
 		else if (type == PAIRWISE_SUITE) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("%s : The count of pairwise cipher is %d\n",
@@ -2867,7 +2867,7 @@ PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
 		return NULL;
 	}
 
-	// skip group cipher and pairwise cipher suite
+	/* skip group cipher and pairwise cipher suite */
 	pBuf += offset;
 	len -= offset;
 
@@ -2876,17 +2876,17 @@ PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
 			      __func__));
 		return NULL;
 	}
-	// pointer to AKM count
+	/* pointer to AKM count */
 	pAkm = (PRSNIE_AUTH) pBuf;
 
-	// Get the count of pairwise cipher
+	/* Get the count of pairwise cipher */
 	acount = cpu2le16(pAkm->acount);
 	if (acount > 2) {
 		DBGPRINT_ERR(("%s : The count(%d) of AKM is invlaid\n",
 			      __func__, acount));
 		return NULL;
 	}
-	// Get the AKM suite
+	/* Get the AKM suite */
 	if (type == AKM_SUITE) {
 		DBGPRINT(RT_DEBUG_TRACE, ("%s : The count of AKM is %d\n",
 					  __func__, acount));
@@ -2898,13 +2898,13 @@ PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
 	pBuf += offset;
 	len -= offset;
 
-	// The remaining length must larger than (RSN-Capability(2) + PMKID-Count(2) + PMKID(16~))
+	/* The remaining length must larger than (RSN-Capability(2) + PMKID-Count(2) + PMKID(16~)) */
 	if (len >= (sizeof(RSN_CAPABILITIES) + 2 + LEN_PMKID)) {
-		// Skip RSN capability and PMKID-Count
+		/* Skip RSN capability and PMKID-Count */
 		pBuf += (sizeof(RSN_CAPABILITIES) + 2);
 		len -= (sizeof(RSN_CAPABILITIES) + 2);
 
-		// Get PMKID
+		/* Get PMKID */
 		if (type == PMKID_LIST) {
 			*count = 1;
 			return pBuf;
@@ -2915,7 +2915,7 @@ PUINT8 GetSuiteFromRSNIE(IN PUINT8 rsnie,
 	}
 
 	*count = 0;
-	//DBGPRINT_ERR(("%s : The type(%d) doesn't support \n", __func__, type));
+	/*DBGPRINT_ERR(("%s : The type(%d) doesn't support \n", __func__, type)); */
 	return NULL;
 
 }
@@ -2927,24 +2927,24 @@ VOID WpaShowAllsuite(IN PUINT8 rsnie, IN UINT rsnie_len)
 
 	hex_dump("RSNIE", rsnie, rsnie_len);
 
-	// group cipher
+	/* group cipher */
 	if ((pSuite =
 	     GetSuiteFromRSNIE(rsnie, rsnie_len, GROUP_SUITE,
 			       &count)) != NULL) {
 		hex_dump("group cipher", pSuite, 4 * count);
 	}
-	// pairwise cipher
+	/* pairwise cipher */
 	if ((pSuite =
 	     GetSuiteFromRSNIE(rsnie, rsnie_len, PAIRWISE_SUITE,
 			       &count)) != NULL) {
 		hex_dump("pairwise cipher", pSuite, 4 * count);
 	}
-	// AKM
+	/* AKM */
 	if ((pSuite =
 	     GetSuiteFromRSNIE(rsnie, rsnie_len, AKM_SUITE, &count)) != NULL) {
 		hex_dump("AKM suite", pSuite, 4 * count);
 	}
-	// PMKID
+	/* PMKID */
 	if ((pSuite =
 	     GetSuiteFromRSNIE(rsnie, rsnie_len, PMKID_LIST, &count)) != NULL) {
 		hex_dump("PMKID", pSuite, LEN_PMKID);
diff --git a/drivers/staging/rt2860/common/ee_efuse.c b/drivers/staging/rt2860/common/ee_efuse.c
index 8e71add..8e49cd7 100644
--- a/drivers/staging/rt2860/common/ee_efuse.c
+++ b/drivers/staging/rt2860/common/ee_efuse.c
@@ -83,23 +83,23 @@ UCHAR eFuseReadRegisters(IN PRTMP_ADAPTER pAd,
 
 	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
 
-	//Step0. Write 10-bit of address to EFSROM_AIN (0x580, bit25:bit16). The address must be 16-byte alignment.
-	//Use the eeprom logical address and covert to address to block number
+	/*Step0. Write 10-bit of address to EFSROM_AIN (0x580, bit25:bit16). The address must be 16-byte alignment. */
+	/*Use the eeprom logical address and covert to address to block number */
 	eFuseCtrlStruc.field.EFSROM_AIN = Offset & 0xfff0;
 
-	//Step1. Write EFSROM_MODE (0x580, bit7:bit6) to 0.
+	/*Step1. Write EFSROM_MODE (0x580, bit7:bit6) to 0. */
 	eFuseCtrlStruc.field.EFSROM_MODE = 0;
 
-	//Step2. Write EFSROM_KICK (0x580, bit30) to 1 to kick-off physical read procedure.
+	/*Step2. Write EFSROM_KICK (0x580, bit30) to 1 to kick-off physical read procedure. */
 	eFuseCtrlStruc.field.EFSROM_KICK = 1;
 
 	NdisMoveMemory(&data, &eFuseCtrlStruc, 4);
 	RTMP_IO_WRITE32(pAd, EFUSE_CTRL, data);
 
-	//Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again.
+	/*Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again. */
 	i = 0;
 	while (i < 500) {
-		//rtmp.HwMemoryReadDword(EFUSE_CTRL, (DWORD *) &eFuseCtrlStruc, 4);
+		/*rtmp.HwMemoryReadDword(EFUSE_CTRL, (DWORD *) &eFuseCtrlStruc, 4); */
 		RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
 		if (eFuseCtrlStruc.field.EFSROM_KICK == 0) {
 			break;
@@ -108,25 +108,25 @@ UCHAR eFuseReadRegisters(IN PRTMP_ADAPTER pAd,
 		i++;
 	}
 
-	//if EFSROM_AOUT is not found in physical address, write 0xffff
+	/*if EFSROM_AOUT is not found in physical address, write 0xffff */
 	if (eFuseCtrlStruc.field.EFSROM_AOUT == 0x3f) {
 		for (i = 0; i < Length / 2; i++)
 			*(pData + 2 * i) = 0xffff;
 	} else {
-		//Step4. Read 16-byte of data from EFUSE_DATA0-3 (0x590-0x59C)
+		/*Step4. Read 16-byte of data from EFUSE_DATA0-3 (0x590-0x59C) */
 		efuseDataOffset = EFUSE_DATA3 - (Offset & 0xC);
-		//data hold 4 bytes data.
-		//In RTMP_IO_READ32 will automatically execute 32-bytes swapping
+		/*data hold 4 bytes data. */
+		/*In RTMP_IO_READ32 will automatically execute 32-bytes swapping */
 		RTMP_IO_READ32(pAd, efuseDataOffset, &data);
-		//Decide the upper 2 bytes or the bottom 2 bytes.
-		// Little-endian                S       |       S       Big-endian
-		// addr 3       2       1       0       |       0       1       2       3
-		// Ori-V        D       C       B       A       |       A       B       C       D
-		//After swapping
-		//              D       C       B       A       |       D       C       B       A
-		//Return 2-bytes
-		//The return byte statrs from S. Therefore, the little-endian will return BA, the Big-endian will return DC.
-		//For returning the bottom 2 bytes, the Big-endian should shift right 2-bytes.
+		/*Decide the upper 2 bytes or the bottom 2 bytes. */
+		/* Little-endian                S       |       S       Big-endian */
+		/* addr 3       2       1       0       |       0       1       2       3 */
+		/* Ori-V        D       C       B       A       |       A       B       C       D */
+		/*After swapping */
+		/*              D       C       B       A       |       D       C       B       A */
+		/*Return 2-bytes */
+		/*The return byte statrs from S. Therefore, the little-endian will return BA, the Big-endian will return DC. */
+		/*For returning the bottom 2 bytes, the Big-endian should shift right 2-bytes. */
 		data = data >> (8 * (Offset & 0x3));
 
 		NdisMoveMemory(pData, &data, Length);
@@ -160,20 +160,20 @@ VOID eFusePhysicalReadRegisters(IN PRTMP_ADAPTER pAd,
 
 	RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
 
-	//Step0. Write 10-bit of address to EFSROM_AIN (0x580, bit25:bit16). The address must be 16-byte alignment.
+	/*Step0. Write 10-bit of address to EFSROM_AIN (0x580, bit25:bit16). The address must be 16-byte alignment. */
 	eFuseCtrlStruc.field.EFSROM_AIN = Offset & 0xfff0;
 
-	//Step1. Write EFSROM_MODE (0x580, bit7:bit6) to 1.
-	//Read in physical view
+	/*Step1. Write EFSROM_MODE (0x580, bit7:bit6) to 1. */
+	/*Read in physical view */
 	eFuseCtrlStruc.field.EFSROM_MODE = 1;
 
-	//Step2. Write EFSROM_KICK (0x580, bit30) to 1 to kick-off physical read procedure.
+	/*Step2. Write EFSROM_KICK (0x580, bit30) to 1 to kick-off physical read procedure. */
 	eFuseCtrlStruc.field.EFSROM_KICK = 1;
 
 	NdisMoveMemory(&data, &eFuseCtrlStruc, 4);
 	RTMP_IO_WRITE32(pAd, EFUSE_CTRL, data);
 
-	//Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again.
+	/*Step3. Polling EFSROM_KICK(0x580, bit30) until it become 0 again. */
 	i = 0;
 	while (i < 500) {
 		RTMP_IO_READ32(pAd, EFUSE_CTRL, &eFuseCtrlStruc.word);
@@ -183,14 +183,14 @@ VOID eFusePhysicalReadRegisters(IN PRTMP_ADAPTER pAd,
 		i++;
 	}
 
-	//Step4. Read 16-byte of data from EFUSE_DATA0-3 (0x59C-0x590)
-	//Because the size of each EFUSE_DATA is 4 Bytes, the size of address of each is 2 bits.
-	//The previous 2 bits is the EFUSE_DATA number, the last 2 bits is used to decide which bytes
-	//Decide which EFUSE_DATA to read
-	//590:F E D C
-	//594:B A 9 8
-	//598:7 6 5 4
-	//59C:3 2 1 0
+	/*Step4. Read 16-byte of data from EFUSE_DATA0-3 (0x59C-0x590) */
+	/*Because the size of each EFUSE_DATA is 4 Bytes, the size of address of each is 2 bits. */
+	/*The previous 2 bits is the EFUSE_DATA number, the last 2 bits is used to decide which bytes */
+	/*Decide which EFUSE_DATA to read */
+	/*590:F E D C */
+	/*594:B A 9 8 */
+	/*598:7 6 5 4 */
+	/*59C:3 2 1 0 */
 	efuseDataOffset = EFUSE_DATA3 - (Offset & 0xC);
 
 	RTMP_IO_READ32(pAd, efuseDataOffset, &data);
@@ -222,8 +222,8 @@ static VOID eFuseReadPhysical(IN PRTMP_ADAPTER pAd,
 	USHORT *pInBuf = (USHORT *) lpInBuffer;
 	USHORT *pOutBuf = (USHORT *) lpOutBuffer;
 
-	USHORT Offset = pInBuf[0];	//addr
-	USHORT Length = pInBuf[1];	//length
+	USHORT Offset = pInBuf[0];	/*addr */
+	USHORT Length = pInBuf[1];	/*length */
 	int i;
 
 	for (i = 0; i < Length; i += 2) {
diff --git a/drivers/staging/rt2860/common/ee_prom.c b/drivers/staging/rt2860/common/ee_prom.c
index b5be6f0..fa3f231 100644
--- a/drivers/staging/rt2860/common/ee_prom.c
+++ b/drivers/staging/rt2860/common/ee_prom.c
@@ -37,15 +37,15 @@
 
 #include	"../rt_config.h"
 
-// IRQL = PASSIVE_LEVEL
+/* IRQL = PASSIVE_LEVEL */
 static inline VOID RaiseClock(IN PRTMP_ADAPTER pAd, IN UINT32 * x)
 {
 	*x = *x | EESK;
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, *x);
-	RTMPusecDelay(1);	// Max frequency = 1MHz in Spec. definition
+	RTMPusecDelay(1);	/* Max frequency = 1MHz in Spec. definition */
 }
 
-// IRQL = PASSIVE_LEVEL
+/* IRQL = PASSIVE_LEVEL */
 static inline VOID LowerClock(IN PRTMP_ADAPTER pAd, IN UINT32 * x)
 {
 	*x = *x & ~EESK;
@@ -53,7 +53,7 @@ static inline VOID LowerClock(IN PRTMP_ADAPTER pAd, IN UINT32 * x)
 	RTMPusecDelay(1);
 }
 
-// IRQL = PASSIVE_LEVEL
+/* IRQL = PASSIVE_LEVEL */
 static inline USHORT ShiftInBits(IN PRTMP_ADAPTER pAd)
 {
 	UINT32 x, i;
@@ -68,7 +68,7 @@ static inline USHORT ShiftInBits(IN PRTMP_ADAPTER pAd)
 		RaiseClock(pAd, &x);
 
 		RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
-		LowerClock(pAd, &x);	//prevent read failed
+		LowerClock(pAd, &x);	/*prevent read failed */
 
 		x &= ~(EEDI);
 		if (x & EEDO)
@@ -78,7 +78,7 @@ static inline USHORT ShiftInBits(IN PRTMP_ADAPTER pAd)
 	return data;
 }
 
-// IRQL = PASSIVE_LEVEL
+/* IRQL = PASSIVE_LEVEL */
 static inline VOID ShiftOutBits(IN PRTMP_ADAPTER pAd,
 				IN USHORT data, IN USHORT count)
 {
@@ -106,7 +106,7 @@ static inline VOID ShiftOutBits(IN PRTMP_ADAPTER pAd,
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 }
 
-// IRQL = PASSIVE_LEVEL
+/* IRQL = PASSIVE_LEVEL */
 static inline VOID EEpromCleanup(IN PRTMP_ADAPTER pAd)
 {
 	UINT32 x;
@@ -124,17 +124,17 @@ static inline VOID EWEN(IN PRTMP_ADAPTER pAd)
 {
 	UINT32 x;
 
-	// reset bits and set EECS
+	/* reset bits and set EECS */
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
 	x &= ~(EEDI | EEDO | EESK);
 	x |= EECS;
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 
-	// kick a pulse
+	/* kick a pulse */
 	RaiseClock(pAd, &x);
 	LowerClock(pAd, &x);
 
-	// output the read_opcode and six pulse in that order
+	/* output the read_opcode and six pulse in that order */
 	ShiftOutBits(pAd, EEPROM_EWEN_OPCODE, 5);
 	ShiftOutBits(pAd, 0, 6);
 
@@ -145,24 +145,24 @@ static inline VOID EWDS(IN PRTMP_ADAPTER pAd)
 {
 	UINT32 x;
 
-	// reset bits and set EECS
+	/* reset bits and set EECS */
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
 	x &= ~(EEDI | EEDO | EESK);
 	x |= EECS;
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 
-	// kick a pulse
+	/* kick a pulse */
 	RaiseClock(pAd, &x);
 	LowerClock(pAd, &x);
 
-	// output the read_opcode and six pulse in that order
+	/* output the read_opcode and six pulse in that order */
 	ShiftOutBits(pAd, EEPROM_EWDS_OPCODE, 5);
 	ShiftOutBits(pAd, 0, 6);
 
 	EEpromCleanup(pAd);
 }
 
-// IRQL = PASSIVE_LEVEL
+/* IRQL = PASSIVE_LEVEL */
 int rtmp_ee_prom_read16(IN PRTMP_ADAPTER pAd,
 			IN USHORT Offset, OUT USHORT * pValue)
 {
@@ -170,23 +170,23 @@ int rtmp_ee_prom_read16(IN PRTMP_ADAPTER pAd,
 	USHORT data;
 
 	Offset /= 2;
-	// reset bits and set EECS
+	/* reset bits and set EECS */
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &x);
 	x &= ~(EEDI | EEDO | EESK);
 	x |= EECS;
 	RTMP_IO_WRITE32(pAd, E2PROM_CSR, x);
 
-	// patch can not access e-Fuse issue
+	/* patch can not access e-Fuse issue */
 	if (!(IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))) {
-		// kick a pulse
+		/* kick a pulse */
 		RaiseClock(pAd, &x);
 		LowerClock(pAd, &x);
 	}
-	// output the read_opcode and register number in that order
+	/* output the read_opcode and register number in that order */
 	ShiftOutBits(pAd, EEPROM_READ_OPCODE, 3);
 	ShiftOutBits(pAd, Offset, pAd->EEPROMAddressNum);
 
-	// Now read the data (16 bits) in from the selected EEPROM word
+	/* Now read the data (16 bits) in from the selected EEPROM word */
 	data = ShiftInBits(pAd);
 
 	EEpromCleanup(pAd);
diff --git a/drivers/staging/rt2860/common/eeprom.c b/drivers/staging/rt2860/common/eeprom.c
index 872b47c..202d313 100644
--- a/drivers/staging/rt2860/common/eeprom.c
+++ b/drivers/staging/rt2860/common/eeprom.c
@@ -65,8 +65,8 @@ INT RtmpChipOpsEepromHook(IN RTMP_ADAPTER * pAd, IN INT infType)
 		return 0;
 	} else
 		DBGPRINT(RT_DEBUG_TRACE, ("NVM is EEPROM\n"));
-#endif // RTMP_EFUSE_SUPPORT //
-#endif // RT30xx //
+#endif /* RTMP_EFUSE_SUPPORT // */
+#endif /* RT30xx // */
 
 	switch (infType) {
 #ifdef RTMP_PCI_SUPPORT
@@ -74,13 +74,13 @@ INT RtmpChipOpsEepromHook(IN RTMP_ADAPTER * pAd, IN INT infType)
 		pChipOps->eeinit = NULL;
 		pChipOps->eeread = rtmp_ee_prom_read16;
 		break;
-#endif // RTMP_PCI_SUPPORT //
+#endif /* RTMP_PCI_SUPPORT // */
 #ifdef RTMP_USB_SUPPORT
 	case RTMP_DEV_INF_USB:
 		pChipOps->eeinit = NULL;
 		pChipOps->eeread = RTUSBReadEEPROM16;
 		break;
-#endif // RTMP_USB_SUPPORT //
+#endif /* RTMP_USB_SUPPORT // */
 
 	default:
 		DBGPRINT(RT_DEBUG_ERROR, ("RtmpChipOpsEepromHook() failed!\n"));
diff --git a/drivers/staging/rt2860/common/mlme.c b/drivers/staging/rt2860/common/mlme.c
index 1d97b73..e047b89 100644
--- a/drivers/staging/rt2860/common/mlme.c
+++ b/drivers/staging/rt2860/common/mlme.c
@@ -52,8 +52,8 @@ UCHAR WPS_OUI[] = { 0x00, 0x50, 0xf2, 0x04 };
 UCHAR PRE_N_HT_OUI[] = { 0x00, 0x90, 0x4c };
 
 UCHAR RateSwitchTable[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x11, 0x00, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x11, 0x00, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x00, 0, 40, 101,
 	0x01, 0x00, 1, 40, 50,
 	0x02, 0x00, 2, 35, 45,
@@ -89,8 +89,8 @@ UCHAR RateSwitchTable[] = {
 };
 
 UCHAR RateSwitchTable11B[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x04, 0x03, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x04, 0x03, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x00, 0, 40, 101,
 	0x01, 0x00, 1, 40, 50,
 	0x02, 0x00, 2, 35, 45,
@@ -98,8 +98,8 @@ UCHAR RateSwitchTable11B[] = {
 };
 
 UCHAR RateSwitchTable11BG[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0a, 0x00, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0a, 0x00, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x00, 0, 40, 101,
 	0x01, 0x00, 1, 40, 50,
 	0x02, 0x00, 2, 35, 45,
@@ -113,8 +113,8 @@ UCHAR RateSwitchTable11BG[] = {
 };
 
 UCHAR RateSwitchTable11G[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x08, 0x00, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x08, 0x00, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x10, 0, 20, 101,
 	0x01, 0x10, 1, 20, 35,
 	0x02, 0x10, 2, 20, 35,
@@ -126,8 +126,8 @@ UCHAR RateSwitchTable11G[] = {
 };
 
 UCHAR RateSwitchTable11N1S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0c, 0x0a, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0c, 0x0a, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x00, 0, 40, 101,
 	0x01, 0x00, 1, 40, 50,
 	0x02, 0x00, 2, 25, 45,
@@ -143,8 +143,8 @@ UCHAR RateSwitchTable11N1S[] = {
 };
 
 UCHAR RateSwitchTable11N2S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0e, 0x0c, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0e, 0x0c, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x00, 0, 40, 101,
 	0x01, 0x00, 1, 40, 50,
 	0x02, 0x00, 2, 25, 45,
@@ -162,24 +162,24 @@ UCHAR RateSwitchTable11N2S[] = {
 };
 
 UCHAR RateSwitchTable11N3S[] = {
-// Item No.     Mode    Curr-MCS        TrainUp TrainDown       // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0b, 0x00, 0, 0, 0,	// 0x0a, 0x00,  0,  0,  0,      // Initial used item after association
+/* Item No.     Mode    Curr-MCS        TrainUp TrainDown       // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0b, 0x00, 0, 0, 0,	/* 0x0a, 0x00,  0,  0,  0,      // Initial used item after association */
 	0x00, 0x21, 0, 30, 101,
 	0x01, 0x21, 1, 20, 50,
 	0x02, 0x21, 2, 20, 50,
 	0x03, 0x21, 3, 15, 50,
 	0x04, 0x21, 4, 15, 30,
-	0x05, 0x20, 11, 15, 30,	// Required by System-Alan @ 20080812
-	0x06, 0x20, 12, 15, 30,	// 0x05, 0x20, 12, 15, 30,
-	0x07, 0x20, 13, 8, 20,	// 0x06, 0x20, 13,  8, 20,
-	0x08, 0x20, 14, 8, 20,	// 0x07, 0x20, 14,  8, 20,
-	0x09, 0x20, 15, 8, 25,	// 0x08, 0x20, 15,  8, 25,
-	0x0a, 0x22, 15, 8, 25,	// 0x09, 0x22, 15,  8, 25,
+	0x05, 0x20, 11, 15, 30,	/* Required by System-Alan @ 20080812 */
+	0x06, 0x20, 12, 15, 30,	/* 0x05, 0x20, 12, 15, 30, */
+	0x07, 0x20, 13, 8, 20,	/* 0x06, 0x20, 13,  8, 20, */
+	0x08, 0x20, 14, 8, 20,	/* 0x07, 0x20, 14,  8, 20, */
+	0x09, 0x20, 15, 8, 25,	/* 0x08, 0x20, 15,  8, 25, */
+	0x0a, 0x22, 15, 8, 25,	/* 0x09, 0x22, 15,  8, 25, */
 };
 
 UCHAR RateSwitchTable11N2SForABand[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0b, 0x09, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0b, 0x09, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x21, 0, 30, 101,
 	0x01, 0x21, 1, 20, 50,
 	0x02, 0x21, 2, 20, 50,
@@ -193,9 +193,9 @@ UCHAR RateSwitchTable11N2SForABand[] = {
 	0x0a, 0x22, 15, 8, 25,
 };
 
-UCHAR RateSwitchTable11N3SForABand[] = {	// 3*3
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0b, 0x09, 0, 0, 0,	// Initial used item after association
+UCHAR RateSwitchTable11N3SForABand[] = {	/* 3*3 */
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0b, 0x09, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x21, 0, 30, 101,
 	0x01, 0x21, 1, 20, 50,
 	0x02, 0x21, 2, 20, 50,
@@ -210,8 +210,8 @@ UCHAR RateSwitchTable11N3SForABand[] = {	// 3*3
 };
 
 UCHAR RateSwitchTable11BGN1S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0c, 0x0a, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0c, 0x0a, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x00, 0, 40, 101,
 	0x01, 0x00, 1, 40, 50,
 	0x02, 0x00, 2, 25, 45,
@@ -227,8 +227,8 @@ UCHAR RateSwitchTable11BGN1S[] = {
 };
 
 UCHAR RateSwitchTable11BGN2S[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0e, 0x0c, 0, 0, 0,	// Initial used item after association
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0e, 0x0c, 0, 0, 0,	/* Initial used item after association */
 	0x00, 0x00, 0, 40, 101,
 	0x01, 0x00, 1, 40, 50,
 	0x02, 0x00, 2, 25, 45,
@@ -245,10 +245,10 @@ UCHAR RateSwitchTable11BGN2S[] = {
 	0x0d, 0x22, 15, 8, 15,
 };
 
-UCHAR RateSwitchTable11BGN3S[] = {	// 3*3
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0a, 0x00, 0, 0, 0,	// Initial used item after association
-	0x00, 0x21, 0, 30, 101,	//50
+UCHAR RateSwitchTable11BGN3S[] = {	/* 3*3 */
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0a, 0x00, 0, 0, 0,	/* Initial used item after association */
+	0x00, 0x21, 0, 30, 101,	/*50 */
 	0x01, 0x21, 1, 20, 50,
 	0x02, 0x21, 2, 20, 50,
 	0x03, 0x21, 3, 20, 50,
@@ -261,9 +261,9 @@ UCHAR RateSwitchTable11BGN3S[] = {	// 3*3
 };
 
 UCHAR RateSwitchTable11BGN2SForABand[] = {
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0b, 0x09, 0, 0, 0,	// Initial used item after association
-	0x00, 0x21, 0, 30, 101,	//50
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0b, 0x09, 0, 0, 0,	/* Initial used item after association */
+	0x00, 0x21, 0, 30, 101,	/*50 */
 	0x01, 0x21, 1, 20, 50,
 	0x02, 0x21, 2, 20, 50,
 	0x03, 0x21, 3, 15, 50,
@@ -276,10 +276,10 @@ UCHAR RateSwitchTable11BGN2SForABand[] = {
 	0x0a, 0x22, 15, 8, 25,
 };
 
-UCHAR RateSwitchTable11BGN3SForABand[] = {	// 3*3
-// Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF)
-	0x0c, 0x09, 0, 0, 0,	// Initial used item after association
-	0x00, 0x21, 0, 30, 101,	//50
+UCHAR RateSwitchTable11BGN3SForABand[] = {	/* 3*3 */
+/* Item No.   Mode   Curr-MCS   TrainUp   TrainDown             // Mode- Bit0: STBC, Bit1: Short GI, Bit4,5: Mode(0:CCK, 1:OFDM, 2:HT Mix, 3:HT GF) */
+	0x0c, 0x09, 0, 0, 0,	/* Initial used item after association */
+	0x00, 0x21, 0, 30, 101,	/*50 */
 	0x01, 0x21, 1, 20, 50,
 	0x02, 0x21, 2, 20, 50,
 	0x03, 0x21, 3, 15, 50,
@@ -294,8 +294,8 @@ UCHAR RateSwitchTable11BGN3SForABand[] = {	// 3*3
 };
 
 extern UCHAR OfdmRateToRxwiMCS[];
-// since RT61 has better RX sensibility, we have to limit TX ACK rate not to exceed our normal data TX rate.
-// otherwise the WLAN peer may not be able to receive the ACK thus downgrade its data TX rate
+/* since RT61 has better RX sensibility, we have to limit TX ACK rate not to exceed our normal data TX rate. */
+/* otherwise the WLAN peer may not be able to receive the ACK thus downgrade its data TX rate */
 ULONG BasicRateMask[12] =
     { 0xfffff001 /* 1-Mbps */ , 0xfffff003 /* 2 Mbps */ , 0xfffff007 /* 5.5 */ ,
 0xfffff00f /* 11 */ ,
@@ -308,10 +308,10 @@ ULONG BasicRateMask[12] =
 UCHAR BROADCAST_ADDR[MAC_ADDR_LEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 UCHAR ZERO_MAC_ADDR[MAC_ADDR_LEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 
-// e.g. RssiSafeLevelForTxRate[RATE_36]" means if the current RSSI is greater than
-//              this value, then it's quaranteed capable of operating in 36 mbps TX rate in
-//              clean environment.
-//                                                                TxRate: 1   2   5.5   11       6        9    12       18       24   36   48   54       72  100
+/* e.g. RssiSafeLevelForTxRate[RATE_36]" means if the current RSSI is greater than */
+/*              this value, then it's quaranteed capable of operating in 36 mbps TX rate in */
+/*              clean environment. */
+/*                                                                TxRate: 1   2   5.5   11       6        9    12       18       24   36   48   54       72  100 */
 CHAR RssiSafeLevelForTxRate[] =
     { -92, -91, -90, -87, -88, -86, -85, -83, -81, -78, -72, -71, -40, -40 };
 
@@ -373,7 +373,7 @@ NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd)
 		{
 			BssTableInit(&pAd->ScanTab);
 
-			// init STA state machines
+			/* init STA state machines */
 			AssocStateMachineInit(pAd, &pAd->Mlme.AssocMachine,
 					      pAd->Mlme.AssocFunc);
 			AuthStateMachineInit(pAd, &pAd->Mlme.AuthMachine,
@@ -383,8 +383,8 @@ NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd)
 			SyncStateMachineInit(pAd, &pAd->Mlme.SyncMachine,
 					     pAd->Mlme.SyncFunc);
 
-			// Since we are using switch/case to implement it, the init is different from the above
-			// state machine init
+			/* Since we are using switch/case to implement it, the init is different from the above */
+			/* state machine init */
 			MlmeCntlInit(pAd, &pAd->Mlme.CntlMachine, NULL);
 		}
 
@@ -394,14 +394,14 @@ NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd)
 		ActionStateMachineInit(pAd, &pAd->Mlme.ActMachine,
 				       pAd->Mlme.ActFunc);
 
-		// Init mlme periodic timer
+		/* Init mlme periodic timer */
 		RTMPInitTimer(pAd, &pAd->Mlme.PeriodicTimer,
 			      GET_TIMER_FUNCTION(MlmePeriodicExec), pAd, TRUE);
 
-		// Set mlme periodic timer
+		/* Set mlme periodic timer */
 		RTMPSetTimer(&pAd->Mlme.PeriodicTimer, MLME_TASK_EXEC_INTV);
 
-		// software-based RX Antenna diversity
+		/* software-based RX Antenna diversity */
 		RTMPInitTimer(pAd, &pAd->Mlme.RxAntEvalTimer,
 			      GET_TIMER_FUNCTION(AsicRxAntEvalTimeout), pAd,
 			      FALSE);
@@ -409,7 +409,7 @@ NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd)
 		{
 #ifdef RTMP_PCI_SUPPORT
 			if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
-				// only PCIe cards need these two timers
+				/* only PCIe cards need these two timers */
 				RTMPInitTimer(pAd, &pAd->Mlme.PsPollTimer,
 					      GET_TIMER_FUNCTION
 					      (PsPollWakeExec), pAd, FALSE);
@@ -417,7 +417,7 @@ NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd)
 					      GET_TIMER_FUNCTION(RadioOnExec),
 					      pAd, FALSE);
 			}
-#endif // RTMP_PCI_SUPPORT //
+#endif /* RTMP_PCI_SUPPORT // */
 
 			RTMPInitTimer(pAd, &pAd->Mlme.LinkDownTimer,
 				      GET_TIMER_FUNCTION(LinkDownExec), pAd,
@@ -429,7 +429,7 @@ NDIS_STATUS MlmeInit(IN PRTMP_ADAPTER pAd)
 				      (RtmpUsbStaAsicForceWakeupTimeout), pAd,
 				      FALSE);
 			pAd->Mlme.AutoWakeupTimerRunning = FALSE;
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 		}
 
 	} while (FALSE);
@@ -457,8 +457,8 @@ VOID MlmeHandler(IN PRTMP_ADAPTER pAd)
 {
 	MLME_QUEUE_ELEM *Elem = NULL;
 
-	// Only accept MLME and Frame from peer side, no other (control/data) frame should
-	// get into this state machine
+	/* Only accept MLME and Frame from peer side, no other (control/data) frame should */
+	/* get into this state machine */
 
 	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
 	if (pAd->Mlme.bRunning) {
@@ -478,7 +478,7 @@ VOID MlmeHandler(IN PRTMP_ADAPTER pAd)
 				  pAd->Mlme.Queue.Num));
 			break;
 		}
-		//From message type, determine which state machine I should drive
+		/*From message type, determine which state machine I should drive */
 		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
 #ifdef RTMP_MAC_USB
 			if (Elem->MsgType == MT2_RESET_CONF) {
@@ -489,11 +489,11 @@ VOID MlmeHandler(IN PRTMP_ADAPTER pAd)
 				Elem->MsgLen = 0;
 				continue;
 			}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-			// if dequeue success
+			/* if dequeue success */
 			switch (Elem->Machine) {
-				// STA state machines
+				/* STA state machines */
 			case ASSOC_STATE_MACHINE:
 				StateMachinePerformAction(pAd,
 							  &pAd->Mlme.
@@ -542,9 +542,9 @@ VOID MlmeHandler(IN PRTMP_ADAPTER pAd)
 					 ("ERROR: Illegal machine %ld in MlmeHandler()\n",
 					  Elem->Machine));
 				break;
-			}	// end of switch
+			}	/* end of switch */
 
-			// free MLME element
+			/* free MLME element */
 			Elem->Occupied = FALSE;
 			Elem->MsgLen = 0;
 
@@ -578,12 +578,12 @@ VOID MlmeHalt(IN PRTMP_ADAPTER pAd)
 	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeHalt\n"));
 
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
-		// disable BEACON generation and other BEACON related hardware timers
+		/* disable BEACON generation and other BEACON related hardware timers */
 		AsicDisableSync(pAd);
 	}
 
 	{
-		// Cancel pending timers
+		/* Cancel pending timers */
 		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &Cancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &Cancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
@@ -597,13 +597,13 @@ VOID MlmeHalt(IN PRTMP_ADAPTER pAd)
 			RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
 			RTMPCancelTimer(&pAd->Mlme.RadioOnOffTimer, &Cancelled);
 		}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 		RTMPCancelTimer(&pAd->Mlme.LinkDownTimer, &Cancelled);
 
 #ifdef RTMP_MAC_USB
 		RTMPCancelTimer(&pAd->Mlme.AutoWakeupTimer, &Cancelled);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	}
 
 	RTMPCancelTimer(&pAd->Mlme.PeriodicTimer, &Cancelled);
@@ -612,9 +612,9 @@ VOID MlmeHalt(IN PRTMP_ADAPTER pAd)
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		RTMP_CHIP_OP *pChipOps = &pAd->chipOps;
 
-		// Set LED
+		/* Set LED */
 		RTMPSetLED(pAd, LED_HALT);
-		RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, firmware is not done it.
+		RTMPSetSignalLED(pAd, -100);	/* Force signal strength Led to be turned off, firmware is not done it. */
 #ifdef RTMP_MAC_USB
 		{
 			LED_CFG_STRUC LedCfg;
@@ -625,13 +625,13 @@ VOID MlmeHalt(IN PRTMP_ADAPTER pAd)
 			LedCfg.field.YLedMode = 0;
 			RTMP_IO_WRITE32(pAd, LED_CFG, LedCfg.word);
 		}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 		if (pChipOps->AsicHaltAction)
 			pChipOps->AsicHaltAction(pAd);
 	}
 
-	RTMPusecDelay(5000);	//  5 msec to gurantee Ant Diversity timer canceled
+	RTMPusecDelay(5000);	/*  5 msec to gurantee Ant Diversity timer canceled */
 
 	MlmeQueueDestroy(&pAd->Mlme.Queue);
 	NdisFreeSpinLock(&pAd->Mlme.TaskLock);
@@ -643,7 +643,7 @@ VOID MlmeResetRalinkCounters(IN PRTMP_ADAPTER pAd)
 {
 	pAd->RalinkCounters.LastOneSecRxOkDataCnt =
 	    pAd->RalinkCounters.OneSecRxOkDataCnt;
-	// clear all OneSecxxx counters.
+	/* clear all OneSecxxx counters. */
 	pAd->RalinkCounters.OneSecBeaconSentCnt = 0;
 	pAd->RalinkCounters.OneSecFalseCCACnt = 0;
 	pAd->RalinkCounters.OneSecRxFcsErrCnt = 0;
@@ -655,7 +655,7 @@ VOID MlmeResetRalinkCounters(IN PRTMP_ADAPTER pAd)
 	pAd->RalinkCounters.OneSecReceivedByteCount = 0;
 	pAd->RalinkCounters.OneSecTransmittedByteCount = 0;
 
-	// TODO: for debug only. to be removed
+	/* TODO: for debug only. to be removed */
 	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BE] = 0;
 	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_BK] = 0;
 	pAd->RalinkCounters.OneSecOsTxCount[QID_AC_VI] = 0;
@@ -688,7 +688,7 @@ VOID MlmeResetRalinkCounters(IN PRTMP_ADAPTER pAd)
 
 	==========================================================================
  */
-#define ADHOC_BEACON_LOST_TIME		(8*OS_HZ)	// 8 sec
+#define ADHOC_BEACON_LOST_TIME		(8*OS_HZ)	/* 8 sec */
 VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 		      IN PVOID FunctionContext,
 		      IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
@@ -698,8 +698,8 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 
 #ifdef RTMP_MAC_PCI
 	{
-		// If Hardware controlled Radio enabled, we have to check GPIO pin2 every 2 second.
-		// Move code to here, because following code will return when radio is off
+		/* If Hardware controlled Radio enabled, we have to check GPIO pin2 every 2 second. */
+		/* Move code to here, because following code will return when radio is off */
 		if ((pAd->Mlme.PeriodicRound % (MLME_TASK_EXEC_MULTIPLE * 2) ==
 		     0) && (pAd->StaCfg.bHardwareRadio == TRUE)
 		    && (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST))
@@ -708,27 +708,27 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 		    ) {
 			UINT32 data = 0;
 
-			// Read GPIO pin2 as Hardware controlled radio state
+			/* Read GPIO pin2 as Hardware controlled radio state */
 #ifndef RT3090
 			RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &data);
-#endif // RT3090 //
-//KH(PCIE PS):Added based on Jane<--
+#endif /* RT3090 // */
+/*KH(PCIE PS):Added based on Jane<-- */
 #ifdef RT3090
-// Read GPIO pin2 as Hardware controlled radio state
-// We need to Read GPIO if HW said so no mater what advance power saving
+/* Read GPIO pin2 as Hardware controlled radio state */
+/* We need to Read GPIO if HW said so no mater what advance power saving */
 			if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
 			    &&
 			    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))
 			    && (pAd->StaCfg.PSControl.field.EnablePSinIdle ==
 				TRUE)) {
-				// Want to make sure device goes to L0 state before reading register.
+				/* Want to make sure device goes to L0 state before reading register. */
 				RTMPPCIeLinkCtrlValueRestore(pAd, 0);
 				RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
 				RTMPPCIeLinkCtrlSetting(pAd, 3);
 			} else
 				RTMP_IO_FORCE_READ32(pAd, GPIO_CTRL_CFG, &data);
-#endif // RT3090 //
-//KH(PCIE PS):Added based on Jane-->
+#endif /* RT3090 // */
+/*KH(PCIE PS):Added based on Jane--> */
 
 			if (data & 0x04) {
 				pAd->StaCfg.bHwRadio = TRUE;
@@ -741,20 +741,20 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 						      && pAd->StaCfg.bSwRadio);
 				if (pAd->StaCfg.bRadio == TRUE) {
 					MlmeRadioOn(pAd);
-					// Update extra information
+					/* Update extra information */
 					pAd->ExtraInfo = EXTRA_INFO_CLEAR;
 				} else {
 					MlmeRadioOff(pAd);
-					// Update extra information
+					/* Update extra information */
 					pAd->ExtraInfo = HW_RADIO_OFF;
 				}
 			}
 		}
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if ((RTMP_TEST_FLAG(pAd, (fRTMP_ADAPTER_HALT_IN_PROGRESS |
 				  fRTMP_ADAPTER_RADIO_OFF |
 				  fRTMP_ADAPTER_RADIO_MEASUREMENT |
@@ -764,12 +764,12 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 	RTMP_MLME_PRE_SANITY_CHECK(pAd);
 
 	{
-		// Do nothing if monitor mode is on
+		/* Do nothing if monitor mode is on */
 		if (MONITOR_ON(pAd))
 			return;
 
 		if (pAd->Mlme.PeriodicRound & 0x1) {
-			// This is the fix for wifi 11n extension channel overlapping test case.  for 2860D
+			/* This is the fix for wifi 11n extension channel overlapping test case.  for 2860D */
 			if (((pAd->MACVersion & 0xffff) == 0x0101) &&
 			    (STA_TGN_WIFI_ON(pAd)) &&
 			    (pAd->CommonCfg.IOTestParm.bToggle == FALSE))
@@ -786,20 +786,20 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 
 	pAd->bUpdateBcnCntDone = FALSE;
 
-//      RECBATimerTimeout(SystemSpecific1,FunctionContext,SystemSpecific2,SystemSpecific3);
+/*      RECBATimerTimeout(SystemSpecific1,FunctionContext,SystemSpecific2,SystemSpecific3); */
 	pAd->Mlme.PeriodicRound++;
 
 #ifdef RTMP_MAC_USB
-	// execute every 100ms, update the Tx FIFO Cnt for update Tx Rate.
+	/* execute every 100ms, update the Tx FIFO Cnt for update Tx Rate. */
 	NICUpdateFifoStaCounters(pAd);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	// execute every 500ms
+	/* execute every 500ms */
 	if ((pAd->Mlme.PeriodicRound % 5 == 0)
 	    && RTMPAutoRateSwitchCheck(pAd)
 	    /*(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)) */ )
 	{
-		// perform dynamic tx rate switching based on past TX history
+		/* perform dynamic tx rate switching based on past TX history */
 		{
 			if ((OPSTATUS_TEST_FLAG
 			     (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
@@ -808,13 +808,13 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 				MlmeDynamicTxRateSwitching(pAd);
 		}
 	}
-	// Normal 1 second Mlme PeriodicExec.
+	/* Normal 1 second Mlme PeriodicExec. */
 	if (pAd->Mlme.PeriodicRound % MLME_TASK_EXEC_MULTIPLE == 0) {
 		pAd->Mlme.OneSecPeriodicRound++;
 
-		//ORIBATimerTimeout(pAd);
+		/*ORIBATimerTimeout(pAd); */
 
-		// Media status changed, report to NDIS
+		/* Media status changed, report to NDIS */
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE)) {
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
 			if (OPSTATUS_TEST_FLAG
@@ -832,26 +832,26 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 
 		NdisGetSystemUpTime(&pAd->Mlme.Now32);
 
-		// add the most up-to-date h/w raw counters into software variable, so that
-		// the dynamic tuning mechanism below are based on most up-to-date information
+		/* add the most up-to-date h/w raw counters into software variable, so that */
+		/* the dynamic tuning mechanism below are based on most up-to-date information */
 		NICUpdateRawCounters(pAd);
 
 #ifdef RTMP_MAC_USB
 		RTUSBWatchDog(pAd);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-		// Need statistics after read counter. So put after NICUpdateRawCounters
+		/* Need statistics after read counter. So put after NICUpdateRawCounters */
 		ORIBATimerTimeout(pAd);
 
-		// if MGMT RING is full more than twice within 1 second, we consider there's
-		// a hardware problem stucking the TX path. In this case, try a hardware reset
-		// to recover the system
-		//      if (pAd->RalinkCounters.MgmtRingFullCount >= 2)
-		//              RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR);
-		//      else
-		//              pAd->RalinkCounters.MgmtRingFullCount = 0;
+		/* if MGMT RING is full more than twice within 1 second, we consider there's */
+		/* a hardware problem stucking the TX path. In this case, try a hardware reset */
+		/* to recover the system */
+		/*      if (pAd->RalinkCounters.MgmtRingFullCount >= 2) */
+		/*              RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_HARDWARE_ERROR); */
+		/*      else */
+		/*              pAd->RalinkCounters.MgmtRingFullCount = 0; */
 
-		// The time period for checking antenna is according to traffic
+		/* The time period for checking antenna is according to traffic */
 		{
 			if (pAd->Mlme.bEnableAutoAntennaCheck) {
 				TxTotalCnt =
@@ -859,7 +859,7 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 				    pAd->RalinkCounters.OneSecTxRetryOkCount +
 				    pAd->RalinkCounters.OneSecTxFailCount;
 
-				// dynamic adjust antenna evaluation period according to the traffic
+				/* dynamic adjust antenna evaluation period according to the traffic */
 				if (TxTotalCnt > 50) {
 					if (pAd->Mlme.OneSecPeriodicRound %
 					    10 == 0) {
@@ -882,14 +882,14 @@ VOID MlmePeriodicExec(IN PVOID SystemSpecific1,
 #ifdef RTMP_MAC_PCI
 			if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_NIC_NOT_EXIST)
 			    && (pAd->bPCIclkOff == FALSE))
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 			{
-				// When Adhoc beacon is enabled and RTS/CTS is enabled, there is a chance that hardware MAC FSM will run into a deadlock
-				// and sending CTS-to-self over and over.
-				// Software Patch Solution:
-				// 1. Polling debug state register 0x10F4 every one second.
-				// 2. If in 0x10F4 the ((bit29==1) && (bit7==1)) OR ((bit29==1) && (bit5==1)), it means the deadlock has occurred.
-				// 3. If the deadlock occurred, reset MAC/BBP by setting 0x1004 to 0x0001 for a while then setting it back to 0x000C again.
+				/* When Adhoc beacon is enabled and RTS/CTS is enabled, there is a chance that hardware MAC FSM will run into a deadlock */
+				/* and sending CTS-to-self over and over. */
+				/* Software Patch Solution: */
+				/* 1. Polling debug state register 0x10F4 every one second. */
+				/* 2. If in 0x10F4 the ((bit29==1) && (bit7==1)) OR ((bit29==1) && (bit5==1)), it means the deadlock has occurred. */
+				/* 3. If the deadlock occurred, reset MAC/BBP by setting 0x1004 to 0x0001 for a while then setting it back to 0x000C again. */
 
 				UINT32 MacReg = 0;
 
@@ -928,13 +928,13 @@ BOOLEAN MlmeValidateSSID(IN PUCHAR pSsid, IN UCHAR SsidLen)
 	if (SsidLen > MAX_LEN_OF_SSID)
 		return (FALSE);
 
-	// Check each character value
+	/* Check each character value */
 	for (index = 0; index < SsidLen; index++) {
 		if (pSsid[index] < 0x20)
 			return (FALSE);
 	}
 
-	// All checked
+	/* All checked */
 	return (TRUE);
 }
 
@@ -944,7 +944,7 @@ VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
 			   IN PUCHAR pTableSize, IN PUCHAR pInitTxRateIdx)
 {
 	do {
-		// decide the rate table for tuning
+		/* decide the rate table for tuning */
 		if (pAd->CommonCfg.TxRateTableSize > 0) {
 			*ppTable = RateSwitchTable;
 			*pTableSize = RateSwitchTable[0];
@@ -954,12 +954,12 @@ VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
 		}
 
 		if ((pAd->OpMode == OPMODE_STA) && ADHOC_ON(pAd)) {
-			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) {	// 11N 1S Adhoc
+			if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) {	/* 11N 1S Adhoc */
 				*ppTable = RateSwitchTable11N1S;
 				*pTableSize = RateSwitchTable11N1S[0];
 				*pInitTxRateIdx = RateSwitchTable11N1S[1];
 
-			} else if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) {	// 11N 2S Adhoc
+			} else if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) {	/* 11N 2S Adhoc */
 				if (pAd->LatchRfRegs.Channel <= 14) {
 					*ppTable = RateSwitchTable11N2S;
 					*pTableSize = RateSwitchTable11N2S[0];
@@ -994,18 +994,18 @@ VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
 			}
 			break;
 		}
-		//if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//      ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
-		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	// 11BGN 1S AP
+		/*if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && */
+		/*      ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) */
+		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	/* 11BGN 1S AP */
 			*ppTable = RateSwitchTable11BGN1S;
 			*pTableSize = RateSwitchTable11BGN1S[0];
 			*pInitTxRateIdx = RateSwitchTable11BGN1S[1];
 
 			break;
 		}
-		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) &&
-		//      (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
-		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	// 11BGN 2S AP
+		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 12) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && */
+		/*      (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) */
+		if (((pEntry->RateLen == 12) || (pAd->OpMode == OPMODE_STA)) && (pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	/* 11BGN 2S AP */
 			if (pAd->LatchRfRegs.Channel <= 14) {
 				*ppTable = RateSwitchTable11BGN2S;
 				*pTableSize = RateSwitchTable11BGN2S[0];
@@ -1020,16 +1020,16 @@ VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
 			}
 			break;
 		}
-		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1)))
-		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	// 11N 1S AP
+		/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && ((pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0x00) || (pAd->Antenna.field.TxPath == 1))) */
+		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && ((pEntry->HTCapability.MCSSet[1] == 0x00) || (pAd->CommonCfg.TxStream == 1))) {	/* 11N 1S AP */
 			*ppTable = RateSwitchTable11N1S;
 			*pTableSize = RateSwitchTable11N1S[0];
 			*pInitTxRateIdx = RateSwitchTable11N1S[1];
 
 			break;
 		}
-		//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2))
-		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	// 11N 2S AP
+		/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0xff) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0xff) && (pAd->Antenna.field.TxPath == 2)) */
+		if ((pEntry->HTCapability.MCSSet[0] == 0xff) && (pEntry->HTCapability.MCSSet[1] == 0xff) && (pAd->CommonCfg.TxStream == 2)) {	/* 11N 2S AP */
 			if (pAd->LatchRfRegs.Channel <= 14) {
 				*ppTable = RateSwitchTable11N2S;
 				*pTableSize = RateSwitchTable11N2S[0];
@@ -1043,33 +1043,33 @@ VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
 
 			break;
 		}
-		//else if ((pAd->StaActive.SupRateLen == 4) && (pAd->StaActive.ExtRateLen == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
+		/*else if ((pAd->StaActive.SupRateLen == 4) && (pAd->StaActive.ExtRateLen == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
 		if ((pEntry->RateLen == 4 || pAd->CommonCfg.PhyMode == PHY_11B)
-		    //Iverson mark for Adhoc b mode,sta will use rate 54  Mbps when connect with sta b/g/n mode
+		    /*Iverson mark for Adhoc b mode,sta will use rate 54  Mbps when connect with sta b/g/n mode */
 		    /* && (pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0) */
-		    ) {		// B only AP
+		    ) {		/* B only AP */
 			*ppTable = RateSwitchTable11B;
 			*pTableSize = RateSwitchTable11B[0];
 			*pInitTxRateIdx = RateSwitchTable11B[1];
 
 			break;
 		}
-		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen > 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
+		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen > 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
 		if ((pEntry->RateLen > 8)
 		    && (pEntry->HTCapability.MCSSet[0] == 0)
 		    && (pEntry->HTCapability.MCSSet[1] == 0)
-		    ) {		// B/G  mixed AP
+		    ) {		/* B/G  mixed AP */
 			*ppTable = RateSwitchTable11BG;
 			*pTableSize = RateSwitchTable11BG[0];
 			*pInitTxRateIdx = RateSwitchTable11BG[1];
 
 			break;
 		}
-		//else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
+		/*else if ((pAd->StaActive.SupRateLen + pAd->StaActive.ExtRateLen == 8) && (pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
 		if ((pEntry->RateLen == 8)
 		    && (pEntry->HTCapability.MCSSet[0] == 0)
 		    && (pEntry->HTCapability.MCSSet[1] == 0)
-		    ) {		// G only AP
+		    ) {		/* G only AP */
 			*ppTable = RateSwitchTable11G;
 			*pTableSize = RateSwitchTable11G[0];
 			*pInitTxRateIdx = RateSwitchTable11G[1];
@@ -1078,8 +1078,8 @@ VOID MlmeSelectTxRateTable(IN PRTMP_ADAPTER pAd,
 		}
 
 		{
-			//else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0))
-			if ((pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)) {	// Legacy mode
+			/*else if ((pAd->StaActive.SupportedPhyInfo.MCSSet[0] == 0) && (pAd->StaActive.SupportedPhyInfo.MCSSet[1] == 0)) */
+			if ((pEntry->HTCapability.MCSSet[0] == 0) && (pEntry->HTCapability.MCSSet[1] == 0)) {	/* Legacy mode */
 				if (pAd->CommonCfg.MaxTxRate <= RATE_11) {
 					*ppTable = RateSwitchTable11B;
 					*pTableSize = RateSwitchTable11B[0];
@@ -1154,11 +1154,11 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 	   that ATE need are not collected via this routine.
 	 */
 #if defined(RT305x)||defined(RT3070)
-	// request by Gary, if Rssi0 > -42, BBP 82 need to be changed from 0x62 to 0x42, , bbp 67 need to be changed from 0x20 to 0x18
+	/* request by Gary, if Rssi0 > -42, BBP 82 need to be changed from 0x62 to 0x42, , bbp 67 need to be changed from 0x20 to 0x18 */
 	if (!pAd->CommonCfg.HighPowerPatchDisabled) {
 #ifdef RT3070
 		if ((IS_RT3070(pAd) && ((pAd->MACVersion & 0xffff) < 0x0201)))
-#endif // RT3070 //
+#endif /* RT3070 // */
 		{
 			if ((pAd->StaCfg.RssiSample.AvgRssi0 != 0)
 			    && (pAd->StaCfg.RssiSample.AvgRssi0 >
@@ -1171,8 +1171,8 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 	}
 #endif
 #ifdef PCIE_PS_SUPPORT
-// don't perform idle-power-save mechanism within 3 min after driver initialization.
-// This can make rebooter test more robust
+/* don't perform idle-power-save mechanism within 3 min after driver initialization. */
+/* This can make rebooter test more robust */
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
 		if ((pAd->OpMode == OPMODE_STA) && (IDLE_ON(pAd))
 		    && (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
@@ -1190,7 +1190,7 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 					AsicSendCommandToMcu(pAd, 0x30,
 							     PowerSafeCID, 0xff,
 							     0x2);
-					// Wait command success
+					/* Wait command success */
 					AsicCheckCommanOk(pAd, PowerSafeCID);
 					RTMP_SET_FLAG(pAd,
 						      fRTMP_ADAPTER_IDLE_RADIO_OFF);
@@ -1209,7 +1209,7 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 					AsicSendCommandToMcu(pAd, 0x30,
 							     PowerSafeCID, 0xff,
 							     0x02);
-					// Wait command success
+					/* Wait command success */
 					AsicCheckCommanOk(pAd, PowerSafeCID);
 					RTMP_SET_FLAG(pAd,
 						      fRTMP_ADAPTER_IDLE_RADIO_OFF);
@@ -1229,10 +1229,10 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 				  pAd->MlmeAux.Ssid[2], pAd->MlmeAux.Ssid[3]));
 		}
 	}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 
 	if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE) {
-		// WPA MIC error should block association attempt for 60 seconds
+		/* WPA MIC error should block association attempt for 60 seconds */
 		if (pAd->StaCfg.bBlockAssoc &&
 		    RTMP_TIME_AFTER(pAd->Mlme.Now32,
 				    pAd->StaCfg.LastMicErrorTime +
@@ -1260,18 +1260,18 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 	    pAd->RalinkCounters.OneSecTxFailCount;
 
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-		// update channel quality for Roaming and UI LinkQuality display
+		/* update channel quality for Roaming and UI LinkQuality display */
 		MlmeCalculateChannelQuality(pAd, NULL, pAd->Mlme.Now32);
 	}
-	// must be AFTER MlmeDynamicTxRateSwitching() because it needs to know if
-	// Radio is currently in noisy environment
+	/* must be AFTER MlmeDynamicTxRateSwitching() because it needs to know if */
+	/* Radio is currently in noisy environment */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
 		AsicAdjustTxPower(pAd);
 
 	if (INFRA_ON(pAd)) {
 
-		// Is PSM bit consistent with user power management policy?
-		// This is the only place that will set PSM bit ON.
+		/* Is PSM bit consistent with user power management policy? */
+		/* This is the only place that will set PSM bit ON. */
 		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 			MlmeCheckPsmChange(pAd, pAd->Mlme.Now32);
 
@@ -1290,18 +1290,18 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 				 ("MMCHK - No BEACON. restore R66 to the low bound(%d) \n",
 				  (0x2E + GET_LNA_GAIN(pAd))));
 		}
-		//if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) &&
-		//    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0))
+		/*if ((pAd->RalinkCounters.OneSecTxNoRetryOkCount == 0) && */
+		/*    (pAd->RalinkCounters.OneSecTxRetryOkCount == 0)) */
 		{
 			if (pAd->CommonCfg.bAPSDCapable
 			    && pAd->CommonCfg.APEdcaParm.bAPSDCapable) {
-				// When APSD is enabled, the period changes as 20 sec
+				/* When APSD is enabled, the period changes as 20 sec */
 				if ((pAd->Mlme.OneSecPeriodicRound % 20) == 8)
 					RTMPSendNullFrame(pAd,
 							  pAd->CommonCfg.TxRate,
 							  TRUE);
 			} else {
-				// Send out a NULL frame every 10 sec to inform AP that STA is still alive (Avoid being age out)
+				/* Send out a NULL frame every 10 sec to inform AP that STA is still alive (Avoid being age out) */
 				if ((pAd->Mlme.OneSecPeriodicRound % 10) == 8) {
 					if (pAd->CommonCfg.bWmmCapable)
 						RTMPSendNullFrame(pAd,
@@ -1323,13 +1323,13 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 				 ("MMCHK - No BEACON. Dead CQI. Auto Recovery attempt #%ld\n",
 				  pAd->RalinkCounters.BadCQIAutoRecoveryCount));
 
-			// Lost AP, send disconnect & link down event
+			/* Lost AP, send disconnect & link down event */
 			LinkDown(pAd, FALSE);
 
 			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
 						0);
 
-			// RTMPPatchMacBbpBug(pAd);
+			/* RTMPPatchMacBbpBug(pAd); */
 			MlmeAutoReconnectLastSSID(pAd);
 		} else if (CQI_IS_BAD(pAd->Mlme.ChannelQuality)) {
 			pAd->RalinkCounters.BadCQIAutoRecoveryCount++;
@@ -1350,7 +1350,7 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 						   pAd->StaCfg.RssiSample.
 						   LastRssi2);
 
-			// Scanning, ignore Roaming
+			/* Scanning, ignore Roaming */
 			if (!RTMP_TEST_FLAG
 			    (pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)
 			    && (pAd->Mlme.SyncMachine.CurrState == SYNC_IDLE)
@@ -1359,7 +1359,7 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 					 ("Rssi=%d, dBmToRoam=%d\n", MaxRssi,
 					  (CHAR) dBmToRoam));
 
-				// Add auto seamless roaming
+				/* Add auto seamless roaming */
 				if (rv == FALSE)
 					rv = MlmeCheckForFastRoaming(pAd);
 
@@ -1377,9 +1377,9 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 			}
 		}
 	} else if (ADHOC_ON(pAd)) {
-		// If all peers leave, and this STA becomes the last one in this IBSS, then change MediaState
-		// to DISCONNECTED. But still holding this IBSS (i.e. sending BEACON) so that other STAs can
-		// join later.
+		/* If all peers leave, and this STA becomes the last one in this IBSS, then change MediaState */
+		/* to DISCONNECTED. But still holding this IBSS (i.e. sending BEACON) so that other STAs can */
+		/* join later. */
 		if (RTMP_TIME_AFTER
 		    (pAd->Mlme.Now32,
 		     pAd->StaCfg.LastBeaconRxTime + ADHOC_BEACON_LOST_TIME)
@@ -1411,7 +1411,7 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 				MacTableDeleteEntry(pAd, pEntry->Aid,
 						    pEntry->Addr);
 		}
-	} else			// no INFRA nor ADHOC connection
+	} else			/* no INFRA nor ADHOC connection */
 	{
 
 		if (pAd->StaCfg.bScanReqIsFromWebUI &&
@@ -1451,10 +1451,10 @@ VOID STAMlmePeriodicExec(PRTMP_ADAPTER pAd)
 						    &ScanReq);
 					pAd->Mlme.CntlMachine.CurrState =
 					    CNTL_WAIT_OID_LIST_SCAN;
-					// Reset Missed scan number
+					/* Reset Missed scan number */
 					pAd->StaCfg.LastScanTime =
 					    pAd->Mlme.Now32;
-				} else if (pAd->StaCfg.BssType == BSS_ADHOC)	// Quit the forever scan when in a very clean room
+				} else if (pAd->StaCfg.BssType == BSS_ADHOC)	/* Quit the forever scan when in a very clean room */
 					MlmeAutoReconnectLastSSID(pAd);
 			} else if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
 				if ((pAd->Mlme.OneSecPeriodicRound % 7) == 0) {
@@ -1486,7 +1486,7 @@ SKIP_AUTO_SCAN_CONN:
 	return;
 }
 
-// Link down report
+/* Link down report */
 VOID LinkDownExec(IN PVOID SystemSpecific1,
 		  IN PVOID FunctionContext,
 		  IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
@@ -1516,10 +1516,10 @@ VOID LinkDownExec(IN PVOID SystemSpecific1,
 	}
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID MlmeAutoScan(IN PRTMP_ADAPTER pAd)
 {
-	// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+	/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
 	if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
 		DBGPRINT(RT_DEBUG_TRACE, ("MMCHK - Driver auto scan\n"));
 		MlmeEnqueue(pAd,
@@ -1531,7 +1531,7 @@ VOID MlmeAutoScan(IN PRTMP_ADAPTER pAd)
 	}
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID MlmeAutoReconnectLastSSID(IN PRTMP_ADAPTER pAd)
 {
 	if (pAd->StaCfg.bAutoConnectByBssid) {
@@ -1550,7 +1550,7 @@ VOID MlmeAutoReconnectLastSSID(IN PRTMP_ADAPTER pAd)
 
 		RTMP_MLME_HANDLER(pAd);
 	}
-	// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+	/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
 	else if ((pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
 		 (MlmeValidateSSID
 		  (pAd->MlmeAux.AutoReconnectSsid,
@@ -1589,30 +1589,30 @@ VOID MlmeCheckForRoaming(IN PRTMP_ADAPTER pAd, IN ULONG Now32)
 	BSS_ENTRY *pBss;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeCheckForRoaming\n"));
-	// put all roaming candidates into RoamTab, and sort in RSSI order
+	/* put all roaming candidates into RoamTab, and sort in RSSI order */
 	BssTableInit(pRoamTab);
 	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
 		pBss = &pAd->ScanTab.BssEntry[i];
 
 		if ((pBss->LastBeaconRxTime + pAd->StaCfg.BeaconLostTime) <
 		    Now32)
-			continue;	// AP disappear
+			continue;	/* AP disappear */
 		if (pBss->Rssi <= RSSI_THRESHOLD_FOR_ROAMING)
-			continue;	// RSSI too weak. forget it.
+			continue;	/* RSSI too weak. forget it. */
 		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
-			continue;	// skip current AP
+			continue;	/* skip current AP */
 		if (pBss->Rssi <
 		    (pAd->StaCfg.RssiSample.LastRssi0 + RSSI_DELTA))
-			continue;	// only AP with stronger RSSI is eligible for roaming
+			continue;	/* only AP with stronger RSSI is eligible for roaming */
 
-		// AP passing all above rules is put into roaming candidate table
+		/* AP passing all above rules is put into roaming candidate table */
 		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss,
 			       sizeof(BSS_ENTRY));
 		pRoamTab->BssNr += 1;
 	}
 
 	if (pRoamTab->BssNr > 0) {
-		// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+		/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
 		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
 			pAd->RalinkCounters.PoorCQIRoamingCount++;
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -1647,26 +1647,26 @@ BOOLEAN MlmeCheckForFastRoaming(IN PRTMP_ADAPTER pAd)
 	BSS_ENTRY *pBss;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> MlmeCheckForFastRoaming\n"));
-	// put all roaming candidates into RoamTab, and sort in RSSI order
+	/* put all roaming candidates into RoamTab, and sort in RSSI order */
 	BssTableInit(pRoamTab);
 	for (i = 0; i < pAd->ScanTab.BssNr; i++) {
 		pBss = &pAd->ScanTab.BssEntry[i];
 
 		if ((pBss->Rssi <= -50)
 		    && (pBss->Channel == pAd->CommonCfg.Channel))
-			continue;	// RSSI too weak. forget it.
+			continue;	/* RSSI too weak. forget it. */
 		if (MAC_ADDR_EQUAL(pBss->Bssid, pAd->CommonCfg.Bssid))
-			continue;	// skip current AP
+			continue;	/* skip current AP */
 		if (!SSID_EQUAL
 		    (pBss->Ssid, pBss->SsidLen, pAd->CommonCfg.Ssid,
 		     pAd->CommonCfg.SsidLen))
-			continue;	// skip different SSID
+			continue;	/* skip different SSID */
 		if (pBss->Rssi <
 		    (RTMPMaxRssi
 		     (pAd, pAd->StaCfg.RssiSample.LastRssi0,
 		      pAd->StaCfg.RssiSample.LastRssi1,
 		      pAd->StaCfg.RssiSample.LastRssi2) + RSSI_DELTA))
-			continue;	// skip AP without better RSSI
+			continue;	/* skip AP without better RSSI */
 
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("LastRssi0 = %d, pBss->Rssi = %d\n",
@@ -1674,7 +1674,7 @@ BOOLEAN MlmeCheckForFastRoaming(IN PRTMP_ADAPTER pAd)
 				      pAd->StaCfg.RssiSample.LastRssi1,
 				      pAd->StaCfg.RssiSample.LastRssi2),
 			  pBss->Rssi));
-		// AP passing all above rules is put into roaming candidate table
+		/* AP passing all above rules is put into roaming candidate table */
 		NdisMoveMemory(&pRoamTab->BssEntry[pRoamTab->BssNr], pBss,
 			       sizeof(BSS_ENTRY));
 		pRoamTab->BssNr += 1;
@@ -1683,7 +1683,7 @@ BOOLEAN MlmeCheckForFastRoaming(IN PRTMP_ADAPTER pAd)
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("<== MlmeCheckForFastRoaming (BssNr=%d)\n", pRoamTab->BssNr));
 	if (pRoamTab->BssNr > 0) {
-		// check CntlMachine.CurrState to avoid collision with NDIS SetOID request
+		/* check CntlMachine.CurrState to avoid collision with NDIS SetOID request */
 		if (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) {
 			pAd->RalinkCounters.PoorCQIRoamingCount++;
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -1719,19 +1719,19 @@ VOID MlmeSetTxRate(IN PRTMP_ADAPTER pAd,
 		pAd->StaCfg.HTPhyMode.field.STBC = STBC_NONE;
 
 	if (ADHOC_ON(pAd)) {
-		// If peer adhoc is b-only mode, we can't send 11g rate.
+		/* If peer adhoc is b-only mode, we can't send 11g rate. */
 		pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
 		pEntry->HTPhyMode.field.STBC = STBC_NONE;
 
-		//
-		// For Adhoc MODE_CCK, driver will use AdhocBOnlyJoined flag to roll back to B only if necessary
-		//
+		/* */
+		/* For Adhoc MODE_CCK, driver will use AdhocBOnlyJoined flag to roll back to B only if necessary */
+		/* */
 		pEntry->HTPhyMode.field.MODE = pTxRate->Mode;
 		pEntry->HTPhyMode.field.ShortGI =
 		    pAd->StaCfg.HTPhyMode.field.ShortGI;
 		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
 
-		// Patch speed error in status page
+		/* Patch speed error in status page */
 		pAd->StaCfg.HTPhyMode.field.MODE = pEntry->HTPhyMode.field.MODE;
 	} else {
 		if (pTxRate->Mode <= MaxMode)
@@ -1743,7 +1743,7 @@ VOID MlmeSetTxRate(IN PRTMP_ADAPTER pAd,
 		else
 			pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
 
-		// Reexam each bandwidth's SGI support.
+		/* Reexam each bandwidth's SGI support. */
 		if (pAd->StaCfg.HTPhyMode.field.ShortGI == GI_400) {
 			if ((pEntry->HTPhyMode.field.BW == BW_20)
 			    &&
@@ -1756,7 +1756,7 @@ VOID MlmeSetTxRate(IN PRTMP_ADAPTER pAd,
 			     (pEntry, fCLIENT_STATUS_SGI40_CAPABLE)))
 				pAd->StaCfg.HTPhyMode.field.ShortGI = GI_800;
 		}
-		// Turn RTS/CTS rate to 6Mbps.
+		/* Turn RTS/CTS rate to 6Mbps. */
 		if ((pEntry->HTPhyMode.field.MCS == 0)
 		    && (pAd->StaCfg.HTPhyMode.field.MCS != 0)) {
 			pEntry->HTPhyMode.field.MCS =
@@ -1857,13 +1857,13 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 	MAC_TABLE_ENTRY *pEntry;
 	RSSI_SAMPLE *pRssi = &pAd->StaCfg.RssiSample;
 
-	//
-	// walk through MAC table, see if need to change AP's TX rate toward each entry
-	//
+	/* */
+	/* walk through MAC table, see if need to change AP's TX rate toward each entry */
+	/* */
 	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 		pEntry = &pAd->MacTab.Content[i];
 
-		// check if this entry need to switch rate automatically
+		/* check if this entry need to switch rate automatically */
 		if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pEntry) == FALSE)
 			continue;
 
@@ -1872,7 +1872,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 					   pRssi->AvgRssi0,
 					   pRssi->AvgRssi1, pRssi->AvgRssi2);
 
-			// Update statistic counter
+			/* Update statistic counter */
 			RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
 			RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
 			pAd->bUpdateBcnCntDone = TRUE;
@@ -1894,9 +1894,9 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 			pAd->WlanCounters.FailedCount.u.LowPart +=
 			    TxStaCnt0.field.TxFailCount;
 
-			// if no traffic in the past 1-sec period, don't change TX rate,
-			// but clear all bad history. because the bad history may affect the next
-			// Chariot throughput test
+			/* if no traffic in the past 1-sec period, don't change TX rate, */
+			/* but clear all bad history. because the bad history may affect the next */
+			/* Chariot throughput test */
 			AccuTxTotalCnt =
 			    pAd->RalinkCounters.OneSecTxNoRetryOkCount +
 			    pAd->RalinkCounters.OneSecTxRetryOkCount +
@@ -1979,27 +1979,27 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 		if (CurrRateIdx >= TableSize) {
 			CurrRateIdx = TableSize - 1;
 		}
-		// When switch from Fixed rate -> auto rate, the REAL TX rate might be different from pAd->CommonCfg.TxRateIndex.
-		// So need to sync here.
+		/* When switch from Fixed rate -> auto rate, the REAL TX rate might be different from pAd->CommonCfg.TxRateIndex. */
+		/* So need to sync here. */
 		pCurrTxRate =
 		    (PRTMP_TX_RATE_SWITCH) & pTable[(CurrRateIdx + 1) * 5];
 		if ((pEntry->HTPhyMode.field.MCS != pCurrTxRate->CurrMCS)
-		    //&& (pAd->StaCfg.bAutoTxRateSwitch == TRUE)
+		    /*&& (pAd->StaCfg.bAutoTxRateSwitch == TRUE) */
 		    ) {
 
-			// Need to sync Real Tx rate and our record.
-			// Then return for next DRS.
+			/* Need to sync Real Tx rate and our record. */
+			/* Then return for next DRS. */
 			pCurrTxRate =
 			    (PRTMP_TX_RATE_SWITCH) & pTable[(InitTxRateIdx + 1)
 							    * 5];
 			pEntry->CurrTxRateIndex = InitTxRateIdx;
 			MlmeSetTxRate(pAd, pEntry, pCurrTxRate);
 
-			// reset all OneSecTx counters
+			/* reset all OneSecTx counters */
 			RESET_ONE_SEC_TX_CNT(pEntry);
 			continue;
 		}
-		// decide the next upgrade rate and downgrade rate, if any
+		/* decide the next upgrade rate and downgrade rate, if any */
 		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1))) {
 			UpRateIdx = CurrRateIdx + 1;
 			DownRateIdx = CurrRateIdx - 1;
@@ -2026,27 +2026,27 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 			TrainDown = pCurrTxRate->TrainDown;
 		}
 
-		//pAd->DrsCounters.LastTimeTxRateChangeAction = pAd->DrsCounters.LastSecTxRateChangeAction;
+		/*pAd->DrsCounters.LastTimeTxRateChangeAction = pAd->DrsCounters.LastSecTxRateChangeAction; */
 
-		//
-		// Keep the last time TxRateChangeAction status.
-		//
+		/* */
+		/* Keep the last time TxRateChangeAction status. */
+		/* */
 		pEntry->LastTimeTxRateChangeAction =
 		    pEntry->LastSecTxRateChangeAction;
 
-		//
-		// CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI
-		//         (criteria copied from RT2500 for Netopia case)
-		//
+		/* */
+		/* CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI */
+		/*         (criteria copied from RT2500 for Netopia case) */
+		/* */
 		if (TxTotalCnt <= 15) {
 			CHAR idx = 0;
 			UCHAR TxRateIdx;
 			UCHAR MCS0 = 0, MCS1 = 0, MCS2 = 0, MCS3 = 0, MCS4 =
 			    0, MCS5 = 0, MCS6 = 0, MCS7 = 0;
 			UCHAR MCS12 = 0, MCS13 = 0, MCS14 = 0, MCS15 = 0;
-			UCHAR MCS20 = 0, MCS21 = 0, MCS22 = 0, MCS23 = 0;	// 3*3
+			UCHAR MCS20 = 0, MCS21 = 0, MCS22 = 0, MCS23 = 0;	/* 3*3 */
 
-			// check the existence and index of each needed MCS
+			/* check the existence and index of each needed MCS */
 			while (idx < pTable[0]) {
 				pCurrTxRate =
 				    (PRTMP_TX_RATE_SWITCH) & pTable[(idx + 1) *
@@ -2067,8 +2067,8 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 				} else if (pCurrTxRate->CurrMCS == MCS_6) {
 					MCS6 = idx;
 				}
-				//else if (pCurrTxRate->CurrMCS == MCS_7)
-				else if ((pCurrTxRate->CurrMCS == MCS_7) && (pCurrTxRate->ShortGI == GI_800))	// prevent the highest MCS using short GI when 1T and low throughput
+				/*else if (pCurrTxRate->CurrMCS == MCS_7) */
+				else if ((pCurrTxRate->CurrMCS == MCS_7) && (pCurrTxRate->ShortGI == GI_800))	/* prevent the highest MCS using short GI when 1T and low throughput */
 				{
 					MCS7 = idx;
 				} else if (pCurrTxRate->CurrMCS == MCS_12) {
@@ -2078,11 +2078,10 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 				} else if (pCurrTxRate->CurrMCS == MCS_14) {
 					MCS14 = idx;
 				}
-				//else if ((pCurrTxRate->CurrMCS == MCS_15)/* && (pCurrTxRate->ShortGI == GI_800)*/)    //we hope to use ShortGI as initial rate
-				else if ((pCurrTxRate->CurrMCS == MCS_15) && (pCurrTxRate->ShortGI == GI_800))	//we hope to use ShortGI as initial rate, however Atheros's chip has bugs when short GI
+				else if ((pCurrTxRate->CurrMCS == MCS_15) && (pCurrTxRate->ShortGI == GI_800))	/*we hope to use ShortGI as initial rate, however Atheros's chip has bugs when short GI */
 				{
 					MCS15 = idx;
-				} else if (pCurrTxRate->CurrMCS == MCS_20)	// 3*3
+				} else if (pCurrTxRate->CurrMCS == MCS_20)	/* 3*3 */
 				{
 					MCS20 = idx;
 				} else if (pCurrTxRate->CurrMCS == MCS_21) {
@@ -2110,7 +2109,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 			}
 
 			/*if (MCS15) */
-			if ((pTable == RateSwitchTable11BGN3S) || (pTable == RateSwitchTable11N3S) || (pTable == RateSwitchTable)) {	// N mode with 3 stream // 3*3
+			if ((pTable == RateSwitchTable11BGN3S) || (pTable == RateSwitchTable11N3S) || (pTable == RateSwitchTable)) {	/* N mode with 3 stream // 3*3 */
 				if (MCS23 && (Rssi >= -70))
 					TxRateIdx = MCS23;
 				else if (MCS22 && (Rssi >= -72))
@@ -2130,9 +2129,9 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 				else
 					TxRateIdx = MCS0;
 			}
-//              else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand) || (pTable == RateSwitchTable))
-			else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) || (pTable == RateSwitchTable11N2S) || (pTable == RateSwitchTable11N2SForABand))	// 3*3
-			{	// N mode with 2 stream
+/*              else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) ||(pTable == RateSwitchTable11N2S) ||(pTable == RateSwitchTable11N2SForABand) || (pTable == RateSwitchTable)) */
+			else if ((pTable == RateSwitchTable11BGN2S) || (pTable == RateSwitchTable11BGN2SForABand) || (pTable == RateSwitchTable11N2S) || (pTable == RateSwitchTable11N2SForABand))	/* 3*3 */
+			{	/* N mode with 2 stream */
 				if (MCS15 && (Rssi >= (-70 + RssiOffset)))
 					TxRateIdx = MCS15;
 				else if (MCS14 && (Rssi >= (-72 + RssiOffset)))
@@ -2151,7 +2150,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 					TxRateIdx = MCS1;
 				else
 					TxRateIdx = MCS0;
-			} else if ((pTable == RateSwitchTable11BGN1S) || (pTable == RateSwitchTable11N1S)) {	// N mode with 1 stream
+			} else if ((pTable == RateSwitchTable11BGN1S) || (pTable == RateSwitchTable11N1S)) {	/* N mode with 1 stream */
 				if (MCS7 && (Rssi > (-72 + RssiOffset)))
 					TxRateIdx = MCS7;
 				else if (MCS6 && (Rssi > (-74 + RssiOffset)))
@@ -2168,7 +2167,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 					TxRateIdx = MCS1;
 				else
 					TxRateIdx = MCS0;
-			} else {	// Legacy mode
+			} else {	/* Legacy mode */
 				if (MCS7 && (Rssi > -70))
 					TxRateIdx = MCS7;
 				else if (MCS6 && (Rssi > -74))
@@ -2177,7 +2176,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 					TxRateIdx = MCS5;
 				else if (MCS4 && (Rssi > -82))
 					TxRateIdx = MCS4;
-				else if (MCS4 == 0)	// for B-only mode
+				else if (MCS4 == 0)	/* for B-only mode */
 					TxRateIdx = MCS3;
 				else if (MCS3 && (Rssi > -85))
 					TxRateIdx = MCS3;
@@ -2189,7 +2188,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 					TxRateIdx = MCS0;
 			}
 
-			//              if (TxRateIdx != pAd->CommonCfg.TxRateIndex)
+			/*              if (TxRateIdx != pAd->CommonCfg.TxRateIndex) */
 			{
 				pEntry->CurrTxRateIndex = TxRateIdx;
 				pNextTxRate =
@@ -2205,7 +2204,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 				       sizeof(UCHAR) *
 				       MAX_STEP_OF_TX_RATE_SWITCH);
 			pEntry->fLastSecAccordingRSSI = TRUE;
-			// reset all OneSecTx counters
+			/* reset all OneSecTx counters */
 			RESET_ONE_SEC_TX_CNT(pEntry);
 
 			continue;
@@ -2214,7 +2213,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 		if (pEntry->fLastSecAccordingRSSI == TRUE) {
 			pEntry->fLastSecAccordingRSSI = FALSE;
 			pEntry->LastSecTxRateChangeAction = 0;
-			// reset all OneSecTx counters
+			/* reset all OneSecTx counters */
 			RESET_ONE_SEC_TX_CNT(pEntry);
 
 			continue;
@@ -2225,29 +2224,29 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 
 			pEntry->CurrTxRateStableTime++;
 
-			// downgrade TX quality if PER >= Rate-Down threshold
+			/* downgrade TX quality if PER >= Rate-Down threshold */
 			if (TxErrorRatio >= TrainDown) {
 				bTrainUpDown = TRUE;
 				pEntry->TxQuality[CurrRateIdx] =
 				    DRS_TX_QUALITY_WORST_BOUND;
 			}
-			// upgrade TX quality if PER <= Rate-Up threshold
+			/* upgrade TX quality if PER <= Rate-Up threshold */
 			else if (TxErrorRatio <= TrainUp) {
 				bTrainUpDown = TRUE;
 				bUpgradeQuality = TRUE;
 				if (pEntry->TxQuality[CurrRateIdx])
-					pEntry->TxQuality[CurrRateIdx]--;	// quality very good in CurrRate
+					pEntry->TxQuality[CurrRateIdx]--;	/* quality very good in CurrRate */
 
 				if (pEntry->TxRateUpPenalty)
 					pEntry->TxRateUpPenalty--;
 				else if (pEntry->TxQuality[UpRateIdx])
-					pEntry->TxQuality[UpRateIdx]--;	// may improve next UP rate's quality
+					pEntry->TxQuality[UpRateIdx]--;	/* may improve next UP rate's quality */
 			}
 
 			pEntry->PER[CurrRateIdx] = (UCHAR) TxErrorRatio;
 
 			if (bTrainUpDown) {
-				// perform DRS - consider TxRate Down first, then rate up.
+				/* perform DRS - consider TxRate Down first, then rate up. */
 				if ((CurrRateIdx != DownRateIdx)
 				    && (pEntry->TxQuality[CurrRateIdx] >=
 					DRS_TX_QUALITY_WORST_BOUND)) {
@@ -2260,11 +2259,11 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 			}
 		} while (FALSE);
 
-		// if rate-up happen, clear all bad history of all TX rates
+		/* if rate-up happen, clear all bad history of all TX rates */
 		if (pEntry->CurrTxRateIndex > CurrRateIdx) {
 			pEntry->CurrTxRateStableTime = 0;
 			pEntry->TxRateUpPenalty = 0;
-			pEntry->LastSecTxRateChangeAction = 1;	// rate UP
+			pEntry->LastSecTxRateChangeAction = 1;	/* rate UP */
 			NdisZeroMemory(pEntry->TxQuality,
 				       sizeof(USHORT) *
 				       MAX_STEP_OF_TX_RATE_SWITCH);
@@ -2272,9 +2271,9 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 				       sizeof(UCHAR) *
 				       MAX_STEP_OF_TX_RATE_SWITCH);
 
-			//
-			// For TxRate fast train up
-			//
+			/* */
+			/* For TxRate fast train up */
+			/* */
 			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning) {
 				RTMPSetTimer(&pAd->StaCfg.
 					     StaQuickResponeForRateUpTimer,
@@ -2285,17 +2284,17 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 			}
 			bTxRateChanged = TRUE;
 		}
-		// if rate-down happen, only clear DownRate's bad history
+		/* if rate-down happen, only clear DownRate's bad history */
 		else if (pEntry->CurrTxRateIndex < CurrRateIdx) {
 			pEntry->CurrTxRateStableTime = 0;
-			pEntry->TxRateUpPenalty = 0;	// no penalty
-			pEntry->LastSecTxRateChangeAction = 2;	// rate DOWN
+			pEntry->TxRateUpPenalty = 0;	/* no penalty */
+			pEntry->LastSecTxRateChangeAction = 2;	/* rate DOWN */
 			pEntry->TxQuality[pEntry->CurrTxRateIndex] = 0;
 			pEntry->PER[pEntry->CurrTxRateIndex] = 0;
 
-			//
-			// For TxRate fast train down
-			//
+			/* */
+			/* For TxRate fast train down */
+			/* */
 			if (!pAd->StaCfg.StaQuickResponeForRateUpTimerRunning) {
 				RTMPSetTimer(&pAd->StaCfg.
 					     StaQuickResponeForRateUpTimer,
@@ -2306,7 +2305,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 			}
 			bTxRateChanged = TRUE;
 		} else {
-			pEntry->LastSecTxRateChangeAction = 0;	// rate no change
+			pEntry->LastSecTxRateChangeAction = 0;	/* rate no change */
 			bTxRateChanged = FALSE;
 		}
 
@@ -2314,7 +2313,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 		{
 			UCHAR tmpTxRate;
 
-			// to fix tcp ack issue
+			/* to fix tcp ack issue */
 			if (!bTxRateChanged
 			    && (pAd->RalinkCounters.OneSecReceivedByteCount >
 				(pAd->RalinkCounters.
@@ -2339,7 +2338,7 @@ VOID MlmeDynamicTxRateSwitching(IN PRTMP_ADAPTER pAd)
 		if (bTxRateChanged && pNextTxRate) {
 			MlmeSetTxRate(pAd, pEntry, pNextTxRate);
 		}
-		// reset all OneSecTx counters
+		/* reset all OneSecTx counters */
 		RESET_ONE_SEC_TX_CNT(pEntry);
 	}
 }
@@ -2369,7 +2368,7 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 	UCHAR UpRateIdx = 0, DownRateIdx = 0, CurrRateIdx = 0;
 	ULONG TxTotalCnt;
 	ULONG TxErrorRatio = 0;
-	BOOLEAN bTxRateChanged;	//, bUpgradeQuality = FALSE;
+	BOOLEAN bTxRateChanged;	/*, bUpgradeQuality = FALSE; */
 	PRTMP_TX_RATE_SWITCH pCurrTxRate, pNextTxRate = NULL;
 	PUCHAR pTable;
 	UCHAR TableSize = 0;
@@ -2383,13 +2382,13 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 
 	pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
 
-	//
-	// walk through MAC table, see if need to change AP's TX rate toward each entry
-	//
+	/* */
+	/* walk through MAC table, see if need to change AP's TX rate toward each entry */
+	/* */
 	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 		pEntry = &pAd->MacTab.Content[i];
 
-		// check if this entry need to switch rate automatically
+		/* check if this entry need to switch rate automatically */
 		if (RTMPCheckEntryEnableAutoRateSwitch(pAd, pEntry) == FALSE)
 			continue;
 
@@ -2409,7 +2408,7 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize,
 				      &InitTxRateIdx);
 
-		// decide the next upgrade rate and downgrade rate, if any
+		/* decide the next upgrade rate and downgrade rate, if any */
 		if ((CurrRateIdx > 0) && (CurrRateIdx < (TableSize - 1))) {
 			UpRateIdx = CurrRateIdx + 1;
 			DownRateIdx = CurrRateIdx - 1;
@@ -2437,7 +2436,7 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 		}
 
 		if (pAd->MacTab.Size == 1) {
-			// Update statistic counter
+			/* Update statistic counter */
 			RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
 			RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
 
@@ -2475,10 +2474,10 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 				    TxTotalCnt;
 		}
 
-		//
-		// CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI
-		//         (criteria copied from RT2500 for Netopia case)
-		//
+		/* */
+		/* CASE 1. when TX samples are fewer than 15, then decide TX rate solely on RSSI */
+		/*         (criteria copied from RT2500 for Netopia case) */
+		/* */
 		if (TxTotalCnt <= 12) {
 			NdisZeroMemory(pAd->DrsCounters.TxQuality,
 				       sizeof(USHORT) *
@@ -2511,7 +2510,7 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 			else
 				ratio = 4;
 
-			// downgrade TX quality if PER >= Rate-Down threshold
+			/* downgrade TX quality if PER >= Rate-Down threshold */
 			if (TxErrorRatio >= TrainDown) {
 				pAd->DrsCounters.TxQuality[CurrRateIdx] =
 				    DRS_TX_QUALITY_WORST_BOUND;
@@ -2522,7 +2521,7 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 
 			OneSecTxNoRetryOKRationCount = (TxSuccess * ratio);
 
-			// perform DRS - consider TxRate Down first, then rate up.
+			/* perform DRS - consider TxRate Down first, then rate up. */
 			if ((pAd->DrsCounters.LastSecTxRateChangeAction == 1)
 			    && (CurrRateIdx != DownRateIdx)) {
 				if ((pAd->DrsCounters.LastTxOkCount + 2) >=
@@ -2548,7 +2547,7 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 			}
 		} while (FALSE);
 
-		// if rate-up happen, clear all bad history of all TX rates
+		/* if rate-up happen, clear all bad history of all TX rates */
 		if (pAd->CommonCfg.TxRateIndex > CurrRateIdx) {
 			pAd->DrsCounters.TxRateUpPenalty = 0;
 			NdisZeroMemory(pAd->DrsCounters.TxQuality,
@@ -2559,13 +2558,13 @@ VOID StaQuickResponeForRateUpExec(IN PVOID SystemSpecific1,
 				       MAX_STEP_OF_TX_RATE_SWITCH);
 			bTxRateChanged = TRUE;
 		}
-		// if rate-down happen, only clear DownRate's bad history
+		/* if rate-down happen, only clear DownRate's bad history */
 		else if (pAd->CommonCfg.TxRateIndex < CurrRateIdx) {
 			DBGPRINT_RAW(RT_DEBUG_TRACE,
 				     ("QuickDRS: --TX rate from %d to %d \n",
 				      CurrRateIdx, pAd->CommonCfg.TxRateIndex));
 
-			pAd->DrsCounters.TxRateUpPenalty = 0;	// no penalty
+			pAd->DrsCounters.TxRateUpPenalty = 0;	/* no penalty */
 			pAd->DrsCounters.TxQuality[pAd->CommonCfg.TxRateIndex] =
 			    0;
 			pAd->DrsCounters.PER[pAd->CommonCfg.TxRateIndex] = 0;
@@ -2606,18 +2605,18 @@ VOID MlmeCheckPsmChange(IN PRTMP_ADAPTER pAd, IN ULONG Now32)
 {
 	ULONG PowerMode;
 
-	// condition -
-	// 1. Psm maybe ON only happen in INFRASTRUCTURE mode
-	// 2. user wants either MAX_PSP or FAST_PSP
-	// 3. but current psm is not in PWR_SAVE
-	// 4. CNTL state machine is not doing SCANning
-	// 5. no TX SUCCESS event for the past 1-sec period
+	/* condition - */
+	/* 1. Psm maybe ON only happen in INFRASTRUCTURE mode */
+	/* 2. user wants either MAX_PSP or FAST_PSP */
+	/* 3. but current psm is not in PWR_SAVE */
+	/* 4. CNTL state machine is not doing SCANning */
+	/* 5. no TX SUCCESS event for the past 1-sec period */
 	PowerMode = pAd->StaCfg.WindowsPowerMode;
 
 	if (INFRA_ON(pAd) &&
 	    (PowerMode != Ndis802_11PowerModeCAM) &&
 	    (pAd->StaCfg.Psm == PWR_ACTIVE) &&
-//              (! RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS))
+/*              (! RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS)) */
 	    (pAd->Mlme.CntlMachine.CurrState == CNTL_IDLE) &&
 	    RTMP_TEST_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP)
 	    /*&&
@@ -2637,8 +2636,8 @@ VOID MlmeCheckPsmChange(IN PRTMP_ADAPTER pAd, IN ULONG Now32)
 	}
 }
 
-// IRQL = PASSIVE_LEVEL
-// IRQL = DISPATCH_LEVEL
+/* IRQL = PASSIVE_LEVEL */
+/* IRQL = DISPATCH_LEVEL */
 VOID MlmeSetPsmBit(IN PRTMP_ADAPTER pAd, IN USHORT psm)
 {
 	AUTO_RSP_CFG_STRUC csr4;
@@ -2683,7 +2682,7 @@ VOID MlmeCalculateChannelQuality(IN PRTMP_ADAPTER pAd,
 	UINT32 OneSecTxFailCount = 0;
 	UINT32 OneSecRxOkCnt = 0;
 	UINT32 OneSecRxFcsErrCnt = 0;
-	ULONG ChannelQuality = 0;	// 0..100, Channel Quality Indication for Roaming
+	ULONG ChannelQuality = 0;	/* 0..100, Channel Quality Indication for Roaming */
 	ULONG BeaconLostTime = pAd->StaCfg.BeaconLostTime;
 
 	if (pAd->OpMode == OPMODE_STA) {
@@ -2699,9 +2698,9 @@ VOID MlmeCalculateChannelQuality(IN PRTMP_ADAPTER pAd,
 	MaxRssi = RTMPMaxRssi(pAd, pRssiSample->LastRssi0,
 			      pRssiSample->LastRssi1, pRssiSample->LastRssi2);
 
-	//
-	// calculate TX packet error ratio and TX retry ratio - if too few TX samples, skip TX related statistics
-	//
+	/* */
+	/* calculate TX packet error ratio and TX retry ratio - if too few TX samples, skip TX related statistics */
+	/* */
 	TxOkCnt = OneSecTxNoRetryOkCount + OneSecTxRetryOkCount;
 	TxCnt = TxOkCnt + OneSecTxFailCount;
 	if (TxCnt < 5) {
@@ -2712,26 +2711,26 @@ VOID MlmeCalculateChannelQuality(IN PRTMP_ADAPTER pAd,
 		TxPRR = ((TxCnt - OneSecTxNoRetryOkCount) * 100) / TxCnt;
 	}
 
-	//
-	// calculate RX PER - don't take RxPER into consideration if too few sample
-	//
+	/* */
+	/* calculate RX PER - don't take RxPER into consideration if too few sample */
+	/* */
 	RxCnt = OneSecRxOkCnt + OneSecRxFcsErrCnt;
 	if (RxCnt < 5)
 		RxPER = 0;
 	else
 		RxPER = (OneSecRxFcsErrCnt * 100) / RxCnt;
 
-	//
-	// decide ChannelQuality based on: 1)last BEACON received time, 2)last RSSI, 3)TxPER, and 4)RxPER
-	//
-	if ((pAd->OpMode == OPMODE_STA) && INFRA_ON(pAd) && (OneSecTxNoRetryOkCount < 2) &&	// no heavy traffic
+	/* */
+	/* decide ChannelQuality based on: 1)last BEACON received time, 2)last RSSI, 3)TxPER, and 4)RxPER */
+	/* */
+	if ((pAd->OpMode == OPMODE_STA) && INFRA_ON(pAd) && (OneSecTxNoRetryOkCount < 2) &&	/* no heavy traffic */
 	    ((pAd->StaCfg.LastBeaconRxTime + BeaconLostTime) < Now32)) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("BEACON lost > %ld msec with TxOkCnt=%ld -> CQI=0\n",
 			  BeaconLostTime, TxOkCnt));
 		ChannelQuality = 0;
 	} else {
-		// Normalize Rssi
+		/* Normalize Rssi */
 		if (MaxRssi > -40)
 			NorRssi = 100;
 		else if (MaxRssi < -90)
@@ -2739,7 +2738,7 @@ VOID MlmeCalculateChannelQuality(IN PRTMP_ADAPTER pAd,
 		else
 			NorRssi = (MaxRssi + 90) * 2;
 
-		// ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER        (RSSI 0..100), (TxPER 100..0), (RxPER 100..0)
+		/* ChannelQuality = W1*RSSI + W2*TxPRR + W3*RxPER        (RSSI 0..100), (TxPER 100..0), (RxPER 100..0) */
 		ChannelQuality = (RSSI_WEIGHTING * NorRssi +
 				  TX_WEIGHTING * (100 - TxPRR) +
 				  RX_WEIGHTING * (100 - RxPER)) / 100;
@@ -2751,16 +2750,16 @@ VOID MlmeCalculateChannelQuality(IN PRTMP_ADAPTER pAd,
 
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID MlmeSetTxPreamble(IN PRTMP_ADAPTER pAd, IN USHORT TxPreamble)
 {
 	AUTO_RSP_CFG_STRUC csr4;
 
-	//
-	// Always use Long preamble before verifiation short preamble functionality works well.
-	// Todo: remove the following line if short preamble functionality works
-	//
-	//TxPreamble = Rt802_11PreambleLong;
+	/* */
+	/* Always use Long preamble before verifiation short preamble functionality works well. */
+	/* Todo: remove the following line if short preamble functionality works */
+	/* */
+	/*TxPreamble = Rt802_11PreambleLong; */
 
 	RTMP_IO_READ32(pAd, AUTO_RSP_CFG, &csr4.word);
 	if (TxPreamble == Rt802_11PreambleLong) {
@@ -2769,7 +2768,7 @@ VOID MlmeSetTxPreamble(IN PRTMP_ADAPTER pAd, IN USHORT TxPreamble)
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
 		csr4.field.AutoResponderPreamble = 0;
 	} else {
-		// NOTE: 1Mbps should always use long preamble
+		/* NOTE: 1Mbps should always use long preamble */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("MlmeSetTxPreamble (= SHORT PREAMBLE)\n"));
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);
@@ -2796,7 +2795,7 @@ VOID UpdateBasicRateBitmap(IN PRTMP_ADAPTER pAdapter)
 	ULONG bitmap = pAdapter->CommonCfg.BasicRateBitmap;
 
 	/* if A mode, always use fix BasicRateBitMap */
-	//if (pAdapter->CommonCfg.Channel == PHY_11A)
+	/*if (pAdapter->CommonCfg.Channel == PHY_11A) */
 	if (pAdapter->CommonCfg.Channel > 14)
 		pAdapter->CommonCfg.BasicRateBitmap = 0x150;	/* 6, 12, 24M */
 	/* End of if */
@@ -2828,10 +2827,10 @@ VOID UpdateBasicRateBitmap(IN PRTMP_ADAPTER pAdapter)
 	}			/* End of for */
 }				/* End of UpdateBasicRateBitmap */
 
-// IRQL = PASSIVE_LEVEL
-// IRQL = DISPATCH_LEVEL
-// bLinkUp is to identify the inital link speed.
-// TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps.
+/* IRQL = PASSIVE_LEVEL */
+/* IRQL = DISPATCH_LEVEL */
+/* bLinkUp is to identify the inital link speed. */
+/* TRUE indicates the rate update at linkup, we should not try to set the rate at 54Mbps. */
 VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 {
 	int i, num;
@@ -2846,7 +2845,7 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 	BOOLEAN *auto_rate_cur_p;
 	UCHAR HtMcs = MCS_AUTO;
 
-	// find max desired rate
+	/* find max desired rate */
 	UpdateBasicRateBitmap(pAd);
 
 	num = 0;
@@ -2901,14 +2900,14 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 			Rate = RATE_54;
 			num++;
 			break;
-			//default: Rate = RATE_1;   break;
+			/*default: Rate = RATE_1;   break; */
 		}
 		if (MaxDesire < Rate)
 			MaxDesire = Rate;
 	}
 
-//===========================================================================
-//===========================================================================
+/*=========================================================================== */
+/*=========================================================================== */
 	{
 		pHtPhy = &pAd->StaCfg.HTPhyMode;
 		pMaxHtPhy = &pAd->StaCfg.MaxHTPhyMode;
@@ -2929,25 +2928,25 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 	pMaxHtPhy->word = 0;
 	pHtPhy->word = 0;
 
-	// Auto rate switching is enabled only if more than one DESIRED RATES are
-	// specified; otherwise disabled
+	/* Auto rate switching is enabled only if more than one DESIRED RATES are */
+	/* specified; otherwise disabled */
 	if (num <= 1) {
-		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch      = FALSE;
+		/*OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
+		/*pAd->CommonCfg.bAutoTxRateSwitch      = FALSE; */
 		*auto_rate_cur_p = FALSE;
 	} else {
-		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch      = TRUE;
+		/*OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
+		/*pAd->CommonCfg.bAutoTxRateSwitch      = TRUE; */
 		*auto_rate_cur_p = TRUE;
 	}
 
 	if (HtMcs != MCS_AUTO) {
-		//OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch      = FALSE;
+		/*OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
+		/*pAd->CommonCfg.bAutoTxRateSwitch      = FALSE; */
 		*auto_rate_cur_p = FALSE;
 	} else {
-		//OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED);
-		//pAd->CommonCfg.bAutoTxRateSwitch      = TRUE;
+		/*OPSTATUS_SET_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED); */
+		/*pAd->CommonCfg.bAutoTxRateSwitch      = TRUE; */
 		*auto_rate_cur_p = TRUE;
 	}
 
@@ -2963,7 +2962,7 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 		ExtRateLen = pAd->CommonCfg.ExtRateLen;
 	}
 
-	// find max supported rate
+	/* find max supported rate */
 	for (i = 0; i < SupRateLen; i++) {
 		switch (pSupRate[i] & 0x7f) {
 		case 2:
@@ -3106,11 +3105,11 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 
 	RTMP_IO_WRITE32(pAd, LEGACY_BASIC_RATE, BasicRateBitmap);
 
-	// bug fix
-	// pAd->CommonCfg.BasicRateBitmap = BasicRateBitmap;
+	/* bug fix */
+	/* pAd->CommonCfg.BasicRateBitmap = BasicRateBitmap; */
 
-	// calculate the exptected ACK rate for each TX rate. This info is used to caculate
-	// the DURATION field of outgoing uniicast DATA/MGMT frame
+	/* calculate the exptected ACK rate for each TX rate. This info is used to caculate */
+	/* the DURATION field of outgoing uniicast DATA/MGMT frame */
 	for (i = 0; i < MAX_LEN_OF_SUPPORTED_RATES; i++) {
 		if (BasicRateBitmap & (0x01 << i))
 			CurrBasicRate = (UCHAR) i;
@@ -3120,21 +3119,19 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("MlmeUpdateTxRates[MaxSupport = %d] = MaxDesire %d Mbps\n",
 		  RateIdToMbps[MaxSupport], RateIdToMbps[MaxDesire]));
-	// max tx rate = min {max desire rate, max supported rate}
+	/* max tx rate = min {max desire rate, max supported rate} */
 	if (MaxSupport < MaxDesire)
 		pAd->CommonCfg.MaxTxRate = MaxSupport;
 	else
 		pAd->CommonCfg.MaxTxRate = MaxDesire;
 
 	pAd->CommonCfg.MinTxRate = MinSupport;
-	// 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success
-	// ratio of initial DHCP packet exchange, TX rate starts from a lower rate depending
-	// on average RSSI
-	//       1. RSSI >= -70db, start at 54 Mbps (short distance)
-	//       2. -70 > RSSI >= -75, start at 24 Mbps (mid distance)
-	//       3. -75 > RSSI, start at 11 Mbps (long distance)
-	//if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED)/* &&
-	//      OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)*/)
+	/* 2003-07-31 john - 2500 doesn't have good sensitivity at high OFDM rates. to increase the success */
+	/* ratio of initial DHCP packet exchange, TX rate starts from a lower rate depending */
+	/* on average RSSI */
+	/*       1. RSSI >= -70db, start at 54 Mbps (short distance) */
+	/*       2. -70 > RSSI >= -75, start at 24 Mbps (mid distance) */
+	/*       3. -75 > RSSI, start at 11 Mbps (long distance) */
 	if (*auto_rate_cur_p) {
 		short dbm = 0;
 
@@ -3150,7 +3147,7 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 		else if (dbm < -70)
 			pAd->CommonCfg.TxRate = RATE_24;
 
-		// should never exceed MaxTxRate (consider 11B-only mode)
+		/* should never exceed MaxTxRate (consider 11B-only mode) */
 		if (pAd->CommonCfg.TxRate > pAd->CommonCfg.MaxTxRate)
 			pAd->CommonCfg.TxRate = pAd->CommonCfg.MaxTxRate;
 
@@ -3206,11 +3203,11 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_CCK;
 			pAd->CommonCfg.MlmeTransmit.field.MCS = RATE_1;
 
-//#ifdef        WIFI_TEST
+/*#ifdef        WIFI_TEST */
 			pAd->CommonCfg.RtsRate = RATE_11;
-//#else
-//                              pAd->CommonCfg.RtsRate = RATE_1;
-//#endif
+/*#else */
+/*                              pAd->CommonCfg.RtsRate = RATE_1; */
+/*#endif */
 			break;
 		case PHY_11G:
 		case PHY_11A:
@@ -3242,7 +3239,7 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 				    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
 			}
 			break;
-		default:	// error
+		default:	/* error */
 			pAd->CommonCfg.MlmeRate = RATE_6;
 			pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
 			pAd->CommonCfg.MlmeTransmit.field.MCS =
@@ -3250,9 +3247,9 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
 			pAd->CommonCfg.RtsRate = RATE_1;
 			break;
 		}
-		//
-		// Keep Basic Mlme Rate.
-		//
+		/* */
+		/* Keep Basic Mlme Rate. */
+		/* */
 		pAd->MacTab.Content[MCAST_WCID].HTPhyMode.word =
 		    pAd->CommonCfg.MlmeTransmit.word;
 		if (pAd->CommonCfg.MlmeTransmit.field.MODE == MODE_OFDM)
@@ -3297,8 +3294,8 @@ VOID MlmeUpdateTxRates(IN PRTMP_ADAPTER pAd, IN BOOLEAN bLinkUp, IN UCHAR apidx)
  */
 VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 {
-	UCHAR StbcMcs;		//j, StbcMcs, bitmask;
-	CHAR i;			// 3*3
+	UCHAR StbcMcs;		/*j, StbcMcs, bitmask; */
+	CHAR i;			/* 3*3 */
 	RT_HT_CAPABILITY *pRtHtCap = NULL;
 	RT_HT_PHY_INFO *pActiveHtPhy = NULL;
 	ULONG BasicMCS;
@@ -3354,7 +3351,7 @@ VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 			pMaxHtPhy->field.STBC = STBC_NONE;
 	}
 
-	// Decide MAX ht rate.
+	/* Decide MAX ht rate. */
 	if ((pRtHtCap->GF) && (pAd->CommonCfg.DesiredHtPhy.GF))
 		pMaxHtPhy->field.MODE = MODE_HTGREENFIELD;
 	else
@@ -3379,7 +3376,7 @@ VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 		pMaxHtPhy->field.MCS = 32;
 	}
 
-	for (i = 23; i >= 0; i--)	// 3*3
+	for (i = 23; i >= 0; i--)	/* 3*3 */
 	{
 		j = i / 8;
 		bitmask = (1 << (i - (j * 8)));
@@ -3394,12 +3391,12 @@ VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 			break;
 	}
 
-	// Copy MIN ht rate.  rt2860???
+	/* Copy MIN ht rate.  rt2860??? */
 	pMinHtPhy->field.BW = BW_20;
 	pMinHtPhy->field.MCS = 0;
 	pMinHtPhy->field.STBC = 0;
 	pMinHtPhy->field.ShortGI = 0;
-	//If STA assigns fixed rate. update to fixed here.
+	/*If STA assigns fixed rate. update to fixed here. */
 	if ((pAd->OpMode == OPMODE_STA) && (pDesireHtPhy->MCSSet[0] != 0xff)) {
 		if (pDesireHtPhy->MCSSet[4] != 0) {
 			pMaxHtPhy->field.MCS = 32;
@@ -3409,7 +3406,7 @@ VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 				  pMinHtPhy->field.MCS));
 		}
 
-		for (i = 23; (CHAR) i >= 0; i--)	// 3*3
+		for (i = 23; (CHAR) i >= 0; i--)	/* 3*3 */
 		{
 			j = i / 8;
 			bitmask = (1 << (i - (j * 8)));
@@ -3424,14 +3421,14 @@ VOID MlmeUpdateHtTxRates(IN PRTMP_ADAPTER pAd, IN UCHAR apidx)
 		}
 	}
 
-	// Decide ht rate
+	/* Decide ht rate */
 	pHtPhy->field.STBC = pMaxHtPhy->field.STBC;
 	pHtPhy->field.BW = pMaxHtPhy->field.BW;
 	pHtPhy->field.MODE = pMaxHtPhy->field.MODE;
 	pHtPhy->field.MCS = pMaxHtPhy->field.MCS;
 	pHtPhy->field.ShortGI = pMaxHtPhy->field.ShortGI;
 
-	// use default now. rt2860
+	/* use default now. rt2860 */
 	if (pDesireHtPhy->MCSSet[0] != 0xff)
 		*auto_rate_cur_p = FALSE;
 	else
@@ -3464,21 +3461,21 @@ VOID BATableInit(IN PRTMP_ADAPTER pAd, IN BA_TABLE * Tab)
 	}
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID MlmeRadioOff(IN PRTMP_ADAPTER pAd)
 {
 	RTMP_MLME_RADIO_OFF(pAd);
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID MlmeRadioOn(IN PRTMP_ADAPTER pAd)
 {
 	RTMP_MLME_RADIO_ON(pAd);
 }
 
-// ===========================================================================================
-// bss_table.c
-// ===========================================================================================
+/* =========================================================================================== */
+/* bss_table.c */
+/* =========================================================================================== */
 
 /*! \brief initialize BSS table
  *	\param p_tab pointer to the table
@@ -3498,7 +3495,7 @@ VOID BssTableInit(IN BSS_TABLE * Tab)
 	Tab->BssOverlapNr = 0;
 	for (i = 0; i < MAX_LEN_OF_BSS_TABLE; i++) {
 		NdisZeroMemory(&Tab->BssEntry[i], sizeof(BSS_ENTRY));
-		Tab->BssEntry[i].Rssi = -127;	// initial the rssi as a minimum value
+		Tab->BssEntry[i].Rssi = -127;	/* initial the rssi as a minimum value */
 	}
 }
 
@@ -3518,10 +3515,10 @@ ULONG BssTableSearch(IN BSS_TABLE * Tab, IN PUCHAR pBssid, IN UCHAR Channel)
 	UCHAR i;
 
 	for (i = 0; i < Tab->BssNr; i++) {
-		//
-		// Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G.
-		// We should distinguish this case.
-		//
+		/* */
+		/* Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G. */
+		/* We should distinguish this case. */
+		/* */
 		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
 		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
 		    MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid)) {
@@ -3538,10 +3535,10 @@ ULONG BssSsidTableSearch(IN BSS_TABLE * Tab,
 	UCHAR i;
 
 	for (i = 0; i < Tab->BssNr; i++) {
-		//
-		// Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G.
-		// We should distinguish this case.
-		//
+		/* */
+		/* Some AP that support A/B/G mode that may used the same BSSID on 11A and 11B/G. */
+		/* We should distinguish this case. */
+		/* */
 		if ((((Tab->BssEntry[i].Channel <= 14) && (Channel <= 14)) ||
 		     ((Tab->BssEntry[i].Channel > 14) && (Channel > 14))) &&
 		    MAC_ADDR_EQUAL(Tab->BssEntry[i].Bssid, pBssid) &&
@@ -3593,7 +3590,7 @@ ULONG BssSsidTableSearchBySSID(IN BSS_TABLE * Tab,
 	return (ULONG) BSS_NOT_FOUND;
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID BssTableDeleteEntry(IN OUT BSS_TABLE * Tab,
 			 IN PUCHAR pBssid, IN UCHAR Channel)
 {
@@ -3635,13 +3632,13 @@ VOID BATableDeleteORIEntry(IN OUT PRTMP_ADAPTER pAd,
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("BATableDeleteORIEntry numAsOriginator= %ld\n",
 				  pAd->BATable.numAsRecipient));
-			// Erase Bitmap flag.
+			/* Erase Bitmap flag. */
 		}
-		pAd->MacTab.Content[pBAORIEntry->Wcid].TXBAbitmap &= (~(1 << (pBAORIEntry->TID)));	// If STA mode,  erase flag here
-		pAd->MacTab.Content[pBAORIEntry->Wcid].BAOriWcidArray[pBAORIEntry->TID] = 0;	// If STA mode,  erase flag here
+		pAd->MacTab.Content[pBAORIEntry->Wcid].TXBAbitmap &= (~(1 << (pBAORIEntry->TID)));	/* If STA mode,  erase flag here */
+		pAd->MacTab.Content[pBAORIEntry->Wcid].BAOriWcidArray[pBAORIEntry->TID] = 0;	/* If STA mode,  erase flag here */
 		pBAORIEntry->ORI_BA_Status = Originator_NONE;
 		pBAORIEntry->Token = 1;
-		// Not clear Sequence here.
+		/* Not clear Sequence here. */
 		NdisReleaseSpinLock(&pAd->BATabLock);
 	}
 }
@@ -3655,7 +3652,7 @@ VOID BATableDeleteORIEntry(IN OUT PRTMP_ADAPTER pAd,
  IRQL = DISPATCH_LEVEL
 
  */
-VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN PCF_PARM pCfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN PCF_PARM pCfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	/* AP might use this additional ht info IE */
 		 IN UCHAR HtCapabilityLen,
 		 IN UCHAR AddHtInfoLen,
 		 IN UCHAR NewExtChanOffset,
@@ -3669,13 +3666,13 @@ VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, I
 		 IN USHORT LengthVIE, IN PNDIS_802_11_VARIABLE_IEs pVIE)
 {
 	COPY_MAC_ADDR(pBss->Bssid, pBssid);
-	// Default Hidden SSID to be TRUE, it will be turned to FALSE after coping SSID
+	/* Default Hidden SSID to be TRUE, it will be turned to FALSE after coping SSID */
 	pBss->Hidden = 1;
 	if (SsidLen > 0) {
-		// For hidden SSID AP, it might send beacon with SSID len equal to 0
-		// Or send beacon /probe response with SSID len matching real SSID length,
-		// but SSID is all zero. such as "00-00-00-00" with length 4.
-		// We have to prevent this case overwrite correct table
+		/* For hidden SSID AP, it might send beacon with SSID len equal to 0 */
+		/* Or send beacon /probe response with SSID len matching real SSID length, */
+		/* but SSID is all zero. such as "00-00-00-00" with length 4. */
+		/* We have to prevent this case overwrite correct table */
 		if (NdisEqualMemory(Ssid, ZeroSsid, SsidLen) == 0) {
 			NdisZeroMemory(pBss->Ssid, MAX_LEN_OF_SSID);
 			NdisMoveMemory(pBss->Ssid, Ssid, SsidLen);
@@ -3698,8 +3695,8 @@ VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, I
 	}
 
 	pBss->CapabilityInfo = CapabilityInfo;
-	// The privacy bit indicate security is ON, it maight be WEP, TKIP or AES
-	// Combine with AuthMode, they will decide the connection methods.
+	/* The privacy bit indicate security is ON, it maight be WEP, TKIP or AES */
+	/* Combine with AuthMode, they will decide the connection methods. */
 	pBss->Privacy = CAP_IS_PRIVACY_ON(pBss->CapabilityInfo);
 	ASSERT(SupRateLen <= MAX_LEN_OF_SUPPORTED_RATES);
 	if (SupRateLen <= MAX_LEN_OF_SUPPORTED_RATES)
@@ -3715,15 +3712,15 @@ VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, I
 	pBss->Channel = Channel;
 	pBss->CentralChannel = Channel;
 	pBss->Rssi = Rssi;
-	// Update CkipFlag. if not exists, the value is 0x0
+	/* Update CkipFlag. if not exists, the value is 0x0 */
 	pBss->CkipFlag = CkipFlag;
 
-	// New for microsoft Fixed IEs
+	/* New for microsoft Fixed IEs */
 	NdisMoveMemory(pBss->FixIEs.Timestamp, &TimeStamp, 8);
 	pBss->FixIEs.BeaconInterval = BeaconPeriod;
 	pBss->FixIEs.Capabilities = CapabilityInfo;
 
-	// New for microsoft Variable IEs
+	/* New for microsoft Variable IEs */
 	if (LengthVIE != 0) {
 		pBss->VarIELen = LengthVIE;
 		NdisMoveMemory(pBss->VarIEs, pVIE, pBss->VarIELen);
@@ -3762,7 +3759,7 @@ VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, I
 
 	BssCipherParse(pBss);
 
-	// new for QOS
+	/* new for QOS */
 	if (pEdcaParm)
 		NdisMoveMemory(&pBss->EdcaParm, pEdcaParm, sizeof(EDCA_PARM));
 	else
@@ -3811,7 +3808,7 @@ VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, I
 				}
 				break;
 			}
-			Length = Length + 2 + (USHORT) pEid->Len;	// Eid[1] + Len[1]+ content[Len]
+			Length = Length + 2 + (USHORT) pEid->Len;	/* Eid[1] + Len[1]+ content[Len] */
 			pEid = (PEID_STRUCT) ((UCHAR *) pEid + 2 + pEid->Len);
 		}
 	}
@@ -3840,7 +3837,7 @@ VOID BssEntrySet(IN PRTMP_ADAPTER pAd, OUT BSS_ENTRY * pBss, IN PUCHAR pBssid, I
  IRQL = DISPATCH_LEVEL
 
  */
-ULONG BssTableSetEntry(IN PRTMP_ADAPTER pAd, OUT BSS_TABLE * Tab, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN CF_PARM * CfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+ULONG BssTableSetEntry(IN PRTMP_ADAPTER pAd, OUT BSS_TABLE * Tab, IN PUCHAR pBssid, IN CHAR Ssid[], IN UCHAR SsidLen, IN UCHAR BssType, IN USHORT BeaconPeriod, IN CF_PARM * CfParm, IN USHORT AtimWin, IN USHORT CapabilityInfo, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN HT_CAPABILITY_IE * pHtCapability, IN ADD_HT_INFO_IE * pAddHtInfo,	/* AP might use this additional ht info IE */
 		       IN UCHAR HtCapabilityLen,
 		       IN UCHAR AddHtInfoLen,
 		       IN UCHAR NewExtChanOffset,
@@ -3860,11 +3857,11 @@ ULONG BssTableSetEntry(IN PRTMP_ADAPTER pAd, OUT BSS_TABLE * Tab, IN PUCHAR pBss
 				   ChannelNo);
 	if (Idx == BSS_NOT_FOUND) {
 		if (Tab->BssNr >= MAX_LEN_OF_BSS_TABLE) {
-			//
-			// It may happen when BSS Table was full.
-			// The desired AP will not be added into BSS Table
-			// In this case, if we found the desired AP then overwrite BSS Table.
-			//
+			/* */
+			/* It may happen when BSS Table was full. */
+			/* The desired AP will not be added into BSS Table */
+			/* In this case, if we found the desired AP then overwrite BSS Table. */
+			/* */
 			if (!OPSTATUS_TEST_FLAG
 			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
 				if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, pBssid)
@@ -3926,7 +3923,7 @@ ULONG BssTableSetEntry(IN PRTMP_ADAPTER pAd, OUT BSS_TABLE * Tab, IN PUCHAR pBss
 	return Idx;
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 		      OUT BSS_TABLE * OutTab, IN CHAR Ssid[], IN UCHAR SsidLen)
 {
@@ -3950,7 +3947,7 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 		     || bIsHiddenApIncluded)) {
 			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
 
-			// 2.4G/5G N only mode
+			/* 2.4G/5G N only mode */
 			if ((pInBss->HtCapabilityLen == 0) &&
 			    ((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
 			     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))) {
@@ -3958,28 +3955,28 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 					 ("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
 				continue;
 			}
-			// New for WPA2
-			// Check the Authmode first
+			/* New for WPA2 */
+			/* Check the Authmode first */
 			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
-				// Check AuthMode and AuthModeAux for matching, in case AP support dual-mode
+				/* Check AuthMode and AuthModeAux for matching, in case AP support dual-mode */
 				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode)
 				    && (pAd->StaCfg.AuthMode !=
 					pInBss->AuthModeAux))
-					// None matched
+					/* None matched */
 					continue;
 
-				// Check cipher suite, AP must have more secured cipher than station setting
+				/* Check cipher suite, AP must have more secured cipher than station setting */
 				if ((pAd->StaCfg.AuthMode ==
 				     Ndis802_11AuthModeWPA)
 				    || (pAd->StaCfg.AuthMode ==
 					Ndis802_11AuthModeWPAPSK)) {
-					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
 					if (pInBss->WPA.bMixMode == FALSE)
 						if (pAd->StaCfg.WepStatus !=
 						    pInBss->WPA.GroupCipher)
 							continue;
 
-					// check group cipher
+					/* check group cipher */
 					if ((pAd->StaCfg.WepStatus <
 					     pInBss->WPA.GroupCipher)
 					    && (pInBss->WPA.GroupCipher !=
@@ -3988,9 +3985,9 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 						Ndis802_11GroupWEP104Enabled))
 						continue;
 
-					// check pairwise cipher, skip if none matched
-					// If profile set to AES, let it pass without question.
-					// If profile set to TKIP, we must find one mateched
+					/* check pairwise cipher, skip if none matched */
+					/* If profile set to AES, let it pass without question. */
+					/* If profile set to TKIP, we must find one mateched */
 					if ((pAd->StaCfg.WepStatus ==
 					     Ndis802_11Encryption2Enabled)
 					    && (pAd->StaCfg.WepStatus !=
@@ -4003,13 +4000,13 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 					 Ndis802_11AuthModeWPA2)
 					|| (pAd->StaCfg.AuthMode ==
 					    Ndis802_11AuthModeWPA2PSK)) {
-					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
 					if (pInBss->WPA2.bMixMode == FALSE)
 						if (pAd->StaCfg.WepStatus !=
 						    pInBss->WPA2.GroupCipher)
 							continue;
 
-					// check group cipher
+					/* check group cipher */
 					if ((pAd->StaCfg.WepStatus <
 					     pInBss->WPA.GroupCipher)
 					    && (pInBss->WPA2.GroupCipher !=
@@ -4018,9 +4015,9 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 						Ndis802_11GroupWEP104Enabled))
 						continue;
 
-					// check pairwise cipher, skip if none matched
-					// If profile set to AES, let it pass without question.
-					// If profile set to TKIP, we must find one mateched
+					/* check pairwise cipher, skip if none matched */
+					/* If profile set to AES, let it pass without question. */
+					/* If profile set to TKIP, we must find one mateched */
 					if ((pAd->StaCfg.WepStatus ==
 					     Ndis802_11Encryption2Enabled)
 					    && (pAd->StaCfg.WepStatus !=
@@ -4030,27 +4027,27 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 						continue;
 				}
 			}
-			// Bss Type matched, SSID matched.
-			// We will check wepstatus for qualification Bss
+			/* Bss Type matched, SSID matched. */
+			/* We will check wepstatus for qualification Bss */
 			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus) {
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("StaCfg.WepStatus=%d, while pInBss->WepStatus=%d\n",
 					  pAd->StaCfg.WepStatus,
 					  pInBss->WepStatus));
-				//
-				// For the SESv2 case, we will not qualify WepStatus.
-				//
+				/* */
+				/* For the SESv2 case, we will not qualify WepStatus. */
+				/* */
 				if (!pInBss->bSES)
 					continue;
 			}
-			// Since the AP is using hidden SSID, and we are trying to connect to ANY
-			// It definitely will fail. So, skip it.
-			// CCX also require not even try to connect it!!
+			/* Since the AP is using hidden SSID, and we are trying to connect to ANY */
+			/* It definitely will fail. So, skip it. */
+			/* CCX also require not even try to connect it!! */
 			if (SsidLen == 0)
 				continue;
 
-			// If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region
-			// If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead,
+			/* If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region */
+			/* If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead, */
 			if ((pInBss->CentralChannel != pInBss->Channel) &&
 			    (pAd->CommonCfg.RegTransmitSetting.field.BW ==
 			     BW_40)) {
@@ -4069,7 +4066,7 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 					}
 				}
 			}
-			// copy matching BSS from InTab to OutTab
+			/* copy matching BSS from InTab to OutTab */
 			NdisMoveMemory(pOutBss, pInBss, sizeof(BSS_ENTRY));
 
 			OutTab->BssNr++;
@@ -4077,7 +4074,7 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 			   && (SsidLen == 0)) {
 			BSS_ENTRY *pOutBss = &OutTab->BssEntry[OutTab->BssNr];
 
-			// 2.4G/5G N only mode
+			/* 2.4G/5G N only mode */
 			if ((pInBss->HtCapabilityLen == 0) &&
 			    ((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
 			     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))) {
@@ -4085,35 +4082,35 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 					 ("STA is in N-only Mode, this AP don't have Ht capability in Beacon.\n"));
 				continue;
 			}
-			// New for WPA2
-			// Check the Authmode first
+			/* New for WPA2 */
+			/* Check the Authmode first */
 			if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
-				// Check AuthMode and AuthModeAux for matching, in case AP support dual-mode
+				/* Check AuthMode and AuthModeAux for matching, in case AP support dual-mode */
 				if ((pAd->StaCfg.AuthMode != pInBss->AuthMode)
 				    && (pAd->StaCfg.AuthMode !=
 					pInBss->AuthModeAux))
-					// None matched
+					/* None matched */
 					continue;
 
-				// Check cipher suite, AP must have more secured cipher than station setting
+				/* Check cipher suite, AP must have more secured cipher than station setting */
 				if ((pAd->StaCfg.AuthMode ==
 				     Ndis802_11AuthModeWPA)
 				    || (pAd->StaCfg.AuthMode ==
 					Ndis802_11AuthModeWPAPSK)) {
-					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
 					if (pInBss->WPA.bMixMode == FALSE)
 						if (pAd->StaCfg.WepStatus !=
 						    pInBss->WPA.GroupCipher)
 							continue;
 
-					// check group cipher
+					/* check group cipher */
 					if (pAd->StaCfg.WepStatus <
 					    pInBss->WPA.GroupCipher)
 						continue;
 
-					// check pairwise cipher, skip if none matched
-					// If profile set to AES, let it pass without question.
-					// If profile set to TKIP, we must find one mateched
+					/* check pairwise cipher, skip if none matched */
+					/* If profile set to AES, let it pass without question. */
+					/* If profile set to TKIP, we must find one mateched */
 					if ((pAd->StaCfg.WepStatus ==
 					     Ndis802_11Encryption2Enabled)
 					    && (pAd->StaCfg.WepStatus !=
@@ -4126,20 +4123,20 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 					 Ndis802_11AuthModeWPA2)
 					|| (pAd->StaCfg.AuthMode ==
 					    Ndis802_11AuthModeWPA2PSK)) {
-					// If it's not mixed mode, we should only let BSS pass with the same encryption
+					/* If it's not mixed mode, we should only let BSS pass with the same encryption */
 					if (pInBss->WPA2.bMixMode == FALSE)
 						if (pAd->StaCfg.WepStatus !=
 						    pInBss->WPA2.GroupCipher)
 							continue;
 
-					// check group cipher
+					/* check group cipher */
 					if (pAd->StaCfg.WepStatus <
 					    pInBss->WPA2.GroupCipher)
 						continue;
 
-					// check pairwise cipher, skip if none matched
-					// If profile set to AES, let it pass without question.
-					// If profile set to TKIP, we must find one mateched
+					/* check pairwise cipher, skip if none matched */
+					/* If profile set to AES, let it pass without question. */
+					/* If profile set to TKIP, we must find one mateched */
 					if ((pAd->StaCfg.WepStatus ==
 					     Ndis802_11Encryption2Enabled)
 					    && (pAd->StaCfg.WepStatus !=
@@ -4149,13 +4146,13 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 						continue;
 				}
 			}
-			// Bss Type matched, SSID matched.
-			// We will check wepstatus for qualification Bss
+			/* Bss Type matched, SSID matched. */
+			/* We will check wepstatus for qualification Bss */
 			else if (pAd->StaCfg.WepStatus != pInBss->WepStatus)
 				continue;
 
-			// If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region
-			// If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead,
+			/* If both station and AP use 40MHz, still need to check if the 40MHZ band's legality in my country region */
+			/* If this 40MHz wideband is not allowed in my country list, use bandwidth 20MHZ instead, */
 			if ((pInBss->CentralChannel != pInBss->Channel) &&
 			    (pAd->CommonCfg.RegTransmitSetting.field.BW ==
 			     BW_40)) {
@@ -4169,7 +4166,7 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 					    BW = BW_40;
 				}
 			}
-			// copy matching BSS from InTab to OutTab
+			/* copy matching BSS from InTab to OutTab */
 			NdisMoveMemory(pOutBss, pInBss, sizeof(BSS_ENTRY));
 
 			OutTab->BssNr++;
@@ -4182,7 +4179,7 @@ VOID BssTableSsidSort(IN PRTMP_ADAPTER pAd,
 	BssTableSortByRssi(OutTab);
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID BssTableSortByRssi(IN OUT BSS_TABLE * OutTab)
 {
 	INT i, j;
@@ -4214,26 +4211,26 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 	INT Length;
 	NDIS_802_11_ENCRYPTION_STATUS TmpCipher;
 
-	//
-	// WepStatus will be reset later, if AP announce TKIP or AES on the beacon frame.
-	//
+	/* */
+	/* WepStatus will be reset later, if AP announce TKIP or AES on the beacon frame. */
+	/* */
 	if (pBss->Privacy) {
 		pBss->WepStatus = Ndis802_11WEPEnabled;
 	} else {
 		pBss->WepStatus = Ndis802_11WEPDisabled;
 	}
-	// Set default to disable & open authentication before parsing variable IE
+	/* Set default to disable & open authentication before parsing variable IE */
 	pBss->AuthMode = Ndis802_11AuthModeOpen;
 	pBss->AuthModeAux = Ndis802_11AuthModeOpen;
 
-	// Init WPA setting
+	/* Init WPA setting */
 	pBss->WPA.PairCipher = Ndis802_11WEPDisabled;
 	pBss->WPA.PairCipherAux = Ndis802_11WEPDisabled;
 	pBss->WPA.GroupCipher = Ndis802_11WEPDisabled;
 	pBss->WPA.RsnCapability = 0;
 	pBss->WPA.bMixMode = FALSE;
 
-	// Init WPA2 setting
+	/* Init WPA2 setting */
 	pBss->WPA2.PairCipher = Ndis802_11WEPDisabled;
 	pBss->WPA2.PairCipherAux = Ndis802_11WEPDisabled;
 	pBss->WPA2.GroupCipher = Ndis802_11WEPDisabled;
@@ -4243,7 +4240,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 	Length = (INT) pBss->VarIELen;
 
 	while (Length > 0) {
-		// Parse cipher suite base on WPA1 & WPA2, they should be parsed differently
+		/* Parse cipher suite base on WPA1 & WPA2, they should be parsed differently */
 		pTmp = ((PUCHAR) pBss->VarIEs) + pBss->VarIELen - Length;
 		pEid = (PEID_STRUCT) pTmp;
 		switch (pEid->Eid) {
@@ -4254,24 +4251,24 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 				break;
 			} else if (NdisEqualMemory(pEid->Octet, WPA_OUI, 4) !=
 				   1) {
-				// if unsupported vendor specific IE
+				/* if unsupported vendor specific IE */
 				break;
 			}
-			// Skip OUI, version, and multicast suite
-			// This part should be improved in the future when AP supported multiple cipher suite.
-			// For now, it's OK since almost all APs have fixed cipher suite supported.
-			// pTmp = (PUCHAR) pEid->Octet;
+			/* Skip OUI, version, and multicast suite */
+			/* This part should be improved in the future when AP supported multiple cipher suite. */
+			/* For now, it's OK since almost all APs have fixed cipher suite supported. */
+			/* pTmp = (PUCHAR) pEid->Octet; */
 			pTmp += 11;
 
-			// Cipher Suite Selectors from Spec P802.11i/D3.2 P26.
-			//      Value      Meaning
-			//      0                       None
-			//      1                       WEP-40
-			//      2                       Tkip
-			//      3                       WRAP
-			//      4                       AES
-			//      5                       WEP-104
-			// Parse group cipher
+			/* Cipher Suite Selectors from Spec P802.11i/D3.2 P26. */
+			/*      Value      Meaning */
+			/*      0                       None */
+			/*      1                       WEP-40 */
+			/*      2                       Tkip */
+			/*      3                       WRAP */
+			/*      4                       AES */
+			/*      5                       WEP-104 */
+			/* Parse group cipher */
 			switch (*pTmp) {
 			case 1:
 				pBss->WPA.GroupCipher =
@@ -4292,22 +4289,22 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 			default:
 				break;
 			}
-			// number of unicast suite
+			/* number of unicast suite */
 			pTmp += 1;
 
-			// skip all unicast cipher suites
-			//Count = *(PUSHORT) pTmp;
+			/* skip all unicast cipher suites */
+			/*Count = *(PUSHORT) pTmp; */
 			Count = (pTmp[1] << 8) + pTmp[0];
 			pTmp += sizeof(USHORT);
 
-			// Parsing all unicast cipher suite
+			/* Parsing all unicast cipher suite */
 			while (Count > 0) {
-				// Skip OUI
+				/* Skip OUI */
 				pTmp += 3;
 				TmpCipher = Ndis802_11WEPDisabled;
 				switch (*pTmp) {
 				case 1:
-				case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+				case 5:	/* Although WEP is not allowed in WPA related auth mode, we parse it anyway */
 					TmpCipher =
 					    Ndis802_11Encryption1Enabled;
 					break;
@@ -4323,7 +4320,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 					break;
 				}
 				if (TmpCipher > pBss->WPA.PairCipher) {
-					// Move the lower cipher suite to PairCipherAux
+					/* Move the lower cipher suite to PairCipherAux */
 					pBss->WPA.PairCipherAux =
 					    pBss->WPA.PairCipher;
 					pBss->WPA.PairCipher = TmpCipher;
@@ -4334,15 +4331,15 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 				Count--;
 			}
 
-			// 4. get AKM suite counts
-			//Count = *(PUSHORT) pTmp;
+			/* 4. get AKM suite counts */
+			/*Count = *(PUSHORT) pTmp; */
 			Count = (pTmp[1] << 8) + pTmp[0];
 			pTmp += sizeof(USHORT);
 			pTmp += 3;
 
 			switch (*pTmp) {
 			case 1:
-				// Set AP support WPA-enterprise mode
+				/* Set AP support WPA-enterprise mode */
 				if (pBss->AuthMode == Ndis802_11AuthModeOpen)
 					pBss->AuthMode = Ndis802_11AuthModeWPA;
 				else
@@ -4350,7 +4347,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 					    Ndis802_11AuthModeWPA;
 				break;
 			case 2:
-				// Set AP support WPA-PSK mode
+				/* Set AP support WPA-PSK mode */
 				if (pBss->AuthMode == Ndis802_11AuthModeOpen)
 					pBss->AuthMode =
 					    Ndis802_11AuthModeWPAPSK;
@@ -4363,12 +4360,12 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 			}
 			pTmp += 1;
 
-			// Fixed for WPA-None
+			/* Fixed for WPA-None */
 			if (pBss->BssType == BSS_ADHOC) {
 				pBss->AuthMode = Ndis802_11AuthModeWPANone;
 				pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
 				pBss->WepStatus = pBss->WPA.GroupCipher;
-				// Patched bugs for old driver
+				/* Patched bugs for old driver */
 				if (pBss->WPA.PairCipherAux ==
 				    Ndis802_11WEPDisabled)
 					pBss->WPA.PairCipherAux =
@@ -4376,7 +4373,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 			} else
 				pBss->WepStatus = pBss->WPA.PairCipher;
 
-			// Check the Pair & Group, if different, turn on mixed mode flag
+			/* Check the Pair & Group, if different, turn on mixed mode flag */
 			if (pBss->WPA.GroupCipher != pBss->WPA.PairCipher)
 				pBss->WPA.bMixMode = TRUE;
 
@@ -4385,17 +4382,17 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 		case IE_RSN:
 			pRsnHeader = (PRSN_IE_HEADER_STRUCT) pTmp;
 
-			// 0. Version must be 1
+			/* 0. Version must be 1 */
 			if (le2cpu16(pRsnHeader->Version) != 1)
 				break;
 			pTmp += sizeof(RSN_IE_HEADER_STRUCT);
 
-			// 1. Check group cipher
+			/* 1. Check group cipher */
 			pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
 			if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
 				break;
 
-			// Parse group cipher
+			/* Parse group cipher */
 			switch (pCipher->Type) {
 			case 1:
 				pBss->WPA2.GroupCipher =
@@ -4416,23 +4413,23 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 			default:
 				break;
 			}
-			// set to correct offset for next parsing
+			/* set to correct offset for next parsing */
 			pTmp += sizeof(CIPHER_SUITE_STRUCT);
 
-			// 2. Get pairwise cipher counts
-			//Count = *(PUSHORT) pTmp;
+			/* 2. Get pairwise cipher counts */
+			/*Count = *(PUSHORT) pTmp; */
 			Count = (pTmp[1] << 8) + pTmp[0];
 			pTmp += sizeof(USHORT);
 
-			// 3. Get pairwise cipher
-			// Parsing all unicast cipher suite
+			/* 3. Get pairwise cipher */
+			/* Parsing all unicast cipher suite */
 			while (Count > 0) {
-				// Skip OUI
+				/* Skip OUI */
 				pCipher = (PCIPHER_SUITE_STRUCT) pTmp;
 				TmpCipher = Ndis802_11WEPDisabled;
 				switch (pCipher->Type) {
 				case 1:
-				case 5:	// Although WEP is not allowed in WPA related auth mode, we parse it anyway
+				case 5:	/* Although WEP is not allowed in WPA related auth mode, we parse it anyway */
 					TmpCipher =
 					    Ndis802_11Encryption1Enabled;
 					break;
@@ -4448,7 +4445,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 					break;
 				}
 				if (TmpCipher > pBss->WPA2.PairCipher) {
-					// Move the lower cipher suite to PairCipherAux
+					/* Move the lower cipher suite to PairCipherAux */
 					pBss->WPA2.PairCipherAux =
 					    pBss->WPA2.PairCipher;
 					pBss->WPA2.PairCipher = TmpCipher;
@@ -4459,13 +4456,13 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 				Count--;
 			}
 
-			// 4. get AKM suite counts
-			//Count = *(PUSHORT) pTmp;
+			/* 4. get AKM suite counts */
+			/*Count = *(PUSHORT) pTmp; */
 			Count = (pTmp[1] << 8) + pTmp[0];
 			pTmp += sizeof(USHORT);
 
-			// 5. Get AKM ciphers
-			// Parsing all AKM ciphers
+			/* 5. Get AKM ciphers */
+			/* Parsing all AKM ciphers */
 			while (Count > 0) {
 				pAKM = (PAKM_SUITE_STRUCT) pTmp;
 				if (!RTMPEqualMemory(pTmp, RSN_OUI, 3))
@@ -4473,7 +4470,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 
 				switch (pAKM->Type) {
 				case 1:
-					// Set AP support WPA-enterprise mode
+					/* Set AP support WPA-enterprise mode */
 					if (pBss->AuthMode ==
 					    Ndis802_11AuthModeOpen)
 						pBss->AuthMode =
@@ -4483,7 +4480,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 						    Ndis802_11AuthModeWPA2;
 					break;
 				case 2:
-					// Set AP support WPA-PSK mode
+					/* Set AP support WPA-PSK mode */
 					if (pBss->AuthMode ==
 					    Ndis802_11AuthModeOpen)
 						pBss->AuthMode =
@@ -4506,7 +4503,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 				Count--;
 			}
 
-			// Fixed for WPA-None
+			/* Fixed for WPA-None */
 			if (pBss->BssType == BSS_ADHOC) {
 				pBss->AuthMode = Ndis802_11AuthModeWPANone;
 				pBss->AuthModeAux = Ndis802_11AuthModeWPANone;
@@ -4514,7 +4511,7 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 				    pBss->WPA2.PairCipherAux;
 				pBss->WPA.GroupCipher = pBss->WPA2.GroupCipher;
 				pBss->WepStatus = pBss->WPA.GroupCipher;
-				// Patched bugs for old driver
+				/* Patched bugs for old driver */
 				if (pBss->WPA.PairCipherAux ==
 				    Ndis802_11WEPDisabled)
 					pBss->WPA.PairCipherAux =
@@ -4522,12 +4519,12 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 			}
 			pBss->WepStatus = pBss->WPA2.PairCipher;
 
-			// 6. Get RSN capability
-			//pBss->WPA2.RsnCapability = *(PUSHORT) pTmp;
+			/* 6. Get RSN capability */
+			/*pBss->WPA2.RsnCapability = *(PUSHORT) pTmp; */
 			pBss->WPA2.RsnCapability = (pTmp[1] << 8) + pTmp[0];
 			pTmp += sizeof(USHORT);
 
-			// Check the Pair & Group, if different, turn on mixed mode flag
+			/* Check the Pair & Group, if different, turn on mixed mode flag */
 			if (pBss->WPA2.GroupCipher != pBss->WPA2.PairCipher)
 				pBss->WPA2.bMixMode = TRUE;
 
@@ -4539,9 +4536,9 @@ VOID BssCipherParse(IN OUT PBSS_ENTRY pBss)
 	}
 }
 
-// ===========================================================================================
-// mac_table.c
-// ===========================================================================================
+/* =========================================================================================== */
+/* mac_table.c */
+/* =========================================================================================== */
 
 /*! \brief generates a random mac address value for IBSS BSSID
  *	\param Addr the bssid location
@@ -4557,7 +4554,7 @@ VOID MacAddrRandomBssid(IN PRTMP_ADAPTER pAd, OUT PUCHAR pAddr)
 		pAddr[i] = RandomByte(pAd);
 	}
 
-	pAddr[0] = (pAddr[0] & 0xfe) | 0x02;	// the first 2 bits must be 01xxxxxxxx
+	pAddr[0] = (pAddr[0] & 0xfe) | 0x02;	/* the first 2 bits must be 01xxxxxxxx */
 }
 
 /*! \brief init the management mac frame header
@@ -4584,17 +4581,17 @@ VOID MgtMacHeaderInit(IN PRTMP_ADAPTER pAd,
 
 	pHdr80211->FC.Type = BTYPE_MGMT;
 	pHdr80211->FC.SubType = SubType;
-//      if (SubType == SUBTYPE_ACK)     // sample, no use, it will conflict with ACTION frame sub type
-//              pHdr80211->FC.Type = BTYPE_CNTL;
+/*      if (SubType == SUBTYPE_ACK)     // sample, no use, it will conflict with ACTION frame sub type */
+/*              pHdr80211->FC.Type = BTYPE_CNTL; */
 	pHdr80211->FC.ToDs = ToDs;
 	COPY_MAC_ADDR(pHdr80211->Addr1, pDA);
 	COPY_MAC_ADDR(pHdr80211->Addr2, pAd->CurrentAddress);
 	COPY_MAC_ADDR(pHdr80211->Addr3, pBssid);
 }
 
-// ===========================================================================================
-// mem_mgmt.c
-// ===========================================================================================
+/* =========================================================================================== */
+/* mem_mgmt.c */
+/* =========================================================================================== */
 
 /*!***************************************************************************
  * This routine build an outgoing frame, and fill all information specified
@@ -4621,7 +4618,7 @@ ULONG MakeOutgoingFrame(OUT UCHAR * Buffer, OUT ULONG * FrameLen, ...)
 	ULONG TotLeng;
 	va_list Args;
 
-	// calculates the total length
+	/* calculates the total length */
 	TotLeng = 0;
 	va_start(Args, FrameLen);
 	do {
@@ -4639,9 +4636,9 @@ ULONG MakeOutgoingFrame(OUT UCHAR * Buffer, OUT ULONG * FrameLen, ...)
 	return TotLeng;
 }
 
-// ===========================================================================================
-// mlme_queue.c
-// ===========================================================================================
+/* =========================================================================================== */
+/* mlme_queue.c */
+/* =========================================================================================== */
 
 /*! \brief	Initialize The MLME Queue, used by MLME Functions
  *	\param	*Queue	   The MLME Queue
@@ -4694,13 +4691,13 @@ BOOLEAN MlmeEnqueue(IN PRTMP_ADAPTER pAd,
 	INT Tail;
 	MLME_QUEUE *Queue = (MLME_QUEUE *) & pAd->Mlme.Queue;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return FALSE;
 
-	// First check the size, it MUST not exceed the mlme queue size
+	/* First check the size, it MUST not exceed the mlme queue size */
 	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
 		DBGPRINT_ERR(("MlmeEnqueue: msg too large, size = %ld \n",
 			      MsgLen));
@@ -4761,15 +4758,15 @@ BOOLEAN MlmeEnqueueForRecv(IN PRTMP_ADAPTER pAd,
 	INT MsgType;
 	MLME_QUEUE *Queue = (MLME_QUEUE *) & pAd->Mlme.Queue;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd,
 	     fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST)) {
 		DBGPRINT_ERR(("MlmeEnqueueForRecv: fRTMP_ADAPTER_HALT_IN_PROGRESS\n"));
 		return FALSE;
 	}
-	// First check the size, it MUST not exceed the mlme queue size
+	/* First check the size, it MUST not exceed the mlme queue size */
 	if (MsgLen > MGMT_DMA_BUFFER_SIZE) {
 		DBGPRINT_ERR(("MlmeEnqueueForRecv: frame too large, size = %ld \n", MsgLen));
 		return FALSE;
@@ -4786,7 +4783,7 @@ BOOLEAN MlmeEnqueueForRecv(IN PRTMP_ADAPTER pAd,
 		}
 	}
 
-	// OK, we got all the informations, it is time to put things into queue
+	/* OK, we got all the informations, it is time to put things into queue */
 	NdisAcquireSpinLock(&(Queue->Lock));
 	Tail = Queue->Tail;
 	Queue->Tail++;
@@ -4842,12 +4839,12 @@ BOOLEAN MlmeDequeue(IN MLME_QUEUE * Queue, OUT MLME_QUEUE_ELEM ** Elem)
 	return TRUE;
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID MlmeRestartStateMachine(IN PRTMP_ADAPTER pAd)
 {
 #ifdef RTMP_MAC_PCI
 	MLME_QUEUE_ELEM *Elem = NULL;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 	BOOLEAN Cancelled;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("MlmeRestartStateMachine \n"));
@@ -4862,11 +4859,11 @@ VOID MlmeRestartStateMachine(IN PRTMP_ADAPTER pAd)
 	}
 	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
 
-	// Remove all Mlme queues elements
+	/* Remove all Mlme queues elements */
 	while (!MlmeQueueEmpty(&pAd->Mlme.Queue)) {
-		//From message type, determine which state machine I should drive
+		/*From message type, determine which state machine I should drive */
 		if (MlmeDequeue(&pAd->Mlme.Queue, &Elem)) {
-			// free MLME element
+			/* free MLME element */
 			Elem->Occupied = FALSE;
 			Elem->MsgLen = 0;
 
@@ -4874,11 +4871,11 @@ VOID MlmeRestartStateMachine(IN PRTMP_ADAPTER pAd)
 			DBGPRINT_ERR(("MlmeRestartStateMachine: MlmeQueue empty\n"));
 		}
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	{
-		// Cancel all timer events
-		// Be careful to cancel new added timer
+		/* Cancel all timer events */
+		/* Be careful to cancel new added timer */
 		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &Cancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &Cancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
@@ -4888,15 +4885,15 @@ VOID MlmeRestartStateMachine(IN PRTMP_ADAPTER pAd)
 
 	}
 
-	// Change back to original channel in case of doing scan
+	/* Change back to original channel in case of doing scan */
 	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
 
-	// Resume MSDU which is turned off durning scan
+	/* Resume MSDU which is turned off durning scan */
 	RTMPResumeMsduTransmission(pAd);
 
 	{
-		// Set all state machines back IDLE
+		/* Set all state machines back IDLE */
 		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
@@ -4906,11 +4903,11 @@ VOID MlmeRestartStateMachine(IN PRTMP_ADAPTER pAd)
 	}
 
 #ifdef RTMP_MAC_PCI
-	// Remove running state
+	/* Remove running state */
 	NdisAcquireSpinLock(&pAd->Mlme.TaskLock);
 	pAd->Mlme.bRunning = FALSE;
 	NdisReleaseSpinLock(&pAd->Mlme.TaskLock);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 }
 
 /*! \brief	test if the MLME Queue is empty
@@ -4994,10 +4991,10 @@ BOOLEAN MsgTypeSubst(IN PRTMP_ADAPTER pAd,
 	UCHAR EAPType;
 	PUCHAR pData;
 
-	// Pointer to start of data frames including SNAP header
+	/* Pointer to start of data frames including SNAP header */
 	pData = (PUCHAR) pFrame + LENGTH_802_11;
 
-	// The only data type will pass to this function is EAPOL frame
+	/* The only data type will pass to this function is EAPOL frame */
 	if (pFrame->Hdr.FC.Type == BTYPE_DATA) {
 		{
 			*Machine = WPA_STATE_MACHINE;
@@ -5046,7 +5043,7 @@ BOOLEAN MsgTypeSubst(IN PRTMP_ADAPTER pAd,
 		*MsgType = MT2_PEER_DISASSOC_REQ;
 		break;
 	case SUBTYPE_AUTH:
-		// get the sequence number from payload 24 Mac Header + 2 bytes algorithm
+		/* get the sequence number from payload 24 Mac Header + 2 bytes algorithm */
 		NdisMoveMemory(&Seq, &pFrame->Octet[2], sizeof(USHORT));
 		NdisMoveMemory(&Alg, &pFrame->Octet[0], sizeof(USHORT));
 		if (Seq == 1 || Seq == 3) {
@@ -5067,7 +5064,7 @@ BOOLEAN MsgTypeSubst(IN PRTMP_ADAPTER pAd,
 		break;
 	case SUBTYPE_ACTION:
 		*Machine = ACTION_STATE_MACHINE;
-		//  Sometimes Sta will return with category bytes with MSB = 1, if they receive catogory out of their support
+		/*  Sometimes Sta will return with category bytes with MSB = 1, if they receive catogory out of their support */
 		if ((pFrame->Octet[0] & 0x7F) > MAX_PEER_CATE_MSG) {
 			*MsgType = MT2_ACT_INVALID;
 		} else {
@@ -5082,9 +5079,9 @@ BOOLEAN MsgTypeSubst(IN PRTMP_ADAPTER pAd,
 	return TRUE;
 }
 
-// ===========================================================================================
-// state_machine.c
-// ===========================================================================================
+/* =========================================================================================== */
+/* state_machine.c */
+/* =========================================================================================== */
 
 /*! \brief Initialize the state machine.
  *	\param *S			pointer to the state machine
@@ -5109,21 +5106,21 @@ VOID StateMachineInit(IN STATE_MACHINE * S,
 {
 	ULONG i, j;
 
-	// set number of states and messages
+	/* set number of states and messages */
 	S->NrState = StNr;
 	S->NrMsg = MsgNr;
 	S->Base = Base;
 
 	S->TransFunc = Trans;
 
-	// init all state transition to default function
+	/* init all state transition to default function */
 	for (i = 0; i < StNr; i++) {
 		for (j = 0; j < MsgNr; j++) {
 			S->TransFunc[i * MsgNr + j] = DefFunc;
 		}
 	}
 
-	// set the starting state
+	/* set the starting state */
 	S->CurrState = InitState;
 }
 
@@ -5147,7 +5144,7 @@ VOID StateMachineSetAction(IN STATE_MACHINE * S,
 	MsgIdx = Msg - S->Base;
 
 	if (St < S->NrState && MsgIdx < S->NrMsg) {
-		// boundary checking before setting the action
+		/* boundary checking before setting the action */
 		S->TransFunc[St * S->NrMsg + MsgIdx] = Func;
 	}
 }
@@ -5180,9 +5177,9 @@ VOID Drop(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 }
 
-// ===========================================================================================
-// lfsr.c
-// ===========================================================================================
+/* =========================================================================================== */
+/* lfsr.c */
+/* =========================================================================================== */
 
 /*
 	==========================================================================
@@ -5260,7 +5257,7 @@ VOID RTMPCheckRates(IN PRTMP_ADAPTER pAd,
 	else
 		RateIdx = 12;
 
-	// Check for support rates exclude basic rate bit
+	/* Check for support rates exclude basic rate bit */
 	for (i = 0; i < *SupRateLen; i++)
 		for (j = 0; j < RateIdx; j++)
 			if ((SupRate[i] & 0x7f) == RateIdTo500Kbps[j])
@@ -5277,7 +5274,7 @@ BOOLEAN RTMPCheckChannel(IN PRTMP_ADAPTER pAd,
 	UCHAR UpperChannel = 0, LowerChannel = 0;
 	UCHAR NoEffectChannelinList = 0;
 
-	// Find upper and lower channel according to 40MHz current operation.
+	/* Find upper and lower channel according to 40MHz current operation. */
 	if (CentralChannel < Channel) {
 		UpperChannel = Channel;
 		if (CentralChannel > 2)
@@ -5331,11 +5328,11 @@ BOOLEAN RTMPCheckHt(IN PRTMP_ADAPTER pAd,
 	if (Wcid >= MAX_LEN_OF_MAC_TABLE)
 		return FALSE;
 
-	// If use AMSDU, set flag.
+	/* If use AMSDU, set flag. */
 	if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable)
 		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
 				       fCLIENT_STATUS_AMSDU_INUSED);
-	// Save Peer Capability
+	/* Save Peer Capability */
 	if (pHtCapability->HtCapInfo.ShortGIfor20)
 		CLIENT_STATUS_SET_FLAG(&pAd->MacTab.Content[Wcid],
 				       fCLIENT_STATUS_SGI20_CAPABLE);
@@ -5357,7 +5354,7 @@ BOOLEAN RTMPCheckHt(IN PRTMP_ADAPTER pAd,
 		pAd->MacTab.Content[Wcid].MpduDensity =
 		    pHtCapability->HtCapParm.MpduDensity;
 	}
-	// Will check ChannelWidth for MCSSet[4] below
+	/* Will check ChannelWidth for MCSSet[4] below */
 	pAd->MlmeAux.HtCapability.MCSSet[4] = 0x1;
 	switch (pAd->CommonCfg.RxStream) {
 	case 1:
@@ -5396,7 +5393,7 @@ BOOLEAN RTMPCheckHt(IN PRTMP_ADAPTER pAd,
 	pAd->MlmeAux.HtCapability.HtCapInfo.GF =
 	    pHtCapability->HtCapInfo.GF & pAd->CommonCfg.DesiredHtPhy.GF;
 
-	// Send Assoc Req with my HT capability.
+	/* Send Assoc Req with my HT capability. */
 	pAd->MlmeAux.HtCapability.HtCapInfo.AMsduSize =
 	    pAd->CommonCfg.DesiredHtPhy.AmsduSize;
 	pAd->MlmeAux.HtCapability.HtCapInfo.MimoPs =
@@ -5430,7 +5427,7 @@ BOOLEAN RTMPCheckHt(IN PRTMP_ADAPTER pAd,
 	}
 
 	if (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_20)
-		pAd->MlmeAux.HtCapability.MCSSet[4] = 0x0;	// BW20 can't transmit MCS32
+		pAd->MlmeAux.HtCapability.MCSSet[4] = 0x0;	/* BW20 can't transmit MCS32 */
 
 	COPY_AP_HTSETTINGS_FROM_BEACON(pAd, pHtCapability);
 	return TRUE;
@@ -5455,8 +5452,8 @@ BOOLEAN RTMPCheckHt(IN PRTMP_ADAPTER pAd,
 VOID RTMPUpdateMlmeRate(IN PRTMP_ADAPTER pAd)
 {
 	UCHAR MinimumRate;
-	UCHAR ProperMlmeRate;	//= RATE_54;
-	UCHAR i, j, RateIdx = 12;	//1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54
+	UCHAR ProperMlmeRate;	/*= RATE_54; */
+	UCHAR i, j, RateIdx = 12;	/*1, 2, 5.5, 11, 6, 9, 12, 18, 24, 36, 48, 54 */
 	BOOLEAN bMatch = FALSE;
 
 	switch (pAd->CommonCfg.PhyMode) {
@@ -5469,7 +5466,7 @@ VOID RTMPUpdateMlmeRate(IN PRTMP_ADAPTER pAd)
 	case PHY_11BGN_MIXED:
 		if ((pAd->MlmeAux.SupRateLen == 4) &&
 		    (pAd->MlmeAux.ExtRateLen == 0))
-			// B only AP
+			/* B only AP */
 			ProperMlmeRate = RATE_11;
 		else
 			ProperMlmeRate = RATE_24;
@@ -5480,7 +5477,7 @@ VOID RTMPUpdateMlmeRate(IN PRTMP_ADAPTER pAd)
 			MinimumRate = RATE_6;
 		break;
 	case PHY_11A:
-	case PHY_11N_2_4G:	// rt2860 need to check mlmerate for 802.11n
+	case PHY_11N_2_4G:	/* rt2860 need to check mlmerate for 802.11n */
 	case PHY_11GN_MIXED:
 	case PHY_11AGN_MIXED:
 	case PHY_11AN_MIXED:
@@ -5495,7 +5492,7 @@ VOID RTMPUpdateMlmeRate(IN PRTMP_ADAPTER pAd)
 		else
 			MinimumRate = RATE_6;
 		break;
-	default:		// error
+	default:		/* error */
 		ProperMlmeRate = RATE_1;
 		MinimumRate = RATE_1;
 		break;
@@ -5609,16 +5606,16 @@ VOID AsicEvaluateRxAnt(IN PRTMP_ADAPTER pAd)
 	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
 #ifdef RT30xx
 	    || (pAd->EepromAccess)
-#endif // RT30xx //
+#endif /* RT30xx // */
 #ifdef RT3090
 	    || (pAd->bPCIclkOff == TRUE)
-#endif // RT3090 //
+#endif /* RT3090 // */
 	    )
 		return;
 
 	{
-		//if (pAd->StaCfg.Psm == PWR_SAVE)
-		//      return;
+		/*if (pAd->StaCfg.Psm == PWR_SAVE) */
+		/*      return; */
 
 		{
 
@@ -5637,7 +5634,7 @@ VOID AsicEvaluateRxAnt(IN PRTMP_ADAPTER pAd)
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
 #ifdef RTMP_MAC_PCI
 			pAd->StaCfg.BBPR3 = BBPR3;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 			if (OPSTATUS_TEST_FLAG
 			    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
 			    ) {
@@ -5646,7 +5643,7 @@ VOID AsicEvaluateRxAnt(IN PRTMP_ADAPTER pAd)
 				    pAd->RalinkCounters.OneSecTxRetryOkCount +
 				    pAd->RalinkCounters.OneSecTxFailCount;
 
-				// dynamic adjust antenna evaluation period according to the traffic
+				/* dynamic adjust antenna evaluation period according to the traffic */
 				if (TxTotalCnt > 50) {
 					RTMPSetTimer(&pAd->Mlme.RxAntEvalTimer,
 						     20);
@@ -5691,21 +5688,21 @@ VOID AsicRxAntEvalTimeout(IN PVOID SystemSpecific1,
 	    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
 #ifdef RT30xx
 	    || (pAd->EepromAccess)
-#endif // RT30xx //
+#endif /* RT30xx // */
 #ifdef RT3090
 	    || (pAd->bPCIclkOff == TRUE)
-#endif // RT3090 //
+#endif /* RT3090 // */
 	    )
 		return;
 
 	{
-		//if (pAd->StaCfg.Psm == PWR_SAVE)
-		//      return;
+		/*if (pAd->StaCfg.Psm == PWR_SAVE) */
+		/*      return; */
 		{
 			if (pAd->StaCfg.Psm == PWR_SAVE)
 				return;
 
-			// if the traffic is low, use average rssi as the criteria
+			/* if the traffic is low, use average rssi as the criteria */
 			if (pAd->Mlme.bLowThroughput == TRUE) {
 				rssi0 = pAd->StaCfg.RssiSample.LastRssi0;
 				rssi1 = pAd->StaCfg.RssiSample.LastRssi1;
@@ -5742,7 +5739,7 @@ VOID AsicRxAntEvalTimeout(IN PVOID SystemSpecific1,
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
 #ifdef RTMP_MAC_PCI
 			pAd->StaCfg.BBPR3 = BBPR3;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 		}
 	}
 
@@ -5759,7 +5756,7 @@ VOID APSDPeriodicExec(IN PVOID SystemSpecific1,
 
 	pAd->CommonCfg.TriggerTimerCount++;
 
-// Driver should not send trigger frame, it should be send by application layer
+/* Driver should not send trigger frame, it should be send by application layer */
 /*
 	if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable
 		&& (pAd->CommonCfg.bNeedSendTriggerFrame ||
@@ -5818,7 +5815,7 @@ BOOLEAN RTMPCheckEntryEnableAutoRateSwitch(IN PRTMP_ADAPTER pAd,
 	BOOLEAN result = TRUE;
 
 	{
-		// only associated STA counts
+		/* only associated STA counts */
 		if (pEntry && (pEntry->ValidAsCLI)
 		    && (pEntry->Sst == SST_ASSOC)) {
 			result = pAd->StaCfg.bAutoTxRateSwitch;
@@ -5895,12 +5892,12 @@ VOID RTMPUpdateLegacyTxSetting(UCHAR fixed_tx_mode, PMAC_TABLE_ENTRY pEntry)
 
 	if (fixed_tx_mode == FIXED_TXMODE_CCK) {
 		TransmitSetting.field.MODE = MODE_CCK;
-		// CCK mode allow MCS 0~3
+		/* CCK mode allow MCS 0~3 */
 		if (TransmitSetting.field.MCS > MCS_3)
 			TransmitSetting.field.MCS = MCS_3;
 	} else {
 		TransmitSetting.field.MODE = MODE_OFDM;
-		// OFDM mode allow MCS 0~7
+		/* OFDM mode allow MCS 0~7 */
 		if (TransmitSetting.field.MCS > MCS_7)
 			TransmitSetting.field.MCS = MCS_7;
 	}
@@ -5926,17 +5923,17 @@ VOID RTMPUpdateLegacyTxSetting(UCHAR fixed_tx_mode, PMAC_TABLE_ENTRY pEntry)
  */
 VOID AsicStaBbpTuning(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR OrigR66Value = 0, R66;	//, R66UpperBound = 0x30, R66LowerBound = 0x30;
+	UCHAR OrigR66Value = 0, R66;	/*, R66UpperBound = 0x30, R66LowerBound = 0x30; */
 	CHAR Rssi;
 
-	// 2860C did not support Fase CCA, therefore can't tune
+	/* 2860C did not support Fase CCA, therefore can't tune */
 	if (pAd->MACVersion == 0x28600100)
 		return;
 
-	//
-	// work as a STA
-	//
-	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)	// no R66 tuning when SCANNING
+	/* */
+	/* work as a STA */
+	/* */
+	if (pAd->Mlme.CntlMachine.CurrState != CNTL_IDLE)	/* no R66 tuning when SCANNING */
 		return;
 
 	if ((pAd->OpMode == OPMODE_STA)
@@ -5945,7 +5942,7 @@ VOID AsicStaBbpTuning(IN PRTMP_ADAPTER pAd)
 	    && !(OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
 #ifdef RTMP_MAC_PCI
 	    && (pAd->bPCIclkOff == FALSE)
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 	    ) {
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &OrigR66Value);
 		R66 = OrigR66Value;
@@ -5957,10 +5954,10 @@ VOID AsicStaBbpTuning(IN PRTMP_ADAPTER pAd)
 		else
 			Rssi = pAd->StaCfg.RssiSample.AvgRssi0;
 
-		if (pAd->LatchRfRegs.Channel <= 14) {	//BG band
+		if (pAd->LatchRfRegs.Channel <= 14) {	/*BG band */
 #ifdef RT30xx
-			// RT3070 is a no LNA solution, it should have different control regarding to AGC gain control
-			// Otherwise, it will have some throughput side effect when low RSSI
+			/* RT3070 is a no LNA solution, it should have different control regarding to AGC gain control */
+			/* Otherwise, it will have some throughput side effect when low RSSI */
 
 			if (IS_RT3070(pAd) || IS_RT3090(pAd) || IS_RT3572(pAd)
 			    || IS_RT3390(pAd)) {
@@ -5979,7 +5976,7 @@ VOID AsicStaBbpTuning(IN PRTMP_ADAPTER pAd)
 					}
 				}
 			} else
-#endif // RT30xx //
+#endif /* RT30xx // */
 			{
 				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
 					R66 = (0x2E + GET_LNA_GAIN(pAd)) + 0x10;
@@ -5995,7 +5992,7 @@ VOID AsicStaBbpTuning(IN PRTMP_ADAPTER pAd)
 					}
 				}
 			}
-		} else {	//A band
+		} else {	/*A band */
 			if (pAd->CommonCfg.BBPCurrentBW == BW_20) {
 				if (Rssi > RSSI_FOR_MID_LOW_SENSIBILITY) {
 					R66 =
@@ -6040,7 +6037,7 @@ VOID RTMPSetAGCInitValue(IN PRTMP_ADAPTER pAd, IN UCHAR BandWidth)
 {
 	UCHAR R66 = 0x30;
 
-	if (pAd->LatchRfRegs.Channel <= 14) {	// BG band
+	if (pAd->LatchRfRegs.Channel <= 14) {	/* BG band */
 #ifdef RT30xx
 		/* Gary was verified Amazon AP and find that RT307x has BBP_R66 invalid default value */
 
@@ -6049,12 +6046,12 @@ VOID RTMPSetAGCInitValue(IN PRTMP_ADAPTER pAd, IN UCHAR BandWidth)
 			R66 = 0x1C + 2 * GET_LNA_GAIN(pAd);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
 		} else
-#endif // RT30xx //
+#endif /* RT30xx // */
 		{
 			R66 = 0x2E + GET_LNA_GAIN(pAd);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R66, R66);
 		}
-	} else {		//A band
+	} else {		/*A band */
 		{
 			if (BandWidth == BW_20) {
 				R66 =
diff --git a/drivers/staging/rt2860/common/rt_channel.c b/drivers/staging/rt2860/common/rt_channel.c
index cc45a08..0af7e6b 100644
--- a/drivers/staging/rt2860/common/rt_channel.c
+++ b/drivers/staging/rt2860/common/rt_channel.c
@@ -147,1276 +147,1276 @@ CH_FREQ_MAP CH_HZ_ID_MAP[] = {
 INT CH_HZ_ID_MAP_NUM = (sizeof(CH_HZ_ID_MAP) / sizeof(CH_FREQ_MAP));
 
 CH_REGION ChRegion[] = {
-	{			// Antigua and Berbuda
+	{			/* Antigua and Berbuda */
 	 "AG",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Argentina
+	{			/* Argentina */
 	 "AR",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Aruba
+	{			/* Aruba */
 	 "AW",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Australia
+	{			/* Australia */
 	 "AU",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 5, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Austria
+	{			/* Austria */
 	 "AT",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Bahamas
+	{			/* Bahamas */
 	 "BS",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 5, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Barbados
+	{			/* Barbados */
 	 "BB",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Bermuda
+	{			/* Bermuda */
 	 "BM",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Brazil
+	{			/* Brazil */
 	 "BR",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 24, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {149, 5, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Belgium
+	{			/* Belgium */
 	 "BE",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 18, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 18, IDOR, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Bulgaria
+	{			/* Bulgaria */
 	 "BG",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, ODOR, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Canada
+	{			/* Canada */
 	 "CA",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 5, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Cayman IsLands
+	{			/* Cayman IsLands */
 	 "KY",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Chile
+	{			/* Chile */
 	 "CL",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 5, 20, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// China
+	{			/* China */
 	 "CN",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {149, 4, 27, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Colombia
+	{			/* Colombia */
 	 "CO",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 17, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {149, 5, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Costa Rica
+	{			/* Costa Rica */
 	 "CR",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 17, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Cyprus
+	{			/* Cyprus */
 	 "CY",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Czech_Republic
+	{			/* Czech_Republic */
 	 "CZ",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Denmark
+	{			/* Denmark */
 	 "DK",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Dominican Republic
+	{			/* Dominican Republic */
 	 "DO",
 	 CE,
 	 {
 	  {1, 0, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 0
+	  ,			/* 2.4 G, ch 0 */
 	  {149, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Equador
+	{			/* Equador */
 	 "EC",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {100, 11, 27, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// El Salvador
+	{			/* El Salvador */
 	 "SV",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 30, BOTH, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 36, BOTH, TRUE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Finland
+	{			/* Finland */
 	 "FI",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// France
+	{			/* France */
 	 "FR",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Germany
+	{			/* Germany */
 	 "DE",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Greece
+	{			/* Greece */
 	 "GR",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, ODOR, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Guam
+	{			/* Guam */
 	 "GU",
 	 CE,
 	 {
 	  {1, 11, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {36, 4, 17, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {149, 5, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Guatemala
+	{			/* Guatemala */
 	 "GT",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 17, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Haiti
+	{			/* Haiti */
 	 "HT",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 17, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Honduras
+	{			/* Honduras */
 	 "HN",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {149, 4, 27, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Hong Kong
+	{			/* Hong Kong */
 	 "HK",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Hungary
+	{			/* Hungary */
 	 "HU",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Iceland
+	{			/* Iceland */
 	 "IS",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// India
+	{			/* India */
 	 "IN",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {149, 4, 24, IDOR, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Indonesia
+	{			/* Indonesia */
 	 "ID",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {149, 4, 27, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Ireland
+	{			/* Ireland */
 	 "IE",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, ODOR, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Israel
+	{			/* Israel */
 	 "IL",
 	 CE,
 	 {
 	  {1, 3, 20, IDOR, FALSE}
-	  ,			// 2.4 G, ch 1~3
+	  ,			/* 2.4 G, ch 1~3 */
 	  {4, 6, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 4~9
+	  ,			/* 2.4 G, ch 4~9 */
 	  {10, 4, 20, IDOR, FALSE}
-	  ,			// 2.4 G, ch 10~13
+	  ,			/* 2.4 G, ch 10~13 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Italy
+	{			/* Italy */
 	 "IT",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, ODOR, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Japan
+	{			/* Japan */
 	 "JP",
 	 JAP,
 	 {
 	  {1, 14, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~14
+	  ,			/* 2.4 G, ch 1~14 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Jordan
+	{			/* Jordan */
 	 "JO",
 	 CE,
 	 {
 	  {1, 13, 20, IDOR, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {149, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Latvia
+	{			/* Latvia */
 	 "LV",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Liechtenstein
+	{			/* Liechtenstein */
 	 "LI",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Lithuania
+	{			/* Lithuania */
 	 "LT",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Luxemburg
+	{			/* Luxemburg */
 	 "LU",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Malaysia
+	{			/* Malaysia */
 	 "MY",
 	 CE,
 	 {
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 5, 20, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Malta
+	{			/* Malta */
 	 "MT",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Marocco
+	{			/* Marocco */
 	 "MA",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 24, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Mexico
+	{			/* Mexico */
 	 "MX",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 5, 30, IDOR, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Netherlands
+	{			/* Netherlands */
 	 "NL",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// New Zealand
+	{			/* New Zealand */
 	 "NZ",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Norway
+	{			/* Norway */
 	 "NO",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 24, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 24, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Peru
+	{			/* Peru */
 	 "PE",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {149, 4, 27, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Portugal
+	{			/* Portugal */
 	 "PT",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Poland
+	{			/* Poland */
 	 "PL",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Romania
+	{			/* Romania */
 	 "RO",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Russia
+	{			/* Russia */
 	 "RU",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {149, 4, 20, IDOR, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Saudi Arabia
+	{			/* Saudi Arabia */
 	 "SA",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Serbia_and_Montenegro
+	{			/* Serbia_and_Montenegro */
 	 "CS",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Singapore
+	{			/* Singapore */
 	 "SG",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {149, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Slovakia
+	{			/* Slovakia */
 	 "SK",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Slovenia
+	{			/* Slovenia */
 	 "SI",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// South Africa
+	{			/* South Africa */
 	 "ZA",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {149, 4, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// South Korea
+	{			/* South Korea */
 	 "KR",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 8, 20, BOTH, FALSE}
-	  ,			// 5G, ch 100~128
+	  ,			/* 5G, ch 100~128 */
 	  {149, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Spain
+	{			/* Spain */
 	 "ES",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 17, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Sweden
+	{			/* Sweden */
 	 "SE",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Switzerland
+	{			/* Switzerland */
 	 "CH",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~13
+	  ,			/* 2.4 G, ch 1~13 */
 	  {36, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Taiwan
+	{			/* Taiwan */
 	 "TW",
 	 CE,
 	 {
 	  {1, 11, 30, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {52, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Turkey
+	{			/* Turkey */
 	 "TR",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {36, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 36~48
+	  ,			/* 5G, ch 36~48 */
 	  {52, 4, 23, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// UK
+	{			/* UK */
 	 "GB",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {36, 4, 23, IDOR, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {52, 4, 23, IDOR, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Ukraine
+	{			/* Ukraine */
 	 "UA",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// United_Arab_Emirates
+	{			/* United_Arab_Emirates */
 	 "AE",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// United_States
+	{			/* United_States */
 	 "US",
 	 CE,
 	 {
 	  {1, 11, 30, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {36, 4, 17, IDOR, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {52, 4, 24, BOTH, TRUE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 30, BOTH, TRUE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {149, 5, 30, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Venezuela
+	{			/* Venezuela */
 	 "VE",
 	 CE,
 	 {
 	  {1, 13, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {149, 4, 27, BOTH, FALSE}
-	  ,			// 5G, ch 149~161
+	  ,			/* 5G, ch 149~161 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
 
-	{			// Default
+	{			/* Default */
 	 "",
 	 CE,
 	 {
 	  {1, 11, 20, BOTH, FALSE}
-	  ,			// 2.4 G, ch 1~11
+	  ,			/* 2.4 G, ch 1~11 */
 	  {36, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {52, 4, 20, BOTH, FALSE}
-	  ,			// 5G, ch 52~64
+	  ,			/* 5G, ch 52~64 */
 	  {100, 11, 20, BOTH, FALSE}
-	  ,			// 5G, ch 100~140
+	  ,			/* 5G, ch 100~140 */
 	  {149, 5, 20, BOTH, FALSE}
-	  ,			// 5G, ch 149~165
+	  ,			/* 5G, ch 149~165 */
 	  {0}
-	  ,			// end
+	  ,			/* end */
 	  }
 	 }
 	,
@@ -1610,7 +1610,7 @@ static UCHAR GetExtCh(IN UCHAR Channel, IN UCHAR Direction)
 
 VOID N_ChannelCheck(IN PRTMP_ADAPTER pAd)
 {
-	//UCHAR ChannelNum = pAd->ChannelListNum;
+	/*UCHAR ChannelNum = pAd->ChannelListNum; */
 	UCHAR Channel = pAd->CommonCfg.Channel;
 
 	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
@@ -1663,7 +1663,7 @@ VOID N_ChannelCheck(IN PRTMP_ADAPTER pAd)
 			if (Channel == 14) {
 				pAd->CommonCfg.RegTransmitSetting.field.BW =
 				    BW_20;
-				//pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_NONE; // We didn't set the ExtCh as NONE due to it'll set in RTMPSetHT()
+				/*pAd->CommonCfg.RegTransmitSetting.field.EXTCHA = EXTCHA_NONE; // We didn't set the ExtCh as NONE due to it'll set in RTMPSetHT() */
 			}
 		}
 	}
diff --git a/drivers/staging/rt2860/common/rt_rf.c b/drivers/staging/rt2860/common/rt_rf.c
index b6e47a1..8b5be17 100644
--- a/drivers/staging/rt2860/common/rt_rf.c
+++ b/drivers/staging/rt2860/common/rt_rf.c
@@ -172,7 +172,7 @@ VOID RtmpChipOpsRFHook(IN RTMP_ADAPTER * pAd)
 				    RT30xxReverseRFSleepModeSetup;
 			}
 		}
-#endif // RT3070 //
+#endif /* RT3070 // */
 #ifdef RT3090
 		if (IS_RT3090(pAd) && (pAd->infType == RTMP_DEV_INF_PCI)) {
 			pChipOps->AsicRfTurnOff = RT30xxLoadRFSleepModeSetup;
@@ -180,9 +180,9 @@ VOID RtmpChipOpsRFHook(IN RTMP_ADAPTER * pAd)
 			pChipOps->AsicReverseRfFromSleepMode =
 			    RT30xxReverseRFSleepModeSetup;
 		}
-#endif // RT3090 //
+#endif /* RT3090 // */
 	}
-#endif // RT30xx //
+#endif /* RT30xx // */
 }
 
-#endif // RTMP_RF_RW_SUPPORT //
+#endif /* RTMP_RF_RW_SUPPORT // */
diff --git a/drivers/staging/rt2860/common/rtmp_init.c b/drivers/staging/rt2860/common/rtmp_init.c
index c169641..0a95870 100644
--- a/drivers/staging/rt2860/common/rtmp_init.c
+++ b/drivers/staging/rt2860/common/rtmp_init.c
@@ -40,32 +40,32 @@ UCHAR BIT8[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
 char *CipherName[] =
     { "none", "wep64", "wep128", "TKIP", "AES", "CKIP64", "CKIP128" };
 
-//
-// BBP register initialization set
-//
+/* */
+/* BBP register initialization set */
+/* */
 REG_PAIR BBPRegTable[] = {
-	{BBP_R65, 0x2C},	// fix rssi issue
-	{BBP_R66, 0x38},	// Also set this default value to pAd->BbpTuning.R66CurrentValue at initial
+	{BBP_R65, 0x2C},	/* fix rssi issue */
+	{BBP_R66, 0x38},	/* Also set this default value to pAd->BbpTuning.R66CurrentValue at initial */
 	{BBP_R69, 0x12},
-	{BBP_R70, 0xa},		// BBP_R70 will change to 0x8 in ApStartUp and LinkUp for rt2860C, otherwise value is 0xa
+	{BBP_R70, 0xa},		/* BBP_R70 will change to 0x8 in ApStartUp and LinkUp for rt2860C, otherwise value is 0xa */
 	{BBP_R73, 0x10},
 	{BBP_R81, 0x37},
 	{BBP_R82, 0x62},
 	{BBP_R83, 0x6A},
-	{BBP_R84, 0x99},	// 0x19 is for rt2860E and after. This is for extension channel overlapping IOT. 0x99 is for rt2860D and before
-	{BBP_R86, 0x00},	// middle range issue, Rory @2008-01-28
-	{BBP_R91, 0x04},	// middle range issue, Rory @2008-01-28
-	{BBP_R92, 0x00},	// middle range issue, Rory @2008-01-28
-	{BBP_R103, 0x00},	// near range high-power issue, requested from Gary @2008-0528
-	{BBP_R105, 0x05},	// 0x05 is for rt2860E to turn on FEQ control. It is safe for rt2860D and before, because Bit 7:2 are reserved in rt2860D and before.
-	{BBP_R106, 0x35},	// for ShortGI throughput
+	{BBP_R84, 0x99},	/* 0x19 is for rt2860E and after. This is for extension channel overlapping IOT. 0x99 is for rt2860D and before */
+	{BBP_R86, 0x00},	/* middle range issue, Rory @2008-01-28 */
+	{BBP_R91, 0x04},	/* middle range issue, Rory @2008-01-28 */
+	{BBP_R92, 0x00},	/* middle range issue, Rory @2008-01-28 */
+	{BBP_R103, 0x00},	/* near range high-power issue, requested from Gary @2008-0528 */
+	{BBP_R105, 0x05},	/* 0x05 is for rt2860E to turn on FEQ control. It is safe for rt2860D and before, because Bit 7:2 are reserved in rt2860D and before. */
+	{BBP_R106, 0x35},	/* for ShortGI throughput */
 };
 
 #define	NUM_BBP_REG_PARMS	(sizeof(BBPRegTable) / sizeof(REG_PAIR))
 
-//
-// ASIC register initialization sets
-//
+/* */
+/* ASIC register initialization sets */
+/* */
 
 RTMP_REG_PAIR MACRegTable[] = {
 #if defined(HW_BEACON_OFFSET) && (HW_BEACON_OFFSET == 0x200)
@@ -76,43 +76,43 @@ RTMP_REG_PAIR MACRegTable[] = {
 	{BCN_OFFSET1, 0xfcf8f4f0},	/* 0x3800, 0x3A00, 0x3C00, 0x3E00, 512B for each beacon */
 #else
 #error You must re-calculate new value for BCN_OFFSET0 & BCN_OFFSET1 in MACRegTable[]!!!
-#endif // HW_BEACON_OFFSET //
-
-	{LEGACY_BASIC_RATE, 0x0000013f},	//  Basic rate set bitmap
-	{HT_BASIC_RATE, 0x00008003},	// Basic HT rate set , 20M, MCS=3, MM. Format is the same as in TXWI.
-	{MAC_SYS_CTRL, 0x00},	// 0x1004, , default Disable RX
-	{RX_FILTR_CFG, 0x17f97},	//0x1400  , RX filter control,
-	{BKOFF_SLOT_CFG, 0x209},	// default set short slot time, CC_DELAY_TIME should be 2
-	//{TX_SW_CFG0,          0x40a06}, // Gary,2006-08-23
-	{TX_SW_CFG0, 0x0},	// Gary,2008-05-21 for CWC test
-	{TX_SW_CFG1, 0x80606},	// Gary,2006-08-23
-	{TX_LINK_CFG, 0x1020},	// Gary,2006-08-23
-	//{TX_TIMEOUT_CFG,      0x00182090},    // CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT
-	{TX_TIMEOUT_CFG, 0x000a2090},	// CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT , Modify for 2860E ,2007-08-01
-	{MAX_LEN_CFG, MAX_AGGREGATION_SIZE | 0x00001000},	// 0x3018, MAX frame length. Max PSDU = 16kbytes.
-	{LED_CFG, 0x7f031e46},	// Gary, 2006-08-23
-
-	{PBF_MAX_PCNT, 0x1F3FBF9F},	//0x1F3f7f9f},          //Jan, 2006/04/20
-
-	{TX_RTY_CFG, 0x47d01f0f},	// Jan, 2006/11/16, Set TxWI->ACK =0 in Probe Rsp Modify for 2860E ,2007-08-03
-
-	{AUTO_RSP_CFG, 0x00000013},	// Initial Auto_Responder, because QA will turn off Auto-Responder
-	{CCK_PROT_CFG, 0x05740003 /*0x01740003 */ },	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
-	{OFDM_PROT_CFG, 0x05740003 /*0x01740003 */ },	// Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled.
+#endif /* HW_BEACON_OFFSET // */
+
+	{LEGACY_BASIC_RATE, 0x0000013f},	/*  Basic rate set bitmap */
+	{HT_BASIC_RATE, 0x00008003},	/* Basic HT rate set , 20M, MCS=3, MM. Format is the same as in TXWI. */
+	{MAC_SYS_CTRL, 0x00},	/* 0x1004, , default Disable RX */
+	{RX_FILTR_CFG, 0x17f97},	/*0x1400  , RX filter control, */
+	{BKOFF_SLOT_CFG, 0x209},	/* default set short slot time, CC_DELAY_TIME should be 2 */
+	/*{TX_SW_CFG0,          0x40a06}, // Gary,2006-08-23 */
+	{TX_SW_CFG0, 0x0},	/* Gary,2008-05-21 for CWC test */
+	{TX_SW_CFG1, 0x80606},	/* Gary,2006-08-23 */
+	{TX_LINK_CFG, 0x1020},	/* Gary,2006-08-23 */
+	/*{TX_TIMEOUT_CFG,      0x00182090},    // CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT */
+	{TX_TIMEOUT_CFG, 0x000a2090},	/* CCK has some problem. So increase timieout value. 2006-10-09// MArvek RT , Modify for 2860E ,2007-08-01 */
+	{MAX_LEN_CFG, MAX_AGGREGATION_SIZE | 0x00001000},	/* 0x3018, MAX frame length. Max PSDU = 16kbytes. */
+	{LED_CFG, 0x7f031e46},	/* Gary, 2006-08-23 */
+
+	{PBF_MAX_PCNT, 0x1F3FBF9F},	/*0x1F3f7f9f},          //Jan, 2006/04/20 */
+
+	{TX_RTY_CFG, 0x47d01f0f},	/* Jan, 2006/11/16, Set TxWI->ACK =0 in Probe Rsp Modify for 2860E ,2007-08-03 */
+
+	{AUTO_RSP_CFG, 0x00000013},	/* Initial Auto_Responder, because QA will turn off Auto-Responder */
+	{CCK_PROT_CFG, 0x05740003 /*0x01740003 */ },	/* Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled. */
+	{OFDM_PROT_CFG, 0x05740003 /*0x01740003 */ },	/* Initial Auto_Responder, because QA will turn off Auto-Responder. And RTS threshold is enabled. */
 #ifdef RTMP_MAC_USB
-	{PBF_CFG, 0xf40006},	// Only enable Queue 2
-	{MM40_PROT_CFG, 0x3F44084},	// Initial Auto_Responder, because QA will turn off Auto-Responder
+	{PBF_CFG, 0xf40006},	/* Only enable Queue 2 */
+	{MM40_PROT_CFG, 0x3F44084},	/* Initial Auto_Responder, because QA will turn off Auto-Responder */
 	{WPDMA_GLO_CFG, 0x00000030},
-#endif // RTMP_MAC_USB //
-	{GF20_PROT_CFG, 0x01744004},	// set 19:18 --> Short NAV for MIMO PS
+#endif /* RTMP_MAC_USB // */
+	{GF20_PROT_CFG, 0x01744004},	/* set 19:18 --> Short NAV for MIMO PS */
 	{GF40_PROT_CFG, 0x03F44084},
 	{MM20_PROT_CFG, 0x01744004},
 #ifdef RTMP_MAC_PCI
 	{MM40_PROT_CFG, 0x03F54084},
-#endif // RTMP_MAC_PCI //
-	{TXOP_CTRL_CFG, 0x0000583f, /*0x0000243f *//*0x000024bf */ },	//Extension channel backoff.
+#endif /* RTMP_MAC_PCI // */
+	{TXOP_CTRL_CFG, 0x0000583f, /*0x0000243f *//*0x000024bf */ },	/*Extension channel backoff. */
 	{TX_RTS_CFG, 0x00092b20},
-	{EXP_ACK_TIME, 0x002400ca},	// default value
+	{EXP_ACK_TIME, 0x002400ca},	/* default value */
 
 	{TXOP_HLDR_ET, 0x00000002},
 
@@ -121,7 +121,7 @@ RTMP_REG_PAIR MACRegTable[] = {
 	   and beacon1 is SIFS (10us), so if INTEL 2200bg card connects to BSS0, the ping
 	   will always lost. So we change the SIFS of CCK from 10us to 16us. */
 	{XIFS_TIME_CFG, 0x33a41010},
-	{PWR_PIN_CFG, 0x00000003},	// patch for 2880-E
+	{PWR_PIN_CFG, 0x00000003},	/* patch for 2880-E */
 };
 
 RTMP_REG_PAIR STAMACRegTable[] = {
@@ -165,7 +165,7 @@ NDIS_STATUS RTMPAllocAdapterBlock(IN PVOID handle,
 	*ppAdapter = NULL;
 
 	do {
-		// Allocate RTMP_ADAPTER memory block
+		/* Allocate RTMP_ADAPTER memory block */
 		pBeaconBuf = kmalloc(MAX_BEACON_SIZE, MEM_ALLOC_FLAG);
 		if (pBeaconBuf == NULL) {
 			Status = NDIS_STATUS_FAILURE;
@@ -184,14 +184,14 @@ NDIS_STATUS RTMPAllocAdapterBlock(IN PVOID handle,
 			 ("\n\n=== pAd = %p, size = %d ===\n\n", pAd,
 			  (UINT32) sizeof(RTMP_ADAPTER)));
 
-		// Init spin locks
+		/* Init spin locks */
 		NdisAllocateSpinLock(&pAd->MgmtRingLock);
 #ifdef RTMP_MAC_PCI
 		NdisAllocateSpinLock(&pAd->RxRingLock);
 #ifdef RT3090
 		NdisAllocateSpinLock(&pAd->McuCmdLock);
-#endif // RT3090 //
-#endif // RTMP_MAC_PCI //
+#endif /* RT3090 // */
+#endif /* RTMP_MAC_PCI // */
 
 		for (index = 0; index < NUM_OF_TX_RING; index++) {
 			NdisAllocateSpinLock(&pAd->TxSwQueueLock[index]);
@@ -238,9 +238,9 @@ VOID RTMPReadTxPwrPerRate(IN PRTMP_ADAPTER pAd)
 	UCHAR t1, t2, t3, t4;
 	BOOLEAN bApwrdeltaMinus = TRUE, bGpwrdeltaMinus = TRUE;
 
-	//
-	// Get power delta for 20MHz and 40MHz.
-	//
+	/* */
+	/* Get power delta for 20MHz and 40MHz. */
+	/* */
 	DBGPRINT(RT_DEBUG_TRACE, ("Txpower per Rate\n"));
 	RT28xx_EEPROM_READ16(pAd, EEPROM_TXPOWER_DELTA, value2);
 	Apwrdelta = 0;
@@ -267,9 +267,9 @@ VOID RTMPReadTxPwrPerRate(IN PRTMP_ADAPTER pAd)
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("Gpwrdelta = %x, Apwrdelta = %x .\n", Gpwrdelta, Apwrdelta));
 
-	//
-	// Get Txpower per MCS for 20MHz in 2.4G.
-	//
+	/* */
+	/* Get Txpower per MCS for 20MHz in 2.4G. */
+	/* */
 	for (i = 0; i < 5; i++) {
 		RT28xx_EEPROM_READ16(pAd,
 				     EEPROM_TXPOWER_BYRATE_20MHZ_2_4G + i * 4,
@@ -447,12 +447,12 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 	EEPROM_TX_PWR_STRUC Power;
 	EEPROM_TX_PWR_STRUC Power2;
 
-	// Read Tx power value for all channels
-	// Value from 1 - 0x7f. Default value is 24.
-	// Power value : 2.4G 0x00 (0) ~ 0x1F (31)
-	//             : 5.5G 0xF9 (-7) ~ 0x0F (15)
+	/* Read Tx power value for all channels */
+	/* Value from 1 - 0x7f. Default value is 24. */
+	/* Power value : 2.4G 0x00 (0) ~ 0x1F (31) */
+	/*             : 5.5G 0xF9 (-7) ~ 0x0F (15) */
 
-	// 0. 11b/g, ch1 - ch 14
+	/* 0. 11b/g, ch1 - ch 14 */
 	for (i = 0; i < 7; i++) {
 		RT28xx_EEPROM_READ16(pAd, EEPROM_G_TX_PWR_OFFSET + i * 2,
 				     Power.word);
@@ -482,8 +482,8 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 			pAd->TxPower[i * 2 + 1].Power2 = Power2.field.Byte1;
 	}
 
-	// 1. U-NII lower/middle band: 36, 38, 40; 44, 46, 48; 52, 54, 56; 60, 62, 64 (including central frequency in BW 40MHz)
-	// 1.1 Fill up channel
+	/* 1. U-NII lower/middle band: 36, 38, 40; 44, 46, 48; 52, 54, 56; 60, 62, 64 (including central frequency in BW 40MHz) */
+	/* 1.1 Fill up channel */
 	choffset = 14;
 	for (i = 0; i < 4; i++) {
 		pAd->TxPower[3 * i + choffset + 0].Channel = 36 + i * 8 + 0;
@@ -499,7 +499,7 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 		pAd->TxPower[3 * i + choffset + 2].Power2 = DEFAULT_RF_TX_POWER;
 	}
 
-	// 1.2 Fill up power
+	/* 1.2 Fill up power */
 	for (i = 0; i < 6; i++) {
 		RT28xx_EEPROM_READ16(pAd, EEPROM_A_TX_PWR_OFFSET + i * 2,
 				     Power.word);
@@ -523,8 +523,8 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 			    Power2.field.Byte1;
 	}
 
-	// 2. HipperLAN 2 100, 102 ,104; 108, 110, 112; 116, 118, 120; 124, 126, 128; 132, 134, 136; 140 (including central frequency in BW 40MHz)
-	// 2.1 Fill up channel
+	/* 2. HipperLAN 2 100, 102 ,104; 108, 110, 112; 116, 118, 120; 124, 126, 128; 132, 134, 136; 140 (including central frequency in BW 40MHz) */
+	/* 2.1 Fill up channel */
 	choffset = 14 + 12;
 	for (i = 0; i < 5; i++) {
 		pAd->TxPower[3 * i + choffset + 0].Channel = 100 + i * 8 + 0;
@@ -543,7 +543,7 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 	pAd->TxPower[3 * 5 + choffset + 0].Power = DEFAULT_RF_TX_POWER;
 	pAd->TxPower[3 * 5 + choffset + 0].Power2 = DEFAULT_RF_TX_POWER;
 
-	// 2.2 Fill up power
+	/* 2.2 Fill up power */
 	for (i = 0; i < 8; i++) {
 		RT28xx_EEPROM_READ16(pAd,
 				     EEPROM_A_TX_PWR_OFFSET + (choffset - 14) +
@@ -569,8 +569,8 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 			    Power2.field.Byte1;
 	}
 
-	// 3. U-NII upper band: 149, 151, 153; 157, 159, 161; 165, 167, 169; 171, 173 (including central frequency in BW 40MHz)
-	// 3.1 Fill up channel
+	/* 3. U-NII upper band: 149, 151, 153; 157, 159, 161; 165, 167, 169; 171, 173 (including central frequency in BW 40MHz) */
+	/* 3.1 Fill up channel */
 	choffset = 14 + 12 + 16;
 	/*for (i = 0; i < 2; i++) */
 	for (i = 0; i < 3; i++) {
@@ -594,7 +594,7 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 	pAd->TxPower[3 * 3 + choffset + 1].Power = DEFAULT_RF_TX_POWER;
 	pAd->TxPower[3 * 3 + choffset + 1].Power2 = DEFAULT_RF_TX_POWER;
 
-	// 3.2 Fill up power
+	/* 3.2 Fill up power */
 	/*for (i = 0; i < 4; i++) */
 	for (i = 0; i < 6; i++) {
 		RT28xx_EEPROM_READ16(pAd,
@@ -621,7 +621,7 @@ VOID RTMPReadChannelPwr(IN PRTMP_ADAPTER pAd)
 			    Power2.field.Byte1;
 	}
 
-	// 4. Print and Debug
+	/* 4. Print and Debug */
 	/*choffset = 14 + 12 + 16 + 7; */
 	choffset = 14 + 12 + 16 + 11;
 
@@ -691,21 +691,21 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 	if (pAd->chipOps.eeinit)
 		pAd->chipOps.eeinit(pAd);
 
-	// Init EEPROM Address Number, before access EEPROM; if 93c46, EEPROMAddressNum=6, else if 93c66, EEPROMAddressNum=8
+	/* Init EEPROM Address Number, before access EEPROM; if 93c46, EEPROMAddressNum=6, else if 93c66, EEPROMAddressNum=8 */
 	RTMP_IO_READ32(pAd, E2PROM_CSR, &data);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> E2PROM_CSR = 0x%x\n", data));
 
 	if ((data & 0x30) == 0)
-		pAd->EEPROMAddressNum = 6;	// 93C46
+		pAd->EEPROMAddressNum = 6;	/* 93C46 */
 	else if ((data & 0x30) == 0x10)
-		pAd->EEPROMAddressNum = 8;	// 93C66
+		pAd->EEPROMAddressNum = 8;	/* 93C66 */
 	else
-		pAd->EEPROMAddressNum = 8;	// 93C86
+		pAd->EEPROMAddressNum = 8;	/* 93C86 */
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("--> EEPROMAddressNum = %d\n", pAd->EEPROMAddressNum));
 
-	// RT2860 MAC no longer auto load MAC address from E2PROM. Driver has to intialize
-	// MAC address registers according to E2PROM setting
+	/* RT2860 MAC no longer auto load MAC address from E2PROM. Driver has to intialize */
+	/* MAC address registers according to E2PROM setting */
 	if (mac_addr == NULL ||
 	    strlen((PSTRING) mac_addr) != 17 ||
 	    mac_addr[2] != ':' || mac_addr[5] != ':' || mac_addr[8] != ':' ||
@@ -741,12 +741,12 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 	}
 
 	{
-		//more conveninet to test mbssid, so ap's bssid &0xf1
+		/*more conveninet to test mbssid, so ap's bssid &0xf1 */
 		if (pAd->PermanentAddress[0] == 0xff)
 			pAd->PermanentAddress[0] = RandomByte(pAd) & 0xf8;
 
-		//if (pAd->PermanentAddress[5] == 0xff)
-		//      pAd->PermanentAddress[5] = RandomByte(pAd)&0xf8;
+		/*if (pAd->PermanentAddress[5] == 0xff) */
+		/*      pAd->PermanentAddress[5] = RandomByte(pAd)&0xf8; */
 
 		DBGPRINT_RAW(RT_DEBUG_TRACE,
 			     ("E2PROM MAC: =%02x:%02x:%02x:%02x:%02x:%02x\n",
@@ -777,12 +777,12 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 		}
 	}
 
-	// if not return early. cause fail at emulation.
-	// Init the channel number for TX channel power
+	/* if not return early. cause fail at emulation. */
+	/* Init the channel number for TX channel power */
 	RTMPReadChannelPwr(pAd);
 
-	// if E2PROM version mismatch with driver's expectation, then skip
-	// all subsequent E2RPOM retieval and set a system error bit to notify GUI
+	/* if E2PROM version mismatch with driver's expectation, then skip */
+	/* all subsequent E2RPOM retieval and set a system error bit to notify GUI */
 	RT28xx_EEPROM_READ16(pAd, EEPROM_VERSION_OFFSET, Version.word);
 	pAd->EepromVersion =
 	    Version.field.Version + Version.field.FaeReleaseNumber * 256;
@@ -811,14 +811,14 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 		   pAd->EEPROMDefaultValue[i] = 0xffff;
 		   return;  */
 	}
-	// Read BBP default value from EEPROM and store to array(EEPROMDefaultValue) in pAd
+	/* Read BBP default value from EEPROM and store to array(EEPROMDefaultValue) in pAd */
 	RT28xx_EEPROM_READ16(pAd, EEPROM_NIC1_OFFSET, value);
 	pAd->EEPROMDefaultValue[0] = value;
 
 	RT28xx_EEPROM_READ16(pAd, EEPROM_NIC2_OFFSET, value);
 	pAd->EEPROMDefaultValue[1] = value;
 
-	RT28xx_EEPROM_READ16(pAd, 0x38, value);	// Country Region
+	RT28xx_EEPROM_READ16(pAd, 0x38, value);	/* Country Region */
 	pAd->EEPROMDefaultValue[2] = value;
 
 	for (i = 0; i < 8; i++) {
@@ -827,10 +827,10 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 		pAd->EEPROMDefaultValue[i + 3] = value;
 	}
 
-	// We have to parse NIC configuration 0 at here.
-	// If TSSI did not have preloaded value, it should reset the TxAutoAgc to false
-	// Therefore, we have to read TxAutoAgc control beforehand.
-	// Read Tx AGC control bit
+	/* We have to parse NIC configuration 0 at here. */
+	/* If TSSI did not have preloaded value, it should reset the TxAutoAgc to false */
+	/* Therefore, we have to read TxAutoAgc control beforehand. */
+	/* Read Tx AGC control bit */
 	Antenna.word = pAd->EEPROMDefaultValue[0];
 	if (Antenna.word == 0xFFFF) {
 #ifdef RT30xx
@@ -840,7 +840,7 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 			Antenna.field.TxPath = 1;
 			Antenna.field.RxPath = 1;
 		} else
-#endif // RT30xx //
+#endif /* RT30xx // */
 		{
 
 			Antenna.word = 0;
@@ -852,7 +852,7 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 				  Antenna.word));
 		}
 	}
-	// Choose the desired Tx&Rx stream.
+	/* Choose the desired Tx&Rx stream. */
 	if ((pAd->CommonCfg.TxStream == 0)
 	    || (pAd->CommonCfg.TxStream > Antenna.field.TxPath))
 		pAd->CommonCfg.TxStream = Antenna.field.TxPath;
@@ -863,13 +863,13 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 
 		if ((pAd->MACVersion < RALINK_2883_VERSION) &&
 		    (pAd->CommonCfg.RxStream > 2)) {
-			// only 2 Rx streams for RT2860 series
+			/* only 2 Rx streams for RT2860 series */
 			pAd->CommonCfg.RxStream = 2;
 		}
 	}
-	// 3*3
-	// read value from EEPROM and set them to CSR174 ~ 177 in chain0 ~ chain2
-	// yet implement
+	/* 3*3 */
+	/* read value from EEPROM and set them to CSR174 ~ 177 in chain0 ~ chain2 */
+	/* yet implement */
 	for (i = 0; i < 3; i++) {
 	}
 
@@ -894,25 +894,25 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 		     ("NICReadEEPROMParameters: RxPath = %d, TxPath = %d\n",
 		      Antenna.field.RxPath, Antenna.field.TxPath));
 
-	// Save the antenna for future use
+	/* Save the antenna for future use */
 	pAd->Antenna.word = Antenna.word;
 
-	// Set the RfICType here, then we can initialize RFIC related operation callbacks
+	/* Set the RfICType here, then we can initialize RFIC related operation callbacks */
 	pAd->Mlme.RealRxPath = (UCHAR) Antenna.field.RxPath;
 	pAd->RfIcType = (UCHAR) Antenna.field.RfIcType;
 
 #ifdef RTMP_RF_RW_SUPPORT
 	RtmpChipOpsRFHook(pAd);
-#endif // RTMP_RF_RW_SUPPORT //
+#endif /* RTMP_RF_RW_SUPPORT // */
 
 #ifdef RTMP_MAC_PCI
 	sprintf((PSTRING) pAd->nickname, "RT2860STA");
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	//
-	// Reset PhyMode if we don't support 802.11a
-	// Only RFIC_2850 & RFIC_2750 support 802.11a
-	//
+	/* */
+	/* Reset PhyMode if we don't support 802.11a */
+	/* Only RFIC_2850 & RFIC_2750 support 802.11a */
+	/* */
 	if ((Antenna.field.RfIcType != RFIC_2850)
 	    && (Antenna.field.RfIcType != RFIC_2750)
 	    && (Antenna.field.RfIcType != RFIC_3052)) {
@@ -925,8 +925,8 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 			 (pAd->CommonCfg.PhyMode == PHY_11N_5G))
 			pAd->CommonCfg.PhyMode = PHY_11BGN_MIXED;
 	}
-	// Read TSSI reference and TSSI boundary for temperature compensation. This is ugly
-	// 0. 11b/g
+	/* Read TSSI reference and TSSI boundary for temperature compensation. This is ugly */
+	/* 0. 11b/g */
 	{
 		/* these are tempature reference value (0x00 ~ 0xFE)
 		   ex: 0x00 0x15 0x25 0x45 0x88 0xA0 0xB5 0xD0 0xF0
@@ -951,7 +951,7 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 		pAd->TssiMinusBoundaryG[0] = pAd->TssiRefG;
 		pAd->TssiPlusBoundaryG[0] = pAd->TssiRefG;
 
-		// Disable TxAgc if the based value is not right
+		/* Disable TxAgc if the based value is not right */
 		if (pAd->TssiRefG == 0xff)
 			pAd->bAutoTxAgcG = FALSE;
 
@@ -965,7 +965,7 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 			  pAd->TssiPlusBoundaryG[3], pAd->TssiPlusBoundaryG[4],
 			  pAd->TxAgcStepG, pAd->bAutoTxAgcG));
 	}
-	// 1. 11a
+	/* 1. 11a */
 	{
 		RT28xx_EEPROM_READ16(pAd, 0xD4, Power.word);
 		pAd->TssiMinusBoundaryA[4] = Power.field.Byte0;
@@ -986,7 +986,7 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 		pAd->TssiMinusBoundaryA[0] = pAd->TssiRefA;
 		pAd->TssiPlusBoundaryA[0] = pAd->TssiRefA;
 
-		// Disable TxAgc if the based value is not right
+		/* Disable TxAgc if the based value is not right */
 		if (pAd->TssiRefA == 0xff)
 			pAd->bAutoTxAgcA = FALSE;
 
@@ -1002,7 +1002,7 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 	}
 	pAd->BbpRssiToDbmDelta = 0x0;
 
-	// Read frequency offset setting for RF
+	/* Read frequency offset setting for RF */
 	RT28xx_EEPROM_READ16(pAd, EEPROM_FREQ_OFFSET, value);
 	if ((value & 0x00FF) != 0x00FF)
 		pAd->RfFreqOffset = (ULONG) (value & 0x00FF);
@@ -1011,9 +1011,9 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("E2PROM: RF FreqOffset=0x%lx \n", pAd->RfFreqOffset));
 
-	//CountryRegion byte offset (38h)
-	value = pAd->EEPROMDefaultValue[2] >> 8;	// 2.4G band
-	value2 = pAd->EEPROMDefaultValue[2] & 0x00FF;	// 5G band
+	/*CountryRegion byte offset (38h) */
+	value = pAd->EEPROMDefaultValue[2] >> 8;	/* 2.4G band */
+	value2 = pAd->EEPROMDefaultValue[2] & 0x00FF;	/* 5G band */
 
 	if ((value <= REGION_MAXIMUM_BG_BAND)
 	    && (value2 <= REGION_MAXIMUM_A_BAND)) {
@@ -1024,10 +1024,10 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 		RTMPSetPhyMode(pAd, TmpPhy);
 		SetCommonHT(pAd);
 	}
-	//
-	// Get RSSI Offset on EEPROM 0x9Ah & 0x9Ch.
-	// The valid value are (-10 ~ 10)
-	//
+	/* */
+	/* Get RSSI Offset on EEPROM 0x9Ah & 0x9Ch. */
+	/* The valid value are (-10 ~ 10) */
+	/* */
 	RT28xx_EEPROM_READ16(pAd, EEPROM_RSSI_BG_OFFSET, value);
 	pAd->BGRssiOffset0 = value & 0x00ff;
 	pAd->BGRssiOffset1 = (value >> 8);
@@ -1038,15 +1038,15 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 	pAd->BLNAGain = value & 0x00ff;
 	pAd->ALNAGain0 = (value >> 8);
 
-	// Validate 11b/g RSSI_0 offset.
+	/* Validate 11b/g RSSI_0 offset. */
 	if ((pAd->BGRssiOffset0 < -10) || (pAd->BGRssiOffset0 > 10))
 		pAd->BGRssiOffset0 = 0;
 
-	// Validate 11b/g RSSI_1 offset.
+	/* Validate 11b/g RSSI_1 offset. */
 	if ((pAd->BGRssiOffset1 < -10) || (pAd->BGRssiOffset1 > 10))
 		pAd->BGRssiOffset1 = 0;
 
-	// Validate 11b/g RSSI_2 offset.
+	/* Validate 11b/g RSSI_2 offset. */
 	if ((pAd->BGRssiOffset2 < -10) || (pAd->BGRssiOffset2 > 10))
 		pAd->BGRssiOffset2 = 0;
 
@@ -1062,25 +1062,25 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 	if (((UCHAR) pAd->ALNAGain2 == 0xFF) || (pAd->ALNAGain2 == 0x00))
 		pAd->ALNAGain2 = pAd->ALNAGain0;
 
-	// Validate 11a RSSI_0 offset.
+	/* Validate 11a RSSI_0 offset. */
 	if ((pAd->ARssiOffset0 < -10) || (pAd->ARssiOffset0 > 10))
 		pAd->ARssiOffset0 = 0;
 
-	// Validate 11a RSSI_1 offset.
+	/* Validate 11a RSSI_1 offset. */
 	if ((pAd->ARssiOffset1 < -10) || (pAd->ARssiOffset1 > 10))
 		pAd->ARssiOffset1 = 0;
 
-	//Validate 11a RSSI_2 offset.
+	/*Validate 11a RSSI_2 offset. */
 	if ((pAd->ARssiOffset2 < -10) || (pAd->ARssiOffset2 > 10))
 		pAd->ARssiOffset2 = 0;
 
 #ifdef RT30xx
-	//
-	// Get TX mixer gain setting
-	// 0xff are invalid value
-	// Note: RT30xX default value is 0x00 and will program to RF_R17 only when this value is not zero.
-	//       RT359X default value is 0x02
-	//
+	/* */
+	/* Get TX mixer gain setting */
+	/* 0xff are invalid value */
+	/* Note: RT30xX default value is 0x00 and will program to RF_R17 only when this value is not zero. */
+	/*       RT359X default value is 0x02 */
+	/* */
 	if (IS_RT30xx(pAd) || IS_RT3572(pAd)) {
 		RT28xx_EEPROM_READ16(pAd, EEPROM_TXMIXER_GAIN_2_4G, value);
 		pAd->TxMixerGain24G = 0;
@@ -1090,11 +1090,11 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 			pAd->TxMixerGain24G = (UCHAR) value;
 		}
 	}
-#endif // RT30xx //
+#endif /* RT30xx // */
 
-	//
-	// Get LED Setting.
-	//
+	/* */
+	/* Get LED Setting. */
+	/* */
 	RT28xx_EEPROM_READ16(pAd, 0x3a, value);
 	pAd->LedCntl.word = (value >> 8);
 	RT28xx_EEPROM_READ16(pAd, EEPROM_LED1_OFFSET, value);
@@ -1109,8 +1109,8 @@ VOID NICReadEEPROMParameters(IN PRTMP_ADAPTER pAd, IN PUCHAR mac_addr)
 #ifdef RT30xx
 #ifdef RTMP_EFUSE_SUPPORT
 	RtmpEfuseSupportCheck(pAd);
-#endif // RTMP_EFUSE_SUPPORT //
-#endif // RT30xx //
+#endif /* RTMP_EFUSE_SUPPORT // */
+#endif /* RT30xx // */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICReadEEPROMParameters\n"));
 }
@@ -1138,7 +1138,7 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 	UINT32 data = 0;
 	UCHAR BBPR1 = 0;
 	USHORT i;
-//      EEPROM_ANTENNA_STRUC    Antenna;
+/*      EEPROM_ANTENNA_STRUC    Antenna; */
 	EEPROM_NIC_CONFIG2_STRUC NicConfig2;
 	UCHAR BBPR3 = 0;
 
@@ -1166,18 +1166,18 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 		}
 	}
 
-	// Save the antenna for future use
+	/* Save the antenna for future use */
 	pAd->NicConfig2.word = NicConfig2.word;
 
 #ifdef RT30xx
-	// set default antenna as main
+	/* set default antenna as main */
 	if (pAd->RfIcType == RFIC_3020)
 		AsicSetRxAnt(pAd, pAd->RxAnt.Pair1PrimaryRxAnt);
-#endif // RT30xx //
+#endif /* RT30xx // */
 
-	//
-	// Send LED Setting to MCU.
-	//
+	/* */
+	/* Send LED Setting to MCU. */
+	/* */
 	if (pAd->LedCntl.word == 0xFF) {
 		pAd->LedCntl.word = 0x01;
 		pAd->Led1 = 0x5555;
@@ -1185,10 +1185,10 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 
 #ifdef RTMP_MAC_PCI
 		pAd->Led3 = 0xA9F8;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 		pAd->Led3 = 0x5627;
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	}
 
 	AsicSendCommandToMcu(pAd, 0x52, 0xff, (UCHAR) pAd->Led1,
@@ -1200,19 +1200,19 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 	AsicSendCommandToMcu(pAd, 0x51, 0xff, 0, pAd->LedCntl.field.Polarity);
 
 	pAd->LedIndicatorStrength = 0xFF;
-	RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, before link up
+	RTMPSetSignalLED(pAd, -100);	/* Force signal strength Led to be turned off, before link up */
 
 	{
-		// Read Hardware controlled Radio state enable bit
+		/* Read Hardware controlled Radio state enable bit */
 		if (NicConfig2.field.HardwareRadioControl == 1) {
 			pAd->StaCfg.bHardwareRadio = TRUE;
 
-			// Read GPIO pin2 as Hardware controlled radio state
+			/* Read GPIO pin2 as Hardware controlled radio state */
 			RTMP_IO_READ32(pAd, GPIO_CTRL_CFG, &data);
 			if ((data & 0x04) == 0) {
 				pAd->StaCfg.bHwRadio = FALSE;
 				pAd->StaCfg.bRadio = FALSE;
-//                              RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
+/*                              RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818); */
 				RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 			}
 		} else
@@ -1227,15 +1227,15 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 			AsicSendCommandToMcu(pAd, 0x30, PowerRadioOffCID, 0xff,
 					     0x02);
 			AsicCheckCommanOk(pAd, PowerRadioOffCID);
-#endif // RT3090 //
+#endif /* RT3090 // */
 #ifndef RT3090
 			AsicSendCommandToMcu(pAd, 0x30, 0xff, 0xff, 0x02);
-#endif // RT3090 //
+#endif /* RT3090 // */
 			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00,
 					     0x00);
-			// 2-1. wait command ok.
+			/* 2-1. wait command ok. */
 			AsicCheckCommanOk(pAd, PowerWakeCID);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 		}
 	}
 
@@ -1246,8 +1246,8 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 		if (pChipOps->AsicReverseRfFromSleepMode)
 			pChipOps->AsicReverseRfFromSleepMode(pAd);
 	}
-	// 3090 MCU Wakeup command needs more time to be stable.
-	// Before stable, don't issue other MCU command to prevent from firmware error.
+	/* 3090 MCU Wakeup command needs more time to be stable. */
+	/* Before stable, don't issue other MCU command to prevent from firmware error. */
 
 	if ((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 	    && IS_VERSION_AFTER_F(pAd)
@@ -1258,22 +1258,22 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 		pAd->brt30xxBanMcuCmd = FALSE;
 		RTMP_SEM_UNLOCK(&pAd->McuCmdLock);
 	}
-#endif // RT30xx //
-#endif // RTMP_MAC_PCI //
+#endif /* RT30xx // */
+#endif /* RTMP_MAC_PCI // */
 
-	// Turn off patching for cardbus controller
+	/* Turn off patching for cardbus controller */
 	if (NicConfig2.field.CardbusAcceleration == 1) {
-//              pAd->bTest1 = TRUE;
+/*              pAd->bTest1 = TRUE; */
 	}
 
 	if (NicConfig2.field.DynamicTxAgcControl == 1)
 		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = TRUE;
 	else
 		pAd->bAutoTxAgcA = pAd->bAutoTxAgcG = FALSE;
-	//
-	// Since BBP has been progamed, to make sure BBP setting will be
-	// upate inside of AsicAntennaSelect, so reset to UNKNOWN_BAND!!
-	//
+	/* */
+	/* Since BBP has been progamed, to make sure BBP setting will be */
+	/* upate inside of AsicAntennaSelect, so reset to UNKNOWN_BAND!! */
+	/* */
 	pAd->CommonCfg.BandState = UNKNOWN_BAND;
 
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &BBPR3);
@@ -1288,7 +1288,7 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, BBPR3);
 
 	{
-		// Handle the difference when 1T
+		/* Handle the difference when 1T */
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &BBPR1);
 		if (pAd->Antenna.field.TxPath == 1) {
 			BBPR1 &= (~0x18);
@@ -1303,13 +1303,13 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 
 #ifdef RTMP_MAC_USB
 #ifdef RT30xx
-	// update registers from EEPROM for RT3071 or later(3572/3592).
+	/* update registers from EEPROM for RT3071 or later(3572/3592). */
 
 	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
 		UCHAR RegIdx, RegValue;
 		USHORT value;
 
-		// after RT3071, write BBP from EEPROM 0xF0 to 0x102
+		/* after RT3071, write BBP from EEPROM 0xF0 to 0x102 */
 		for (i = 0xF0; i <= 0x102; i = i + 2) {
 			value = 0xFFFF;
 			RT28xx_EEPROM_READ16(pAd, i, value);
@@ -1324,7 +1324,7 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 			}
 		}
 
-		// after RT3071, write RF from EEPROM 0x104 to 0x116
+		/* after RT3071, write RF from EEPROM 0x104 to 0x116 */
 		for (i = 0x104; i <= 0x116; i = i + 2) {
 			value = 0xFFFF;
 			RT28xx_EEPROM_READ16(pAd, i, value);
@@ -1338,8 +1338,8 @@ VOID NICInitAsicFromEEPROM(IN PRTMP_ADAPTER pAd)
 			}
 		}
 	}
-#endif // RT30xx //
-#endif // RTMP_MAC_USB //
+#endif /* RT30xx // */
+#endif /* RTMP_MAC_USB // */
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("TxPath = %d, RxPath = %d, RFIC=%d, Polar+LED mode=%x\n",
@@ -1373,14 +1373,14 @@ NDIS_STATUS NICInitializeAdapter(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 #ifdef RTMP_MAC_PCI
 	UINT32 Value;
 	DELAY_INT_CFG_STRUC IntCfg;
-#endif // RTMP_MAC_PCI //
-//      INT_MASK_CSR_STRUC              IntMask;
+#endif /* RTMP_MAC_PCI // */
+/*      INT_MASK_CSR_STRUC              IntMask; */
 	ULONG i = 0, j = 0;
 	AC_TXOP_CSR0_STRUC csr0;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitializeAdapter\n"));
 
-	// 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits:
+	/* 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits: */
 retry:
 	i = 0;
 	do {
@@ -1398,7 +1398,7 @@ retry:
 	GloCfg.field.EnTXWriteBackDDONE = 1;
 	RTMP_IO_WRITE32(pAd, WPDMA_GLO_CFG, GloCfg.word);
 
-	// Record HW Beacon offset
+	/* Record HW Beacon offset */
 	pAd->BeaconOffset[0] = HW_BEACON_BASE0;
 	pAd->BeaconOffset[1] = HW_BEACON_BASE1;
 	pAd->BeaconOffset[2] = HW_BEACON_BASE2;
@@ -1408,19 +1408,19 @@ retry:
 	pAd->BeaconOffset[6] = HW_BEACON_BASE6;
 	pAd->BeaconOffset[7] = HW_BEACON_BASE7;
 
-	//
-	// write all shared Ring's base address into ASIC
-	//
+	/* */
+	/* write all shared Ring's base address into ASIC */
+	/* */
 
-	// asic simulation sequence put this ahead before loading firmware.
-	// pbf hardware reset
+	/* asic simulation sequence put this ahead before loading firmware. */
+	/* pbf hardware reset */
 #ifdef RTMP_MAC_PCI
-	RTMP_IO_WRITE32(pAd, WPDMA_RST_IDX, 0x1003f);	// 0x10000 for reset rx, 0x3f resets all 6 tx rings.
+	RTMP_IO_WRITE32(pAd, WPDMA_RST_IDX, 0x1003f);	/* 0x10000 for reset rx, 0x3f resets all 6 tx rings. */
 	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0xe1f);
 	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, 0xe00);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// Initialze ASIC for TX & Rx operation
+	/* Initialze ASIC for TX & Rx operation */
 	if (NICInitializeAsic(pAd, bHardReset) != NDIS_STATUS_SUCCESS) {
 		if (j++ == 0) {
 			NICLoadFirmware(pAd);
@@ -1430,46 +1430,46 @@ retry:
 	}
 
 #ifdef RTMP_MAC_PCI
-	// Write AC_BK base address register
+	/* Write AC_BK base address register */
 	Value =
 	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BK].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR1, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR1 : 0x%x\n", Value));
 
-	// Write AC_BE base address register
+	/* Write AC_BE base address register */
 	Value =
 	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_BE].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR0, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR0 : 0x%x\n", Value));
 
-	// Write AC_VI base address register
+	/* Write AC_VI base address register */
 	Value =
 	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VI].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR2, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR2 : 0x%x\n", Value));
 
-	// Write AC_VO base address register
+	/* Write AC_VO base address register */
 	Value =
 	    RTMP_GetPhysicalAddressLow(pAd->TxRing[QID_AC_VO].Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR3, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR3 : 0x%x\n", Value));
 
-	// Write MGMT_BASE_CSR register
+	/* Write MGMT_BASE_CSR register */
 	Value = RTMP_GetPhysicalAddressLow(pAd->MgmtRing.Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, TX_BASE_PTR5, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> TX_BASE_PTR5 : 0x%x\n", Value));
 
-	// Write RX_BASE_CSR register
+	/* Write RX_BASE_CSR register */
 	Value = RTMP_GetPhysicalAddressLow(pAd->RxRing.Cell[0].AllocPa);
 	RTMP_IO_WRITE32(pAd, RX_BASE_PTR, Value);
 	DBGPRINT(RT_DEBUG_TRACE, ("--> RX_BASE_PTR : 0x%x\n", Value));
 
-	// Init RX Ring index pointer
+	/* Init RX Ring index pointer */
 	pAd->RxRing.RxSwReadIdx = 0;
 	pAd->RxRing.RxCpuIdx = RX_RING_SIZE - 1;
 	RTMP_IO_WRITE32(pAd, RX_CRX_IDX, pAd->RxRing.RxCpuIdx);
 
-	// Init TX rings index pointer
+	/* Init TX rings index pointer */
 	{
 		for (i = 0; i < NUM_OF_TX_RING; i++) {
 			pAd->TxRing[i].TxSwFreeIdx = 0;
@@ -1479,16 +1479,16 @@ retry:
 		}
 	}
 
-	// init MGMT ring index pointer
+	/* init MGMT ring index pointer */
 	pAd->MgmtRing.TxSwFreeIdx = 0;
 	pAd->MgmtRing.TxCpuIdx = 0;
 	RTMP_IO_WRITE32(pAd, TX_MGMTCTX_IDX, pAd->MgmtRing.TxCpuIdx);
 
-	//
-	// set each Ring's SIZE  into ASIC. Descriptor Size is fixed by design.
-	//
+	/* */
+	/* set each Ring's SIZE  into ASIC. Descriptor Size is fixed by design. */
+	/* */
 
-	// Write TX_RING_CSR0 register
+	/* Write TX_RING_CSR0 register */
 	Value = TX_RING_SIZE;
 	RTMP_IO_WRITE32(pAd, TX_MAX_CNT0, Value);
 	RTMP_IO_WRITE32(pAd, TX_MAX_CNT1, Value);
@@ -1498,25 +1498,25 @@ retry:
 	Value = MGMT_RING_SIZE;
 	RTMP_IO_WRITE32(pAd, TX_MGMTMAX_CNT, Value);
 
-	// Write RX_RING_CSR register
+	/* Write RX_RING_CSR register */
 	Value = RX_RING_SIZE;
 	RTMP_IO_WRITE32(pAd, RX_MAX_CNT, Value);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// WMM parameter
+	/* WMM parameter */
 	csr0.word = 0;
 	RTMP_IO_WRITE32(pAd, WMM_TXOP0_CFG, csr0.word);
 	if (pAd->CommonCfg.PhyMode == PHY_11B) {
-		csr0.field.Ac0Txop = 192;	// AC_VI: 192*32us ~= 6ms
-		csr0.field.Ac1Txop = 96;	// AC_VO: 96*32us  ~= 3ms
+		csr0.field.Ac0Txop = 192;	/* AC_VI: 192*32us ~= 6ms */
+		csr0.field.Ac1Txop = 96;	/* AC_VO: 96*32us  ~= 3ms */
 	} else {
-		csr0.field.Ac0Txop = 96;	// AC_VI: 96*32us ~= 3ms
-		csr0.field.Ac1Txop = 48;	// AC_VO: 48*32us ~= 1.5ms
+		csr0.field.Ac0Txop = 96;	/* AC_VI: 96*32us ~= 3ms */
+		csr0.field.Ac1Txop = 48;	/* AC_VO: 48*32us ~= 1.5ms */
 	}
 	RTMP_IO_WRITE32(pAd, WMM_TXOP1_CFG, csr0.word);
 
 #ifdef RTMP_MAC_PCI
-	// 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits:
+	/* 3. Set DMA global configuration except TX_DMA_EN and RX_DMA_EN bits: */
 	i = 0;
 	do {
 		RTMP_IO_READ32(pAd, WPDMA_GLO_CFG, &GloCfg.word);
@@ -1534,11 +1534,11 @@ retry:
 
 	IntCfg.word = 0;
 	RTMP_IO_WRITE32(pAd, DELAY_INT_CFG, IntCfg.word);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// reset action
-	// Load firmware
-	//  Status = NICLoadFirmware(pAd);
+	/* reset action */
+	/* Load firmware */
+	/*  Status = NICLoadFirmware(pAd); */
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICInitializeAdapter\n"));
 	return Status;
@@ -1571,25 +1571,25 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 	UINT32 MacCsr0 = 0;
 	NTSTATUS Status;
 	UCHAR Value = 0xff;
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 #ifdef RT30xx
 	UCHAR bbpreg = 0;
 	UCHAR RFValue = 0;
-#endif // RT30xx //
+#endif /* RT30xx // */
 	USHORT KeyIdx;
 	INT i, apidx;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICInitializeAsic\n"));
 
 #ifdef RTMP_MAC_PCI
-	RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x3);	// To fix driver disable/enable hang issue when radio off
+	RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x3);	/* To fix driver disable/enable hang issue when radio off */
 	if (bHardReset == TRUE) {
 		RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x3);
 	} else
 		RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);
 
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
-	// Initialize MAC register to default value
+	/* Initialize MAC register to default value */
 	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++) {
 		RTMP_IO_WRITE32(pAd, MACRegTable[Index].Register,
 				MACRegTable[Index].Value);
@@ -1601,15 +1601,15 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 					STAMACRegTable[Index].Value);
 		}
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
-	//
-	// Make sure MAC gets ready after NICLoadFirmware().
-	//
+	/* */
+	/* Make sure MAC gets ready after NICLoadFirmware(). */
+	/* */
 	Index = 0;
 
-	//To avoid hang-on issue when interface up in kernel 2.4,
-	//we use a local variable "MacCsr0" instead of using "pAd->MACVersion" directly.
+	/*To avoid hang-on issue when interface up in kernel 2.4, */
+	/*we use a local variable "MacCsr0" instead of using "pAd->MACVersion" directly. */
 	do {
 		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
 
@@ -1622,7 +1622,7 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 	pAd->MACVersion = MacCsr0;
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("MAC_CSR0  [ Ver:Rev=0x%08x]\n", pAd->MACVersion));
-	// turn on bit13 (set to zero) after rt2860D. This is to solve high-current issue.
+	/* turn on bit13 (set to zero) after rt2860D. This is to solve high-current issue. */
 	RTMP_IO_READ32(pAd, PBF_SYS_CTRL, &MacCsr12);
 	MacCsr12 &= (~0x2000);
 	RTMP_IO_WRITE32(pAd, PBF_SYS_CTRL, MacCsr12);
@@ -1633,7 +1633,7 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
 
-	// Initialize MAC register to default value
+	/* Initialize MAC register to default value */
 	for (Index = 0; Index < NUM_MAC_REG_PARMS; Index++) {
 #ifdef RT30xx
 		if ((MACRegTable[Index].Register == TX_SW_CFG0)
@@ -1641,7 +1641,7 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 			|| IS_RT3090(pAd) || IS_RT3390(pAd))) {
 			MACRegTable[Index].Value = 0x00000400;
 		}
-#endif // RT30xx //
+#endif /* RT30xx // */
 		RTMP_IO_WRITE32(pAd, (USHORT) MACRegTable[Index].Register,
 				MACRegTable[Index].Value);
 	}
@@ -1653,19 +1653,19 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 					STAMACRegTable[Index].Value);
 		}
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 #ifdef RT30xx
-	// Initialize RT3070 serial MAC registers which is different from RT2870 serial
+	/* Initialize RT3070 serial MAC registers which is different from RT2870 serial */
 	if (IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {
 		RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
 
-		// RT3071 version E has fixed this issue
+		/* RT3071 version E has fixed this issue */
 		if ((pAd->MACVersion & 0xffff) < 0x0211) {
 			if (pAd->NicConfig2.field.DACTestBit == 1) {
-				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	// To fix throughput drop drastically
+				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	/* To fix throughput drop drastically */
 			} else {
-				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0F);	// To fix throughput drop drastically
+				RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0F);	/* To fix throughput drop drastically */
 			}
 		} else {
 			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x0);
@@ -1673,21 +1673,21 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 	} else if (IS_RT3070(pAd)) {
 		if (((pAd->MACVersion & 0xffff) < 0x0201)) {
 			RTMP_IO_WRITE32(pAd, TX_SW_CFG1, 0);
-			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	// To fix throughput drop drastically
+			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0x2C);	/* To fix throughput drop drastically */
 		} else {
 			RTMP_IO_WRITE32(pAd, TX_SW_CFG2, 0);
 		}
 	}
-#endif // RT30xx //
+#endif /* RT30xx // */
 
-	//
-	// Before program BBP, we need to wait BBP/RF get wake up.
-	//
+	/* */
+	/* Before program BBP, we need to wait BBP/RF get wake up. */
+	/* */
 	Index = 0;
 	do {
 		RTMP_IO_READ32(pAd, MAC_STATUS_CFG, &MacCsr12);
 
-		if ((MacCsr12 & 0x03) == 0)	// if BB.RF is stable
+		if ((MacCsr12 & 0x03) == 0)	/* if BB.RF is stable */
 			break;
 
 		DBGPRINT(RT_DEBUG_TRACE,
@@ -1695,87 +1695,87 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 		RTMPusecDelay(1000);
 	} while (Index++ < 100);
 
-	// The commands to firmware should be after these commands, these commands will init firmware
-	// PCI and USB are not the same because PCI driver needs to wait for PCI bus ready
-	RTMP_IO_WRITE32(pAd, H2M_BBP_AGENT, 0);	// initialize BBP R/W access agent
+	/* The commands to firmware should be after these commands, these commands will init firmware */
+	/* PCI and USB are not the same because PCI driver needs to wait for PCI bus ready */
+	RTMP_IO_WRITE32(pAd, H2M_BBP_AGENT, 0);	/* initialize BBP R/W access agent */
 	RTMP_IO_WRITE32(pAd, H2M_MAILBOX_CSR, 0);
 #ifdef RT3090
-	//2008/11/28:KH add to fix the dead rf frequency offset bug<--
+	/*2008/11/28:KH add to fix the dead rf frequency offset bug<-- */
 	AsicSendCommandToMcu(pAd, 0x72, 0, 0, 0);
-	//2008/11/28:KH add to fix the dead rf frequency offset bug-->
-#endif // RT3090 //
+	/*2008/11/28:KH add to fix the dead rf frequency offset bug--> */
+#endif /* RT3090 // */
 	RTMPusecDelay(1000);
 
-	// Read BBP register, make sure BBP is up and running before write new data
+	/* Read BBP register, make sure BBP is up and running before write new data */
 	Index = 0;
 	do {
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R0, &R0);
 		DBGPRINT(RT_DEBUG_TRACE, ("BBP version = %x\n", R0));
 	} while ((++Index < 20) && ((R0 == 0xff) || (R0 == 0x00)));
-	//ASSERT(Index < 20); //this will cause BSOD on Check-build driver
+	/*ASSERT(Index < 20); //this will cause BSOD on Check-build driver */
 
 	if ((R0 == 0xff) || (R0 == 0x00))
 		return NDIS_STATUS_FAILURE;
 
-	// Initialize BBP register to default value
+	/* Initialize BBP register to default value */
 	for (Index = 0; Index < NUM_BBP_REG_PARMS; Index++) {
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBPRegTable[Index].Register,
 					     BBPRegTable[Index].Value);
 	}
 
 #ifdef RTMP_MAC_PCI
-	// TODO: shiang, check MACVersion, currently, rbus-based chip use this.
+	/* TODO: shiang, check MACVersion, currently, rbus-based chip use this. */
 	if (pAd->MACVersion == 0x28720200) {
-		//UCHAR value;
+		/*UCHAR value; */
 		ULONG value2;
 
-		//disable MLD by Bruce 20080704
-		//BBP_IO_READ8_BY_REG_ID(pAd, BBP_R105, &value);
-		//BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R105, value | 4);
+		/*disable MLD by Bruce 20080704 */
+		/*BBP_IO_READ8_BY_REG_ID(pAd, BBP_R105, &value); */
+		/*BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R105, value | 4); */
 
-		//Maximum PSDU length from 16K to 32K bytes
+		/*Maximum PSDU length from 16K to 32K bytes */
 		RTMP_IO_READ32(pAd, MAX_LEN_CFG, &value2);
 		value2 &= ~(0x3 << 12);
 		value2 |= (0x2 << 12);
 		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, value2);
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// for rt2860E and after, init BBP_R84 with 0x19. This is for extension channel overlapping IOT.
-	// RT3090 should not program BBP R84 to 0x19, otherwise TX will block.
-	//3070/71/72,3090,3090A( are included in RT30xx),3572,3390
+	/* for rt2860E and after, init BBP_R84 with 0x19. This is for extension channel overlapping IOT. */
+	/* RT3090 should not program BBP R84 to 0x19, otherwise TX will block. */
+	/*3070/71/72,3090,3090A( are included in RT30xx),3572,3390 */
 	if (((pAd->MACVersion & 0xffff) != 0x0101)
 	    && !(IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)))
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R84, 0x19);
 
 #ifdef RT30xx
-// add by johnli, RF power sequence setup
-	if (IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {	//update for RT3070/71/72/90/91/92,3572,3390.
+/* add by johnli, RF power sequence setup */
+	if (IS_RT30xx(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd)) {	/*update for RT3070/71/72/90/91/92,3572,3390. */
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R79, 0x13);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R80, 0x05);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R81, 0x33);
 	}
 
-	if (IS_RT3090(pAd) || IS_RT3390(pAd))	// RT309x, RT3071/72
+	if (IS_RT3090(pAd) || IS_RT3390(pAd))	/* RT309x, RT3071/72 */
 	{
-		// enable DC filter
+		/* enable DC filter */
 		if ((pAd->MACVersion & 0xffff) >= 0x0211) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R103, 0xc0);
 		}
-		// improve power consumption
+		/* improve power consumption */
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R138, &bbpreg);
 		if (pAd->Antenna.field.TxPath == 1) {
-			// turn off tx DAC_1
+			/* turn off tx DAC_1 */
 			bbpreg = (bbpreg | 0x20);
 		}
 
 		if (pAd->Antenna.field.RxPath == 1) {
-			// turn off tx ADC_1
+			/* turn off tx ADC_1 */
 			bbpreg &= (~0x2);
 		}
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R138, bbpreg);
 
-		// improve power consumption in RT3071 Ver.E
+		/* improve power consumption in RT3071 Ver.E */
 		if ((pAd->MACVersion & 0xffff) >= 0x0211) {
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R31, &bbpreg);
 			bbpreg &= (~0x3);
@@ -1783,39 +1783,39 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 		}
 	} else if (IS_RT3070(pAd)) {
 		if ((pAd->MACVersion & 0xffff) >= 0x0201) {
-			// enable DC filter
+			/* enable DC filter */
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R103, 0xc0);
 
-			// improve power consumption in RT3070 Ver.F
+			/* improve power consumption in RT3070 Ver.F */
 			RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R31, &bbpreg);
 			bbpreg &= (~0x3);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R31, bbpreg);
 		}
-		// TX_LO1_en, RF R17 register Bit 3 to 0
+		/* TX_LO1_en, RF R17 register Bit 3 to 0 */
 		RT30xxReadRFRegister(pAd, RF_R17, &RFValue);
 		RFValue &= (~0x08);
-		// to fix rx long range issue
+		/* to fix rx long range issue */
 		if (pAd->NicConfig2.field.ExternalLNAForG == 0) {
 			RFValue |= 0x20;
 		}
-		// set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h
+		/* set RF_R17_bit[2:0] equal to EEPROM setting at 0x48h */
 		if (pAd->TxMixerGain24G >= 1) {
-			RFValue &= (~0x7);	// clean bit [2:0]
+			RFValue &= (~0x7);	/* clean bit [2:0] */
 			RFValue |= pAd->TxMixerGain24G;
 		}
 		RT30xxWriteRFRegister(pAd, RF_R17, RFValue);
 	}
-// end johnli
-#endif // RT30xx //
+/* end johnli */
+#endif /* RT30xx // */
 
 	if (pAd->MACVersion == 0x28600100) {
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x16);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x12);
 	}
 
-	if (pAd->MACVersion >= RALINK_2880E_VERSION && pAd->MACVersion < RALINK_3070_VERSION)	// 3*3
+	if (pAd->MACVersion >= RALINK_2880E_VERSION && pAd->MACVersion < RALINK_3070_VERSION)	/* 3*3 */
 	{
-		// enlarge MAX_LEN_CFG
+		/* enlarge MAX_LEN_CFG */
 		UINT32 csr;
 		RTMP_IO_READ32(pAd, MAX_LEN_CFG, &csr);
 		csr &= 0xFFF;
@@ -1827,7 +1827,7 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 		UCHAR MAC_Value[] =
 		    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0 };
 
-		//Initialize WCID table
+		/*Initialize WCID table */
 		Value = 0xff;
 		for (Index = 0; Index < 254; Index++) {
 			RTUSBMultiWrite(pAd,
@@ -1835,18 +1835,18 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 					MAC_Value, 8);
 		}
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	// Add radio off control
+	/* Add radio off control */
 	{
 		if (pAd->StaCfg.bRadio == FALSE) {
-//                      RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818);
+/*                      RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x00001818); */
 			RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF);
 			DBGPRINT(RT_DEBUG_TRACE, ("Set Radio Off\n"));
 		}
 	}
 
-	// Clear raw counters
+	/* Clear raw counters */
 	RTMP_IO_READ32(pAd, RX_STA_CNT0, &Counter);
 	RTMP_IO_READ32(pAd, RX_STA_CNT1, &Counter);
 	RTMP_IO_READ32(pAd, RX_STA_CNT2, &Counter);
@@ -1854,29 +1854,29 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 	RTMP_IO_READ32(pAd, TX_STA_CNT1, &Counter);
 	RTMP_IO_READ32(pAd, TX_STA_CNT2, &Counter);
 
-	// ASIC will keep garbage value after boot
-	// Clear all shared key table when initial
-	// This routine can be ignored in radio-ON/OFF operation.
+	/* ASIC will keep garbage value after boot */
+	/* Clear all shared key table when initial */
+	/* This routine can be ignored in radio-ON/OFF operation. */
 	if (bHardReset) {
 		for (KeyIdx = 0; KeyIdx < 4; KeyIdx++) {
 			RTMP_IO_WRITE32(pAd, SHARED_KEY_MODE_BASE + 4 * KeyIdx,
 					0);
 		}
 
-		// Clear all pairwise key table when initial
+		/* Clear all pairwise key table when initial */
 		for (KeyIdx = 0; KeyIdx < 256; KeyIdx++) {
 			RTMP_IO_WRITE32(pAd,
 					MAC_WCID_ATTRIBUTE_BASE +
 					(KeyIdx * HW_WCID_ATTRI_SIZE), 1);
 		}
 	}
-	// assert HOST ready bit
-//  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x0); // 2004-09-14 asked by Mark
-//  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x4);
+	/* assert HOST ready bit */
+/*  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x0); // 2004-09-14 asked by Mark */
+/*  RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x4); */
 
-	// It isn't necessary to clear this space when not hard reset.
+	/* It isn't necessary to clear this space when not hard reset. */
 	if (bHardReset == TRUE) {
-		// clear all on-chip BEACON frame space
+		/* clear all on-chip BEACON frame space */
 		for (apidx = 0; apidx < HW_BEACON_MAX_COUNT; apidx++) {
 			for (i = 0; i < HW_BEACON_OFFSET >> 2; i += 4)
 				RTMP_IO_WRITE32(pAd,
@@ -1886,22 +1886,22 @@ NDIS_STATUS NICInitializeAsic(IN PRTMP_ADAPTER pAd, IN BOOLEAN bHardReset)
 	}
 #ifdef RTMP_MAC_USB
 	AsicDisableSync(pAd);
-	// Clear raw counters
+	/* Clear raw counters */
 	RTMP_IO_READ32(pAd, RX_STA_CNT0, &Counter);
 	RTMP_IO_READ32(pAd, RX_STA_CNT1, &Counter);
 	RTMP_IO_READ32(pAd, RX_STA_CNT2, &Counter);
 	RTMP_IO_READ32(pAd, TX_STA_CNT0, &Counter);
 	RTMP_IO_READ32(pAd, TX_STA_CNT1, &Counter);
 	RTMP_IO_READ32(pAd, TX_STA_CNT2, &Counter);
-	// Default PCI clock cycle per ms is different as default setting, which is based on PCI.
+	/* Default PCI clock cycle per ms is different as default setting, which is based on PCI. */
 	RTMP_IO_READ32(pAd, USB_CYC_CFG, &Counter);
 	Counter &= 0xffffff00;
 	Counter |= 0x000001e;
 	RTMP_IO_WRITE32(pAd, USB_CYC_CFG, Counter);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 	{
-		// for rt2860E and after, init TXOP_CTRL_CFG with 0x583f. This is for extension channel overlapping IOT.
+		/* for rt2860E and after, init TXOP_CTRL_CFG with 0x583f. This is for extension channel overlapping IOT. */
 		if ((pAd->MACVersion & 0xffff) != 0x0101)
 			RTMP_IO_WRITE32(pAd, TXOP_CTRL_CFG, 0x583f);
 	}
@@ -1934,16 +1934,16 @@ VOID NICIssueReset(IN PRTMP_ADAPTER pAd)
 	UINT32 Value = 0;
 	DBGPRINT(RT_DEBUG_TRACE, ("--> NICIssueReset\n"));
 
-	// Abort Tx, prevent ASIC from writing to Host memory
-	//RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x001f0000);
+	/* Abort Tx, prevent ASIC from writing to Host memory */
+	/*RTMP_IO_WRITE32(pAd, TX_CNTL_CSR, 0x001f0000); */
 
-	// Disable Rx, register value supposed will remain after reset
+	/* Disable Rx, register value supposed will remain after reset */
 	RTMP_IO_READ32(pAd, MAC_SYS_CTRL, &Value);
 	Value &= (0xfffffff3);
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, Value);
 
-	// Issue reset and clear from reset state
-	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x03);	// 2004-09-17 change from 0x01
+	/* Issue reset and clear from reset state */
+	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x03);	/* 2004-09-17 change from 0x01 */
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x00);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- NICIssueReset\n"));
@@ -2001,7 +2001,7 @@ VOID NICUpdateFifoStaCounters(IN PRTMP_ADAPTER pAd)
 
 		pEntry->DebugFIFOCount++;
 
-		if (StaFifo.field.TxBF)	// 3*3
+		if (StaFifo.field.TxBF)	/* 3*3 */
 			pEntry->TxBFCount++;
 
 		if (!StaFifo.field.TxSuccess) {
@@ -2022,17 +2022,17 @@ VOID NICUpdateFifoStaCounters(IN PRTMP_ADAPTER pAd)
 								     FALSE);
 					}
 
-					// Update the continuous transmission counter except PS mode
+					/* Update the continuous transmission counter except PS mode */
 					pEntry->ContinueTxFailCnt++;
 				} else {
-					// Clear the FIFOCount when sta in Power Save mode. Basically we assume
-					//     this tx error happened due to sta just go to sleep.
+					/* Clear the FIFOCount when sta in Power Save mode. Basically we assume */
+					/*     this tx error happened due to sta just go to sleep. */
 					pEntry->FIFOCount = 0;
 					pEntry->ContinueTxFailCnt = 0;
 				}
-				//pEntry->FIFOCount = 0;
+				/*pEntry->FIFOCount = 0; */
 			}
-			//pEntry->bSendBAR = TRUE;
+			/*pEntry->bSendBAR = TRUE; */
 		} else {
 			if ((pEntry->PsMode != PWR_SAVE)
 			    && (pEntry->NoBADataCountDown > 0)) {
@@ -2044,7 +2044,7 @@ VOID NICUpdateFifoStaCounters(IN PRTMP_ADAPTER pAd)
 
 			pEntry->FIFOCount = 0;
 			pEntry->OneSecTxNoRetryOkCount++;
-			// update NoDataIdleCount when sucessful send packet to STA.
+			/* update NoDataIdleCount when sucessful send packet to STA. */
 			pEntry->NoDataIdleCount = 0;
 			pEntry->ContinueTxFailCnt = 0;
 		}
@@ -2072,7 +2072,7 @@ VOID NICUpdateFifoStaCounters(IN PRTMP_ADAPTER pAd)
 		}
 
 		i++;
-		// ASIC store 16 stack
+		/* ASIC store 16 stack */
 	} while (i < (2 * TX_RING_SIZE));
 
 }
@@ -2096,9 +2096,9 @@ VOID NICUpdateFifoStaCounters(IN PRTMP_ADAPTER pAd)
 */
 VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd)
 {
-	UINT32 OldValue;	//, Value2;
-	//ULONG PageSum, OneSecTransmitCount;
-	//ULONG TxErrorRatio, Retry, Fail;
+	UINT32 OldValue;	/*, Value2; */
+	/*ULONG PageSum, OneSecTransmitCount; */
+	/*ULONG TxErrorRatio, Retry, Fail; */
 	RX_STA_CNT0_STRUC RxStaCnt0;
 	RX_STA_CNT1_STRUC RxStaCnt1;
 	RX_STA_CNT2_STRUC RxStaCnt2;
@@ -2123,34 +2123,34 @@ VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd)
 
 	{
 		RTMP_IO_READ32(pAd, RX_STA_CNT1, &RxStaCnt1.word);
-		// Update RX PLCP error counter
+		/* Update RX PLCP error counter */
 		pAd->PrivateInfo.PhyRxErrCnt += RxStaCnt1.field.PlcpErr;
-		// Update False CCA counter
+		/* Update False CCA counter */
 		pAd->RalinkCounters.OneSecFalseCCACnt +=
 		    RxStaCnt1.field.FalseCca;
 	}
 
-	// Update FCS counters
+	/* Update FCS counters */
 	OldValue = pAd->WlanCounters.FCSErrorCount.u.LowPart;
-	pAd->WlanCounters.FCSErrorCount.u.LowPart += (RxStaCnt0.field.CrcErr);	// >> 7);
+	pAd->WlanCounters.FCSErrorCount.u.LowPart += (RxStaCnt0.field.CrcErr);	/* >> 7); */
 	if (pAd->WlanCounters.FCSErrorCount.u.LowPart < OldValue)
 		pAd->WlanCounters.FCSErrorCount.u.HighPart++;
 
-	// Add FCS error count to private counters
+	/* Add FCS error count to private counters */
 	pRalinkCounters->OneSecRxFcsErrCnt += RxStaCnt0.field.CrcErr;
 	OldValue = pRalinkCounters->RealFcsErrCount.u.LowPart;
 	pRalinkCounters->RealFcsErrCount.u.LowPart += RxStaCnt0.field.CrcErr;
 	if (pRalinkCounters->RealFcsErrCount.u.LowPart < OldValue)
 		pRalinkCounters->RealFcsErrCount.u.HighPart++;
 
-	// Update Duplicate Rcv check
+	/* Update Duplicate Rcv check */
 	pRalinkCounters->DuplicateRcv += RxStaCnt2.field.RxDupliCount;
 	pAd->WlanCounters.FrameDuplicateCount.u.LowPart +=
 	    RxStaCnt2.field.RxDupliCount;
-	// Update RX Overflow counter
+	/* Update RX Overflow counter */
 	pAd->Counters8023.RxNoBuffer += (RxStaCnt2.field.RxFifoOverflowCount);
 
-	//pAd->RalinkCounters.RxCount = 0;
+	/*pAd->RalinkCounters.RxCount = 0; */
 #ifdef RTMP_MAC_USB
 	if (pRalinkCounters->RxCount != pAd->watchDogRxCnt) {
 		pAd->watchDogRxCnt = pRalinkCounters->RxCount;
@@ -2161,12 +2161,12 @@ VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd)
 		else
 			pAd->watchDogRxOverFlowCnt = 0;
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	//if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) ||
-	//      (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1)))
+	/*if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) || */
+	/*      (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_TX_RATE_SWITCH_ENABLED) && (pAd->MacTab.Size != 1))) */
 	if (!pAd->bUpdateBcnCntDone) {
-		// Update BEACON sent count
+		/* Update BEACON sent count */
 		RTMP_IO_READ32(pAd, TX_STA_CNT0, &TxStaCnt0.word);
 		RTMP_IO_READ32(pAd, TX_STA_CNT1, &StaTx1.word);
 		RTMP_IO_READ32(pAd, TX_STA_CNT2, &StaTx2.word);
@@ -2186,7 +2186,7 @@ VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd)
 		    TxStaCnt0.field.TxFailCount;
 	}
 
-	//if (pAd->bStaFifoTest == TRUE)
+	/*if (pAd->bStaFifoTest == TRUE) */
 	{
 		RTMP_IO_READ32(pAd, TX_AGG_CNT, &TxAggCnt.word);
 		RTMP_IO_READ32(pAd, TX_AGG_CNT0, &TxAggCnt0.word);
@@ -2236,7 +2236,7 @@ VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd)
 		pRalinkCounters->TxAgg16MPDUCount +=
 		    TxAggCnt7.field.AggSize16Count;
 
-		// Calculate the transmitted A-MPDU count
+		/* Calculate the transmitted A-MPDU count */
 		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
 		    TxAggCnt0.field.AggSize1Count;
 		pRalinkCounters->TransmittedAMPDUCount.u.LowPart +=
@@ -2301,18 +2301,18 @@ VOID NICUpdateRawCounters(IN PRTMP_ADAPTER pAd)
 */
 VOID NICResetFromError(IN PRTMP_ADAPTER pAd)
 {
-	// Reset BBP (according to alex, reset ASIC will force reset BBP
-	// Therefore, skip the reset BBP
-	// RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x2);
+	/* Reset BBP (according to alex, reset ASIC will force reset BBP */
+	/* Therefore, skip the reset BBP */
+	/* RTMP_IO_WRITE32(pAd, MAC_CSR1, 0x2); */
 
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x1);
-	// Remove ASIC from reset state
+	/* Remove ASIC from reset state */
 	RTMP_IO_WRITE32(pAd, MAC_SYS_CTRL, 0x0);
 
 	NICInitializeAdapter(pAd, FALSE);
 	NICInitAsicFromEEPROM(pAd);
 
-	// Switch to current channel, since during reset process, the connection should remains on.
+	/* Switch to current channel, since during reset process, the connection should remains on. */
 	AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
 	AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
 }
@@ -2409,7 +2409,7 @@ ULONG RTMPCompareMemory(IN PVOID pSrc1, IN PVOID pSrc2, IN ULONG Length)
 			return (2);
 	}
 
-	// Equal
+	/* Equal */
 	return (0);
 }
 
@@ -2506,9 +2506,9 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 
 	DBGPRINT(RT_DEBUG_TRACE, ("--> UserCfgInit\n"));
 
-	//
-	//  part I. intialize common configuration
-	//
+	/* */
+	/*  part I. intialize common configuration */
+	/* */
 #ifdef RTMP_MAC_USB
 	pAd->BulkOutReq = 0;
 
@@ -2519,22 +2519,22 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 	pAd->BulkInComplete = 0;
 	pAd->BulkInCompleteFail = 0;
 
-	//pAd->QuickTimerP = 100;
-	//pAd->TurnAggrBulkInCount = 0;
+	/*pAd->QuickTimerP = 100; */
+	/*pAd->TurnAggrBulkInCount = 0; */
 	pAd->bUsbTxBulkAggre = 0;
 
-	// init as unsed value to ensure driver will set to MCU once.
+	/* init as unsed value to ensure driver will set to MCU once. */
 	pAd->LedIndicatorStrength = 0xFF;
 
 	pAd->CommonCfg.MaxPktOneTxBulk = 2;
 	pAd->CommonCfg.TxBulkFactor = 1;
 	pAd->CommonCfg.RxBulkFactor = 1;
 
-	pAd->CommonCfg.TxPower = 100;	//mW
+	pAd->CommonCfg.TxPower = 100;	/*mW */
 
 	NdisZeroMemory(&pAd->CommonCfg.IOTestParm,
 		       sizeof(pAd->CommonCfg.IOTestParm));
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 	for (key_index = 0; key_index < SHARE_KEY_NUM; key_index++) {
 		for (bss_index = 0; bss_index < MAX_MBSSID_NUM; bss_index++) {
@@ -2556,29 +2556,29 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 	pAd->HostLnkCtrlOffset = 0;
 	pAd->StaCfg.PSControl.field.EnableNewPS = TRUE;
 	pAd->CheckDmaBusyCount = 0;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	pAd->bAutoTxAgcA = FALSE;	// Default is OFF
-	pAd->bAutoTxAgcG = FALSE;	// Default is OFF
+	pAd->bAutoTxAgcA = FALSE;	/* Default is OFF */
+	pAd->bAutoTxAgcG = FALSE;	/* Default is OFF */
 	pAd->RfIcType = RFIC_2820;
 
-	// Init timer for reset complete event
+	/* Init timer for reset complete event */
 	pAd->CommonCfg.CentralChannel = 1;
 	pAd->bForcePrintTX = FALSE;
 	pAd->bForcePrintRX = FALSE;
 	pAd->bStaFifoTest = FALSE;
 	pAd->bProtectionTest = FALSE;
-	pAd->CommonCfg.Dsifs = 10;	// in units of usec
-	pAd->CommonCfg.TxPower = 100;	//mW
-	pAd->CommonCfg.TxPowerPercentage = 0xffffffff;	// AUTO
-	pAd->CommonCfg.TxPowerDefault = 0xffffffff;	// AUTO
-	pAd->CommonCfg.TxPreamble = Rt802_11PreambleAuto;	// use Long preamble on TX by defaut
+	pAd->CommonCfg.Dsifs = 10;	/* in units of usec */
+	pAd->CommonCfg.TxPower = 100;	/*mW */
+	pAd->CommonCfg.TxPowerPercentage = 0xffffffff;	/* AUTO */
+	pAd->CommonCfg.TxPowerDefault = 0xffffffff;	/* AUTO */
+	pAd->CommonCfg.TxPreamble = Rt802_11PreambleAuto;	/* use Long preamble on TX by defaut */
 	pAd->CommonCfg.bUseZeroToDisableFragment = FALSE;
 	pAd->CommonCfg.RtsThreshold = 2347;
 	pAd->CommonCfg.FragmentThreshold = 2346;
-	pAd->CommonCfg.UseBGProtection = 0;	// 0: AUTO
-	pAd->CommonCfg.bEnableTxBurst = TRUE;	//0;
-	pAd->CommonCfg.PhyMode = 0xff;	// unknown
+	pAd->CommonCfg.UseBGProtection = 0;	/* 0: AUTO */
+	pAd->CommonCfg.bEnableTxBurst = TRUE;	/*0; */
+	pAd->CommonCfg.PhyMode = 0xff;	/* unknown */
 	pAd->CommonCfg.BandState = UNKNOWN_BAND;
 	pAd->CommonCfg.RadarDetect.CSPeriod = 10;
 	pAd->CommonCfg.RadarDetect.CSCount = 0;
@@ -2607,8 +2607,8 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 	pAd->CommonCfg.BACapability.field.MMPSmode = MMPS_ENABLE;
 	pAd->CommonCfg.BACapability.field.MpduDensity = 0;
 	pAd->CommonCfg.BACapability.field.Policy = IMMED_BA;
-	pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64;	//32;
-	pAd->CommonCfg.BACapability.field.TxBAWinLimit = 64;	//32;
+	pAd->CommonCfg.BACapability.field.RxBAWinLimit = 64;	/*32; */
+	pAd->CommonCfg.BACapability.field.TxBAWinLimit = 64;	/*32; */
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("--> UserCfgInit. BACapability = 0x%x\n",
 		  pAd->CommonCfg.BACapability.word));
@@ -2619,35 +2619,35 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 	pAd->CommonCfg.bExtChannelSwitchAnnouncement = 1;
 	pAd->CommonCfg.bHTProtect = 1;
 	pAd->CommonCfg.bMIMOPSEnable = TRUE;
-	//2008/11/05:KH add to support Antenna power-saving of AP<--
+	/*2008/11/05:KH add to support Antenna power-saving of AP<-- */
 	pAd->CommonCfg.bGreenAPEnable = FALSE;
-	//2008/11/05:KH add to support Antenna power-saving of AP-->
+	/*2008/11/05:KH add to support Antenna power-saving of AP--> */
 	pAd->CommonCfg.bBADecline = FALSE;
 	pAd->CommonCfg.bDisableReordering = FALSE;
 
 	if (pAd->MACVersion == 0x28720200) {
-		pAd->CommonCfg.TxBASize = 13;	//by Jerry recommend
+		pAd->CommonCfg.TxBASize = 13;	/*by Jerry recommend */
 	} else {
 		pAd->CommonCfg.TxBASize = 7;
 	}
 
 	pAd->CommonCfg.REGBACapability.word = pAd->CommonCfg.BACapability.word;
 
-	//pAd->CommonCfg.HTPhyMode.field.BW = BW_20;
-	//pAd->CommonCfg.HTPhyMode.field.MCS = MCS_AUTO;
-	//pAd->CommonCfg.HTPhyMode.field.ShortGI = GI_800;
-	//pAd->CommonCfg.HTPhyMode.field.STBC = STBC_NONE;
+	/*pAd->CommonCfg.HTPhyMode.field.BW = BW_20; */
+	/*pAd->CommonCfg.HTPhyMode.field.MCS = MCS_AUTO; */
+	/*pAd->CommonCfg.HTPhyMode.field.ShortGI = GI_800; */
+	/*pAd->CommonCfg.HTPhyMode.field.STBC = STBC_NONE; */
 	pAd->CommonCfg.TxRate = RATE_6;
 
 	pAd->CommonCfg.MlmeTransmit.field.MCS = MCS_RATE_6;
 	pAd->CommonCfg.MlmeTransmit.field.BW = BW_20;
 	pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
 
-	pAd->CommonCfg.BeaconPeriod = 100;	// in mSec
+	pAd->CommonCfg.BeaconPeriod = 100;	/* in mSec */
 
-	//
-	// part II. intialize STA specific configuration
-	//
+	/* */
+	/* part II. intialize STA specific configuration */
+	/* */
 	{
 		RX_FILTER_SET_FLAG(pAd, fRX_FILTER_ACCEPT_DIRECT);
 		RX_FILTER_CLEAR_FLAG(pAd, fRX_FILTER_ACCEPT_MULTICAST);
@@ -2662,7 +2662,7 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 		pAd->StaCfg.bMixCipher = FALSE;
 		pAd->StaCfg.DefaultKeyId = 0;
 
-		// 802.1x port control
+		/* 802.1x port control */
 		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
 		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
 		pAd->StaCfg.LastMicErrorTime = 0;
@@ -2670,15 +2670,15 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 		pAd->StaCfg.bBlockAssoc = FALSE;
 		pAd->StaCfg.WpaState = SS_NOTUSE;
 
-		pAd->CommonCfg.NdisRadioStateOff = FALSE;	// New to support microsoft disable radio with OID command
+		pAd->CommonCfg.NdisRadioStateOff = FALSE;	/* New to support microsoft disable radio with OID command */
 
 		pAd->StaCfg.RssiTrigger = 0;
 		NdisZeroMemory(&pAd->StaCfg.RssiSample, sizeof(RSSI_SAMPLE));
 		pAd->StaCfg.RssiTriggerMode =
 		    RSSI_TRIGGERED_UPON_BELOW_THRESHOLD;
 		pAd->StaCfg.AtimWin = 0;
-		pAd->StaCfg.DefaultListenCount = 3;	//default listen count;
-		pAd->StaCfg.BssType = BSS_INFRA;	// BSS_INFRA or BSS_ADHOC or BSS_MONITOR
+		pAd->StaCfg.DefaultListenCount = 3;	/*default listen count; */
+		pAd->StaCfg.BssType = BSS_INFRA;	/* BSS_INFRA or BSS_ADHOC or BSS_MONITOR */
 		pAd->StaCfg.bScanReqIsFromWebUI = FALSE;
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_WAKEUP_NOW);
@@ -2690,23 +2690,23 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 #ifdef PCIE_PS_SUPPORT
 	pAd->brt30xxBanMcuCmd = FALSE;
 	pAd->b3090ESpecialChip = FALSE;
-//KH Debug:the following must be removed
+/*KH Debug:the following must be removed */
 	pAd->StaCfg.PSControl.field.rt30xxPowerMode = 3;
 	pAd->StaCfg.PSControl.field.rt30xxForceASPMTest = 0;
 	pAd->StaCfg.PSControl.field.rt30xxFollowHostASPM = 1;
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 
-	// global variables mXXXX used in MAC protocol state machines
+	/* global variables mXXXX used in MAC protocol state machines */
 	OPSTATUS_SET_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM);
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
 
-	// PHY specification
-	pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;	// default PHY mode
-	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);	// CCK use LONG preamble
+	/* PHY specification */
+	pAd->CommonCfg.PhyMode = PHY_11BG_MIXED;	/* default PHY mode */
+	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED);	/* CCK use LONG preamble */
 
 	{
-		// user desired power mode
+		/* user desired power mode */
 		pAd->StaCfg.WindowsPowerMode = Ndis802_11PowerModeCAM;
 		pAd->StaCfg.WindowsBatteryPowerMode = Ndis802_11PowerModeCAM;
 		pAd->StaCfg.bWindowsACCAMEnable = FALSE;
@@ -2716,20 +2716,20 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 			      pAd, FALSE);
 		pAd->StaCfg.StaQuickResponeForRateUpTimerRunning = FALSE;
 
-		// Patch for Ndtest
+		/* Patch for Ndtest */
 		pAd->StaCfg.ScanCnt = 0;
 
-		pAd->StaCfg.bHwRadio = TRUE;	// Default Hardware Radio status is On
-		pAd->StaCfg.bSwRadio = TRUE;	// Default Software Radio status is On
-		pAd->StaCfg.bRadio = TRUE;	// bHwRadio && bSwRadio
-		pAd->StaCfg.bHardwareRadio = FALSE;	// Default is OFF
-		pAd->StaCfg.bShowHiddenSSID = FALSE;	// Default no show
+		pAd->StaCfg.bHwRadio = TRUE;	/* Default Hardware Radio status is On */
+		pAd->StaCfg.bSwRadio = TRUE;	/* Default Software Radio status is On */
+		pAd->StaCfg.bRadio = TRUE;	/* bHwRadio && bSwRadio */
+		pAd->StaCfg.bHardwareRadio = FALSE;	/* Default is OFF */
+		pAd->StaCfg.bShowHiddenSSID = FALSE;	/* Default no show */
 
-		// Nitro mode control
+		/* Nitro mode control */
 		pAd->StaCfg.bAutoReconnect = TRUE;
 
-		// Save the init time as last scan time, the system should do scan after 2 seconds.
-		// This patch is for driver wake up from standby mode, system will do scan right away.
+		/* Save the init time as last scan time, the system should do scan after 2 seconds. */
+		/* This patch is for driver wake up from standby mode, system will do scan right away. */
 		NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
 		if (pAd->StaCfg.LastScanTime > 10 * OS_HZ)
 			pAd->StaCfg.LastScanTime -= (10 * OS_HZ);
@@ -2737,10 +2737,10 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 		NdisZeroMemory(pAd->nickname, IW_ESSID_MAX_SIZE + 1);
 #ifdef RTMP_MAC_PCI
 		sprintf((PSTRING) pAd->nickname, "RT2860STA");
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 		sprintf((PSTRING) pAd->nickname, "RT2870STA");
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 		RTMPInitTimer(pAd, &pAd->StaCfg.WpaDisassocAndBlockAssocTimer,
 			      GET_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc),
 			      pAd, FALSE);
@@ -2760,83 +2760,83 @@ VOID UserCfgInit(IN PRTMP_ADAPTER pAd)
 		pAd->StaCfg.bForceTxBurst = FALSE;
 	}
 
-	// Default for extra information is not valid
+	/* Default for extra information is not valid */
 	pAd->ExtraInfo = EXTRA_INFO_CLEAR;
 
-	// Default Config change flag
+	/* Default Config change flag */
 	pAd->bConfigChanged = FALSE;
 
-	//
-	// part III. AP configurations
-	//
+	/* */
+	/* part III. AP configurations */
+	/* */
 
-	//
-	// part IV. others
-	//
-	// dynamic BBP R66:sensibity tuning to overcome background noise
+	/* */
+	/* part IV. others */
+	/* */
+	/* dynamic BBP R66:sensibity tuning to overcome background noise */
 	pAd->BbpTuning.bEnable = TRUE;
 	pAd->BbpTuning.FalseCcaLowerThreshold = 100;
 	pAd->BbpTuning.FalseCcaUpperThreshold = 512;
 	pAd->BbpTuning.R66Delta = 4;
 	pAd->Mlme.bEnableAutoAntennaCheck = TRUE;
 
-	//
-	// Also initial R66CurrentValue, RTUSBResumeMsduTransmission might use this value.
-	// if not initial this value, the default value will be 0.
-	//
+	/* */
+	/* Also initial R66CurrentValue, RTUSBResumeMsduTransmission might use this value. */
+	/* if not initial this value, the default value will be 0. */
+	/* */
 	pAd->BbpTuning.R66CurrentValue = 0x38;
 
 	pAd->Bbp94 = BBPR94_DEFAULT;
 	pAd->BbpForCCK = FALSE;
 
-	// Default is FALSE for test bit 1
-	//pAd->bTest1 = FALSE;
+	/* Default is FALSE for test bit 1 */
+	/*pAd->bTest1 = FALSE; */
 
-	// initialize MAC table and allocate spin lock
+	/* initialize MAC table and allocate spin lock */
 	NdisZeroMemory(&pAd->MacTab, sizeof(MAC_TABLE));
 	InitializeQueueHeader(&pAd->MacTab.McastPsQueue);
 	NdisAllocateSpinLock(&pAd->MacTabLock);
 
-	//RTMPInitTimer(pAd, &pAd->RECBATimer, RECBATimerTimeout, pAd, TRUE);
-	//RTMPSetTimer(&pAd->RECBATimer, REORDER_EXEC_INTV);
+	/*RTMPInitTimer(pAd, &pAd->RECBATimer, RECBATimerTimeout, pAd, TRUE); */
+	/*RTMPSetTimer(&pAd->RECBATimer, REORDER_EXEC_INTV); */
 
 	pAd->CommonCfg.bWiFiTest = FALSE;
 #ifdef RTMP_MAC_PCI
 	pAd->bPCIclkOff = FALSE;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 	DBGPRINT(RT_DEBUG_TRACE, ("<-- UserCfgInit\n"));
 }
 
-// IRQL = PASSIVE_LEVEL
+/* IRQL = PASSIVE_LEVEL */
 UCHAR BtoH(STRING ch)
 {
 	if (ch >= '0' && ch <= '9')
-		return (ch - '0');	// Handle numerals
+		return (ch - '0');	/* Handle numerals */
 	if (ch >= 'A' && ch <= 'F')
-		return (ch - 'A' + 0xA);	// Handle capitol hex digits
+		return (ch - 'A' + 0xA);	/* Handle capitol hex digits */
 	if (ch >= 'a' && ch <= 'f')
-		return (ch - 'a' + 0xA);	// Handle small hex digits
+		return (ch - 'a' + 0xA);	/* Handle small hex digits */
 	return (255);
 }
 
-//
-//  FUNCTION: AtoH(char *, UCHAR *, int)
-//
-//  PURPOSE:  Converts ascii string to network order hex
-//
-//  PARAMETERS:
-//    src    - pointer to input ascii string
-//    dest   - pointer to output hex
-//    destlen - size of dest
-//
-//  COMMENTS:
-//
-//    2 ascii bytes make a hex byte so must put 1st ascii byte of pair
-//    into upper nibble and 2nd ascii byte of pair into lower nibble.
-//
-// IRQL = PASSIVE_LEVEL
+/* */
+/*  FUNCTION: AtoH(char *, UCHAR *, int) */
+/* */
+/*  PURPOSE:  Converts ascii string to network order hex */
+/* */
+/*  PARAMETERS: */
+/*    src    - pointer to input ascii string */
+/*    dest   - pointer to output hex */
+/*    destlen - size of dest */
+/* */
+/*  COMMENTS: */
+/* */
+/*    2 ascii bytes make a hex byte so must put 1st ascii byte of pair */
+/*    into upper nibble and 2nd ascii byte of pair into lower nibble. */
+/* */
+/* IRQL = PASSIVE_LEVEL */
 
 void AtoH(PSTRING src, PUCHAR dest, int destlen)
 {
@@ -2847,14 +2847,14 @@ void AtoH(PSTRING src, PUCHAR dest, int destlen)
 	destTemp = (PUCHAR) dest;
 
 	while (destlen--) {
-		*destTemp = BtoH(*srcptr++) << 4;	// Put 1st ascii byte in upper nibble.
-		*destTemp += BtoH(*srcptr++);	// Add 2nd ascii byte to above.
+		*destTemp = BtoH(*srcptr++) << 4;	/* Put 1st ascii byte in upper nibble. */
+		*destTemp += BtoH(*srcptr++);	/* Add 2nd ascii byte to above. */
 		destTemp++;
 	}
 }
 
-//+++Mark by shiang, not use now, need to remove after confirm
-//---Mark by shiang, not use now, need to remove after confirm
+/*+++Mark by shiang, not use now, need to remove after confirm */
+/*---Mark by shiang, not use now, need to remove after confirm */
 
 /*
 	========================================================================
@@ -2879,11 +2879,11 @@ VOID RTMPInitTimer(IN PRTMP_ADAPTER pAd,
 		   IN PRALINK_TIMER_STRUCT pTimer,
 		   IN PVOID pTimerFunc, IN PVOID pData, IN BOOLEAN Repeat)
 {
-	//
-	// Set Valid to TRUE for later used.
-	// It will crash if we cancel a timer or set a timer
-	// that we haven't initialize before.
-	//
+	/* */
+	/* Set Valid to TRUE for later used. */
+	/* It will crash if we cancel a timer or set a timer */
+	/* that we haven't initialize before. */
+	/* */
 	pTimer->Valid = TRUE;
 
 	pTimer->PeriodicType = Repeat;
@@ -2892,7 +2892,7 @@ VOID RTMPInitTimer(IN PRTMP_ADAPTER pAd,
 
 #ifdef RTMP_TIMER_TASK_SUPPORT
 	pTimer->pAd = pAd;
-#endif // RTMP_TIMER_TASK_SUPPORT //
+#endif /* RTMP_TIMER_TASK_SUPPORT // */
 
 	RTMP_OS_Init_Timer(pAd, &pTimer->TimerObj, pTimerFunc, (PVOID) pTimer);
 }
@@ -3001,10 +3001,10 @@ VOID RTMPCancelTimer(IN PRALINK_TIMER_STRUCT pTimer, OUT BOOLEAN * pCancelled)
 			pTimer->State = TRUE;
 
 #ifdef RTMP_TIMER_TASK_SUPPORT
-		// We need to go-through the TimerQ to findout this timer handler and remove it if
-		//              it's still waiting for execution.
+		/* We need to go-through the TimerQ to findout this timer handler and remove it if */
+		/*              it's still waiting for execution. */
 		RtmpTimerQRemove(pTimer->pAd, pTimer);
-#endif // RTMP_TIMER_TASK_SUPPORT //
+#endif /* RTMP_TIMER_TASK_SUPPORT // */
 	} else {
 		DBGPRINT_ERR(("RTMPCancelTimer failed, Timer hasn't been initialize!\n"));
 	}
@@ -3032,7 +3032,7 @@ VOID RTMPCancelTimer(IN PRALINK_TIMER_STRUCT pTimer, OUT BOOLEAN * pCancelled)
 */
 VOID RTMPSetLED(IN PRTMP_ADAPTER pAd, IN UCHAR Status)
 {
-	//ULONG                 data;
+	/*ULONG                 data; */
 	UCHAR HighByte = 0;
 	UCHAR LowByte;
 
@@ -3055,7 +3055,7 @@ VOID RTMPSetLED(IN PRTMP_ADAPTER pAd, IN UCHAR Status)
 		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
 		break;
 	case LED_HALT:
-		LowByte = 0;	// Driver sets MAC register and MAC controls LED
+		LowByte = 0;	/* Driver sets MAC register and MAC controls LED */
 	case LED_RADIO_OFF:
 		HighByte = 0;
 		AsicSendCommandToMcu(pAd, 0x50, 0xff, LowByte, HighByte);
@@ -3078,10 +3078,10 @@ VOID RTMPSetLED(IN PRTMP_ADAPTER pAd, IN UCHAR Status)
 		break;
 	}
 
-	//
-	// Keep LED status for LED SiteSurvey mode.
-	// After SiteSurvey, we will set the LED mode to previous status.
-	//
+	/* */
+	/* Keep LED status for LED SiteSurvey mode. */
+	/* After SiteSurvey, we will set the LED mode to previous status. */
+	/* */
 	if ((Status != LED_ON_SITE_SURVEY) && (Status != LED_POWER_UP))
 		pAd->LedStatus = Status;
 
@@ -3135,9 +3135,9 @@ VOID RTMPSetSignalLED(IN PRTMP_ADAPTER pAd, IN NDIS_802_11_RSSI Dbm)
 		else
 			nLed = 31;
 
-		//
-		// Update Signal Stregth to firmware if changed.
-		//
+		/* */
+		/* Update Signal Stregth to firmware if changed. */
+		/* */
 		if (pAd->LedIndicatorStrength != nLed) {
 			AsicSendCommandToMcu(pAd, 0x51, 0xff, nLed,
 					     pAd->LedCntl.field.Polarity);
@@ -3166,25 +3166,25 @@ VOID RTMPSetSignalLED(IN PRTMP_ADAPTER pAd, IN NDIS_802_11_RSSI Dbm)
 */
 VOID RTMPEnableRxTx(IN PRTMP_ADAPTER pAd)
 {
-//      WPDMA_GLO_CFG_STRUC     GloCfg;
-//      ULONG   i = 0;
+/*      WPDMA_GLO_CFG_STRUC     GloCfg; */
+/*      ULONG   i = 0; */
 	UINT32 rx_filter_flag;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("==> RTMPEnableRxTx\n"));
 
-	// Enable Rx DMA.
+	/* Enable Rx DMA. */
 	RT28XXDMAEnable(pAd);
 
-	// enable RX of MAC block
+	/* enable RX of MAC block */
 	if (pAd->OpMode == OPMODE_AP) {
 		rx_filter_flag = APNORMAL;
 
-		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);	// enable RX of DMA block
+		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);	/* enable RX of DMA block */
 	} else {
 		if (pAd->CommonCfg.PSPXlink)
 			rx_filter_flag = PSPXLINK;
 		else
-			rx_filter_flag = STANORMAL;	// Staion not drop control frame will fail WiFi Certification.
+			rx_filter_flag = STANORMAL;	/* Staion not drop control frame will fail WiFi Certification. */
 		RTMP_IO_WRITE32(pAd, RX_FILTR_CFG, rx_filter_flag);
 	}
 
@@ -3192,7 +3192,7 @@ VOID RTMPEnableRxTx(IN PRTMP_ADAPTER pAd)
 	DBGPRINT(RT_DEBUG_TRACE, ("<== RTMPEnableRxTx\n"));
 }
 
-//+++Add by shiang, move from os/linux/rt_main_dev.c
+/*+++Add by shiang, move from os/linux/rt_main_dev.c */
 void CfgInitHook(PRTMP_ADAPTER pAd)
 {
 	pAd->bBroadComHT = TRUE;
@@ -3208,9 +3208,9 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 
 #ifdef RTMP_MAC_PCI
 	{
-		// If dirver doesn't wake up firmware here,
-		// NICLoadFirmware will hang forever when interface is up again.
-		// RT2860 PCI
+		/* If dirver doesn't wake up firmware here, */
+		/* NICLoadFirmware will hang forever when interface is up again. */
+		/* RT2860 PCI */
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE) &&
 		    OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
 			AUTO_WAKEUP_STRUC AutoWakeupCfg;
@@ -3221,17 +3221,17 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
 		}
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// reset Adapter flags
+	/* reset Adapter flags */
 	RTMP_CLEAR_FLAGS(pAd);
 
-	// Init BssTab & ChannelInfo tabbles for auto channel select.
+	/* Init BssTab & ChannelInfo tabbles for auto channel select. */
 
-	// Allocate BA Reordering memory
+	/* Allocate BA Reordering memory */
 	ba_reordering_resource_init(pAd, MAX_REORDERING_MPDU_NUM);
 
-	// Make sure MAC gets ready.
+	/* Make sure MAC gets ready. */
 	index = 0;
 	do {
 		RTMP_IO_READ32(pAd, MAC_CSR0, &MacCsr0);
@@ -3256,16 +3256,16 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 		RTMP_IO_WRITE32(pAd, AUX_CTRL, MacCsr0);
 		DBGPRINT(RT_DEBUG_TRACE, ("AUX_CTRL = 0x%x\n", MacCsr0));
 	}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 
-	// To fix driver disable/enable hang issue when radio off
+	/* To fix driver disable/enable hang issue when radio off */
 	RTMP_IO_WRITE32(pAd, PWR_PIN_CFG, 0x2);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// Disable DMA
+	/* Disable DMA */
 	RT28XXDMADisable(pAd);
 
-	// Load 8051 firmware
+	/* Load 8051 firmware */
 	Status = NICLoadFirmware(pAd);
 	if (Status != NDIS_STATUS_SUCCESS) {
 		DBGPRINT_ERR(("NICLoadFirmware failed, Status[=0x%08x]\n",
@@ -3275,13 +3275,13 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 
 	NICLoadRateSwitchingParams(pAd);
 
-	// Disable interrupts here which is as soon as possible
-	// This statement should never be true. We might consider to remove it later
+	/* Disable interrupts here which is as soon as possible */
+	/* This statement should never be true. We might consider to remove it later */
 #ifdef RTMP_MAC_PCI
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_ACTIVE)) {
 		RTMP_ASIC_INTERRUPT_DISABLE(pAd);
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	Status = RTMPAllocTxRxRingMemory(pAd);
 	if (Status != NDIS_STATUS_SUCCESS) {
@@ -3292,8 +3292,8 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 
 	RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
 
-	// initialize MLME
-	//
+	/* initialize MLME */
+	/* */
 
 	Status = RtmpMgmtTaskInit(pAd);
 	if (Status != NDIS_STATUS_SUCCESS)
@@ -3304,15 +3304,15 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 		DBGPRINT_ERR(("MlmeInit failed, Status[=0x%08x]\n", Status));
 		goto err2;
 	}
-	// Initialize pAd->StaCfg, pAd->ApCfg, pAd->CommonCfg to manufacture default
-	//
+	/* Initialize pAd->StaCfg, pAd->ApCfg, pAd->CommonCfg to manufacture default */
+	/* */
 	UserCfgInit(pAd);
 	Status = RtmpNetTaskInit(pAd);
 	if (Status != NDIS_STATUS_SUCCESS)
 		goto err3;
 
-//      COPY_MAC_ADDR(pAd->ApCfg.MBSSID[apidx].Bssid, netif->hwaddr);
-//      pAd->bForcePrintTX = TRUE;
+/*      COPY_MAC_ADDR(pAd->ApCfg.MBSSID[apidx].Bssid, netif->hwaddr); */
+/*      pAd->bForcePrintTX = TRUE; */
 
 	CfgInitHook(pAd);
 
@@ -3321,9 +3321,9 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 	MeasureReqTabInit(pAd);
 	TpcReqTabInit(pAd);
 
-	//
-	// Init the hardware, we need to init asic before read registry, otherwise mac register will be reset
-	//
+	/* */
+	/* Init the hardware, we need to init asic before read registry, otherwise mac register will be reset */
+	/* */
 	Status = NICInitializeAdapter(pAd, TRUE);
 	if (Status != NDIS_STATUS_SUCCESS) {
 		DBGPRINT_ERR(("NICInitializeAdapter failed, Status[=0x%08x]\n",
@@ -3341,10 +3341,10 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 		pAd->CommonCfg.NumOfBulkInIRP = RX_RING_SIZE;
 	else
 		pAd->CommonCfg.NumOfBulkInIRP = 1;
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	//Init Ba Capability parameters.
-//      RT28XX_BA_INIT(pAd);
+	/*Init Ba Capability parameters. */
+/*      RT28XX_BA_INIT(pAd); */
 	pAd->CommonCfg.DesiredHtPhy.MpduDensity =
 	    (UCHAR) pAd->CommonCfg.BACapability.field.MpduDensity;
 	pAd->CommonCfg.DesiredHtPhy.AmsduEnable =
@@ -3353,7 +3353,7 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 	    (USHORT) pAd->CommonCfg.BACapability.field.AmsduSize;
 	pAd->CommonCfg.DesiredHtPhy.MimoPs =
 	    (USHORT) pAd->CommonCfg.BACapability.field.MMPSmode;
-	// UPdata to HT IE
+	/* UPdata to HT IE */
 	pAd->CommonCfg.HtCapability.HtCapInfo.MimoPs =
 	    (USHORT) pAd->CommonCfg.BACapability.field.MMPSmode;
 	pAd->CommonCfg.HtCapability.HtCapInfo.AMsduSize =
@@ -3361,29 +3361,29 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 	pAd->CommonCfg.HtCapability.HtCapParm.MpduDensity =
 	    (UCHAR) pAd->CommonCfg.BACapability.field.MpduDensity;
 
-	// after reading Registry, we now know if in AP mode or STA mode
+	/* after reading Registry, we now know if in AP mode or STA mode */
 
-	// Load 8051 firmware; crash when FW image not existent
-	// Status = NICLoadFirmware(pAd);
-	// if (Status != NDIS_STATUS_SUCCESS)
-	//    break;
+	/* Load 8051 firmware; crash when FW image not existent */
+	/* Status = NICLoadFirmware(pAd); */
+	/* if (Status != NDIS_STATUS_SUCCESS) */
+	/*    break; */
 
 	DBGPRINT(RT_DEBUG_OFF, ("2. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
 
-	// We should read EEPROM for all cases.  rt2860b
+	/* We should read EEPROM for all cases.  rt2860b */
 	NICReadEEPROMParameters(pAd, (PUCHAR) pDefaultMac);
 
 	DBGPRINT(RT_DEBUG_OFF, ("3. Phy Mode = %d\n", pAd->CommonCfg.PhyMode));
 
-	NICInitAsicFromEEPROM(pAd);	//rt2860b
+	NICInitAsicFromEEPROM(pAd);	/*rt2860b */
 
-	// Set PHY to appropriate mode
+	/* Set PHY to appropriate mode */
 	TmpPhy = pAd->CommonCfg.PhyMode;
 	pAd->CommonCfg.PhyMode = 0xff;
 	RTMPSetPhyMode(pAd, TmpPhy);
 	SetCommonHT(pAd);
 
-	// No valid channels.
+	/* No valid channels. */
 	if (pAd->ChannelListNum == 0) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("Wrong configuration. No valid channel found. Check \"ContryCode\" and \"ChannelGeography\" setting.\n"));
@@ -3399,35 +3399,35 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 		  pAd->CommonCfg.HtCapability.MCSSet[4]));
 
 #ifdef RTMP_RF_RW_SUPPORT
-	//Init RT30xx RFRegisters after read RFIC type from EEPROM
+	/*Init RT30xx RFRegisters after read RFIC type from EEPROM */
 	NICInitRFRegisters(pAd);
-#endif // RTMP_RF_RW_SUPPORT //
+#endif /* RTMP_RF_RW_SUPPORT // */
 
-//              APInitialize(pAd);
+/*              APInitialize(pAd); */
 
-	//
-	// Initialize RF register to default value
-	//
+	/* */
+	/* Initialize RF register to default value */
+	/* */
 	AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 	AsicLockChannel(pAd, pAd->CommonCfg.Channel);
 
-	// 8051 firmware require the signal during booting time.
-	//2008/11/28:KH marked the following codes to patch Frequency offset bug
-	//AsicSendCommandToMcu(pAd, 0x72, 0xFF, 0x00, 0x00);
+	/* 8051 firmware require the signal during booting time. */
+	/*2008/11/28:KH marked the following codes to patch Frequency offset bug */
+	/*AsicSendCommandToMcu(pAd, 0x72, 0xFF, 0x00, 0x00); */
 
 	if (pAd && (Status != NDIS_STATUS_SUCCESS)) {
-		//
-		// Undo everything if it failed
-		//
+		/* */
+		/* Undo everything if it failed */
+		/* */
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE)) {
-//                      NdisMDeregisterInterrupt(&pAd->Interrupt);
+/*                      NdisMDeregisterInterrupt(&pAd->Interrupt); */
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_INTERRUPT_IN_USE);
 		}
-//              RTMPFreeAdapter(pAd); // we will free it in disconnect()
+/*              RTMPFreeAdapter(pAd); // we will free it in disconnect() */
 	} else if (pAd) {
-		// Microsoft HCT require driver send a disconnect event after driver initialization.
+		/* Microsoft HCT require driver send a disconnect event after driver initialization. */
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-//              pAd->IndicateMediaState = NdisMediaStateDisconnected;
+/*              pAd->IndicateMediaState = NdisMediaStateDisconnected; */
 		RTMP_SET_FLAG(pAd, fRTMP_ADAPTER_MEDIA_STATE_CHANGE);
 
 		DBGPRINT(RT_DEBUG_TRACE,
@@ -3437,18 +3437,18 @@ int rt28xx_init(IN PRTMP_ADAPTER pAd,
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS);
 		RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_REMOVE_IN_PROGRESS);
 
-		//
-		// Support multiple BulkIn IRP,
-		// the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1.
-		//
+		/* */
+		/* Support multiple BulkIn IRP, */
+		/* the value on pAd->CommonCfg.NumOfBulkInIRP may be large than 1. */
+		/* */
 		for (index = 0; index < pAd->CommonCfg.NumOfBulkInIRP; index++) {
 			RTUSBBulkReceive(pAd);
 			DBGPRINT(RT_DEBUG_TRACE, ("RTUSBBulkReceive!\n"));
 		}
-#endif // RTMP_MAC_USB //
-	}			// end of else
+#endif /* RTMP_MAC_USB // */
+	}			/* end of else */
 
-	// Set up the Mac address
+	/* Set up the Mac address */
 	RtmpOSNetDevAddrSet(pAd->net_dev, &pAd->CurrentAddress[0]);
 
 	DBGPRINT_S(Status, ("<==== rt28xx_init, Status=%x\n", Status));
@@ -3462,19 +3462,19 @@ err2:
 	RTMPFreeTxRxRingMemory(pAd);
 err1:
 
-	os_free_mem(pAd, pAd->mpdu_blk_pool.mem);	// free BA pool
+	os_free_mem(pAd, pAd->mpdu_blk_pool.mem);	/* free BA pool */
 
-	// shall not set priv to NULL here because the priv didn't been free yet.
-	//net_dev->ml_priv = 0;
+	/* shall not set priv to NULL here because the priv didn't been free yet. */
+	/*net_dev->ml_priv = 0; */
 #ifdef ST
 err0:
-#endif // ST //
+#endif /* ST // */
 
 	DBGPRINT(RT_DEBUG_ERROR, ("!!! rt28xx Initialized fail !!!\n"));
 	return FALSE;
 }
 
-//---Add by shiang, move from os/linux/rt_main_dev.c
+/*---Add by shiang, move from os/linux/rt_main_dev.c */
 
 static INT RtmpChipOpsRegister(IN RTMP_ADAPTER * pAd, IN INT infType)
 {
@@ -3494,13 +3494,13 @@ static INT RtmpChipOpsRegister(IN RTMP_ADAPTER * pAd, IN INT infType)
 		pChipOps->eraseFirmware = RtmpAsicEraseFirmware;
 		pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
 		break;
-#endif // RTMP_PCI_SUPPORT //
+#endif /* RTMP_PCI_SUPPORT // */
 #ifdef RTMP_USB_SUPPORT
 	case RTMP_DEV_INF_USB:
 		pChipOps->loadFirmware = RtmpAsicLoadFirmware;
 		pChipOps->sendCommandToMcu = RtmpAsicSendCommandToMcu;
 		break;
-#endif // RTMP_USB_SUPPORT //
+#endif /* RTMP_USB_SUPPORT // */
 	default:
 		break;
 	}
@@ -3510,9 +3510,9 @@ static INT RtmpChipOpsRegister(IN RTMP_ADAPTER * pAd, IN INT infType)
 
 INT RtmpRaDevCtrlInit(IN RTMP_ADAPTER * pAd, IN RTMP_INF_TYPE infType)
 {
-	//VOID  *handle;
+	/*VOID  *handle; */
 
-	// Assign the interface type. We need use it when do register/EEPROM access.
+	/* Assign the interface type. We need use it when do register/EEPROM access. */
 	pAd->infType = infType;
 
 	pAd->OpMode = OPMODE_STA;
@@ -3528,7 +3528,7 @@ INT RtmpRaDevCtrlInit(IN RTMP_ADAPTER * pAd, IN RTMP_INF_TYPE infType)
 			 ("Allocate vendor request temp buffer failed!\n"));
 		return FALSE;
 	}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 	RtmpChipOpsRegister(pAd, infType);
 
@@ -3543,7 +3543,7 @@ BOOLEAN RtmpRaDevCtrlExit(IN RTMP_ADAPTER * pAd)
 	return TRUE;
 }
 
-// not yet support MBSS
+/* not yet support MBSS */
 PNET_DEV get_netdev_from_bssid(IN PRTMP_ADAPTER pAd, IN UCHAR FromWhichBSSID)
 {
 	PNET_DEV dev_p = NULL;
diff --git a/drivers/staging/rt2860/common/rtmp_mcu.c b/drivers/staging/rt2860/common/rtmp_mcu.c
index d962f02..09d46f7 100644
--- a/drivers/staging/rt2860/common/rtmp_mcu.c
+++ b/drivers/staging/rt2860/common/rtmp_mcu.c
@@ -48,16 +48,14 @@
 
 #include <linux/bitrev.h>
 
-//#define BIN_IN_FILE /* use *.bin firmware */
-
 #ifdef RTMP_MAC_USB
-//
-// RT2870 Firmware Spec only used 1 oct for version expression
-//
+/* */
+/* RT2870 Firmware Spec only used 1 oct for version expression */
+/* */
 #define FIRMWARE_MINOR_VERSION	7
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-// New 8k byte firmware size for RT3071/RT3072
+/* New 8k byte firmware size for RT3071/RT3072 */
 #define FIRMWAREIMAGE_MAX_LENGTH	0x2000
 #define FIRMWAREIMAGE_LENGTH			(sizeof (FirmwareImage) / sizeof(UCHAR))
 #define FIRMWARE_MAJOR_VERSION		0
@@ -67,7 +65,7 @@
 
 #ifdef RTMP_MAC_PCI
 #define FIRMWARE_MINOR_VERSION		2
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 /*
 	========================================================================
@@ -120,7 +118,7 @@ NDIS_STATUS RtmpAsicLoadFirmware(IN PRTMP_ADAPTER pAd)
 	UINT32 Version = (pAd->MACVersion >> 16);
 #endif
 
-	// New 8k byte firmware size for RT3071/RT3072
+	/* New 8k byte firmware size for RT3071/RT3072 */
 	{
 #ifdef RTMP_MAC_PCI
 		if (IS_RT3090(pAd) || IS_RT3390(pAd)) {
@@ -130,24 +128,24 @@ NDIS_STATUS RtmpAsicLoadFirmware(IN PRTMP_ADAPTER pAd)
 			pFirmwareImage = FirmwareImage_2860;
 			FileLength = FIRMWAREIMAGE_MAX_LENGTH;
 		}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 		/* the firmware image consists of two parts */
 		if ((Version != 0x2860) && (Version != 0x2872) && (Version != 0x3070)) {	/* use the second part */
-			//printk("KH:Use New Version,part2\n");
+			/*printk("KH:Use New Version,part2\n"); */
 			pFirmwareImage =
 			    (PUCHAR) &
 			    FirmwareImage_3070[FIRMWAREIMAGEV1_LENGTH];
 			FileLength = FIRMWAREIMAGEV2_LENGTH;
 		} else {
-			//printk("KH:Use New Version,part1\n");
+			/*printk("KH:Use New Version,part1\n"); */
 			if (Version == 0x3070)
 				pFirmwareImage = FirmwareImage_3070;
 			else
 				pFirmwareImage = FirmwareImage_2870;
 			FileLength = FIRMWAREIMAGEV1_LENGTH;
 		}
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	}
 
 	RTMP_WRITE_FIRMWARE(pAd, pFirmwareImage, FileLength);
@@ -183,8 +181,8 @@ INT RtmpAsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
 	ULONG i = 0;
 
 #ifdef PCIE_PS_SUPPORT
-	// 3090F power solution 3 has hw limitation that needs to ban all mcu command
-	// when firmware is in radio state.  For other chip doesn't have this limitation.
+	/* 3090F power solution 3 has hw limitation that needs to ban all mcu command */
+	/* when firmware is in radio state.  For other chip doesn't have this limitation. */
 	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
 	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
@@ -228,7 +226,7 @@ INT RtmpAsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
 			return FALSE;
 		}
 
-		H2MMailbox.field.Owner = 1;	// pass ownership to MCU
+		H2MMailbox.field.Owner = 1;	/* pass ownership to MCU */
 		H2MMailbox.field.CmdToken = Token;
 		H2MMailbox.field.HighByte = Arg1;
 		H2MMailbox.field.LowByte = Arg0;
@@ -239,7 +237,7 @@ INT RtmpAsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
 		RTMP_IO_FORCE_WRITE32(pAd, HOST_CMD_CSR, H2MCmd.word);
 
 	} else
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 	{
 		do {
 			RTMP_IO_READ32(pAd, H2M_MAILBOX_CSR, &H2MMailbox.word);
@@ -251,16 +249,16 @@ INT RtmpAsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
 
 		if (i > 100) {
 #ifdef RTMP_MAC_PCI
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 			{
 				DBGPRINT_ERR(("H2M_MAILBOX still hold by MCU. command fail\n"));
 			}
 			return FALSE;
 		}
 #ifdef RTMP_MAC_PCI
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-		H2MMailbox.field.Owner = 1;	// pass ownership to MCU
+		H2MMailbox.field.Owner = 1;	/* pass ownership to MCU */
 		H2MMailbox.field.CmdToken = Token;
 		H2MMailbox.field.HighByte = Arg1;
 		H2MMailbox.field.LowByte = Arg0;
@@ -274,20 +272,20 @@ INT RtmpAsicSendCommandToMcu(IN PRTMP_ADAPTER pAd,
 		}
 	}
 #ifdef PCIE_PS_SUPPORT
-	// 3090 MCU Wakeup command needs more time to be stable.
-	// Before stable, don't issue other MCU command to prevent from firmware error.
+	/* 3090 MCU Wakeup command needs more time to be stable. */
+	/* Before stable, don't issue other MCU command to prevent from firmware error. */
 	if (((IS_RT3090(pAd) || IS_RT3572(pAd) || IS_RT3390(pAd))
 	     && IS_VERSION_AFTER_F(pAd)) && IS_VERSION_AFTER_F(pAd)
 	    && (pAd->StaCfg.PSControl.field.rt30xxPowerMode == 3)
 	    && (pAd->StaCfg.PSControl.field.EnableNewPS == TRUE)
 	    && (Command == WAKE_MCU_CMD)) {
 		RTMPusecDelay(2000);
-		//Put this is after RF programming.
-		//NdisAcquireSpinLock(&pAd->McuCmdLock);
-		//pAd->brt30xxBanMcuCmd = FALSE;
-		//NdisReleaseSpinLock(&pAd->McuCmdLock);
+		/*Put this is after RF programming. */
+		/*NdisAcquireSpinLock(&pAd->McuCmdLock); */
+		/*pAd->brt30xxBanMcuCmd = FALSE; */
+		/*NdisReleaseSpinLock(&pAd->McuCmdLock); */
 	}
-#endif // PCIE_PS_SUPPORT //
+#endif /* PCIE_PS_SUPPORT // */
 
 	return TRUE;
 }
diff --git a/drivers/staging/rt2860/common/rtmp_timer.c b/drivers/staging/rt2860/common/rtmp_timer.c
index 9abfe63..d29e6e8 100644
--- a/drivers/staging/rt2860/common/rtmp_timer.c
+++ b/drivers/staging/rt2860/common/rtmp_timer.c
@@ -41,13 +41,13 @@
 #include "../rt_config.h"
 
 BUILD_TIMER_FUNCTION(MlmePeriodicExec);
-//BUILD_TIMER_FUNCTION(MlmeRssiReportExec);
+/*BUILD_TIMER_FUNCTION(MlmeRssiReportExec); */
 BUILD_TIMER_FUNCTION(AsicRxAntEvalTimeout);
 BUILD_TIMER_FUNCTION(APSDPeriodicExec);
 BUILD_TIMER_FUNCTION(AsicRfTuningExec);
 #ifdef RTMP_MAC_USB
 BUILD_TIMER_FUNCTION(BeaconUpdateExec);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 BUILD_TIMER_FUNCTION(BeaconTimeout);
 BUILD_TIMER_FUNCTION(ScanTimeout);
@@ -61,10 +61,10 @@ BUILD_TIMER_FUNCTION(WpaDisassocApAndBlockAssoc);
 #ifdef RTMP_MAC_PCI
 BUILD_TIMER_FUNCTION(PsPollWakeExec);
 BUILD_TIMER_FUNCTION(RadioOnExec);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 BUILD_TIMER_FUNCTION(RtmpUsbStaAsicForceWakeupTimeout);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 #if defined(AP_LED) || defined(STA_LED)
 extern void LedCtrlMain(IN PVOID SystemSpecific1,
@@ -97,19 +97,19 @@ static void RtmpTimerQHandle(RTMP_ADAPTER * pAd)
 		if (pAd->TimerQ.status == RTMP_TASK_STAT_STOPED)
 			break;
 
-		// event happened.
+		/* event happened. */
 		while (pAd->TimerQ.pQHead) {
 			RTMP_INT_LOCK(&pAd->TimerQLock, irqFlag);
 			pEntry = pAd->TimerQ.pQHead;
 			if (pEntry) {
 				pTimer = pEntry->pRaTimer;
 
-				// update pQHead
+				/* update pQHead */
 				pAd->TimerQ.pQHead = pEntry->pNext;
 				if (pEntry == pAd->TimerQ.pQTail)
 					pAd->TimerQ.pQTail = NULL;
 
-				// return this queue entry to timerQFreeList.
+				/* return this queue entry to timerQFreeList. */
 				pEntry->pNext = pAd->TimerQ.pQPollFreeList;
 				pAd->TimerQ.pQPollFreeList = pEntry;
 			}
@@ -226,7 +226,7 @@ BOOLEAN RtmpTimerQRemove(IN RTMP_ADAPTER * pAd, IN RALINK_TIMER_STRUCT * pTimer)
 			pNode = pNode->pNext;
 		}
 
-		// Now move it to freeList queue.
+		/* Now move it to freeList queue. */
 		if (pNode) {
 			if (pNode == pAd->TimerQ.pQHead)
 				pAd->TimerQ.pQHead = pNode->pNext;
@@ -235,7 +235,7 @@ BOOLEAN RtmpTimerQRemove(IN RTMP_ADAPTER * pAd, IN RALINK_TIMER_STRUCT * pTimer)
 			if (pPrev != NULL)
 				pPrev->pNext = pNode->pNext;
 
-			// return this queue entry to timerQFreeList.
+			/* return this queue entry to timerQFreeList. */
 			pNode->pNext = pAd->TimerQ.pQPollFreeList;
 			pAd->TimerQ.pQPollFreeList = pNode;
 		}
@@ -254,7 +254,7 @@ void RtmpTimerQExit(RTMP_ADAPTER * pAd)
 	while (pAd->TimerQ.pQHead) {
 		pTimerQ = pAd->TimerQ.pQHead;
 		pAd->TimerQ.pQHead = pTimerQ->pNext;
-		// remove the timeQ
+		/* remove the timeQ */
 	}
 	pAd->TimerQ.pQPollFreeList = NULL;
 	os_free_mem(pAd, pAd->TimerQ.pTimerQPoll);
@@ -299,4 +299,4 @@ void RtmpTimerQInit(RTMP_ADAPTER * pAd)
 		RTMP_INT_UNLOCK(&pAd->TimerQLock, irqFlags);
 	}
 }
-#endif // RTMP_TIMER_TASK_SUPPORT //
+#endif /* RTMP_TIMER_TASK_SUPPORT // */
diff --git a/drivers/staging/rt2860/common/spectrum.c b/drivers/staging/rt2860/common/spectrum.c
index 9c2df55..2cc73de 100644
--- a/drivers/staging/rt2860/common/spectrum.c
+++ b/drivers/staging/rt2860/common/spectrum.c
@@ -45,7 +45,7 @@ DOT11_REGULATORY_INFORMATION USARegulatoryInfo[] = {
 	{0, {0, 0, {0}
 	     }
 	 }
-	,			// Invlid entry
+	,			/* Invlid entry */
 	{1, {4, 16, {36, 40, 44, 48}
 	     }
 	 }
@@ -103,7 +103,7 @@ DOT11_REGULATORY_INFORMATION EuropeRegulatoryInfo[] = {
 	{0, {0, 0, {0}
 	     }
 	 }
-	,			// Invalid entry
+	,			/* Invalid entry */
 	{1, {4, 20, {36, 40, 44, 48}
 	     }
 	 }
@@ -129,7 +129,7 @@ DOT11_REGULATORY_INFORMATION JapanRegulatoryInfo[] = {
 	{0, {0, 0, {0}
 	     }
 	 }
-	,			// Invalid entry
+	,			/* Invalid entry */
 	{1, {4, 22, {34, 38, 42, 46}
 	     }
 	 }
@@ -489,7 +489,7 @@ PMEASURE_REQ_ENTRY MeasureReqInsert(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 				PMEASURE_REQ_ENTRY pProbeEntry =
 				    pTab->Hash[HashIdx];
 
-				// update Hash list
+				/* update Hash list */
 				do {
 					if (pProbeEntry == pEntry) {
 						if (pPrevEntry == NULL) {
@@ -529,7 +529,7 @@ PMEASURE_REQ_ENTRY MeasureReqInsert(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 				 ("%s: pMeasureReqTab tab full.\n", __func__));
 		}
 
-		// add this Neighbor entry into HASH table
+		/* add this Neighbor entry into HASH table */
 		if (pEntry) {
 			HashIdx = MQ_DIALOGTOKEN_HASH_INDEX(DialogToken);
 			if (pTab->Hash[HashIdx] == NULL) {
@@ -558,7 +558,7 @@ VOID MeasureReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 			 ("%s: pMeasureReqTab doesn't exist.\n", __func__));
 		return;
 	}
-	// if empty, return
+	/* if empty, return */
 	if (pTab->Size == 0) {
 		DBGPRINT(RT_DEBUG_ERROR, ("pMeasureReqTab empty.\n"));
 		return;
@@ -571,7 +571,7 @@ VOID MeasureReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 		PMEASURE_REQ_ENTRY pProbeEntry = pTab->Hash[HashIdx];
 
 		RTMP_SEM_LOCK(&pAd->CommonCfg.MeasureReqTabLock);
-		// update Hash list
+		/* update Hash list */
 		do {
 			if (pProbeEntry == pEntry) {
 				if (pPrevEntry == NULL) {
@@ -687,7 +687,7 @@ static PTPC_REQ_ENTRY TpcReqInsert(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 				PTPC_REQ_ENTRY pProbeEntry =
 				    pTab->Hash[HashIdx];
 
-				// update Hash list
+				/* update Hash list */
 				do {
 					if (pProbeEntry == pEntry) {
 						if (pPrevEntry == NULL) {
@@ -726,7 +726,7 @@ static PTPC_REQ_ENTRY TpcReqInsert(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 				 ("%s: pTpcReqTab tab full.\n", __func__));
 		}
 
-		// add this Neighbor entry into HASH table
+		/* add this Neighbor entry into HASH table */
 		if (pEntry) {
 			HashIdx = TPC_DIALOGTOKEN_HASH_INDEX(DialogToken);
 			if (pTab->Hash[HashIdx] == NULL) {
@@ -755,7 +755,7 @@ static VOID TpcReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 			 ("%s: pTpcReqTab doesn't exist.\n", __func__));
 		return;
 	}
-	// if empty, return
+	/* if empty, return */
 	if (pTab->Size == 0) {
 		DBGPRINT(RT_DEBUG_ERROR, ("pTpcReqTab empty.\n"));
 		return;
@@ -768,7 +768,7 @@ static VOID TpcReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
 		PTPC_REQ_ENTRY pProbeEntry = pTab->Hash[HashIdx];
 
 		RTMP_SEM_LOCK(&pAd->CommonCfg.TpcReqTabLock);
-		// update Hash list
+		/* update Hash list */
 		do {
 			if (pProbeEntry == pEntry) {
 				if (pPrevEntry == NULL) {
@@ -804,7 +804,7 @@ static VOID TpcReqDelete(IN PRTMP_ADAPTER pAd, IN UINT8 DialogToken)
  */
 static UINT64 GetCurrentTimeStamp(IN PRTMP_ADAPTER pAd)
 {
-	// get current time stamp.
+	/* get current time stamp. */
 	return 0;
 }
 
@@ -1121,7 +1121,7 @@ VOID MakeMeasurementReqFrame(IN PRTMP_ADAPTER pAd,
 	InsertActField(pAd, (pOutBuffer + *pFrameLen), pFrameLen, Category,
 		       Action);
 
-	// fill Dialog Token
+	/* fill Dialog Token */
 	InsertDialogToken(pAd, (pOutBuffer + *pFrameLen), pFrameLen,
 			  MeasureToken);
 
@@ -1132,7 +1132,7 @@ VOID MakeMeasurementReqFrame(IN PRTMP_ADAPTER pAd,
 
 		*pFrameLen += TempLen;
 	}
-	// prepare Measurement IE.
+	/* prepare Measurement IE. */
 	NdisZeroMemory(&MeasureReqIE, sizeof(MEASURE_REQ_INFO));
 	MeasureReqIE.Token = MeasureToken;
 	MeasureReqIE.ReqMode.word = MeasureReqMode;
@@ -1169,11 +1169,11 @@ VOID EnqueueMeasurementRep(IN PRTMP_ADAPTER pAd,
 	HEADER_802_11 ActHdr;
 	MEASURE_REPORT_INFO MeasureRepIE;
 
-	// build action frame header.
+	/* build action frame header. */
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
 			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("%s() allocate memory failed \n", __func__));
@@ -1185,10 +1185,10 @@ VOID EnqueueMeasurementRep(IN PRTMP_ADAPTER pAd,
 	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
 		       CATEGORY_SPECTRUM, SPEC_MRP);
 
-	// fill Dialog Token
+	/* fill Dialog Token */
 	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
 
-	// prepare Measurement IE.
+	/* prepare Measurement IE. */
 	NdisZeroMemory(&MeasureRepIE, sizeof(MEASURE_REPORT_INFO));
 	MeasureRepIE.Token = MeasureToken;
 	MeasureRepIE.ReportMode = MeasureReqMode;
@@ -1222,11 +1222,11 @@ VOID EnqueueTPCReq(IN PRTMP_ADAPTER pAd, IN PUCHAR pDA, IN UCHAR DialogToken)
 
 	HEADER_802_11 ActHdr;
 
-	// build action frame header.
+	/* build action frame header. */
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
 			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("%s() allocate memory failed \n", __func__));
@@ -1238,10 +1238,10 @@ VOID EnqueueTPCReq(IN PRTMP_ADAPTER pAd, IN PUCHAR pDA, IN UCHAR DialogToken)
 	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
 		       CATEGORY_SPECTRUM, SPEC_TPCRQ);
 
-	// fill Dialog Token
+	/* fill Dialog Token */
 	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
 
-	// Insert TPC Request IE.
+	/* Insert TPC Request IE. */
 	InsertTpcReqIE(pAd, (pOutBuffer + FrameLen), &FrameLen);
 
 	MiniportMMRequest(pAd, QID_AC_BE, pOutBuffer, FrameLen);
@@ -1272,11 +1272,11 @@ VOID EnqueueTPCRep(IN PRTMP_ADAPTER pAd,
 
 	HEADER_802_11 ActHdr;
 
-	// build action frame header.
+	/* build action frame header. */
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
 			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("%s() allocate memory failed \n", __func__));
@@ -1288,10 +1288,10 @@ VOID EnqueueTPCRep(IN PRTMP_ADAPTER pAd,
 	InsertActField(pAd, (pOutBuffer + FrameLen), &FrameLen,
 		       CATEGORY_SPECTRUM, SPEC_TPCRP);
 
-	// fill Dialog Token
+	/* fill Dialog Token */
 	InsertDialogToken(pAd, (pOutBuffer + FrameLen), &FrameLen, DialogToken);
 
-	// Insert TPC Request IE.
+	/* Insert TPC Request IE. */
 	InsertTpcReportIE(pAd, (pOutBuffer + FrameLen), &FrameLen, TxPwr,
 			  LinkMargin);
 
@@ -1324,11 +1324,11 @@ VOID EnqueueChSwAnn(IN PRTMP_ADAPTER pAd,
 
 	HEADER_802_11 ActHdr;
 
-	// build action frame header.
+	/* build action frame header. */
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0, pDA,
 			 pAd->CurrentAddress);
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("%s() allocate memory failed \n", __func__));
@@ -1355,18 +1355,18 @@ static BOOLEAN DfsRequirementCheck(IN PRTMP_ADAPTER pAd, IN UINT8 Channel)
 	INT i;
 
 	do {
-		// check DFS procedure is running.
-		// make sure DFS procedure won't start twice.
+		/* check DFS procedure is running. */
+		/* make sure DFS procedure won't start twice. */
 		if (pAd->CommonCfg.RadarDetect.RDMode != RD_NORMAL_MODE) {
 			Result = FALSE;
 			break;
 		}
-		// check the new channel carried from Channel Switch Announcemnet is valid.
+		/* check the new channel carried from Channel Switch Announcemnet is valid. */
 		for (i = 0; i < pAd->ChannelListNum; i++) {
 			if ((Channel == pAd->ChannelList[i].Channel)
 			    && (pAd->ChannelList[i].RemainingTimeForUse == 0)) {
-				// found radar signal in the channel. the channel can't use at least for 30 minutes.
-				pAd->ChannelList[i].RemainingTimeForUse = 1800;	//30 min = 1800 sec
+				/* found radar signal in the channel. the channel can't use at least for 30 minutes. */
+				pAd->ChannelList[i].RemainingTimeForUse = 1800;	/*30 min = 1800 sec */
 				Result = TRUE;
 				break;
 			}
@@ -1385,7 +1385,7 @@ VOID NotifyChSwAnnToPeerAPs(IN PRTMP_ADAPTER pAd,
 static VOID StartDFSProcedure(IN PRTMP_ADAPTER pAd,
 			      IN UCHAR Channel, IN UINT8 ChSwMode)
 {
-	// start DFS procedure
+	/* start DFS procedure */
 	pAd->CommonCfg.Channel = Channel;
 
 	N_ChannelCheck(pAd);
@@ -1425,10 +1425,10 @@ static BOOLEAN PeerChSwAnnSanity(IN PRTMP_ADAPTER pAd,
 	BOOLEAN result = FALSE;
 	PEID_STRUCT eid_ptr;
 
-	// skip 802.11 header.
+	/* skip 802.11 header. */
 	MsgLen -= sizeof(HEADER_802_11);
 
-	// skip category and action code.
+	/* skip category and action code. */
 	pFramePtr += 2;
 	MsgLen -= 2;
 
@@ -1487,10 +1487,10 @@ static BOOLEAN PeerMeasureReqSanity(IN PRTMP_ADAPTER pAd,
 	UINT64 MeasureStartTime;
 	UINT16 MeasureDuration;
 
-	// skip 802.11 header.
+	/* skip 802.11 header. */
 	MsgLen -= sizeof(HEADER_802_11);
 
-	// skip category and action code.
+	/* skip category and action code. */
 	pFramePtr += 2;
 	MsgLen -= 2;
 
@@ -1580,10 +1580,10 @@ static BOOLEAN PeerMeasureReportSanity(IN PRTMP_ADAPTER pAd,
 	PEID_STRUCT eid_ptr;
 	PUCHAR ptr;
 
-	// skip 802.11 header.
+	/* skip 802.11 header. */
 	MsgLen -= sizeof(HEADER_802_11);
 
-	// skip category and action code.
+	/* skip category and action code. */
 	pFramePtr += 2;
 	MsgLen -= 2;
 
@@ -1677,7 +1677,7 @@ static BOOLEAN PeerTpcReqSanity(IN PRTMP_ADAPTER pAd,
 
 	MsgLen -= sizeof(HEADER_802_11);
 
-	// skip category and action code.
+	/* skip category and action code. */
 	pFramePtr += 2;
 	MsgLen -= 2;
 
@@ -1732,7 +1732,7 @@ static BOOLEAN PeerTpcRepSanity(IN PRTMP_ADAPTER pAd,
 
 	MsgLen -= sizeof(HEADER_802_11);
 
-	// skip category and action code.
+	/* skip category and action code. */
 	pFramePtr += 2;
 	MsgLen -= 2;
 
@@ -1808,16 +1808,16 @@ static VOID PeerChSwAnnAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0)
 		    && (Channel != NewChannel)) {
-			// Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection).
-			// In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results.
+			/* Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection). */
+			/* In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results. */
 			AsicSwitchChannel(pAd, 1, FALSE);
 			AsicLockChannel(pAd, 1);
 			LinkDown(pAd, FALSE);
 			MlmeQueueInit(&pAd->Mlme.Queue);
 			BssTableInit(&pAd->ScanTab);
-			RTMPusecDelay(1000000);	// use delay to prevent STA do reassoc
+			RTMPusecDelay(1000000);	/* use delay to prevent STA do reassoc */
 
-			// channel sanity check
+			/* channel sanity check */
 			for (index = 0; index < pAd->ChannelListNum; index++) {
 				if (pAd->ChannelList[index].Channel ==
 				    NewChannel) {
@@ -1897,8 +1897,8 @@ static VOID PeerMeasureReportAction(IN PRTMP_ADAPTER pAd,
 	UINT8 DialogToken;
 	PUINT8 pMeasureReportInfo;
 
-//      if (pAd->CommonCfg.bIEEE80211H != TRUE)
-//              return;
+/*      if (pAd->CommonCfg.bIEEE80211H != TRUE) */
+/*              return; */
 
 	if ((pMeasureReportInfo =
 	     kmalloc(sizeof(MEASURE_RPI_REPORT), GFP_ATOMIC)) == NULL) {
@@ -1916,8 +1916,8 @@ static VOID PeerMeasureReportAction(IN PRTMP_ADAPTER pAd,
 		do {
 			PMEASURE_REQ_ENTRY pEntry = NULL;
 
-			// Not a autonomous measure report.
-			// check the dialog token field. drop it if the dialog token doesn't match.
+			/* Not a autonomous measure report. */
+			/* check the dialog token field. drop it if the dialog token doesn't match. */
 			if ((DialogToken != 0)
 			    && ((pEntry = MeasureReqLookUp(pAd, DialogToken)) ==
 				NULL))
@@ -1974,18 +1974,18 @@ static VOID PeerTpcReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	UINT8 LinkMargin = 0;
 	CHAR RealRssi;
 
-	// link margin: Ratio of the received signal power to the minimum desired by the station (STA). The
-	//                              STA may incorporate rate information and channel conditions, including interference, into its computation
-	//                              of link margin.
+	/* link margin: Ratio of the received signal power to the minimum desired by the station (STA). The */
+	/*                              STA may incorporate rate information and channel conditions, including interference, into its computation */
+	/*                              of link margin. */
 
 	RealRssi = RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0),
 			       ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
 			       ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
 
-	// skip Category and action code.
+	/* skip Category and action code. */
 	pFramePtr += 2;
 
-	// Dialog token.
+	/* Dialog token. */
 	NdisMoveMemory(&DialogToken, pFramePtr, 1);
 
 	LinkMargin = (RealRssi / MIN_RCV_PWR);
@@ -2050,8 +2050,8 @@ VOID PeerSpectrumAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	switch (Action) {
 	case SPEC_MRQ:
-		// current rt2860 unable do such measure specified in Measurement Request.
-		// reject all measurement request.
+		/* current rt2860 unable do such measure specified in Measurement Request. */
+		/* reject all measurement request. */
 		PeerMeasureReqAction(pAd, Elem);
 		break;
 
@@ -2104,7 +2104,7 @@ INT Set_MeasureReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 	NDIS_STATUS NStatus;
 	ULONG FrameLen;
 
-	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("%s() allocate memory failed \n", __func__));
@@ -2114,11 +2114,11 @@ INT Set_MeasureReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 	ArgIdx = 1;
 	while ((thisChar = strsep((char **)&arg, "-")) != NULL) {
 		switch (ArgIdx) {
-		case 1:	// Aid.
+		case 1:	/* Aid. */
 			Aid = (UINT8) simple_strtol(thisChar, 0, 16);
 			break;
 
-		case 2:	// Measurement Request Type.
+		case 2:	/* Measurement Request Type. */
 			MeasureReqType = simple_strtol(thisChar, 0, 16);
 			if (MeasureReqType > 3) {
 				DBGPRINT(RT_DEBUG_ERROR,
@@ -2128,7 +2128,7 @@ INT Set_MeasureReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 			}
 			break;
 
-		case 3:	// Measurement channel.
+		case 3:	/* Measurement channel. */
 			MeasureCh = (UINT8) simple_strtol(thisChar, 0, 16);
 			break;
 		}
@@ -2149,7 +2149,7 @@ INT Set_MeasureReq_Proc(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
 
 	MeasureReqInsert(pAd, MeasureReqToken);
 
-	// build action frame header.
+	/* build action frame header. */
 	MgtMacHeaderInit(pAd, &ActHdr, SUBTYPE_ACTION, 0,
 			 pAd->MacTab.Content[Aid].Addr, pAd->CurrentAddress);
 
-- 
1.7.1

