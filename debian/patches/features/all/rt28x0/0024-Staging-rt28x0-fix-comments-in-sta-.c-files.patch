From 05bf57c2de80a8c11de7eca3465040fe85489291 Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Fri, 11 Dec 2009 12:23:15 -0800
Subject: [PATCH 24/42] Staging: rt28x0: fix comments in sta/*.c files

commit 8281958ba7c8f4cb8695113a221e1f508f4feea6 upstream.

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2860/sta/assoc.c     |  246 +++++-----
 drivers/staging/rt2860/sta/auth.c      |   30 +-
 drivers/staging/rt2860/sta/auth_rsp.c  |    8 +-
 drivers/staging/rt2860/sta/connect.c   |  694 ++++++++++++++--------------
 drivers/staging/rt2860/sta/rtmp_data.c |  786 ++++++++++++++++----------------
 drivers/staging/rt2860/sta/sanity.c    |   66 ++--
 drivers/staging/rt2860/sta/sync.c      |  336 +++++++-------
 drivers/staging/rt2860/sta/wpa.c       |   92 ++--
 8 files changed, 1129 insertions(+), 1129 deletions(-)

diff --git a/drivers/staging/rt2860/sta/assoc.c b/drivers/staging/rt2860/sta/assoc.c
index e977416..c5a1738 100644
--- a/drivers/staging/rt2860/sta/assoc.c
+++ b/drivers/staging/rt2860/sta/assoc.c
@@ -37,27 +37,27 @@
 #include "../rt_config.h"
 
 UCHAR CipherWpaTemplate[] = {
-	0xdd,			// WPA IE
-	0x16,			// Length
-	0x00, 0x50, 0xf2, 0x01,	// oui
-	0x01, 0x00,		// Version
-	0x00, 0x50, 0xf2, 0x02,	// Multicast
-	0x01, 0x00,		// Number of unicast
-	0x00, 0x50, 0xf2, 0x02,	// unicast
-	0x01, 0x00,		// number of authentication method
-	0x00, 0x50, 0xf2, 0x01	// authentication
+	0xdd,			/* WPA IE */
+	0x16,			/* Length */
+	0x00, 0x50, 0xf2, 0x01,	/* oui */
+	0x01, 0x00,		/* Version */
+	0x00, 0x50, 0xf2, 0x02,	/* Multicast */
+	0x01, 0x00,		/* Number of unicast */
+	0x00, 0x50, 0xf2, 0x02,	/* unicast */
+	0x01, 0x00,		/* number of authentication method */
+	0x00, 0x50, 0xf2, 0x01	/* authentication */
 };
 
 UCHAR CipherWpa2Template[] = {
-	0x30,			// RSN IE
-	0x14,			// Length
-	0x01, 0x00,		// Version
-	0x00, 0x0f, 0xac, 0x02,	// group cipher, TKIP
-	0x01, 0x00,		// number of pairwise
-	0x00, 0x0f, 0xac, 0x02,	// unicast
-	0x01, 0x00,		// number of authentication method
-	0x00, 0x0f, 0xac, 0x02,	// authentication
-	0x00, 0x00,		// RSN capability
+	0x30,			/* RSN IE */
+	0x14,			/* Length */
+	0x01, 0x00,		/* Version */
+	0x00, 0x0f, 0xac, 0x02,	/* group cipher, TKIP */
+	0x01, 0x00,		/* number of pairwise */
+	0x00, 0x0f, 0xac, 0x02,	/* unicast */
+	0x01, 0x00,		/* number of authentication method */
+	0x00, 0x0f, 0xac, 0x02,	/* authentication */
+	0x00, 0x00,		/* RSN capability */
 };
 
 UCHAR Ccx2IeInfo[] = { 0x00, 0x40, 0x96, 0x03, 0x02 };
@@ -80,7 +80,7 @@ VOID AssocStateMachineInit(IN PRTMP_ADAPTER pAd,
 			 (STATE_MACHINE_FUNC) Drop, ASSOC_IDLE,
 			 ASSOC_MACHINE_BASE);
 
-	// first column
+	/* first column */
 	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ,
 			      (STATE_MACHINE_FUNC) MlmeAssocReqAction);
 	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ,
@@ -90,7 +90,7 @@ VOID AssocStateMachineInit(IN PRTMP_ADAPTER pAd,
 	StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ,
 			      (STATE_MACHINE_FUNC) PeerDisassocAction);
 
-	// second column
+	/* second column */
 	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
 			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
 	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
@@ -102,16 +102,16 @@ VOID AssocStateMachineInit(IN PRTMP_ADAPTER pAd,
 			      (STATE_MACHINE_FUNC) PeerDisassocAction);
 	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP,
 			      (STATE_MACHINE_FUNC) PeerAssocRspAction);
-	//
-	// Patch 3Com AP MOde:3CRWE454G72
-	// We send Assoc request frame to this AP, it always send Reassoc Rsp not Associate Rsp.
-	//
+	/* */
+	/* Patch 3Com AP MOde:3CRWE454G72 */
+	/* We send Assoc request frame to this AP, it always send Reassoc Rsp not Associate Rsp. */
+	/* */
 	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP,
 			      (STATE_MACHINE_FUNC) PeerAssocRspAction);
 	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT,
 			      (STATE_MACHINE_FUNC) AssocTimeoutAction);
 
-	// third column
+	/* third column */
 	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
 			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
 	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
@@ -123,15 +123,15 @@ VOID AssocStateMachineInit(IN PRTMP_ADAPTER pAd,
 			      (STATE_MACHINE_FUNC) PeerDisassocAction);
 	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP,
 			      (STATE_MACHINE_FUNC) PeerReassocRspAction);
-	//
-	// Patch, AP doesn't send Reassociate Rsp frame to Station.
-	//
+	/* */
+	/* Patch, AP doesn't send Reassociate Rsp frame to Station. */
+	/* */
 	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP,
 			      (STATE_MACHINE_FUNC) PeerReassocRspAction);
 	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT,
 			      (STATE_MACHINE_FUNC) ReassocTimeoutAction);
 
-	// fourth column
+	/* fourth column */
 	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
 			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
 	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
@@ -144,7 +144,7 @@ VOID AssocStateMachineInit(IN PRTMP_ADAPTER pAd,
 	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT,
 			      (STATE_MACHINE_FUNC) DisassocTimeoutAction);
 
-	// initialize the timer
+	/* initialize the timer */
 	RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer,
 		      GET_TIMER_FUNCTION(AssocTimeout), pAd, FALSE);
 	RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer,
@@ -171,8 +171,8 @@ VOID AssocTimeout(IN PVOID SystemSpecific1,
 {
 	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
@@ -199,8 +199,8 @@ VOID ReassocTimeout(IN PVOID SystemSpecific1,
 {
 	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
@@ -227,8 +227,8 @@ VOID DisassocTimeout(IN PVOID SystemSpecific1,
 {
 	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
@@ -277,7 +277,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	USHORT VarIesOffset;
 	USHORT Status;
 
-	// Block all authentication request durning WPA block period
+	/* Block all authentication request durning WPA block period */
 	if (pAd->StaCfg.bBlockAssoc == TRUE) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("ASSOC - Block Assoc request durning WPA block period!\n"));
@@ -286,14 +286,14 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2,
 			    &Status);
 	}
-	// check sanity first
+	/* check sanity first */
 	else if (MlmeAssocReqSanity
 		 (pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo,
 		  &Timeout, &ListenIntv)) {
 		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &TimerCancelled);
 		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
 
-		// Get an unused nonpaged memory
+		/* Get an unused nonpaged memory */
 		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
 		if (NStatus != NDIS_STATUS_SUCCESS) {
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -304,10 +304,10 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    MT2_ASSOC_CONF, 2, &Status);
 			return;
 		}
-		// Add by James 03/06/27
+		/* Add by James 03/06/27 */
 		pAd->StaCfg.AssocInfo.Length =
 		    sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
-		// Association don't need to report MAC address
+		/* Association don't need to report MAC address */
 		pAd->StaCfg.AssocInfo.AvailableRequestFixedIEs =
 		    NDIS_802_11_AI_REQFI_CAPABILITIES |
 		    NDIS_802_11_AI_REQFI_LISTENINTERVAL;
@@ -315,13 +315,13 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		    CapabilityInfo;
 		pAd->StaCfg.AssocInfo.RequestFixedIEs.ListenInterval =
 		    ListenIntv;
-		// Only reassociate need this
-		//COPY_MAC_ADDR(pAd->StaCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr);
+		/* Only reassociate need this */
+		/*COPY_MAC_ADDR(pAd->StaCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr); */
 		pAd->StaCfg.AssocInfo.OffsetRequestIEs =
 		    sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
 
 		NdisZeroMemory(pAd->StaCfg.ReqVarIEs, MAX_VIE_LEN);
-		// First add SSID
+		/* First add SSID */
 		VarIesOffset = 0;
 		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SsidIe,
 			       1);
@@ -333,7 +333,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			       pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
 		VarIesOffset += pAd->MlmeAux.SsidLen;
 
-		// Second add Supported rates
+		/* Second add Supported rates */
 		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SupRateIe,
 			       1);
 		VarIesOffset += 1;
@@ -343,7 +343,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
 			       pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
 		VarIesOffset += pAd->MlmeAux.SupRateLen;
-		// End Add by James
+		/* End Add by James */
 
 		if ((pAd->CommonCfg.Channel > 14) &&
 		    (pAd->CommonCfg.bIEEE80211H == TRUE))
@@ -353,7 +353,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, ApAddr,
 				 ApAddr);
 
-		// Build basic frame first
+		/* Build basic frame first */
 		MakeOutgoingFrame(pOutBuffer, &FrameLen,
 				  sizeof(HEADER_802_11), &AssocHdr,
 				  2, &CapabilityInfo,
@@ -374,7 +374,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
 			FrameLen += tmp;
 		}
-		// HT
+		/* HT */
 		if ((pAd->MlmeAux.HtCapabilityLen > 0)
 		    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
 			ULONG TmpLen;
@@ -398,14 +398,14 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			}
 			FrameLen += TmpLen;
 		}
-		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION
-		// Case I: (Aggregation + Piggy-Back)
-		// 1. user enable aggregation, AND
-		// 2. Mac support piggy-back
-		// 3. AP annouces it's PIGGY-BACK+AGGREGATION-capable in BEACON
-		// Case II: (Aggregation)
-		// 1. user enable aggregation, AND
-		// 2. AP annouces it's AGGREGATION-capable in BEACON
+		/* add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION */
+		/* Case I: (Aggregation + Piggy-Back) */
+		/* 1. user enable aggregation, AND */
+		/* 2. Mac support piggy-back */
+		/* 3. AP annouces it's PIGGY-BACK+AGGREGATION-capable in BEACON */
+		/* Case II: (Aggregation) */
+		/* 1. user enable aggregation, AND */
+		/* 2. AP annouces it's AGGREGATION-capable in BEACON */
 		if (pAd->CommonCfg.bAggregationCapable) {
 			if ((pAd->CommonCfg.bPiggyBackCapable)
 			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
@@ -452,20 +452,20 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    pAd->CommonCfg.MaxSPLength;
 				WmeIe[8] |= *(PUCHAR) & QosInfo;
 			} else {
-				// The Parameter Set Count is set to ¡§0¡¨ in the association request frames
-				// WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
+				/* The Parameter Set Count is set to ¡§0¡¨ in the association request frames */
+				/* WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f); */
 			}
 
 			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
 					  9, &WmeIe[0], END_OF_ARGS);
 			FrameLen += tmp;
 		}
-		//
-		// Let WPA(#221) Element ID on the end of this association frame.
-		// Otherwise some AP will fail on parsing Element ID and set status fail on Assoc Rsp.
-		// For example: Put Vendor Specific IE on the front of WPA IE.
-		// This happens on AP (Model No:Linksys WRK54G)
-		//
+		/* */
+		/* Let WPA(#221) Element ID on the end of this association frame. */
+		/* Otherwise some AP will fail on parsing Element ID and set status fail on Assoc Rsp. */
+		/* For example: Put Vendor Specific IE on the front of WPA IE. */
+		/* This happens on AP (Model No:Linksys WRK54G) */
+		/* */
 		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
 		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
 		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
@@ -486,11 +486,11 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode,
 					      pAd->StaCfg.WepStatus, BSS0);
 
-			// Check for WPA PMK cache list
+			/* Check for WPA PMK cache list */
 			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) {
 				INT idx;
 				BOOLEAN FoundPMK = FALSE;
-				// Search chched PMKID, append it if existed
+				/* Search chched PMKID, append it if existed */
 				for (idx = 0; idx < PMKID_NO; idx++) {
 					if (NdisEqualMemory
 					    (ApAddr,
@@ -501,7 +501,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					}
 				}
 				if (FoundPMK) {
-					// Set PMK number
+					/* Set PMK number */
 					*(PUSHORT) & pAd->StaCfg.RSN_IE[pAd->
 									StaCfg.
 									RSNIE_Len]
@@ -538,7 +538,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			     WPA_SUPPLICANT_ENABLE)
 			    || (pAd->StaCfg.bRSN_IE_FromWpaSupplicant ==
 				FALSE)) {
-				// Append Variable IE
+				/* Append Variable IE */
 				NdisMoveMemory(pAd->StaCfg.ReqVarIEs +
 					       VarIesOffset, &RSNIe, 1);
 				VarIesOffset += 1;
@@ -552,7 +552,7 @@ VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				       pAd->StaCfg.RSNIE_Len);
 			VarIesOffset += pAd->StaCfg.RSNIE_Len;
 
-			// Set Variable IEs Length
+			/* Set Variable IEs Length */
 			pAd->StaCfg.ReqVarIELen = VarIesOffset;
 		}
 
@@ -605,7 +605,7 @@ VOID MlmeReassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	PUCHAR pOutBuffer = NULL;
 	USHORT Status;
 
-	// Block all authentication request durning WPA block period
+	/* Block all authentication request durning WPA block period */
 	if (pAd->StaCfg.bBlockAssoc == TRUE) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("ASSOC - Block ReAssoc request durning WPA block period!\n"));
@@ -614,13 +614,13 @@ VOID MlmeReassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2,
 			    &Status);
 	}
-	// the parameters are the same as the association
+	/* the parameters are the same as the association */
 	else if (MlmeAssocReqSanity
 		 (pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo,
 		  &Timeout, &ListenIntv)) {
 		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &TimerCancelled);
 
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 		if (NStatus != NDIS_STATUS_SUCCESS) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("ASSOC - MlmeReassocReqAction() allocate memory failed \n"));
@@ -633,7 +633,7 @@ VOID MlmeReassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
 
-		// make frame, use bssid as the AP address??
+		/* make frame, use bssid as the AP address?? */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("ASSOC - Send RE-ASSOC request...\n"));
 		MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0,
@@ -676,7 +676,7 @@ VOID MlmeReassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					  9, &WmeIe[0], END_OF_ARGS);
 			FrameLen += tmp;
 		}
-		// HT
+		/* HT */
 		if ((pAd->MlmeAux.HtCapabilityLen > 0)
 		    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
 			ULONG TmpLen;
@@ -700,14 +700,14 @@ VOID MlmeReassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			}
 			FrameLen += TmpLen;
 		}
-		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION
-		// Case I: (Aggregation + Piggy-Back)
-		// 1. user enable aggregation, AND
-		// 2. Mac support piggy-back
-		// 3. AP annouces it's PIGGY-BACK+AGGREGATION-capable in BEACON
-		// Case II: (Aggregation)
-		// 1. user enable aggregation, AND
-		// 2. AP annouces it's AGGREGATION-capable in BEACON
+		/* add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION */
+		/* Case I: (Aggregation + Piggy-Back) */
+		/* 1. user enable aggregation, AND */
+		/* 2. Mac support piggy-back */
+		/* 3. AP annouces it's PIGGY-BACK+AGGREGATION-capable in BEACON */
+		/* Case II: (Aggregation) */
+		/* 1. user enable aggregation, AND */
+		/* 2. AP annouces it's AGGREGATION-capable in BEACON */
 		if (pAd->CommonCfg.bAggregationCapable) {
 			if ((pAd->CommonCfg.bPiggyBackCapable)
 			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
@@ -777,10 +777,10 @@ VOID MlmeDisassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	ULONG Timeout = 500;
 	USHORT Status;
 
-	// skip sanity check
+	/* skip sanity check */
 	pDisassocReq = (PMLME_DISASSOC_REQ_STRUCT) (Elem->Msg);
 
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("ASSOC - MlmeDisassocReqAction() allocate memory failed\n"));
@@ -799,15 +799,15 @@ VOID MlmeDisassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		  pDisassocReq->Addr[2], pDisassocReq->Addr[3],
 		  pDisassocReq->Addr[4], pDisassocReq->Addr[5],
 		  pDisassocReq->Reason));
-	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pDisassocReq->Addr, pDisassocReq->Addr);	// patch peap ttls switching issue
+	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pDisassocReq->Addr, pDisassocReq->Addr);	/* patch peap ttls switching issue */
 	MakeOutgoingFrame(pOutBuffer, &FrameLen,
 			  sizeof(HEADER_802_11), &DisassocHdr,
 			  2, &pDisassocReq->Reason, END_OF_ARGS);
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 
-	// To patch Instance and Buffalo(N) AP
-	// Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine
-	// Therefore, we send both of them.
+	/* To patch Instance and Buffalo(N) AP */
+	/* Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine */
+	/* Therefore, we send both of them. */
 	pDisassocHdr = (PHEADER_802_11) pOutBuffer;
 	pDisassocHdr->FC.SubType = SUBTYPE_DEAUTH;
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
@@ -845,7 +845,7 @@ VOID PeerAssocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	UCHAR CkipFlag;
 	EDCA_PARM EdcaParm;
 	HT_CAPABILITY_IE HtCapability;
-	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	ADD_HT_INFO_IE AddHtInfo;	/* AP might use this additional ht info IE */
 	UCHAR HtCapabilityLen = 0;
 	UCHAR AddHtInfoLen;
 	UCHAR NewExtChannelOffset = 0xff;
@@ -855,7 +855,7 @@ VOID PeerAssocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	     &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &HtCapability,
 	     &AddHtInfo, &HtCapabilityLen, &AddHtInfoLen, &NewExtChannelOffset,
 	     &EdcaParm, &CkipFlag)) {
-		// The frame is for me ?
+		/* The frame is for me ? */
 		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("PeerAssocRspAction():ASSOC - receive ASSOC_RSP to me (status=%d)\n",
@@ -873,7 +873,7 @@ VOID PeerAssocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				UCHAR MaxSupportedRateIn500Kbps = 0;
 				UCHAR idx;
 
-				// supported rates array may not be sorted. sort it and find the maximum rate
+				/* supported rates array may not be sorted. sort it and find the maximum rate */
 				for (idx = 0; idx < SupRateLen; idx++) {
 					if (MaxSupportedRateIn500Kbps <
 					    (SupRate[idx] & 0x7f))
@@ -887,7 +887,7 @@ VOID PeerAssocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						MaxSupportedRateIn500Kbps =
 						    ExtRate[idx] & 0x7f;
 				}
-				// go to procedure listed on page 376
+				/* go to procedure listed on page 376 */
 				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid,
 					      SupRate, SupRateLen, ExtRate,
 					      ExtRateLen, &EdcaParm,
@@ -936,7 +936,7 @@ VOID PeerReassocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	BOOLEAN TimerCancelled;
 	EDCA_PARM EdcaParm;
 	HT_CAPABILITY_IE HtCapability;
-	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	ADD_HT_INFO_IE AddHtInfo;	/* AP might use this additional ht info IE */
 	UCHAR HtCapabilityLen;
 	UCHAR AddHtInfoLen;
 	UCHAR NewExtChannelOffset = 0xff;
@@ -946,7 +946,7 @@ VOID PeerReassocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	     &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &HtCapability,
 	     &AddHtInfo, &HtCapabilityLen, &AddHtInfoLen, &NewExtChannelOffset,
 	     &EdcaParm, &CkipFlag)) {
-		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid))	// The frame is for me ?
+		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid))	/* The frame is for me ? */
 		{
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("ASSOC - receive REASSOC_RSP to me (status=%d)\n",
@@ -955,7 +955,7 @@ VOID PeerReassocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					&TimerCancelled);
 
 			if (Status == MLME_SUCCESS) {
-				// go to procedure listed on page 376
+				/* go to procedure listed on page 376 */
 				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid,
 					      SupRate, SupRateLen, ExtRate,
 					      ExtRateLen, &EdcaParm,
@@ -972,7 +972,7 @@ VOID PeerReassocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				}
 
 			}
-			// CkipFlag is no use for reassociate
+			/* CkipFlag is no use for reassociate */
 			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
 				    MT2_REASSOC_CONF, 2, &Status);
@@ -994,7 +994,7 @@ VOID PeerReassocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	==========================================================================
  */
-VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityInfo, IN USHORT Aid, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN PEDCA_PARM pEdcaParm, IN HT_CAPABILITY_IE * pHtCapability, IN UCHAR HtCapabilityLen, IN ADD_HT_INFO_IE * pAddHtInfo)	// AP might use this additional ht info IE
+VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityInfo, IN USHORT Aid, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN PEDCA_PARM pEdcaParm, IN HT_CAPABILITY_IE * pHtCapability, IN UCHAR HtCapabilityLen, IN ADD_HT_INFO_IE * pAddHtInfo)	/* AP might use this additional ht info IE */
 {
 	ULONG Idx;
 
@@ -1004,7 +1004,7 @@ VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityI
 	pAd->MlmeAux.CapabilityInfo =
 	    CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
 
-	// Some HT AP might lost WMM IE. We add WMM ourselves. beacuase HT requires QoS on.
+	/* Some HT AP might lost WMM IE. We add WMM ourselves. beacuase HT requires QoS on. */
 	if ((HtCapabilityLen > 0) && (pEdcaParm->bValid == FALSE)) {
 		pEdcaParm->bValid = TRUE;
 		pEdcaParm->Aifsn[0] = 3;
@@ -1031,12 +1031,12 @@ VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityI
 
 	NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, pEdcaParm, sizeof(EDCA_PARM));
 
-	// filter out un-supported rates
+	/* filter out un-supported rates */
 	pAd->MlmeAux.SupRateLen = SupRateLen;
 	NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
 	RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
 
-	// filter out un-supported rates
+	/* filter out un-supported rates */
 	pAd->MlmeAux.ExtRateLen = ExtRateLen;
 	NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
 	RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
@@ -1054,17 +1054,17 @@ VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityI
 		  pAd->MacTab.Content[BSSID_WCID].MmpsMode,
 		  pAd->MacTab.Content[BSSID_WCID].AMsduSize));
 
-	// Set New WPA information
+	/* Set New WPA information */
 	Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
 	if (Idx == BSS_NOT_FOUND) {
 		DBGPRINT_ERR(("ASSOC - Can't find BSS after receiving Assoc response\n"));
 	} else {
-		// Init variable
+		/* Init variable */
 		pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = 0;
 		NdisZeroMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE,
 			       MAX_LEN_OF_RSNIE);
 
-		// Store appropriate RSN_IE for WPA SM negotiation later
+		/* Store appropriate RSN_IE for WPA SM negotiation later */
 		if ((pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
 		    && (pAd->ScanTab.BssEntry[Idx].VarIELen != 0)) {
 			PUCHAR pVIE;
@@ -1073,14 +1073,14 @@ VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityI
 
 			pVIE = pAd->ScanTab.BssEntry[Idx].VarIEs;
 			len = pAd->ScanTab.BssEntry[Idx].VarIELen;
-			//KH need to check again
-			// Don't allow to go to sleep mode if authmode is WPA-related.
-			//This can make Authentication process more smoothly.
+			/*KH need to check again */
+			/* Don't allow to go to sleep mode if authmode is WPA-related. */
+			/*This can make Authentication process more smoothly. */
 			RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 
 			while (len > 0) {
 				pEid = (PEID_STRUCT) pVIE;
-				// For WPA/WPAPSK
+				/* For WPA/WPAPSK */
 				if ((pEid->Eid == IE_WPA)
 				    &&
 				    (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
@@ -1097,7 +1097,7 @@ VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityI
 					DBGPRINT(RT_DEBUG_TRACE,
 						 ("AssocPostProc===> Store RSN_IE for WPA SM negotiation \n"));
 				}
-				// For WPA2/WPA2PSK
+				/* For WPA2/WPA2PSK */
 				else if ((pEid->Eid == IE_RSN)
 					 &&
 					 (NdisEqualMemory
@@ -1292,21 +1292,21 @@ VOID Cls3errAction(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr)
 	NDIS_STATUS NStatus;
 	USHORT Reason = REASON_CLS3ERR;
 
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS)
 		return;
 
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("ASSOC - Class 3 Error, Send DISASSOC frame\n"));
-	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, pAd->CommonCfg.Bssid);	// patch peap ttls switching issue
+	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, pAd->CommonCfg.Bssid);	/* patch peap ttls switching issue */
 	MakeOutgoingFrame(pOutBuffer, &FrameLen,
 			  sizeof(HEADER_802_11), &DisassocHdr,
 			  2, &Reason, END_OF_ARGS);
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 
-	// To patch Instance and Buffalo(N) AP
-	// Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine
-	// Therefore, we send both of them.
+	/* To patch Instance and Buffalo(N) AP */
+	/* Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine */
+	/* Therefore, we send both of them. */
 	pDisassocHdr = (PHEADER_802_11) pOutBuffer;
 	pDisassocHdr->FC.SubType = SUBTYPE_DEAUTH;
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
@@ -1393,7 +1393,7 @@ BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
 	    && (MaxSupportedRate < RATE_FIRST_OFDM_RATE))
 		return FALSE;
 
-	// 11n only
+	/* 11n only */
 	if (((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
 	     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))
 	    && (HtCapabilityLen == 0))
@@ -1445,10 +1445,10 @@ BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
 	}
 
 	NdisZeroMemory(&pEntry->HTCapability, sizeof(pEntry->HTCapability));
-	// If this Entry supports 802.11n, upgrade to HT rate.
+	/* If this Entry supports 802.11n, upgrade to HT rate. */
 	if ((HtCapabilityLen != 0)
 	    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
-		UCHAR j, bitmask;	//k,bitmask;
+		UCHAR j, bitmask;	/*k,bitmask; */
 		CHAR i;
 
 		if (ADHOC_ON(pAd))
@@ -1484,14 +1484,14 @@ BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
 			pAd->MacTab.fAnyStation20Only = TRUE;
 		}
 
-		// 3*3
+		/* 3*3 */
 		if (pAd->MACVersion >= RALINK_2883_VERSION
 		    && pAd->MACVersion < RALINK_3070_VERSION)
 			pEntry->MaxHTPhyMode.field.TxBF =
 			    pAd->CommonCfg.RegTransmitSetting.field.TxBF;
 
-		// find max fixed rate
-		for (i = 23; i >= 0; i--)	// 3*3
+		/* find max fixed rate */
+		for (i = 23; i >= 0; i--)	/* 3*3 */
 		{
 			j = i / 8;
 			bitmask = (1 << (i - (j * 8)));
@@ -1506,7 +1506,7 @@ BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
 
 		if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO) {
 			if (pAd->StaCfg.DesiredTransmitSetting.field.MCS == 32) {
-				// Fix MCS as HT Duplicated Mode
+				/* Fix MCS as HT Duplicated Mode */
 				pEntry->MaxHTPhyMode.field.BW = 1;
 				pEntry->MaxHTPhyMode.field.MODE = MODE_HTMIX;
 				pEntry->MaxHTPhyMode.field.STBC = 0;
@@ -1514,7 +1514,7 @@ BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
 				pEntry->MaxHTPhyMode.field.MCS = 32;
 			} else if (pEntry->MaxHTPhyMode.field.MCS >
 				   pAd->StaCfg.HTPhyMode.field.MCS) {
-				// STA supports fixed MCS
+				/* STA supports fixed MCS */
 				pEntry->MaxHTPhyMode.field.MCS =
 				    pAd->StaCfg.HTPhyMode.field.MCS;
 			}
@@ -1565,7 +1565,7 @@ BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
 	pEntry->HTPhyMode.word = pEntry->MaxHTPhyMode.word;
 	pEntry->CurrTxRate = pEntry->MaxSupportedRate;
 
-	// Set asic auto fall back
+	/* Set asic auto fall back */
 	if (pAd->StaCfg.bAutoTxRateSwitch == TRUE) {
 		PUCHAR pTable;
 		UCHAR TableSize = 0;
@@ -1578,7 +1578,7 @@ BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
 		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
 		pEntry->bAutoTxRateSwitch = FALSE;
 
-		// If the legacy mode is set, overwrite the transmit setting of this entry.
+		/* If the legacy mode is set, overwrite the transmit setting of this entry. */
 		RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.
 					  DesiredTransmitSetting.field.
 					  FixedTxMode, pEntry);
diff --git a/drivers/staging/rt2860/sta/auth.c b/drivers/staging/rt2860/sta/auth.c
index 8b75b46..a69b6a7 100644
--- a/drivers/staging/rt2860/sta/auth.c
+++ b/drivers/staging/rt2860/sta/auth.c
@@ -62,11 +62,11 @@ void AuthStateMachineInit(IN PRTMP_ADAPTER pAd,
 			 (STATE_MACHINE_FUNC) Drop, AUTH_REQ_IDLE,
 			 AUTH_MACHINE_BASE);
 
-	// the first column
+	/* the first column */
 	StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_MLME_AUTH_REQ,
 			      (STATE_MACHINE_FUNC) MlmeAuthReqAction);
 
-	// the second column
+	/* the second column */
 	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_MLME_AUTH_REQ,
 			      (STATE_MACHINE_FUNC) InvalidStateWhenAuth);
 	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_PEER_AUTH_EVEN,
@@ -74,7 +74,7 @@ void AuthStateMachineInit(IN PRTMP_ADAPTER pAd,
 	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_AUTH_TIMEOUT,
 			      (STATE_MACHINE_FUNC) AuthTimeoutAction);
 
-	// the third column
+	/* the third column */
 	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_MLME_AUTH_REQ,
 			      (STATE_MACHINE_FUNC) InvalidStateWhenAuth);
 	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_PEER_AUTH_EVEN,
@@ -103,13 +103,13 @@ VOID AuthTimeout(IN PVOID SystemSpecific1,
 
 	DBGPRINT(RT_DEBUG_TRACE, ("AUTH - AuthTimeout\n"));
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG
 	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
-	// send a de-auth to reset AP's state machine (Patch AP-Dir635)
+	/* send a de-auth to reset AP's state machine (Patch AP-Dir635) */
 	if (pAd->Mlme.AuthMachine.CurrState == AUTH_WAIT_SEQ2)
 		Cls2errAction(pAd, pAd->MlmeAux.Bssid);
 
@@ -173,7 +173,7 @@ VOID PeerAuthRspAtSeq2Action(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					&TimerCancelled);
 
 			if (Status == MLME_SUCCESS) {
-				// Authentication Mode "LEAP" has allow for CCX 1.X
+				/* Authentication Mode "LEAP" has allow for CCX 1.X */
 				if (pAd->MlmeAux.Alg == Ndis802_11AuthModeOpen) {
 					pAd->Mlme.AuthMachine.CurrState =
 					    AUTH_REQ_IDLE;
@@ -181,11 +181,11 @@ VOID PeerAuthRspAtSeq2Action(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						    MLME_CNTL_STATE_MACHINE,
 						    MT2_AUTH_CONF, 2, &Status);
 				} else {
-					// 2. shared key, need to be challenged
+					/* 2. shared key, need to be challenged */
 					Seq++;
 					RemoteStatus = MLME_SUCCESS;
 
-					// Get an unused nonpaged memory
+					/* Get an unused nonpaged memory */
 					NStatus =
 					    MlmeAllocateMemory(pAd,
 							       &pOutBuffer);
@@ -208,7 +208,7 @@ VOID PeerAuthRspAtSeq2Action(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 							 SUBTYPE_AUTH, 0, Addr2,
 							 pAd->MlmeAux.Bssid);
 					AuthHdr.FC.Wep = 1;
-					// Encrypt challenge text & auth information
+					/* Encrypt challenge text & auth information */
 					RTMPInitWepEngine(pAd,
 							  pAd->
 							  SharedKey[BSS0][pAd->
@@ -332,7 +332,7 @@ VOID MlmeDeauthReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	pInfo = (MLME_DEAUTH_REQ_STRUCT *) Elem->Msg;
 
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("AUTH - MlmeDeauthReqAction() allocate memory fail\n"));
@@ -359,7 +359,7 @@ VOID MlmeDeauthReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	Status = MLME_SUCCESS;
 	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2, &Status);
 
-	// send wireless event - for deauthentication
+	/* send wireless event - for deauthentication */
 	if (pAd->CommonCfg.bWirelessEvent)
 		RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG,
 				      pAd->MacTab.Content[BSSID_WCID].Addr,
@@ -422,7 +422,7 @@ VOID Cls2errAction(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr)
 	ULONG FrameLen = 0;
 	USHORT Reason = REASON_CLS2ERR;
 
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NStatus != NDIS_STATUS_SUCCESS)
 		return;
 
@@ -455,7 +455,7 @@ BOOLEAN AUTH_ReqSend(IN PRTMP_ADAPTER pAd,
 	PUCHAR pOutBuffer = NULL;
 	ULONG FrameLen = 0, tmp = 0;
 
-	// Block all authentication request durning WPA block period
+	/* Block all authentication request durning WPA block period */
 	if (pAd->StaCfg.bBlockAssoc == TRUE) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("%s - Block Auth request durning WPA block period!\n",
@@ -475,7 +475,7 @@ BOOLEAN AUTH_ReqSend(IN PRTMP_ADAPTER pAd,
 		Seq = SeqNo;
 		Status = MLME_SUCCESS;
 
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 		if (NStatus != NDIS_STATUS_SUCCESS) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("%s - MlmeAuthReqAction(Alg:%d) allocate memory failed\n",
diff --git a/drivers/staging/rt2860/sta/auth_rsp.c b/drivers/staging/rt2860/sta/auth_rsp.c
index 3f383c5..e3c07a4 100644
--- a/drivers/staging/rt2860/sta/auth_rsp.c
+++ b/drivers/staging/rt2860/sta/auth_rsp.c
@@ -55,11 +55,11 @@ VOID AuthRspStateMachineInit(IN PRTMP_ADAPTER pAd,
 			 (STATE_MACHINE_FUNC) Drop, AUTH_RSP_IDLE,
 			 AUTH_RSP_MACHINE_BASE);
 
-	// column 1
+	/* column 1 */
 	StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_PEER_DEAUTH,
 			      (STATE_MACHINE_FUNC) PeerDeauthAction);
 
-	// column 2
+	/* column 2 */
 	StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_PEER_DEAUTH,
 			      (STATE_MACHINE_FUNC) PeerDeauthAction);
 
@@ -88,7 +88,7 @@ VOID PeerAuthSimpleRspGenAndSend(IN PRTMP_ADAPTER pAd,
 		DBGPRINT(RT_DEBUG_TRACE, ("Peer AUTH fail...\n"));
 		return;
 	}
-	//Get an unused nonpaged memory
+	/*Get an unused nonpaged memory */
 	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
 	if (NStatus != NDIS_STATUS_SUCCESS)
 		return;
@@ -126,7 +126,7 @@ VOID PeerDeauthAction(IN PRTMP_ADAPTER pAd, IN PMLME_QUEUE_ELEM Elem)
 			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
 						0);
 
-			// send wireless event - for deauthentication
+			/* send wireless event - for deauthentication */
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG,
 						      pAd->MacTab.
diff --git a/drivers/staging/rt2860/sta/connect.c b/drivers/staging/rt2860/sta/connect.c
index dc8b2d5..29906be 100644
--- a/drivers/staging/rt2860/sta/connect.c
+++ b/drivers/staging/rt2860/sta/connect.c
@@ -37,35 +37,35 @@
 #include "../rt_config.h"
 
 UCHAR CipherSuiteWpaNoneTkip[] = {
-	0x00, 0x50, 0xf2, 0x01,	// oui
-	0x01, 0x00,		// Version
-	0x00, 0x50, 0xf2, 0x02,	// Multicast
-	0x01, 0x00,		// Number of unicast
-	0x00, 0x50, 0xf2, 0x02,	// unicast
-	0x01, 0x00,		// number of authentication method
-	0x00, 0x50, 0xf2, 0x00	// authentication
+	0x00, 0x50, 0xf2, 0x01,	/* oui */
+	0x01, 0x00,		/* Version */
+	0x00, 0x50, 0xf2, 0x02,	/* Multicast */
+	0x01, 0x00,		/* Number of unicast */
+	0x00, 0x50, 0xf2, 0x02,	/* unicast */
+	0x01, 0x00,		/* number of authentication method */
+	0x00, 0x50, 0xf2, 0x00	/* authentication */
 };
 
 UCHAR CipherSuiteWpaNoneTkipLen =
     (sizeof(CipherSuiteWpaNoneTkip) / sizeof(UCHAR));
 
 UCHAR CipherSuiteWpaNoneAes[] = {
-	0x00, 0x50, 0xf2, 0x01,	// oui
-	0x01, 0x00,		// Version
-	0x00, 0x50, 0xf2, 0x04,	// Multicast
-	0x01, 0x00,		// Number of unicast
-	0x00, 0x50, 0xf2, 0x04,	// unicast
-	0x01, 0x00,		// number of authentication method
-	0x00, 0x50, 0xf2, 0x00	// authentication
+	0x00, 0x50, 0xf2, 0x01,	/* oui */
+	0x01, 0x00,		/* Version */
+	0x00, 0x50, 0xf2, 0x04,	/* Multicast */
+	0x01, 0x00,		/* Number of unicast */
+	0x00, 0x50, 0xf2, 0x04,	/* unicast */
+	0x01, 0x00,		/* number of authentication method */
+	0x00, 0x50, 0xf2, 0x00	/* authentication */
 };
 
 UCHAR CipherSuiteWpaNoneAesLen =
     (sizeof(CipherSuiteWpaNoneAes) / sizeof(UCHAR));
 
-// The following MACRO is called after 1. starting an new IBSS, 2. succesfully JOIN an IBSS,
-// or 3. succesfully ASSOCIATE to a BSS, 4. successfully RE_ASSOCIATE to a BSS
-// All settings successfuly negotiated furing MLME state machines become final settings
-// and are copied to pAd->StaActive
+/* The following MACRO is called after 1. starting an new IBSS, 2. succesfully JOIN an IBSS, */
+/* or 3. succesfully ASSOCIATE to a BSS, 4. successfully RE_ASSOCIATE to a BSS */
+/* All settings successfuly negotiated furing MLME state machines become final settings */
+/* and are copied to pAd->StaActive */
 #define COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(_pAd)                                 \
 {                                                                                       \
 	NdisZeroMemory((_pAd)->CommonCfg.Ssid, MAX_LEN_OF_SSID);							\
@@ -105,8 +105,8 @@ UCHAR CipherSuiteWpaNoneAesLen =
 VOID MlmeCntlInit(IN PRTMP_ADAPTER pAd,
 		  IN STATE_MACHINE * S, OUT STATE_MACHINE_FUNC Trans[])
 {
-	// Control state machine differs from other state machines, the interface
-	// follows the standard interface
+	/* Control state machine differs from other state machines, the interface */
+	/* follows the standard interface */
 	pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 }
 
@@ -133,12 +133,12 @@ VOID MlmeCntlMachinePerformAction(IN PRTMP_ADAPTER pAd,
 		CntlWaitJoinProc(pAd, Elem);
 		break;
 
-		// CNTL_WAIT_REASSOC is the only state in CNTL machine that does
-		// not triggered directly or indirectly by "RTMPSetInformation(OID_xxx)".
-		// Therefore not protected by NDIS's "only one outstanding OID request"
-		// rule. Which means NDIS may SET OID in the middle of ROAMing attempts.
-		// Current approach is to block new SET request at RTMPSetInformation()
-		// when CntlMachine.CurrState is not CNTL_IDLE
+		/* CNTL_WAIT_REASSOC is the only state in CNTL machine that does */
+		/* not triggered directly or indirectly by "RTMPSetInformation(OID_xxx)". */
+		/* Therefore not protected by NDIS's "only one outstanding OID request" */
+		/* rule. Which means NDIS may SET OID in the middle of ROAMing attempts. */
+		/* Current approach is to block new SET request at RTMPSetInformation() */
+		/* when CntlMachine.CurrState is not CNTL_IDLE */
 	case CNTL_WAIT_REASSOC:
 		CntlWaitReassocProc(pAd, Elem);
 		break;
@@ -158,15 +158,15 @@ VOID MlmeCntlMachinePerformAction(IN PRTMP_ADAPTER pAd,
 
 	case CNTL_WAIT_OID_LIST_SCAN:
 		if (Elem->MsgType == MT2_SCAN_CONF) {
-			// Resume TxRing after SCANING complete. We hope the out-of-service time
-			// won't be too long to let upper layer time-out the waiting frames
+			/* Resume TxRing after SCANING complete. We hope the out-of-service time */
+			/* won't be too long to let upper layer time-out the waiting frames */
 			RTMPResumeMsduTransmission(pAd);
 
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 
-			//
-			// Set LED status to previous status.
-			//
+			/* */
+			/* Set LED status to previous status. */
+			/* */
 			if (pAd->bLedOnScanning) {
 				pAd->bLedOnScanning = FALSE;
 				RTMPSetLED(pAd, pAd->LedStatus);
@@ -181,28 +181,28 @@ VOID MlmeCntlMachinePerformAction(IN PRTMP_ADAPTER pAd,
 		}
 		break;
 #ifdef RTMP_MAC_USB
-		//
-		// This state is for that we want to connect to an AP but
-		// it didn't find on BSS List table. So we need to scan the air first,
-		// after that we can try to connect to the desired AP if available.
-		//
+		/* */
+		/* This state is for that we want to connect to an AP but */
+		/* it didn't find on BSS List table. So we need to scan the air first, */
+		/* after that we can try to connect to the desired AP if available. */
+		/* */
 	case CNTL_WAIT_SCAN_FOR_CONNECT:
 		if (Elem->MsgType == MT2_SCAN_CONF) {
-			// Resume TxRing after SCANING complete. We hope the out-of-service time
-			// won't be too long to let upper layer time-out the waiting frames
+			/* Resume TxRing after SCANING complete. We hope the out-of-service time */
+			/* won't be too long to let upper layer time-out the waiting frames */
 			RTMPResumeMsduTransmission(pAd);
 #ifdef CCX_SUPPORT
 			if (pAd->StaCfg.CCXReqType != MSRN_TYPE_UNUSED) {
-				// Cisco scan request is finished, prepare beacon report
+				/* Cisco scan request is finished, prepare beacon report */
 				MlmeEnqueue(pAd, AIRONET_STATE_MACHINE,
 					    MT2_AIRONET_SCAN_DONE, 0, NULL);
 			}
-#endif // CCX_SUPPORT //
+#endif /* CCX_SUPPORT // */
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 
-			//
-			// Check if we can connect to.
-			//
+			/* */
+			/* Check if we can connect to. */
+			/* */
 			BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab,
 					 (CHAR *) pAd->MlmeAux.
 					 AutoReconnectSsid,
@@ -212,7 +212,7 @@ VOID MlmeCntlMachinePerformAction(IN PRTMP_ADAPTER pAd,
 			}
 		}
 		break;
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	default:
 		DBGPRINT_ERR(("!ERROR! CNTL - Illegal message type(=%ld)",
 			      Elem->MsgType));
@@ -257,8 +257,8 @@ VOID CntlIdleProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 		if (pAd->StaCfg.WpaSupplicantUP !=
 		    WPA_SUPPLICANT_ENABLE_WITH_WEB_UI) {
-			// Set the AutoReconnectSsid to prevent it reconnect to old SSID
-			// Since calling this indicate user don't want to connect to that SSID anymore.
+			/* Set the AutoReconnectSsid to prevent it reconnect to old SSID */
+			/* Since calling this indicate user don't want to connect to that SSID anymore. */
 			pAd->MlmeAux.AutoReconnectSsidLen = 32;
 			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid,
 				       pAd->MlmeAux.AutoReconnectSsidLen);
@@ -287,8 +287,8 @@ VOID CntlOidScanProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	ULONG BssIdx = BSS_NOT_FOUND;
 	BSS_ENTRY CurrBss;
 
-	// record current BSS if network is connected.
-	// 2003-2-13 do not include current IBSS if this is the only STA in this IBSS.
+	/* record current BSS if network is connected. */
+	/* 2003-2-13 do not include current IBSS if this is the only STA in this IBSS. */
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
 		BssIdx =
 		    BssSsidTableSearch(&pAd->ScanTab, pAd->CommonCfg.Bssid,
@@ -300,14 +300,14 @@ VOID CntlOidScanProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				       sizeof(BSS_ENTRY));
 		}
 	}
-	// clean up previous SCAN result, add current BSS back to table if any
+	/* clean up previous SCAN result, add current BSS back to table if any */
 	BssTableInit(&pAd->ScanTab);
 	if (BssIdx != BSS_NOT_FOUND) {
-		// DDK Note: If the NIC is associated with a particular BSSID and SSID
-		//    that are not contained in the list of BSSIDs generated by this scan, the
-		//    BSSID description of the currently associated BSSID and SSID should be
-		//    appended to the list of BSSIDs in the NIC's database.
-		// To ensure this, we append this BSS as the first entry in SCAN result
+		/* DDK Note: If the NIC is associated with a particular BSSID and SSID */
+		/*    that are not contained in the list of BSSIDs generated by this scan, the */
+		/*    BSSID description of the currently associated BSSID and SSID should be */
+		/*    appended to the list of BSSIDs in the NIC's database. */
+		/* To ensure this, we append this BSS as the first entry in SCAN result */
 		NdisMoveMemory(&pAd->ScanTab.BssEntry[0], &CurrBss,
 			       sizeof(BSS_ENTRY));
 		pAd->ScanTab.BssNr = 1;
@@ -335,7 +335,7 @@ VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	MLME_DISASSOC_REQ_STRUCT DisassocReq;
 	ULONG Now;
 
-	// Step 1. record the desired user settings to MlmeAux
+	/* Step 1. record the desired user settings to MlmeAux */
 	NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
 	NdisMoveMemory(pAd->MlmeAux.Ssid, pOidSsid->Ssid, pOidSsid->SsidLength);
 	pAd->MlmeAux.SsidLen = (UCHAR) pOidSsid->SsidLength;
@@ -344,16 +344,16 @@ VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	pAd->StaCfg.bAutoConnectByBssid = FALSE;
 
-	//
-	// Update Reconnect Ssid, that user desired to connect.
-	//
+	/* */
+	/* Update Reconnect Ssid, that user desired to connect. */
+	/* */
 	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
 	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.Ssid,
 		       pAd->MlmeAux.SsidLen);
 	pAd->MlmeAux.AutoReconnectSsidLen = pAd->MlmeAux.SsidLen;
 
-	// step 2. find all matching BSS in the lastest SCAN result (inBssTab)
-	//    & log them into MlmeAux.SsidBssTab for later-on iteration. Sort by RSSI order
+	/* step 2. find all matching BSS in the lastest SCAN result (inBssTab) */
+	/*    & log them into MlmeAux.SsidBssTab for later-on iteration. Sort by RSSI order */
 	BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab,
 			 (PCHAR) pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
 
@@ -371,18 +371,18 @@ VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			       pAd->CommonCfg.SsidLen)
 	    && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid,
 			      pAd->MlmeAux.SsidBssTab.BssEntry[0].Bssid)) {
-		// Case 1. already connected with an AP who has the desired SSID
-		//         with highest RSSI
+		/* Case 1. already connected with an AP who has the desired SSID */
+		/*         with highest RSSI */
 
-		// Add checking Mode "LEAP" for CCX 1.0
+		/* Add checking Mode "LEAP" for CCX 1.0 */
 		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
 		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
 		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
 		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
 		    ) &&
 		    (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) {
-			// case 1.1 For WPA, WPA-PSK, if the 1x port is not secured, we have to redo
-			//          connection process
+			/* case 1.1 For WPA, WPA-PSK, if the 1x port is not secured, we have to redo */
+			/*          connection process */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
 			DisassocParmFill(pAd, &DisassocReq,
@@ -394,7 +394,7 @@ VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    &DisassocReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
 		} else if (pAd->bConfigChanged == TRUE) {
-			// case 1.2 Important Config has changed, we have to reconnect to the same AP
+			/* case 1.2 Important Config has changed, we have to reconnect to the same AP */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CntlOidSsidProc():CNTL - disassociate with current AP Because config changed...\n"));
 			DisassocParmFill(pAd, &DisassocReq,
@@ -406,22 +406,22 @@ VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    &DisassocReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
 		} else {
-			// case 1.3. already connected to the SSID with highest RSSI.
+			/* case 1.3. already connected to the SSID with highest RSSI. */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CntlOidSsidProc():CNTL - already with this BSSID. ignore this SET_SSID request\n"));
-			//
-			// (HCT 12.1) 1c_wlan_mediaevents required
-			// media connect events are indicated when associating with the same AP
-			//
+			/* */
+			/* (HCT 12.1) 1c_wlan_mediaevents required */
+			/* media connect events are indicated when associating with the same AP */
+			/* */
 			if (INFRA_ON(pAd)) {
-				//
-				// Since MediaState already is NdisMediaStateConnected
-				// We just indicate the connect event again to meet the WHQL required.
-				//
+				/* */
+				/* Since MediaState already is NdisMediaStateConnected */
+				/* We just indicate the connect event again to meet the WHQL required. */
+				/* */
 				pAd->IndicateMediaState =
 				    NdisMediaStateConnected;
 				RTMP_IndicateMediaState(pAd);
-				pAd->ExtraInfo = GENERAL_LINK_UP;	// Update extra information to link is up
+				pAd->ExtraInfo = GENERAL_LINK_UP;	/* Update extra information to link is up */
 			}
 
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
@@ -430,26 +430,26 @@ VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						0);
 		}
 	} else if (INFRA_ON(pAd)) {
-		//
-		// For RT61
-		// [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: )
-		// RT61 may lost SSID, and not connect to NDTEST_WEP_AP2 and will connect to NDTEST_WEP_AP2 by Autoreconnect
-		// But media status is connected, so the SSID not report correctly.
-		//
+		/* */
+		/* For RT61 */
+		/* [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: ) */
+		/* RT61 may lost SSID, and not connect to NDTEST_WEP_AP2 and will connect to NDTEST_WEP_AP2 by Autoreconnect */
+		/* But media status is connected, so the SSID not report correctly. */
+		/* */
 		if (!SSID_EQUAL
 		    (pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen,
 		     pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen)) {
-			//
-			// Different SSID means not Roaming case, so we let LinkDown() to Indicate a disconnect event.
-			//
+			/* */
+			/* Different SSID means not Roaming case, so we let LinkDown() to Indicate a disconnect event. */
+			/* */
 			pAd->MlmeAux.CurrReqIsFromNdis = TRUE;
 		}
-		// case 2. active INFRA association existent
-		//    roaming is done within miniport driver, nothing to do with configuration
-		//    utility. so upon a new SET(OID_802_11_SSID) is received, we just
-		//    disassociate with the current associated AP,
-		//    then perform a new association with this new SSID, no matter the
-		//    new/old SSID are the same or not.
+		/* case 2. active INFRA association existent */
+		/*    roaming is done within miniport driver, nothing to do with configuration */
+		/*    utility. so upon a new SET(OID_802_11_SSID) is received, we just */
+		/*    disassociate with the current associated AP, */
+		/*    then perform a new association with this new SSID, no matter the */
+		/*    new/old SSID are the same or not. */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
 		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
@@ -488,7 +488,7 @@ VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
 			pAd->Mlme.CntlMachine.CurrState =
 			    CNTL_WAIT_OID_LIST_SCAN;
-			// Reset Missed scan number
+			/* Reset Missed scan number */
 			pAd->StaCfg.LastScanTime = Now;
 		} else {
 			pAd->MlmeAux.BssIdx = 0;
@@ -512,18 +512,18 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	MLME_DISASSOC_REQ_STRUCT DisassocReq;
 	MLME_JOIN_REQ_STRUCT JoinReq;
 
-	// record user desired settings
+	/* record user desired settings */
 	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pOidBssid);
 	pAd->MlmeAux.BssType = pAd->StaCfg.BssType;
 
-	// find the desired BSS in the latest SCAN result table
+	/* find the desired BSS in the latest SCAN result table */
 	BssIdx = BssTableSearch(&pAd->ScanTab, pOidBssid, pAd->MlmeAux.Channel);
 	if (BssIdx == BSS_NOT_FOUND) {
 		MLME_SCAN_REQ_STRUCT ScanReq;
 
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("CNTL - BSSID not found. reply NDIS_STATUS_NOT_ACCEPTED\n"));
-		//pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		/*pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE; */
 
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("CNTL - BSSID not found. start a new scan\n"));
@@ -532,13 +532,13 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
 			    sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
-		// Reset Missed scan number
+		/* Reset Missed scan number */
 		NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
 		return;
 	}
-	//
-	// Update Reconnect Ssid, that user desired to connect.
-	//
+	/* */
+	/* Update Reconnect Ssid, that user desired to connect. */
+	/* */
 	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
 	pAd->MlmeAux.AutoReconnectSsidLen =
 	    pAd->ScanTab.BssEntry[BssIdx].SsidLen;
@@ -546,21 +546,21 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		       pAd->ScanTab.BssEntry[BssIdx].Ssid,
 		       pAd->ScanTab.BssEntry[BssIdx].SsidLen);
 
-	// copy the matched BSS entry from ScanTab to MlmeAux.SsidBssTab. Why?
-	// Because we need this entry to become the JOIN target in later on SYNC state machine
+	/* copy the matched BSS entry from ScanTab to MlmeAux.SsidBssTab. Why? */
+	/* Because we need this entry to become the JOIN target in later on SYNC state machine */
 	pAd->MlmeAux.BssIdx = 0;
 	pAd->MlmeAux.SsidBssTab.BssNr = 1;
 	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab.BssEntry[0],
 		       &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
 
-	// Add SSID into MlmeAux for site surey joining hidden SSID
+	/* Add SSID into MlmeAux for site surey joining hidden SSID */
 	pAd->MlmeAux.SsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
 	NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid,
 		       pAd->MlmeAux.SsidLen);
 
 	{
 		if (INFRA_ON(pAd)) {
-			// disassoc from current AP first
+			/* disassoc from current AP first */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CNTL - disassociate with current AP ...\n"));
 			DisassocParmFill(pAd, &DisassocReq,
@@ -586,14 +586,14 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("NDIS_STATUS_MEDIA_DISCONNECT Event C!\n"));
 			}
-			// Change the wepstatus to original wepstatus
+			/* Change the wepstatus to original wepstatus */
 			pAd->StaCfg.WepStatus = pAd->StaCfg.OrigWepStatus;
 			pAd->StaCfg.PairCipher = pAd->StaCfg.OrigWepStatus;
 			pAd->StaCfg.GroupCipher = pAd->StaCfg.OrigWepStatus;
 
-			// Check cipher suite, AP must have more secured cipher than station setting
-			// Set the Pairwise and Group cipher to match the intended AP setting
-			// We can only connect to AP with less secured cipher setting
+			/* Check cipher suite, AP must have more secured cipher than station setting */
+			/* Set the Pairwise and Group cipher to match the intended AP setting */
+			/* We can only connect to AP with less secured cipher setting */
 			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
 			    || (pAd->StaCfg.AuthMode ==
 				Ndis802_11AuthModeWPAPSK)) {
@@ -612,7 +612,7 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					pAd->StaCfg.PairCipher =
 					    pAd->ScanTab.BssEntry[BssIdx].WPA.
 					    PairCipherAux;
-				else	// There is no PairCipher Aux, downgrade our capability to TKIP
+				else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
 					pAd->StaCfg.PairCipher =
 					    Ndis802_11Encryption2Enabled;
 			} else
@@ -634,16 +634,16 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					pAd->StaCfg.PairCipher =
 					    pAd->ScanTab.BssEntry[BssIdx].WPA2.
 					    PairCipherAux;
-				else	// There is no PairCipher Aux, downgrade our capability to TKIP
+				else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
 					pAd->StaCfg.PairCipher =
 					    Ndis802_11Encryption2Enabled;
 
-				// RSN capability
+				/* RSN capability */
 				pAd->StaCfg.RsnCapability =
 				    pAd->ScanTab.BssEntry[BssIdx].WPA2.
 				    RsnCapability;
 			}
-			// Set Mix cipher flag
+			/* Set Mix cipher flag */
 			pAd->StaCfg.bMixCipher =
 			    (pAd->StaCfg.PairCipher ==
 			     pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
@@ -652,7 +652,7 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			   // If mix cipher, re-build RSNIE
 			   RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
 			   } */
-			// No active association, join the BSS immediately
+			/* No active association, join the BSS immediately */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CNTL - joining %02x:%02x:%02x:%02x:%02x:%02x ...\n",
 				  pOidBssid[0], pOidBssid[1], pOidBssid[2],
@@ -667,14 +667,14 @@ VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	}
 }
 
-// Roaming is the only external request triggering CNTL state machine
-// despite of other "SET OID" operation. All "SET OID" related oerations
-// happen in sequence, because no other SET OID will be sent to this device
-// until the the previous SET operation is complete (successful o failed).
-// So, how do we quarantee this ROAMING request won't corrupt other "SET OID"?
-// or been corrupted by other "SET OID"?
-//
-// IRQL = DISPATCH_LEVEL
+/* Roaming is the only external request triggering CNTL state machine */
+/* despite of other "SET OID" operation. All "SET OID" related oerations */
+/* happen in sequence, because no other SET OID will be sent to this device */
+/* until the the previous SET operation is complete (successful o failed). */
+/* So, how do we quarantee this ROAMING request won't corrupt other "SET OID"? */
+/* or been corrupted by other "SET OID"? */
+/* */
+/* IRQL = DISPATCH_LEVEL */
 VOID CntlMlmeRoamingProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	UCHAR BBPValue = 0;
@@ -682,7 +682,7 @@ VOID CntlMlmeRoamingProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Roaming in MlmeAux.RoamTab...\n"));
 
 	{
-		//Let BBP register at 20MHz to do (fast) roaming.
+		/*Let BBP register at 20MHz to do (fast) roaming. */
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 		BBPValue &= (~0x18);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
@@ -720,7 +720,7 @@ VOID CntlWaitDisassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 		LinkDown(pAd, FALSE);
 
-		// case 1. no matching BSS, and user wants ADHOC, so we just start a new one
+		/* case 1. no matching BSS, and user wants ADHOC, so we just start a new one */
 		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0)
 		    && (pAd->StaCfg.BssType == BSS_ADHOC)) {
 			DBGPRINT(RT_DEBUG_TRACE,
@@ -732,7 +732,7 @@ VOID CntlWaitDisassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    sizeof(MLME_START_REQ_STRUCT), &StartReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
 		}
-		// case 2. try each matched BSS
+		/* case 2. try each matched BSS */
 		else {
 			pAd->MlmeAux.BssIdx = 0;
 
@@ -757,12 +757,12 @@ VOID CntlWaitJoinProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	if (Elem->MsgType == MT2_JOIN_CONF) {
 		NdisMoveMemory(&Reason, Elem->Msg, sizeof(USHORT));
 		if (Reason == MLME_SUCCESS) {
-			// 1. joined an IBSS, we are pretty much done here
+			/* 1. joined an IBSS, we are pretty much done here */
 			if (pAd->MlmeAux.BssType == BSS_ADHOC) {
-				//
-				// 5G bands rules of Japan:
-				// Ad hoc must be disabled in W53(ch52,56,60,64) channels.
-				//
+				/* */
+				/* 5G bands rules of Japan: */
+				/* Ad hoc must be disabled in W53(ch52,56,60,64) channels. */
+				/* */
 				if ((pAd->CommonCfg.bIEEE80211H == 1) &&
 				    RadarChannelCheck(pAd,
 						      pAd->CommonCfg.Channel)
@@ -790,10 +790,10 @@ VOID CntlWaitJoinProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    NdisMediaStateConnected;
 				pAd->ExtraInfo = GENERAL_LINK_UP;
 			}
-			// 2. joined a new INFRA network, start from authentication
+			/* 2. joined a new INFRA network, start from authentication */
 			else {
 				{
-					// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
+					/* either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first */
 					if ((pAd->StaCfg.AuthMode ==
 					     Ndis802_11AuthModeShared)
 					    || (pAd->StaCfg.AuthMode ==
@@ -817,7 +817,7 @@ VOID CntlWaitJoinProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    CNTL_WAIT_AUTH;
 			}
 		} else {
-			// 3. failed, try next BSS
+			/* 3. failed, try next BSS */
 			pAd->MlmeAux.BssIdx++;
 			IterateOnBssTab(pAd);
 		}
@@ -839,10 +839,10 @@ VOID CntlWaitStartProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	if (Elem->MsgType == MT2_START_CONF) {
 		NdisMoveMemory(&Result, Elem->Msg, sizeof(USHORT));
 		if (Result == MLME_SUCCESS) {
-			//
-			// 5G bands rules of Japan:
-			// Ad hoc must be disabled in W53(ch52,56,60,64) channels.
-			//
+			/* */
+			/* 5G bands rules of Japan: */
+			/* Ad hoc must be disabled in W53(ch52,56,60,64) channels. */
+			/* */
 			if ((pAd->CommonCfg.bIEEE80211H == 1) &&
 			    RadarChannelCheck(pAd, pAd->CommonCfg.Channel)
 			    ) {
@@ -892,7 +892,7 @@ VOID CntlWaitStartProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			}
 			LinkUp(pAd, BSS_ADHOC);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			// Before send beacon, driver need do radar detection
+			/* Before send beacon, driver need do radar detection */
 			if ((pAd->CommonCfg.Channel > 14)
 			    && (pAd->CommonCfg.bIEEE80211H == 1)
 			    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
@@ -950,9 +950,9 @@ VOID CntlWaitAuthProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				    CNTL_WAIT_ASSOC;
 			}
 		} else {
-			// This fail may because of the AP already keep us in its MAC table without
-			// ageing-out. The previous authentication attempt must have let it remove us.
-			// so try Authentication again may help. For D-Link DWL-900AP+ compatibility.
+			/* This fail may because of the AP already keep us in its MAC table without */
+			/* ageing-out. The previous authentication attempt must have let it remove us. */
+			/* so try Authentication again may help. For D-Link DWL-900AP+ compatibility. */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CNTL - AUTH FAIL, try again...\n"));
 
@@ -961,7 +961,7 @@ VOID CntlWaitAuthProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				     Ndis802_11AuthModeShared)
 				    || (pAd->StaCfg.AuthMode ==
 					Ndis802_11AuthModeAutoSwitch)) {
-					// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
+					/* either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first */
 					AuthParmFill(pAd, &AuthReq,
 						     pAd->MlmeAux.Bssid,
 						     AUTH_MODE_KEY);
@@ -1028,10 +1028,10 @@ VOID CntlWaitAuthProc2(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				pAd->Mlme.CntlMachine.CurrState =
 				    CNTL_WAIT_AUTH2;
 			} else {
-				// not success, try next BSS
+				/* not success, try next BSS */
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("CNTL - AUTH FAIL, give up; try next BSS\n"));
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;	//???????
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;	/*??????? */
 				pAd->MlmeAux.BssIdx++;
 				IterateOnBssTab(pAd);
 			}
@@ -1067,7 +1067,7 @@ VOID CntlWaitAssocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				 ("CNTL - Association successful on BSS #%ld\n",
 				  pAd->MlmeAux.BssIdx));
 		} else {
-			// not success, try next BSS
+			/* not success, try next BSS */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CNTL - Association fails on BSS #%ld\n",
 				  pAd->MlmeAux.BssIdx));
@@ -1092,16 +1092,16 @@ VOID CntlWaitReassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	if (Elem->MsgType == MT2_REASSOC_CONF) {
 		NdisMoveMemory(&Result, Elem->Msg, sizeof(USHORT));
 		if (Result == MLME_SUCCESS) {
-			// send wireless event - for association
+			/* send wireless event - for association */
 			if (pAd->CommonCfg.bWirelessEvent)
 				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG,
 						      pAd->MacTab.
 						      Content[BSSID_WCID].Addr,
 						      BSS0, 0);
 
-			//
-			// NDIS requires a new Link UP indication but no Link Down for RE-ASSOC
-			//
+			/* */
+			/* NDIS requires a new Link UP indication but no Link Down for RE-ASSOC */
+			/* */
 			LinkUp(pAd, BSS_INFRA);
 
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
@@ -1109,7 +1109,7 @@ VOID CntlWaitReassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				 ("CNTL - Re-assocition successful on BSS #%ld\n",
 				  pAd->MlmeAux.RoamIdx));
 		} else {
-			// reassoc failed, try to pick next BSS in the BSS Table
+			/* reassoc failed, try to pick next BSS in the BSS Table */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("CNTL - Re-assocition fails on BSS #%ld\n",
 				  pAd->MlmeAux.RoamIdx));
@@ -1128,7 +1128,7 @@ VOID AdhocTurnOnQos(IN PRTMP_ADAPTER pAd)
 #define AC2_DEF_TXOP		94
 #define AC3_DEF_TXOP		47
 
-	// Turn on QOs if use HT rate.
+	/* Turn on QOs if use HT rate. */
 	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE) {
 		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
 		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
@@ -1170,7 +1170,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	UCHAR Value = 0, idx = 0, HashIdx = 0;
 	MAC_TABLE_ENTRY *pEntry = NULL, *pCurrEntry = NULL;
 
-	// Init ChannelQuality to prevent DEAD_CQI at initial LinkUp
+	/* Init ChannelQuality to prevent DEAD_CQI at initial LinkUp */
 	pAd->Mlme.ChannelQuality = 50;
 
 	pEntry = MacTableLookup(pAd, pAd->CommonCfg.Bssid);
@@ -1181,15 +1181,15 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 
 	pEntry = &pAd->MacTab.Content[BSSID_WCID];
 
-	//
-	// ASSOC - DisassocTimeoutAction
-	// CNTL - Dis-associate successful
-	// !!! LINK DOWN !!!
-	// [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: )
-	//
-	// To prevent DisassocTimeoutAction to call Link down after we link up,
-	// cancel the DisassocTimer no matter what it start or not.
-	//
+	/* */
+	/* ASSOC - DisassocTimeoutAction */
+	/* CNTL - Dis-associate successful */
+	/* !!! LINK DOWN !!! */
+	/* [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: ) */
+	/* */
+	/* To prevent DisassocTimeoutAction to call Link down after we link up, */
+	/* cancel the DisassocTimer no matter what it start or not. */
+	/* */
 	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
 
 	COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
@@ -1197,8 +1197,8 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
 
 #ifdef RTMP_MAC_PCI
-	// Before power save before link up function, We will force use 1R.
-	// So after link up, check Rx antenna # again.
+	/* Before power save before link up function, We will force use 1R. */
+	/* So after link up, check Rx antenna # again. */
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
 	if (pAd->Antenna.field.RxPath == 3) {
 		Value |= (0x10);
@@ -1209,7 +1209,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	}
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 	pAd->StaCfg.BBPR3 = Value;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	if (BssType == BSS_ADHOC) {
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_ADHOC_ON);
@@ -1226,17 +1226,17 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		DBGPRINT(RT_DEBUG_TRACE, ("!!!Infra LINK UP !!! \n"));
 	}
 
-	// 3*3
-	// reset Tx beamforming bit
+	/* 3*3 */
+	/* reset Tx beamforming bit */
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &Value);
 	Value &= (~0x01);
 	Value |= pAd->CommonCfg.RegTransmitSetting.field.TxBF;
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
 
-	// Change to AP channel
+	/* Change to AP channel */
 	if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
 	    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)) {
-		// Must using 40MHz.
+		/* Must using 40MHz. */
 		pAd->CommonCfg.BBPCurrentBW = BW_40;
 		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
 		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
@@ -1246,13 +1246,13 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		Value |= 0x10;
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
 
-		//  RX : control channel at lower
+		/*  RX : control channel at lower */
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
 		Value &= (~0x20);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 #ifdef RTMP_MAC_PCI
 		pAd->StaCfg.BBPR3 = Value;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Data);
 		Data &= 0xfffffffe;
@@ -1271,7 +1271,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	} else if ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
 		   && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth ==
 		       BW_40)) {
-		// Must using 40MHz.
+		/* Must using 40MHz. */
 		pAd->CommonCfg.BBPCurrentBW = BW_40;
 		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
 		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
@@ -1290,7 +1290,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 #ifdef RTMP_MAC_PCI
 		pAd->StaCfg.BBPR3 = Value;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 		if (pAd->MACVersion == 0x28600100) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x1A);
@@ -1321,7 +1321,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 #ifdef RTMP_MAC_PCI
 		pAd->StaCfg.BBPR3 = Value;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 		if (pAd->MACVersion == 0x28600100) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x16);
@@ -1335,9 +1335,9 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 
 	RTMPSetAGCInitValue(pAd, pAd->CommonCfg.BBPCurrentBW);
 
-	//
-	// Save BBP_R66 value, it will be used in RTUSBResumeMsduTransmission
-	//
+	/* */
+	/* Save BBP_R66 value, it will be used in RTUSBResumeMsduTransmission */
+	/* */
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66,
 				    &pAd->BbpTuning.R66CurrentValue);
 
@@ -1355,12 +1355,12 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	AsicSetSlotTime(pAd, TRUE);
 	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
 
-	// Call this for RTS protectionfor legacy rate, we will always enable RTS threshold, but normally it will not hit
+	/* Call this for RTS protectionfor legacy rate, we will always enable RTS threshold, but normally it will not hit */
 	AsicUpdateProtect(pAd, 0, (OFDMSETPROTECT | CCKSETPROTECT), TRUE,
 			  FALSE);
 
 	if ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)) {
-		// Update HT protectionfor based on AP's operating mode.
+		/* Update HT protectionfor based on AP's operating mode. */
 		if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1) {
 			AsicUpdateProtect(pAd,
 					  pAd->MlmeAux.AddHtInfo.AddHtInfo2.
@@ -1376,7 +1376,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	NdisZeroMemory(&pAd->DrsCounters, sizeof(COUNTER_DRS));
 
 	NdisGetSystemUpTime(&Now);
-	pAd->StaCfg.LastBeaconRxTime = Now;	// last RX timestamp
+	pAd->StaCfg.LastBeaconRxTime = Now;	/* last RX timestamp */
 
 	if ((pAd->CommonCfg.TxPreamble != Rt802_11PreambleLong) &&
 	    CAP_IS_SHORT_PREAMBLE_ON(pAd->StaActive.CapabilityInfo)) {
@@ -1394,18 +1394,18 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		if ((pAd->CommonCfg.Channel > 14)
 		    && (pAd->CommonCfg.bIEEE80211H == 1)
 		    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
-			;	//Do nothing
+			;	/*Do nothing */
 		} else {
 			AsicEnableIbssSync(pAd);
 		}
 
-		// In ad hoc mode, use MAC table from index 1.
-		// p.s ASIC use all 0xff as termination of WCID table search.To prevent it's 0xff-ff-ff-ff-ff-ff, Write 0 here.
+		/* In ad hoc mode, use MAC table from index 1. */
+		/* p.s ASIC use all 0xff as termination of WCID table search.To prevent it's 0xff-ff-ff-ff-ff-ff, Write 0 here. */
 		RTMP_IO_WRITE32(pAd, MAC_WCID_BASE, 0x00);
 		RTMP_IO_WRITE32(pAd, 0x1808, 0x00);
 
-		// If WEP is enabled, add key material and cipherAlg into Asic
-		// Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000)
+		/* If WEP is enabled, add key material and cipherAlg into Asic */
+		/* Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000) */
 
 		if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) {
 			PUCHAR Key;
@@ -1416,13 +1416,13 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 				Key = pAd->SharedKey[BSS0][idx].Key;
 
 				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
-					// Set key material and cipherAlg to Asic
+					/* Set key material and cipherAlg to Asic */
 					AsicAddSharedKeyEntry(pAd, BSS0, idx,
 							      CipherAlg, Key,
 							      NULL, NULL);
 
 					if (idx == pAd->StaCfg.DefaultKeyId) {
-						// Update WCID attribute table and IVEIV table for this group key table
+						/* Update WCID attribute table and IVEIV table for this group key table */
 						RTMPAddWcidAttributeEntry(pAd,
 									  BSS0,
 									  idx,
@@ -1433,10 +1433,10 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 
 			}
 		}
-		// If WPANone is enabled, add key material and cipherAlg into Asic
-		// Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000)
+		/* If WPANone is enabled, add key material and cipherAlg into Asic */
+		/* Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000) */
 		else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
-			pAd->StaCfg.DefaultKeyId = 0;	// always be zero
+			pAd->StaCfg.DefaultKeyId = 0;	/* always be zero */
 
 			NdisZeroMemory(&pAd->SharedKey[BSS0][0],
 				       sizeof(CIPHER_KEY));
@@ -1453,7 +1453,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 					       &pAd->StaCfg.PMK[16],
 					       LEN_TKIP_TXMICK);
 			}
-			// Decide its ChiperAlg
+			/* Decide its ChiperAlg */
 			if (pAd->StaCfg.PairCipher ==
 			    Ndis802_11Encryption2Enabled)
 				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
@@ -1467,7 +1467,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
 			}
 
-			// Set key material and cipherAlg to Asic
+			/* Set key material and cipherAlg to Asic */
 			AsicAddSharedKeyEntry(pAd,
 					      BSS0,
 					      0,
@@ -1476,16 +1476,16 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 					      pAd->SharedKey[BSS0][0].TxMic,
 					      pAd->SharedKey[BSS0][0].RxMic);
 
-			// Update WCID attribute table and IVEIV table for this group key table
+			/* Update WCID attribute table and IVEIV table for this group key table */
 			RTMPAddWcidAttributeEntry(pAd, BSS0, 0,
 						  pAd->SharedKey[BSS0][0].
 						  CipherAlg, NULL);
 
 		}
 
-	} else			// BSS_INFRA
+	} else			/* BSS_INFRA */
 	{
-		// Check the new SSID with last SSID
+		/* Check the new SSID with last SSID */
 		while (Cancelled == TRUE) {
 			if (pAd->CommonCfg.LastSsidLen ==
 			    pAd->CommonCfg.SsidLen) {
@@ -1493,11 +1493,11 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 				    (pAd->CommonCfg.LastSsid,
 				     pAd->CommonCfg.Ssid,
 				     pAd->CommonCfg.LastSsidLen) == 0) {
-					// Link to the old one no linkdown is required.
+					/* Link to the old one no linkdown is required. */
 					break;
 				}
 			}
-			// Send link down event before set to link up
+			/* Send link down event before set to link up */
 			pAd->IndicateMediaState = NdisMediaStateDisconnected;
 			RTMP_IndicateMediaState(pAd);
 			pAd->ExtraInfo = GENERAL_LINK_DOWN;
@@ -1506,43 +1506,43 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 			break;
 		}
 
-		//
-		// On WPA mode, Remove All Keys if not connect to the last BSSID
-		// Key will be set after 4-way handshake.
-		//
+		/* */
+		/* On WPA mode, Remove All Keys if not connect to the last BSSID */
+		/* Key will be set after 4-way handshake. */
+		/* */
 		if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
 			ULONG IV;
 
-			// Remove all WPA keys
+			/* Remove all WPA keys */
 			RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 			RTMPWPARemoveAllKeys(pAd);
 			pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
 			pAd->StaCfg.PrivacyFilter =
 			    Ndis802_11PrivFilter8021xWEP;
 
-			// Fixed connection failed with Range Maximizer - 515 AP (Marvell Chip) when security is WPAPSK/TKIP
-			// If IV related values are too large in GroupMsg2, AP would ignore this message.
+			/* Fixed connection failed with Range Maximizer - 515 AP (Marvell Chip) when security is WPAPSK/TKIP */
+			/* If IV related values are too large in GroupMsg2, AP would ignore this message. */
 			IV = 1;
 			IV |= (pAd->StaCfg.DefaultKeyId << 30);
 			AsicUpdateWCIDIVEIV(pAd, BSSID_WCID, IV, 0);
 		}
-		// NOTE:
-		// the decision of using "short slot time" or not may change dynamically due to
-		// new STA association to the AP. so we have to decide that upon parsing BEACON, not here
+		/* NOTE: */
+		/* the decision of using "short slot time" or not may change dynamically due to */
+		/* new STA association to the AP. so we have to decide that upon parsing BEACON, not here */
 
-		// NOTE:
-		// the decision to use "RTC/CTS" or "CTS-to-self" protection or not may change dynamically
-		// due to new STA association to the AP. so we have to decide that upon parsing BEACON, not here
+		/* NOTE: */
+		/* the decision to use "RTC/CTS" or "CTS-to-self" protection or not may change dynamically */
+		/* due to new STA association to the AP. so we have to decide that upon parsing BEACON, not here */
 
 		ComposePsPoll(pAd);
 		ComposeNullFrame(pAd);
 
 		AsicEnableBssSync(pAd);
 
-		// Add BSSID to WCID search table
+		/* Add BSSID to WCID search table */
 		AsicUpdateRxWCIDTable(pAd, BSSID_WCID, pAd->CommonCfg.Bssid);
 
-		// If WEP is enabled, add paiewise and shared key
+		/* If WEP is enabled, add paiewise and shared key */
 		if (((pAd->StaCfg.WpaSupplicantUP) &&
 		     (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
 		     (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)) ||
@@ -1556,13 +1556,13 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 				Key = pAd->SharedKey[BSS0][idx].Key;
 
 				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
-					// Set key material and cipherAlg to Asic
+					/* Set key material and cipherAlg to Asic */
 					AsicAddSharedKeyEntry(pAd, BSS0, idx,
 							      CipherAlg, Key,
 							      NULL, NULL);
 
 					if (idx == pAd->StaCfg.DefaultKeyId) {
-						// Assign group key info
+						/* Assign group key info */
 						RTMPAddWcidAttributeEntry(pAd,
 									  BSS0,
 									  idx,
@@ -1570,7 +1570,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 									  NULL);
 
 						pEntry->Aid = BSSID_WCID;
-						// Assign pairwise key info
+						/* Assign pairwise key info */
 						RTMPAddWcidAttributeEntry(pAd,
 									  BSS0,
 									  idx,
@@ -1580,11 +1580,11 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 				}
 			}
 		}
-		// only INFRASTRUCTURE mode need to indicate connectivity immediately; ADHOC mode
-		// should wait until at least 2 active nodes in this BSSID.
+		/* only INFRASTRUCTURE mode need to indicate connectivity immediately; ADHOC mode */
+		/* should wait until at least 2 active nodes in this BSSID. */
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 
-		// For GUI ++
+		/* For GUI ++ */
 		if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA) {
 			pAd->IndicateMediaState = NdisMediaStateConnected;
 			pAd->ExtraInfo = GENERAL_LINK_UP;
@@ -1597,11 +1597,11 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 				RTMPSetTimer(&pAd->Mlme.LinkDownTimer,
 					     LINK_DOWN_TIMEOUT);
 		}
-		// --
+		/* -- */
 
-		// Add BSSID in my MAC Table.
+		/* Add BSSID in my MAC Table. */
 		NdisAcquireSpinLock(&pAd->MacTabLock);
-		// add this MAC entry into HASH table
+		/* add this MAC entry into HASH table */
 		if (pEntry) {
 			HashIdx = MAC_ADDR_HASH_INDEX(pAd->CommonCfg.Bssid);
 			if (pAd->MacTab.Hash[HashIdx] == NULL) {
@@ -1618,8 +1618,8 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 			       MAC_ADDR_LEN);
 		pEntry->Aid = BSSID_WCID;
 		pEntry->pAd = pAd;
-		pEntry->ValidAsCLI = TRUE;	//Although this is bssid..still set ValidAsCl
-		pAd->MacTab.Size = 1;	// infra mode always set MACtab size =1.
+		pEntry->ValidAsCLI = TRUE;	/*Although this is bssid..still set ValidAsCl */
+		pAd->MacTab.Size = 1;	/* infra mode always set MACtab size =1. */
 		pEntry->Sst = SST_ASSOC;
 		pEntry->AuthState = SST_ASSOC;
 		pEntry->AuthMode = pAd->StaCfg.AuthMode;
@@ -1687,15 +1687,15 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		  pAd->CommonCfg.BACapability.word,
 		  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
 
-	// Set LED
+	/* Set LED */
 	RTMPSetLED(pAd, LED_LINK_UP);
 
 	pAd->Mlme.PeriodicRound = 0;
 	pAd->Mlme.OneSecPeriodicRound = 0;
-	pAd->bConfigChanged = FALSE;	// Reset config flag
-	pAd->ExtraInfo = GENERAL_LINK_UP;	// Update extra information to link is up
+	pAd->bConfigChanged = FALSE;	/* Reset config flag */
+	pAd->ExtraInfo = GENERAL_LINK_UP;	/* Update extra information to link is up */
 
-	// Set asic auto fall back
+	/* Set asic auto fall back */
 	{
 		PUCHAR pTable;
 		UCHAR TableSize = 0;
@@ -1719,7 +1719,7 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		    || (pEntry->HTPhyMode.field.MCS == 32))
 			pEntry->HTPhyMode.field.STBC = STBC_NONE;
 
-		// If the legacy mode is set, overwrite the transmit setting of this entry.
+		/* If the legacy mode is set, overwrite the transmit setting of this entry. */
 		if (pEntry->HTPhyMode.field.MODE <= MODE_OFDM)
 			RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.
 						  DesiredTransmitSetting.field.
@@ -1728,9 +1728,9 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		pEntry->bAutoTxRateSwitch = TRUE;
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
-	//  Let Link Status Page display first initial rate.
+	/*  Let Link Status Page display first initial rate. */
 	pAd->LastTxRate = (USHORT) (pEntry->HTPhyMode.word);
-	// Select DAC according to HT or Legacy
+	/* Select DAC according to HT or Legacy */
 	if (pAd->StaActive.SupportedPhyInfo.MCSSet[0] != 0x00) {
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &Value);
 		Value &= (~0x18);
@@ -1746,20 +1746,20 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 
 	if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) {
 	} else if (pEntry->MaxRAmpduFactor == 0) {
-		// If HT AP doesn't support MaxRAmpduFactor = 1, we need to set max PSDU to 0.
-		// Because our Init value is 1 at MACRegTable.
+		/* If HT AP doesn't support MaxRAmpduFactor = 1, we need to set max PSDU to 0. */
+		/* Because our Init value is 1 at MACRegTable. */
 		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, 0x0fff);
 	}
-	// Patch for Marvel AP to gain high throughput
-	// Need to set as following,
-	// 1. Set txop in register-EDCA_AC0_CFG as 0x60
-	// 2. Set EnTXWriteBackDDONE in register-WPDMA_GLO_CFG as zero
-	// 3. PBF_MAX_PCNT as 0x1F3FBF9F
-	// 4. kick per two packets when dequeue
-	//
-	// Txop can only be modified when RDG is off, WMM is disable and TxBurst is enable
-	//
-	// if 1. Legacy AP WMM on,  or 2. 11n AP, AMPDU disable.  Force turn off burst no matter what bEnableTxBurst is.
+	/* Patch for Marvel AP to gain high throughput */
+	/* Need to set as following, */
+	/* 1. Set txop in register-EDCA_AC0_CFG as 0x60 */
+	/* 2. Set EnTXWriteBackDDONE in register-WPDMA_GLO_CFG as zero */
+	/* 3. PBF_MAX_PCNT as 0x1F3FBF9F */
+	/* 4. kick per two packets when dequeue */
+	/* */
+	/* Txop can only be modified when RDG is off, WMM is disable and TxBurst is enable */
+	/* */
+	/* if 1. Legacy AP WMM on,  or 2. 11n AP, AMPDU disable.  Force turn off burst no matter what bEnableTxBurst is. */
 	if (!((pAd->CommonCfg.RxStream == 1) && (pAd->CommonCfg.TxStream == 1))
 	    && (pAd->StaCfg.bForceTxBurst == FALSE)
 	    &&
@@ -1791,14 +1791,14 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 3\n"));
 	}
 
-	// Re-check to turn on TX burst or not.
+	/* Re-check to turn on TX burst or not. */
 	if ((pAd->CommonCfg.IOTestParm.bLastAtheros == TRUE)
 	    && ((STA_WEP_ON(pAd)) || (STA_TKIP_ON(pAd)))) {
 		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = TRUE;
 		if (pAd->CommonCfg.bEnableTxBurst) {
 			UINT32 MACValue = 0;
-			// Force disable  TXOP value in this case. The same action in MLMEUpdateProtect too.
-			// I didn't change PBF_MAX_PCNT setting.
+			/* Force disable  TXOP value in this case. The same action in MLMEUpdateProtect too. */
+			/* I didn't change PBF_MAX_PCNT setting. */
 			RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &MACValue);
 			MACValue &= 0xFFFFFF00;
 			RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, MACValue);
@@ -1813,9 +1813,9 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("!!!pAd->bNextDisableRxBA= %d \n",
 		  pAd->CommonCfg.IOTestParm.bNextDisableRxBA));
-	// BSSID add in one MAC entry too.  Because in Tx, ASIC need to check Cipher and IV/EIV, BAbitmap
-	// Pther information in MACTab.Content[BSSID_WCID] is not necessary for driver.
-	// Note: As STA, The MACTab.Content[BSSID_WCID]. PairwiseKey and Shared Key for BSS0 are the same.
+	/* BSSID add in one MAC entry too.  Because in Tx, ASIC need to check Cipher and IV/EIV, BAbitmap */
+	/* Pther information in MACTab.Content[BSSID_WCID] is not necessary for driver. */
+	/* Note: As STA, The MACTab.Content[BSSID_WCID]. PairwiseKey and Shared Key for BSS0 are the same. */
 
 	if (pAd->StaCfg.WepStatus <= Ndis802_11WEPDisabled) {
 		if (pAd->StaCfg.WpaSupplicantUP &&
@@ -1832,10 +1832,10 @@ VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 	pEntry->PortSecured = pAd->StaCfg.PortSecured;
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
-	//
-	// Patch Atheros AP TX will breakdown issue.
-	// AP Model: DLink DWL-8200AP
-	//
+	/* */
+	/* Patch Atheros AP TX will breakdown issue. */
+	/* AP Model: DLink DWL-8200AP */
+	/* */
 	if (INFRA_ON(pAd) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)
 	    && STA_TKIP_ON(pAd)) {
 		RTMP_IO_WRITE32(pAd, RX_PARSER_CFG, 0x01);
@@ -1877,14 +1877,14 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 {
 	UCHAR i, ByteValue = 0;
 
-	// Do nothing if monitor mode is on
+	/* Do nothing if monitor mode is on */
 	if (MONITOR_ON(pAd))
 		return;
 
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_GO_TO_SLEEP_NOW);
-	//Comment the codes, beasue the line 2291 call the same function.
-	//RTMPCancelTimer(&pAd->Mlme.PsPollTimer,               &Cancelled);
-	// Not allow go to sleep within linkdown function.
+	/*Comment the codes, beasue the line 2291 call the same function. */
+	/*RTMPCancelTimer(&pAd->Mlme.PsPollTimer,               &Cancelled); */
+	/* Not allow go to sleep within linkdown function. */
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 
 	if (pAd->CommonCfg.bWirelessEvent) {
@@ -1904,7 +1904,7 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	}
 
 	pAd->bPCIclkOff = FALSE;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
 	    || RTMP_TEST_PSFLAG(pAd, fRTMP_PS_SET_PCI_CLK_OFF_COMMAND)
@@ -1917,9 +1917,9 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	}
 #ifdef RTMP_MAC_PCI
 	pAd->bPCIclkOff = FALSE;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	if (ADHOC_ON(pAd))	// Adhoc mode link down
+	if (ADHOC_ON(pAd))	/* Adhoc mode link down */
 	{
 		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN 1!!!\n"));
 
@@ -1932,14 +1932,14 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 				    pAd->CommonCfg.Channel);
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("!!! MacTab.Size=%d !!!\n", pAd->MacTab.Size));
-	} else			// Infra structure mode
+	} else			/* Infra structure mode */
 	{
 		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN 2!!!\n"));
 
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 
-		// Saved last SSID for linkup comparison
+		/* Saved last SSID for linkup comparison */
 		pAd->CommonCfg.LastSsidLen = pAd->CommonCfg.SsidLen;
 		NdisMoveMemory(pAd->CommonCfg.LastSsid, pAd->CommonCfg.Ssid,
 			       pAd->CommonCfg.LastSsidLen);
@@ -1952,20 +1952,20 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 				 ("NDIS_STATUS_MEDIA_DISCONNECT Event A!\n"));
 			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
 		} else {
-			//
-			// If disassociation request is from NDIS, then we don't need to delete BSSID from entry.
-			// Otherwise lost beacon or receive De-Authentication from AP,
-			// then we should delete BSSID from BssTable.
-			// If we don't delete from entry, roaming will fail.
-			//
+			/* */
+			/* If disassociation request is from NDIS, then we don't need to delete BSSID from entry. */
+			/* Otherwise lost beacon or receive De-Authentication from AP, */
+			/* then we should delete BSSID from BssTable. */
+			/* If we don't delete from entry, roaming will fail. */
+			/* */
 			BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid,
 					    pAd->CommonCfg.Channel);
 		}
 
-		// restore back to -
-		//      1. long slot (20 us) or short slot (9 us) time
-		//      2. turn on/off RTS/CTS and/or CTS-to-self protection
-		//      3. short preamble
+		/* restore back to - */
+		/*      1. long slot (20 us) or short slot (9 us) time */
+		/*      2. turn on/off RTS/CTS and/or CTS-to-self protection */
+		/*      3. short preamble */
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
 
 	}
@@ -1976,13 +1976,13 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 					    pAd->MacTab.Content[i].Addr);
 	}
 
-	AsicSetSlotTime(pAd, TRUE);	//FALSE);
+	AsicSetSlotTime(pAd, TRUE);	/*FALSE); */
 	AsicSetEdcaParm(pAd, NULL);
 
-	// Set LED
+	/* Set LED */
 	RTMPSetLED(pAd, LED_LINK_DOWN);
 	pAd->LedIndicatorStrength = 0xF0;
-	RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, firmware is not done it.
+	RTMPSetSignalLED(pAd, -100);	/* Force signal strength Led to be turned off, firmware is not done it. */
 
 	AsicDisableSync(pAd);
 
@@ -1990,7 +1990,7 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	pAd->Mlme.OneSecPeriodicRound = 0;
 
 	if (pAd->StaCfg.BssType == BSS_INFRA) {
-		// Remove StaCfg Information after link down
+		/* Remove StaCfg Information after link down */
 		NdisZeroMemory(pAd->CommonCfg.Bssid, MAC_ADDR_LEN);
 		NdisZeroMemory(pAd->CommonCfg.Ssid, MAX_LEN_OF_SSID);
 		pAd->CommonCfg.SsidLen = 0;
@@ -2001,25 +2001,25 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	pAd->MlmeAux.HtCapabilityLen = 0;
 	pAd->MlmeAux.NewExtChannelOffset = 0xff;
 
-	// Reset WPA-PSK state. Only reset when supplicant enabled
+	/* Reset WPA-PSK state. Only reset when supplicant enabled */
 	if (pAd->StaCfg.WpaState != SS_NOTUSE) {
 		pAd->StaCfg.WpaState = SS_START;
-		// Clear Replay counter
+		/* Clear Replay counter */
 		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
 
 	}
-	//
-	// if link down come from AP, we need to remove all WPA keys on WPA mode.
-	// otherwise will cause 4-way handshaking failed, since the WPA key not empty.
-	//
+	/* */
+	/* if link down come from AP, we need to remove all WPA keys on WPA mode. */
+	/* otherwise will cause 4-way handshaking failed, since the WPA key not empty. */
+	/* */
 	if ((IsReqFromAP) && (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)) {
-		// Remove all WPA keys
+		/* Remove all WPA keys */
 		RTMPWPARemoveAllKeys(pAd);
 	}
-	// 802.1x port control
+	/* 802.1x port control */
 
-	// Prevent clear PortSecured here with static WEP
-	// NetworkManger set security policy first then set SSID to connect AP.
+	/* Prevent clear PortSecured here with static WEP */
+	/* NetworkManger set security policy first then set SSID to connect AP. */
 	if (pAd->StaCfg.WpaSupplicantUP &&
 	    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
 	    (pAd->StaCfg.IEEE8021X == FALSE)) {
@@ -2037,16 +2037,16 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	pAd->StaCfg.MicErrCnt = 0;
 
 	pAd->IndicateMediaState = NdisMediaStateDisconnected;
-	// Update extra information to link is up
+	/* Update extra information to link is up */
 	pAd->ExtraInfo = GENERAL_LINK_DOWN;
 
 	pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
 
 #ifdef RTMP_MAC_USB
 	pAd->bUsbTxBulkAggre = FALSE;
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
-	// Clean association information
+	/* Clean association information */
 	NdisZeroMemory(&pAd->StaCfg.AssocInfo,
 		       sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
 	pAd->StaCfg.AssocInfo.Length =
@@ -2054,9 +2054,9 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	pAd->StaCfg.ReqVarIELen = 0;
 	pAd->StaCfg.ResVarIELen = 0;
 
-	//
-	// Reset RSSI value after link down
-	//
+	/* */
+	/* Reset RSSI value after link down */
+	/* */
 	pAd->StaCfg.RssiSample.AvgRssi0 = 0;
 	pAd->StaCfg.RssiSample.AvgRssi0X8 = 0;
 	pAd->StaCfg.RssiSample.AvgRssi1 = 0;
@@ -2064,20 +2064,20 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	pAd->StaCfg.RssiSample.AvgRssi2 = 0;
 	pAd->StaCfg.RssiSample.AvgRssi2X8 = 0;
 
-	// Restore MlmeRate
+	/* Restore MlmeRate */
 	pAd->CommonCfg.MlmeRate = pAd->CommonCfg.BasicMlmeRate;
 	pAd->CommonCfg.RtsRate = pAd->CommonCfg.BasicMlmeRate;
 
-	//
-	// After Link down, reset piggy-back setting in ASIC. Disable RDG.
-	//
+	/* */
+	/* After Link down, reset piggy-back setting in ASIC. Disable RDG. */
+	/* */
 	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
 		pAd->CommonCfg.BBPCurrentBW = BW_20;
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &ByteValue);
 		ByteValue &= (~0x18);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, ByteValue);
 	}
-	// Reset DAC
+	/* Reset DAC */
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &ByteValue);
 	ByteValue &= (~0x18);
 	if (pAd->Antenna.field.TxPath == 2) {
@@ -2090,7 +2090,7 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 
 	pAd->CommonCfg.BACapability.word = pAd->CommonCfg.REGBACapability.word;
 
-	// Restore all settings in the following.
+	/* Restore all settings in the following. */
 	AsicUpdateProtect(pAd, 0,
 			  (ALLN_SETPROTECT | CCKSETPROTECT | OFDMSETPROTECT),
 			  TRUE, FALSE);
@@ -2101,7 +2101,7 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, 0x1fff);
 	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
 
-// Allow go to sleep after linkdown steps.
+/* Allow go to sleep after linkdown steps. */
 	RTMP_SET_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 
 	RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
@@ -2111,7 +2111,7 @@ VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 	    && (pAd->Antenna.field.RxPath > 1 || pAd->Antenna.field.TxPath > 1)) {
 		RTMP_ASIC_MMPS_DISABLE(pAd);
 	}
-#endif // RT30xx //
+#endif /* RT30xx // */
 }
 
 /*
@@ -2128,16 +2128,16 @@ VOID IterateOnBssTab(IN PRTMP_ADAPTER pAd)
 	MLME_JOIN_REQ_STRUCT JoinReq;
 	ULONG BssIdx;
 
-	// Change the wepstatus to original wepstatus
+	/* Change the wepstatus to original wepstatus */
 	pAd->StaCfg.WepStatus = pAd->StaCfg.OrigWepStatus;
 	pAd->StaCfg.PairCipher = pAd->StaCfg.OrigWepStatus;
 	pAd->StaCfg.GroupCipher = pAd->StaCfg.OrigWepStatus;
 
 	BssIdx = pAd->MlmeAux.BssIdx;
 	if (BssIdx < pAd->MlmeAux.SsidBssTab.BssNr) {
-		// Check cipher suite, AP must have more secured cipher than station setting
-		// Set the Pairwise and Group cipher to match the intended AP setting
-		// We can only connect to AP with less secured cipher setting
+		/* Check cipher suite, AP must have more secured cipher than station setting */
+		/* Set the Pairwise and Group cipher to match the intended AP setting */
+		/* We can only connect to AP with less secured cipher setting */
 		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
 		    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
 			pAd->StaCfg.GroupCipher =
@@ -2155,7 +2155,7 @@ VOID IterateOnBssTab(IN PRTMP_ADAPTER pAd)
 				pAd->StaCfg.PairCipher =
 				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
 				    WPA.PairCipherAux;
-			else	// There is no PairCipher Aux, downgrade our capability to TKIP
+			else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
 				pAd->StaCfg.PairCipher =
 				    Ndis802_11Encryption2Enabled;
 		} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
@@ -2176,16 +2176,16 @@ VOID IterateOnBssTab(IN PRTMP_ADAPTER pAd)
 				pAd->StaCfg.PairCipher =
 				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
 				    WPA2.PairCipherAux;
-			else	// There is no PairCipher Aux, downgrade our capability to TKIP
+			else	/* There is no PairCipher Aux, downgrade our capability to TKIP */
 				pAd->StaCfg.PairCipher =
 				    Ndis802_11Encryption2Enabled;
 
-			// RSN capability
+			/* RSN capability */
 			pAd->StaCfg.RsnCapability =
 			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
 			    RsnCapability;
 		}
-		// Set Mix cipher flag
+		/* Set Mix cipher flag */
 		pAd->StaCfg.bMixCipher =
 		    (pAd->StaCfg.PairCipher ==
 		     pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
@@ -2211,7 +2211,7 @@ VOID IterateOnBssTab(IN PRTMP_ADAPTER pAd)
 		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
 			    sizeof(MLME_START_REQ_STRUCT), &StartReq);
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
-	} else			// no more BSS
+	} else			/* no more BSS */
 	{
 
 		{
@@ -2226,8 +2226,8 @@ VOID IterateOnBssTab(IN PRTMP_ADAPTER pAd)
 	}
 }
 
-// for re-association only
-// IRQL = DISPATCH_LEVEL
+/* for re-association only */
+/* IRQL = DISPATCH_LEVEL */
 VOID IterateOnBssTab2(IN PRTMP_ADAPTER pAd)
 {
 	MLME_REASSOC_REQ_STRUCT ReassocReq;
@@ -2245,7 +2245,7 @@ VOID IterateOnBssTab2(IN PRTMP_ADAPTER pAd)
 		AsicSwitchChannel(pAd, pBss->Channel, FALSE);
 		AsicLockChannel(pAd, pBss->Channel);
 
-		// reassociate message has the same structure as associate message
+		/* reassociate message has the same structure as associate message */
 		AssocParmFill(pAd, &ReassocReq, pBss->Bssid,
 			      pBss->CapabilityInfo, ASSOC_TIMEOUT,
 			      pAd->StaCfg.DefaultListenCount);
@@ -2253,7 +2253,7 @@ VOID IterateOnBssTab2(IN PRTMP_ADAPTER pAd)
 			    sizeof(MLME_REASSOC_REQ_STRUCT), &ReassocReq);
 
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_REASSOC;
-	} else			// no more BSS
+	} else			/* no more BSS */
 	{
 
 		{
@@ -2355,7 +2355,7 @@ VOID ComposePsPoll(IN PRTMP_ADAPTER pAd)
 	COPY_MAC_ADDR(pAd->PsPollFrame.Ta, pAd->CurrentAddress);
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID ComposeNullFrame(IN PRTMP_ADAPTER pAd)
 {
 	NdisZeroMemory(&pAd->NullFrame, sizeof(HEADER_802_11));
@@ -2366,7 +2366,7 @@ VOID ComposeNullFrame(IN PRTMP_ADAPTER pAd)
 	COPY_MAC_ADDR(pAd->NullFrame.Addr2, pAd->CurrentAddress);
 	COPY_MAC_ADDR(pAd->NullFrame.Addr3, pAd->CommonCfg.Bssid);
 }
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 VOID MlmeCntlConfirm(IN PRTMP_ADAPTER pAd, IN ULONG MsgType, IN USHORT Msg)
 {
@@ -2407,12 +2407,12 @@ VOID ComposePsPoll(IN PRTMP_ADAPTER pAd)
 	RTMPMoveMemory(&pAd->PsPollContext.TransferBuffer->field.
 		       WirelessPacket[TXWI_SIZE + TXINFO_SIZE],
 		       &pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
-	// Append 4 extra zero bytes.
+	/* Append 4 extra zero bytes. */
 	pAd->PsPollContext.BulkOutSize =
 	    TXINFO_SIZE + TXWI_SIZE + sizeof(PSPOLL_FRAME) + 4;
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID ComposeNullFrame(IN PRTMP_ADAPTER pAd)
 {
 	PTXINFO_STRUC pTxInfo;
@@ -2446,7 +2446,7 @@ VOID ComposeNullFrame(IN PRTMP_ADAPTER pAd)
 	pAd->NullContext.BulkOutSize =
 	    TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
 }
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 /*
 	==========================================================================
@@ -2477,27 +2477,27 @@ ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 
 	if ((pAd->CommonCfg.PhyMode == PHY_11B)
 	    && (pAd->CommonCfg.Channel <= 14)) {
-		SupRate[0] = 0x82;	// 1 mbps
-		SupRate[1] = 0x84;	// 2 mbps
-		SupRate[2] = 0x8b;	// 5.5 mbps
-		SupRate[3] = 0x96;	// 11 mbps
+		SupRate[0] = 0x82;	/* 1 mbps */
+		SupRate[1] = 0x84;	/* 2 mbps */
+		SupRate[2] = 0x8b;	/* 5.5 mbps */
+		SupRate[3] = 0x96;	/* 11 mbps */
 		SupRateLen = 4;
 		ExtRateLen = 0;
 	} else if (pAd->CommonCfg.Channel > 14) {
-		SupRate[0] = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
-		SupRate[1] = 0x12;	// 9 mbps, in units of 0.5 Mbps
-		SupRate[2] = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
-		SupRate[3] = 0x24;	// 18 mbps, in units of 0.5 Mbps
-		SupRate[4] = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
-		SupRate[5] = 0x48;	// 36 mbps, in units of 0.5 Mbps
-		SupRate[6] = 0x60;	// 48 mbps, in units of 0.5 Mbps
-		SupRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		SupRate[0] = 0x8C;	/* 6 mbps, in units of 0.5 Mbps, basic rate */
+		SupRate[1] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
+		SupRate[2] = 0x98;	/* 12 mbps, in units of 0.5 Mbps, basic rate */
+		SupRate[3] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
+		SupRate[4] = 0xb0;	/* 24 mbps, in units of 0.5 Mbps, basic rate */
+		SupRate[5] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
+		SupRate[6] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
+		SupRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
 		SupRateLen = 8;
 		ExtRateLen = 0;
 
-		//
-		// Also Update MlmeRate & RtsRate for G only & A only
-		//
+		/* */
+		/* Also Update MlmeRate & RtsRate for G only & A only */
+		/* */
 		pAd->CommonCfg.MlmeRate = RATE_6;
 		pAd->CommonCfg.RtsRate = RATE_6;
 		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
@@ -2508,20 +2508,20 @@ ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS =
 		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
 	} else {
-		SupRate[0] = 0x82;	// 1 mbps
-		SupRate[1] = 0x84;	// 2 mbps
-		SupRate[2] = 0x8b;	// 5.5 mbps
-		SupRate[3] = 0x96;	// 11 mbps
+		SupRate[0] = 0x82;	/* 1 mbps */
+		SupRate[1] = 0x84;	/* 2 mbps */
+		SupRate[2] = 0x8b;	/* 5.5 mbps */
+		SupRate[3] = 0x96;	/* 11 mbps */
 		SupRateLen = 4;
 
-		ExtRate[0] = 0x0C;	// 6 mbps, in units of 0.5 Mbps,
-		ExtRate[1] = 0x12;	// 9 mbps, in units of 0.5 Mbps
-		ExtRate[2] = 0x18;	// 12 mbps, in units of 0.5 Mbps,
-		ExtRate[3] = 0x24;	// 18 mbps, in units of 0.5 Mbps
-		ExtRate[4] = 0x30;	// 24 mbps, in units of 0.5 Mbps,
-		ExtRate[5] = 0x48;	// 36 mbps, in units of 0.5 Mbps
-		ExtRate[6] = 0x60;	// 48 mbps, in units of 0.5 Mbps
-		ExtRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		ExtRate[0] = 0x0C;	/* 6 mbps, in units of 0.5 Mbps, */
+		ExtRate[1] = 0x12;	/* 9 mbps, in units of 0.5 Mbps */
+		ExtRate[2] = 0x18;	/* 12 mbps, in units of 0.5 Mbps, */
+		ExtRate[3] = 0x24;	/* 18 mbps, in units of 0.5 Mbps */
+		ExtRate[4] = 0x30;	/* 24 mbps, in units of 0.5 Mbps, */
+		ExtRate[5] = 0x48;	/* 36 mbps, in units of 0.5 Mbps */
+		ExtRate[6] = 0x60;	/* 48 mbps, in units of 0.5 Mbps */
+		ExtRate[7] = 0x6c;	/* 54 mbps, in units of 0.5 Mbps */
 		ExtRateLen = 8;
 	}
 
@@ -2530,7 +2530,7 @@ ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 	pAd->StaActive.ExtRateLen = ExtRateLen;
 	NdisMoveMemory(pAd->StaActive.ExtRate, ExtRate, ExtRateLen);
 
-	// compose IBSS beacon frame
+	/* compose IBSS beacon frame */
 	MgtMacHeaderInit(pAd, &BcnHdr, SUBTYPE_BEACON, 0, BROADCAST_ADDR,
 			 pAd->CommonCfg.Bssid);
 	Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled)
@@ -2558,7 +2558,7 @@ ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 			  1, &IbssIe,
 			  1, &IbssLen, 2, &pAd->StaActive.AtimWin, END_OF_ARGS);
 
-	// add ERP_IE and EXT_RAE IE of in 802.11g
+	/* add ERP_IE and EXT_RAE IE of in 802.11g */
 	if (ExtRateLen) {
 		ULONG tmp;
 
@@ -2569,7 +2569,7 @@ ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 				  ExtRateLen, ExtRate, END_OF_ARGS);
 		FrameLen += tmp;
 	}
-	// If adhoc secruity is set for WPA-None, append the cipher suite IE
+	/* If adhoc secruity is set for WPA-None, append the cipher suite IE */
 	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
 		ULONG tmp;
 		RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus,
@@ -2587,7 +2587,7 @@ ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 		ULONG TmpLen;
 		UCHAR HtLen, HtLen1;
 
-		// add HT Capability IE
+		/* add HT Capability IE */
 		HtLen = sizeof(pAd->CommonCfg.HtCapability);
 		HtLen1 = sizeof(pAd->CommonCfg.AddHTInfo);
 
@@ -2602,14 +2602,14 @@ ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 
 		FrameLen += TmpLen;
 	}
-	//beacon use reserved WCID 0xff
+	/*beacon use reserved WCID 0xff */
 	if (pAd->CommonCfg.Channel > 14) {
 		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, TRUE, FALSE, FALSE,
 			      TRUE, 0, 0xff, FrameLen, PID_MGMT, PID_BEACON,
 			      RATE_1, IFS_HTTXOP, FALSE,
 			      &pAd->CommonCfg.MlmeTransmit);
 	} else {
-		// Set to use 1Mbps for Adhoc beacon.
+		/* Set to use 1Mbps for Adhoc beacon. */
 		HTTRANSMIT_SETTING Transmit;
 		Transmit.word = 0;
 		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, TRUE, FALSE, FALSE,
diff --git a/drivers/staging/rt2860/sta/rtmp_data.c b/drivers/staging/rt2860/sta/rtmp_data.c
index 3a93ef6..db65188 100644
--- a/drivers/staging/rt2860/sta/rtmp_data.c
+++ b/drivers/staging/rt2860/sta/rtmp_data.c
@@ -45,10 +45,10 @@ VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
 	UCHAR *pTmpBuf;
 
 	if (pAd->StaCfg.WpaSupplicantUP) {
-		// All EAPoL frames have to pass to upper layer (ex. WPA_SUPPLICANT daemon)
-		// TBD : process fragmented EAPol frames
+		/* All EAPoL frames have to pass to upper layer (ex. WPA_SUPPLICANT daemon) */
+		/* TBD : process fragmented EAPol frames */
 		{
-			// In 802.1x mode, if the received frame is EAP-SUCCESS packet, turn on the PortSecured variable
+			/* In 802.1x mode, if the received frame is EAP-SUCCESS packet, turn on the PortSecured variable */
 			if (pAd->StaCfg.IEEE8021X == TRUE &&
 			    (EAP_CODE_SUCCESS ==
 			     WpaCheckEapCode(pAd, pRxBlk->pData,
@@ -60,7 +60,7 @@ VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
 
 				DBGPRINT_RAW(RT_DEBUG_TRACE,
 					     ("Receive EAP-SUCCESS Packet\n"));
-				//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+				/*pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED; */
 				STA_PORT_SECURED(pAd);
 
 				if (pAd->StaCfg.IEEE8021x_required_keys ==
@@ -80,21 +80,21 @@ VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
 						    &pAd->MacTab.
 						    Content[BSSID_WCID];
 
-						// Set key material and cipherAlg to Asic
+						/* Set key material and cipherAlg to Asic */
 						AsicAddSharedKeyEntry(pAd, BSS0,
 								      idx,
 								      CipherAlg,
 								      Key, NULL,
 								      NULL);
 
-						// Assign group key info
+						/* Assign group key info */
 						RTMPAddWcidAttributeEntry(pAd,
 									  BSS0,
 									  idx,
 									  CipherAlg,
 									  NULL);
 
-						// Assign pairwise key info
+						/* Assign pairwise key info */
 						RTMPAddWcidAttributeEntry(pAd,
 									  BSS0,
 									  idx,
@@ -105,7 +105,7 @@ VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
 						    NdisMediaStateConnected;
 						pAd->ExtraInfo =
 						    GENERAL_LINK_UP;
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 						union {
 							char buf[sizeof
@@ -144,7 +144,7 @@ VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
 						    NdisMediaStateConnected;
 						pAd->ExtraInfo =
 						    GENERAL_LINK_UP;
-						// need to enqueue cmd to thread
+						/* need to enqueue cmd to thread */
 						RTUSBEnqueueCmdFromNdis(pAd,
 									OID_802_11_ADD_WEP,
 									TRUE,
@@ -154,8 +154,8 @@ VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
 									 keyinfo)
 									+ len -
 									1);
-#endif // RTMP_MAC_USB //
-						// For Preventing ShardKey Table is cleared by remove key procedure.
+#endif /* RTMP_MAC_USB // */
+						/* For Preventing ShardKey Table is cleared by remove key procedure. */
 						pAd->SharedKey[BSS0][idx].
 						    CipherAlg = CipherAlg;
 						pAd->SharedKey[BSS0][idx].
@@ -179,9 +179,9 @@ VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
 			return;
 		}
 	} else {
-		// Special DATA frame that has to pass to MLME
-		//       1. Cisco Aironet frames for CCX2. We need pass it to MLME for special process
-		//       2. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
+		/* Special DATA frame that has to pass to MLME */
+		/*       1. Cisco Aironet frames for CCX2. We need pass it to MLME for special process */
+		/*       2. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process */
 		{
 			pTmpBuf = pRxBlk->pData - LENGTH_802_11;
 			NdisMoveMemory(pTmpBuf, pRxBlk->pHeader, LENGTH_802_11);
@@ -207,30 +207,30 @@ VOID STARxDataFrameAnnounce(IN PRTMP_ADAPTER pAd,
 			    IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
 
-	// non-EAP frame
+	/* non-EAP frame */
 	if (!RTMPCheckWPAframe
 	    (pAd, pEntry, pRxBlk->pData, pRxBlk->DataSize, FromWhichBSSID)) {
 
 		{
-			// drop all non-EAP DATA frame before
-			// this client's Port-Access-Control is secured
+			/* drop all non-EAP DATA frame before */
+			/* this client's Port-Access-Control is secured */
 			if (pRxBlk->pHeader->FC.Wep) {
-				// unsupported cipher suite
+				/* unsupported cipher suite */
 				if (pAd->StaCfg.WepStatus ==
 				    Ndis802_11EncryptionDisabled) {
-					// release packet
+					/* release packet */
 					RELEASE_NDIS_PACKET(pAd,
 							    pRxBlk->pRxPacket,
 							    NDIS_STATUS_FAILURE);
 					return;
 				}
 			} else {
-				// encryption in-use but receive a non-EAPOL clear text frame, drop it
+				/* encryption in-use but receive a non-EAPOL clear text frame, drop it */
 				if ((pAd->StaCfg.WepStatus !=
 				     Ndis802_11EncryptionDisabled)
 				    && (pAd->StaCfg.PortSecured ==
 					WPA_802_1X_PORT_NOT_SECURED)) {
-					// release packet
+					/* release packet */
 					RELEASE_NDIS_PACKET(pAd,
 							    pRxBlk->pRxPacket,
 							    NDIS_STATUS_FAILURE);
@@ -240,12 +240,12 @@ VOID STARxDataFrameAnnounce(IN PRTMP_ADAPTER pAd,
 		}
 		RX_BLK_CLEAR_FLAG(pRxBlk, fRX_EAP);
 		if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_ARALINK)) {
-			// Normal legacy, AMPDU or AMSDU
+			/* Normal legacy, AMPDU or AMSDU */
 			CmmRxnonRalinkFrameIndicate(pAd, pRxBlk,
 						    FromWhichBSSID);
 
 		} else {
-			// ARALINK
+			/* ARALINK */
 			CmmRxRalinkFrameIndicate(pAd, pEntry, pRxBlk,
 						 FromWhichBSSID);
 		}
@@ -256,15 +256,15 @@ VOID STARxDataFrameAnnounce(IN PRTMP_ADAPTER pAd,
 		    && (pAd->CommonCfg.bDisableReordering == 0)) {
 			Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
 		} else {
-			// Determin the destination of the EAP frame
-			//  to WPA state machine or upper layer
+			/* Determin the destination of the EAP frame */
+			/*  to WPA state machine or upper layer */
 			STARxEAPOLFrameIndicate(pAd, pEntry, pRxBlk,
 						FromWhichBSSID);
 		}
 	}
 }
 
-// For TKIP frame, calculate the MIC value
+/* For TKIP frame, calculate the MIC value */
 BOOLEAN STACheckTkipMICValue(IN PRTMP_ADAPTER pAd,
 			     IN MAC_TABLE_ENTRY * pEntry, IN RX_BLK * pRxBlk)
 {
@@ -301,7 +301,7 @@ BOOLEAN STACheckTkipMICValue(IN PRTMP_ADAPTER pAd,
 			RTMPReportMicError(pAd, pWpaKey);
 		}
 
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
 				    NDIS_STATUS_FAILURE);
 		return FALSE;
@@ -310,14 +310,14 @@ BOOLEAN STACheckTkipMICValue(IN PRTMP_ADAPTER pAd,
 	return TRUE;
 }
 
-//
-// All Rx routines use RX_BLK structure to hande rx events
-// It is very important to build pRxBlk attributes
-//  1. pHeader pointer to 802.11 Header
-//  2. pData pointer to payload including LLC (just skip Header)
-//  3. set payload size including LLC to DataSize
-//  4. set some flags with RX_BLK_SET_FLAG()
-//
+/* */
+/* All Rx routines use RX_BLK structure to hande rx events */
+/* It is very important to build pRxBlk attributes */
+/*  1. pHeader pointer to 802.11 Header */
+/*  2. pData pointer to payload including LLC (just skip Header) */
+/*  3. set payload size including LLC to DataSize */
+/*  4. set some flags with RX_BLK_SET_FLAG() */
+/* */
 VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 {
 	PRT28XX_RXD_STRUC pRxD = &(pRxBlk->RxD);
@@ -330,17 +330,17 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 	UCHAR UserPriority = 0;
 
 	{
-		// before LINK UP, all DATA frames are rejected
+		/* before LINK UP, all DATA frames are rejected */
 		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
-			// release packet
+			/* release packet */
 			RELEASE_NDIS_PACKET(pAd, pRxPacket,
 					    NDIS_STATUS_FAILURE);
 			return;
 		}
-		// Drop not my BSS frames
+		/* Drop not my BSS frames */
 		if (pRxD->MyBss == 0) {
 			{
-				// release packet
+				/* release packet */
 				RELEASE_NDIS_PACKET(pAd, pRxPacket,
 						    NDIS_STATUS_FAILURE);
 				return;
@@ -354,14 +354,14 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 			UCHAR *pData;
 			DBGPRINT(RT_DEBUG_INFO, ("bAPSDCapable\n"));
 
-			// Qos bit 4
+			/* Qos bit 4 */
 			pData = (PUCHAR) pHeader + LENGTH_802_11;
 			if ((*pData >> 4) & 0x01) {
 				DBGPRINT(RT_DEBUG_INFO,
 					 ("RxDone- Rcv EOSP frame, driver may fall into sleep\n"));
 				pAd->CommonCfg.bInServicePeriod = FALSE;
 
-				// Force driver to fall into sleep mode when rcv EOSP frame
+				/* Force driver to fall into sleep mode when rcv EOSP frame */
 				if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
 					USHORT TbttNumToNextWakeUp;
 					USHORT NextDtim =
@@ -383,7 +383,7 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 						TbttNumToNextWakeUp = NextDtim;
 
 					RTMP_SET_PSM_BIT(pAd, PWR_SAVE);
-					// if WMM-APSD is failed, try to disable following line
+					/* if WMM-APSD is failed, try to disable following line */
 					AsicSleepThenAutoWakeup(pAd,
 								TbttNumToNextWakeUp);
 				}
@@ -395,58 +395,58 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 					 ("Sending another trigger frame when More Data bit is set to 1\n"));
 			}
 		}
-		// Drop NULL, CF-ACK(no data), CF-POLL(no data), and CF-ACK+CF-POLL(no data) data frame
-		if ((pHeader->FC.SubType & 0x04))	// bit 2 : no DATA
+		/* Drop NULL, CF-ACK(no data), CF-POLL(no data), and CF-ACK+CF-POLL(no data) data frame */
+		if ((pHeader->FC.SubType & 0x04))	/* bit 2 : no DATA */
 		{
-			// release packet
+			/* release packet */
 			RELEASE_NDIS_PACKET(pAd, pRxPacket,
 					    NDIS_STATUS_FAILURE);
 			return;
 		}
-		// Drop not my BSS frame (we can not only check the MyBss bit in RxD)
+		/* Drop not my BSS frame (we can not only check the MyBss bit in RxD) */
 
 		if (INFRA_ON(pAd)) {
-			// Infrastructure mode, check address 2 for BSSID
+			/* Infrastructure mode, check address 2 for BSSID */
 			if (!RTMPEqualMemory
 			    (&pHeader->Addr2, &pAd->CommonCfg.Bssid, 6)) {
-				// Receive frame not my BSSID
-				// release packet
+				/* Receive frame not my BSSID */
+				/* release packet */
 				RELEASE_NDIS_PACKET(pAd, pRxPacket,
 						    NDIS_STATUS_FAILURE);
 				return;
 			}
-		} else		// Ad-Hoc mode or Not associated
+		} else		/* Ad-Hoc mode or Not associated */
 		{
-			// Ad-Hoc mode, check address 3 for BSSID
+			/* Ad-Hoc mode, check address 3 for BSSID */
 			if (!RTMPEqualMemory
 			    (&pHeader->Addr3, &pAd->CommonCfg.Bssid, 6)) {
-				// Receive frame not my BSSID
-				// release packet
+				/* Receive frame not my BSSID */
+				/* release packet */
 				RELEASE_NDIS_PACKET(pAd, pRxPacket,
 						    NDIS_STATUS_FAILURE);
 				return;
 			}
 		}
 
-		//
-		// find pEntry
-		//
+		/* */
+		/* find pEntry */
+		/* */
 		if (pRxWI->WirelessCliID < MAX_LEN_OF_MAC_TABLE) {
 			pEntry = &pAd->MacTab.Content[pRxWI->WirelessCliID];
 		} else {
-			// 1. release packet if infra mode
-			// 2. new a pEntry if ad-hoc mode
+			/* 1. release packet if infra mode */
+			/* 2. new a pEntry if ad-hoc mode */
 			RELEASE_NDIS_PACKET(pAd, pRxPacket,
 					    NDIS_STATUS_FAILURE);
 			return;
 		}
 
-		// infra or ad-hoc
+		/* infra or ad-hoc */
 		if (INFRA_ON(pAd)) {
 			RX_BLK_SET_FLAG(pRxBlk, fRX_INFRA);
 			ASSERT(pRxWI->WirelessCliID == BSSID_WCID);
 		}
-		// check Atheros Client
+		/* check Atheros Client */
 		if ((pEntry->bIAmBadAtheros == FALSE) && (pRxD->AMPDU == 1)
 		    && (pHeader->FC.Retry)) {
 			pEntry->bIAmBadAtheros = TRUE;
@@ -461,26 +461,26 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 
 	pRxBlk->pData = (UCHAR *) pHeader;
 
-	//
-	// update RxBlk->pData, DataSize
-	// 802.11 Header, QOS, HTC, Hw Padding
-	//
+	/* */
+	/* update RxBlk->pData, DataSize */
+	/* 802.11 Header, QOS, HTC, Hw Padding */
+	/* */
 
-	// 1. skip 802.11 HEADER
+	/* 1. skip 802.11 HEADER */
 	{
 		pRxBlk->pData += LENGTH_802_11;
 		pRxBlk->DataSize -= LENGTH_802_11;
 	}
 
-	// 2. QOS
+	/* 2. QOS */
 	if (pHeader->FC.SubType & 0x08) {
 		RX_BLK_SET_FLAG(pRxBlk, fRX_QOS);
 		UserPriority = *(pRxBlk->pData) & 0x0f;
-		// bit 7 in QoS Control field signals the HT A-MSDU format
+		/* bit 7 in QoS Control field signals the HT A-MSDU format */
 		if ((*pRxBlk->pData) & 0x80) {
 			RX_BLK_SET_FLAG(pRxBlk, fRX_AMSDU);
 		}
-		// skip QOS contorl field
+		/* skip QOS contorl field */
 		pRxBlk->pData += 2;
 		pRxBlk->DataSize -= 2;
 	}
@@ -500,7 +500,7 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 			RTMP_PS_POLL_ENQUEUE(pAd);
 		}
 	}
-	// 3. Order bit: A-Ralink or HTC+
+	/* 3. Order bit: A-Ralink or HTC+ */
 	if (pHeader->FC.Order) {
 #ifdef AGGREGATION_SUPPORT
 		if ((pRxWI->PHYMODE <= MODE_OFDM)
@@ -508,18 +508,18 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 		{
 			RX_BLK_SET_FLAG(pRxBlk, fRX_ARALINK);
 		} else
-#endif // AGGREGATION_SUPPORT //
+#endif /* AGGREGATION_SUPPORT // */
 		{
 			RX_BLK_SET_FLAG(pRxBlk, fRX_HTC);
-			// skip HTC contorl field
+			/* skip HTC contorl field */
 			pRxBlk->pData += 4;
 			pRxBlk->DataSize -= 4;
 		}
 	}
-	// 4. skip HW padding
+	/* 4. skip HW padding */
 	if (pRxD->L2PAD) {
-		// just move pData pointer
-		// because DataSize excluding HW padding
+		/* just move pData pointer */
+		/* because DataSize excluding HW padding */
 		RX_BLK_SET_FLAG(pRxBlk, fRX_PAD);
 		pRxBlk->pData += 2;
 	}
@@ -527,23 +527,23 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 	if (pRxD->BA) {
 		RX_BLK_SET_FLAG(pRxBlk, fRX_AMPDU);
 	}
-	//
-	// Case I  Process Broadcast & Multicast data frame
-	//
+	/* */
+	/* Case I  Process Broadcast & Multicast data frame */
+	/* */
 	if (pRxD->Bcast || pRxD->Mcast) {
 		INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
 
-		// Drop Mcast/Bcast frame with fragment bit on
+		/* Drop Mcast/Bcast frame with fragment bit on */
 		if (pHeader->FC.MoreFrag) {
-			// release packet
+			/* release packet */
 			RELEASE_NDIS_PACKET(pAd, pRxPacket,
 					    NDIS_STATUS_FAILURE);
 			return;
 		}
-		// Filter out Bcast frame which AP relayed for us
+		/* Filter out Bcast frame which AP relayed for us */
 		if (pHeader->FC.FrDs
 		    && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress)) {
-			// release packet
+			/* release packet */
 			RELEASE_NDIS_PACKET(pAd, pRxPacket,
 					    NDIS_STATUS_FAILURE);
 			return;
@@ -571,8 +571,8 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 		pAd->RalinkCounters.OneSecRxOkDataCnt++;
 
 		if (!((pHeader->Frag == 0) && (pHeader->FC.MoreFrag == 0))) {
-			// re-assemble the fragmented packets
-			// return complete frame (pRxPacket) or NULL
+			/* re-assemble the fragmented packets */
+			/* return complete frame (pRxPacket) or NULL */
 			bFragment = TRUE;
 			pRxPacket = RTMPDeFragmentDataFrame(pAd, pRxBlk);
 		}
@@ -580,14 +580,14 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 		if (pRxPacket) {
 			pEntry = &pAd->MacTab.Content[pRxWI->WirelessCliID];
 
-			// process complete frame
+			/* process complete frame */
 			if (bFragment && (pRxD->Decrypted)
 			    && (pEntry->WepStatus ==
 				Ndis802_11Encryption2Enabled)) {
-				// Minus MIC length
+				/* Minus MIC length */
 				pRxBlk->DataSize -= 8;
 
-				// For TKIP frame, calculate the MIC value
+				/* For TKIP frame, calculate the MIC value */
 				if (STACheckTkipMICValue(pAd, pEntry, pRxBlk) ==
 				    FALSE) {
 					return;
@@ -598,15 +598,15 @@ VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 					       FromWhichBSSID);
 			return;
 		} else {
-			// just return
-			// because RTMPDeFragmentDataFrame() will release rx packet,
-			// if packet is fragmented
+			/* just return */
+			/* because RTMPDeFragmentDataFrame() will release rx packet, */
+			/* if packet is fragmented */
 			return;
 		}
 	}
 
 	ASSERT(0);
-	// release packet
+	/* release packet */
 	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
 }
 
@@ -631,7 +631,7 @@ VOID STAHandleRxMgmtFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 
 		/* TODO: if MoreData == 0, station can go to sleep */
 
-		// We should collect RSSI not only U2M data but also my beacon
+		/* We should collect RSSI not only U2M data but also my beacon */
 		if ((pHeader->FC.SubType == SUBTYPE_BEACON)
 		    && (MAC_ADDR_EQUAL(&pAd->CommonCfg.Bssid, &pHeader->Addr2))
 		    && (pAd->RxAnt.EvaluatePeriod == 0)) {
@@ -641,7 +641,7 @@ VOID STAHandleRxMgmtFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 			pAd->StaCfg.LastSNR1 = (UCHAR) (pRxWI->SNR1);
 		}
 
-		// First check the size, it MUST not exceed the mlme queue size
+		/* First check the size, it MUST not exceed the mlme queue size */
 		if (pRxWI->MPDUtotalByteCount > MGMT_DMA_BUFFER_SIZE) {
 			DBGPRINT_ERR(("STAHandleRxMgmtFrame: frame too large, size = %d \n", pRxWI->MPDUtotalByteCount));
 			break;
@@ -712,7 +712,7 @@ BOOLEAN STARxDoneInterruptHandle(IN PRTMP_ADAPTER pAd, IN BOOLEAN argc)
 
 	RxProcessed = RxPending = 0;
 
-	// process whole rx ring
+	/* process whole rx ring */
 	while (1) {
 
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF |
@@ -724,36 +724,36 @@ BOOLEAN STARxDoneInterruptHandle(IN PRTMP_ADAPTER pAd, IN BOOLEAN argc)
 		}
 #ifdef RTMP_MAC_PCI
 		if (RxProcessed++ > MAX_RX_PROCESS_CNT) {
-			// need to reschedule rx handle
+			/* need to reschedule rx handle */
 			bReschedule = TRUE;
 			break;
 		}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-		RxProcessed++;	// test
+		RxProcessed++;	/* test */
 
-		// 1. allocate a new data packet into rx ring to replace received packet
-		//    then processing the received packet
-		// 2. the callee must take charge of release of packet
-		// 3. As far as driver is concerned ,
-		//    the rx packet must
-		//      a. be indicated to upper layer or
-		//      b. be released if it is discarded
+		/* 1. allocate a new data packet into rx ring to replace received packet */
+		/*    then processing the received packet */
+		/* 2. the callee must take charge of release of packet */
+		/* 3. As far as driver is concerned , */
+		/*    the rx packet must */
+		/*      a. be indicated to upper layer or */
+		/*      b. be released if it is discarded */
 		pRxPacket =
 		    GetPacketFromRxRing(pAd, &(RxCell.RxD), &bReschedule,
 					&RxPending);
 		if (pRxPacket == NULL) {
-			// no more packet to process
+			/* no more packet to process */
 			break;
 		}
-		// get rx ring descriptor
+		/* get rx ring descriptor */
 		pRxD = &(RxCell.RxD);
-		// get rx data buffer
+		/* get rx data buffer */
 		pData = GET_OS_PKT_DATAPTR(pRxPacket);
 		pRxWI = (PRXWI_STRUC) pData;
 		pHeader = (PHEADER_802_11) (pData + RXWI_SIZE);
 
-		// build RxCell
+		/* build RxCell */
 		RxCell.pRxWI = pRxWI;
 		RxCell.pHeader = pHeader;
 		RxCell.pRxPacket = pRxPacket;
@@ -761,7 +761,7 @@ BOOLEAN STARxDoneInterruptHandle(IN PRTMP_ADAPTER pAd, IN BOOLEAN argc)
 		RxCell.DataSize = pRxWI->MPDUtotalByteCount;
 		RxCell.Flags = 0;
 
-		// Increase Total receive byte counter after real data received no mater any error or not
+		/* Increase Total receive byte counter after real data received no mater any error or not */
 		pAd->RalinkCounters.ReceivedByteCount +=
 		    pRxWI->MPDUtotalByteCount;
 		pAd->RalinkCounters.OneSecReceivedByteCount +=
@@ -780,32 +780,32 @@ BOOLEAN STARxDoneInterruptHandle(IN PRTMP_ADAPTER pAd, IN BOOLEAN argc)
 
 		/* STARxDoneInterruptHandle() is called in rtusb_bulk.c */
 
-		// Check for all RxD errors
+		/* Check for all RxD errors */
 		Status = RTMPCheckRxError(pAd, pHeader, pRxWI, pRxD);
 
-		// Handle the received frame
+		/* Handle the received frame */
 		if (Status == NDIS_STATUS_SUCCESS) {
 			switch (pHeader->FC.Type) {
-				// CASE I, receive a DATA frame
+				/* CASE I, receive a DATA frame */
 			case BTYPE_DATA:
 				{
-					// process DATA frame
+					/* process DATA frame */
 					STAHandleRxDataFrame(pAd, &RxCell);
 				}
 				break;
-				// CASE II, receive a MGMT frame
+				/* CASE II, receive a MGMT frame */
 			case BTYPE_MGMT:
 				{
 					STAHandleRxMgmtFrame(pAd, &RxCell);
 				}
 				break;
-				// CASE III. receive a CNTL frame
+				/* CASE III. receive a CNTL frame */
 			case BTYPE_CNTL:
 				{
 					STAHandleRxControlFrame(pAd, &RxCell);
 				}
 				break;
-				// discard other type
+				/* discard other type */
 			default:
 				RELEASE_NDIS_PACKET(pAd, pRxPacket,
 						    NDIS_STATUS_FAILURE);
@@ -813,7 +813,7 @@ BOOLEAN STARxDoneInterruptHandle(IN PRTMP_ADAPTER pAd, IN BOOLEAN argc)
 			}
 		} else {
 			pAd->Counters8023.RxErrors++;
-			// discard this frame
+			/* discard this frame */
 			RELEASE_NDIS_PACKET(pAd, pRxPacket,
 					    NDIS_STATUS_FAILURE);
 		}
@@ -872,15 +872,15 @@ VOID STASendPackets(IN NDIS_HANDLE MiniportAdapterContext,
 			    || RTMP_TEST_FLAG(pAd,
 					      fRTMP_ADAPTER_HALT_IN_PROGRESS)
 			    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) {
-				// Drop send request since hardware is in reset state
+				/* Drop send request since hardware is in reset state */
 				break;
 			} else if (!INFRA_ON(pAd) && !ADHOC_ON(pAd)) {
-				// Drop send request since there are no physical connection yet
+				/* Drop send request since there are no physical connection yet */
 				break;
 			} else {
-				// Record that orignal packet source is from NDIS layer,so that
-				// later on driver knows how to release this NDIS PACKET
-				RTMP_SET_PACKET_WCID(pPacket, 0);	// this field is useless when in STA mode
+				/* Record that orignal packet source is from NDIS layer,so that */
+				/* later on driver knows how to release this NDIS PACKET */
+				RTMP_SET_PACKET_WCID(pPacket, 0);	/* this field is useless when in STA mode */
 				RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
 				NDIS_SET_PACKET_STATUS(pPacket,
 						       NDIS_STATUS_PENDING);
@@ -896,7 +896,7 @@ VOID STASendPackets(IN NDIS_HANDLE MiniportAdapterContext,
 			RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 	}
 
-	// Dequeue outgoing frames from TxSwQueue[] and process it
+	/* Dequeue outgoing frames from TxSwQueue[] and process it */
 	RTMPDeQueuePacket(pAd, FALSE, NUM_OF_TX_RING, MAX_TX_PROCESS);
 
 }
@@ -934,16 +934,16 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 	UCHAR FlgIsIP = 0;
 	UCHAR Rate;
 
-	// Prepare packet information structure for buffer descriptor
-	// chained within a single NDIS packet.
+	/* Prepare packet information structure for buffer descriptor */
+	/* chained within a single NDIS packet. */
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
 	if (pSrcBufVA == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("STASendPacket --> pSrcBufVA == NULL !!!SrcBufLen=%x\n",
 			  SrcBufLen));
-		// Resourece is low, system did not allocate virtual address
-		// return NDIS_STATUS_FAILURE directly to upper layer
+		/* Resourece is low, system did not allocate virtual address */
+		/* return NDIS_STATUS_FAILURE directly to upper layer */
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 		return NDIS_STATUS_FAILURE;
 	}
@@ -954,8 +954,8 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 		return (NDIS_STATUS_FAILURE);
 	}
-	// In HT rate adhoc mode, A-MPDU is often used. So need to lookup BA Table and MAC Entry.
-	// Note multicast packets in adhoc also use BSSID_WCID index.
+	/* In HT rate adhoc mode, A-MPDU is often used. So need to lookup BA Table and MAC Entry. */
+	/* Note multicast packets in adhoc also use BSSID_WCID index. */
 	{
 		if (INFRA_ON(pAd)) {
 			{
@@ -978,8 +978,8 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		DBGPRINT(RT_DEBUG_ERROR,
 			 ("STASendPacket->Cannot find pEntry(%2x:%2x:%2x:%2x:%2x:%2x) in MacTab!\n",
 			  PRINT_MAC(pSrcBufVA)));
-		// Resourece is low, system did not allocate virtual address
-		// return NDIS_STATUS_FAILURE directly to upper layer
+		/* Resourece is low, system did not allocate virtual address */
+		/* return NDIS_STATUS_FAILURE directly to upper layer */
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 		return NDIS_STATUS_FAILURE;
 	}
@@ -988,14 +988,14 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 	    ) {
 		RTMP_SET_PACKET_WCID(pPacket, (UCHAR) pEntry->Aid);
 	}
-	//
-	// Check the Ethernet Frame type of this packet, and set the RTMP_SET_PACKET_SPECIFIC flags.
-	//              Here we set the PACKET_SPECIFIC flags(LLC, VLAN, DHCP/ARP, EAPOL).
+	/* */
+	/* Check the Ethernet Frame type of this packet, and set the RTMP_SET_PACKET_SPECIFIC flags. */
+	/*              Here we set the PACKET_SPECIFIC flags(LLC, VLAN, DHCP/ARP, EAPOL). */
 	RTMPCheckEtherType(pAd, pPacket);
 
-	//
-	// WPA 802.1x secured port control - drop all non-802.1x frame before port secured
-	//
+	/* */
+	/* WPA 802.1x secured port control - drop all non-802.1x frame before port secured */
+	/* */
 	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
 	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
 	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
@@ -1013,30 +1013,30 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		return (NDIS_STATUS_FAILURE);
 	}
 
-	// STEP 1. Decide number of fragments required to deliver this MSDU.
-	//         The estimation here is not very accurate because difficult to
-	//         take encryption overhead into consideration here. The result
-	//         "NumberOfFrag" is then just used to pre-check if enough free
-	//         TXD are available to hold this MSDU.
+	/* STEP 1. Decide number of fragments required to deliver this MSDU. */
+	/*         The estimation here is not very accurate because difficult to */
+	/*         take encryption overhead into consideration here. The result */
+	/*         "NumberOfFrag" is then just used to pre-check if enough free */
+	/*         TXD are available to hold this MSDU. */
 
-	if (*pSrcBufVA & 0x01)	// fragmentation not allowed on multicast & broadcast
+	if (*pSrcBufVA & 0x01)	/* fragmentation not allowed on multicast & broadcast */
 		NumberOfFrag = 1;
 	else if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED))
-		NumberOfFrag = 1;	// Aggregation overwhelms fragmentation
+		NumberOfFrag = 1;	/* Aggregation overwhelms fragmentation */
 	else if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_AMSDU_INUSED))
-		NumberOfFrag = 1;	// Aggregation overwhelms fragmentation
+		NumberOfFrag = 1;	/* Aggregation overwhelms fragmentation */
 	else if ((pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTMIX)
 		 || (pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTGREENFIELD))
-		NumberOfFrag = 1;	// MIMO RATE overwhelms fragmentation
+		NumberOfFrag = 1;	/* MIMO RATE overwhelms fragmentation */
 	else {
-		// The calculated "NumberOfFrag" is a rough estimation because of various
-		// encryption/encapsulation overhead not taken into consideration. This number is just
-		// used to make sure enough free TXD are available before fragmentation takes place.
-		// In case the actual required number of fragments of an NDIS packet
-		// excceeds "NumberOfFrag"caculated here and not enough free TXD available, the
-		// last fragment (i.e. last MPDU) will be dropped in RTMPHardTransmit() due to out of
-		// resource, and the NDIS packet will be indicated NDIS_STATUS_FAILURE. This should
-		// rarely happen and the penalty is just like a TX RETRY fail. Affordable.
+		/* The calculated "NumberOfFrag" is a rough estimation because of various */
+		/* encryption/encapsulation overhead not taken into consideration. This number is just */
+		/* used to make sure enough free TXD are available before fragmentation takes place. */
+		/* In case the actual required number of fragments of an NDIS packet */
+		/* excceeds "NumberOfFrag"caculated here and not enough free TXD available, the */
+		/* last fragment (i.e. last MPDU) will be dropped in RTMPHardTransmit() due to out of */
+		/* resource, and the NDIS packet will be indicated NDIS_STATUS_FAILURE. This should */
+		/* rarely happen and the penalty is just like a TX RETRY fail. Affordable. */
 
 		AllowFragSize =
 		    (pAd->CommonCfg.FragmentThreshold) - LENGTH_802_11 -
@@ -1044,21 +1044,21 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		NumberOfFrag =
 		    ((PacketInfo.TotalPacketLength - LENGTH_802_3 +
 		      LENGTH_802_1_H) / AllowFragSize) + 1;
-		// To get accurate number of fragmentation, Minus 1 if the size just match to allowable fragment size
+		/* To get accurate number of fragmentation, Minus 1 if the size just match to allowable fragment size */
 		if (((PacketInfo.TotalPacketLength - LENGTH_802_3 +
 		      LENGTH_802_1_H) % AllowFragSize) == 0) {
 			NumberOfFrag--;
 		}
 	}
 
-	// Save fragment number to Ndis packet reserved field
+	/* Save fragment number to Ndis packet reserved field */
 	RTMP_SET_PACKET_FRAGMENTS(pPacket, NumberOfFrag);
 
-	// STEP 2. Check the requirement of RTS:
-	//         If multiple fragment required, RTS is required only for the first fragment
-	//         if the fragment size large than RTS threshold
-	//     For RT28xx, Let ASIC send RTS/CTS
-//      RTMP_SET_PACKET_RTS(pPacket, 0);
+	/* STEP 2. Check the requirement of RTS: */
+	/*         If multiple fragment required, RTS is required only for the first fragment */
+	/*         if the fragment size large than RTS threshold */
+	/*     For RT28xx, Let ASIC send RTS/CTS */
+/*      RTMP_SET_PACKET_RTS(pPacket, 0); */
 	if (NumberOfFrag > 1)
 		RTSRequired =
 		    (pAd->CommonCfg.FragmentThreshold >
@@ -1068,13 +1068,13 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		    (PacketInfo.TotalPacketLength >
 		     pAd->CommonCfg.RtsThreshold) ? 1 : 0;
 
-	// Save RTS requirement to Ndis packet reserved field
+	/* Save RTS requirement to Ndis packet reserved field */
 	RTMP_SET_PACKET_RTS(pPacket, RTSRequired);
 	RTMP_SET_PACKET_TXRATE(pPacket, pAd->CommonCfg.TxRate);
 
-	//
-	// STEP 3. Traffic classification. outcome = <UserPriority, QueIdx>
-	//
+	/* */
+	/* STEP 3. Traffic classification. outcome = <UserPriority, QueIdx> */
+	/* */
 	UserPriority = 0;
 	QueIdx = QID_AC_BE;
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) &&
@@ -1082,11 +1082,11 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		USHORT Protocol;
 		UCHAR LlcSnapLen = 0, Byte0, Byte1;
 		do {
-			// get Ethernet protocol field
+			/* get Ethernet protocol field */
 			Protocol =
 			    (USHORT) ((pSrcBufVA[12] << 8) + pSrcBufVA[13]);
 			if (Protocol <= 1500) {
-				// get Ethernet protocol field from LLC/SNAP
+				/* get Ethernet protocol field from LLC/SNAP */
 				if (Sniff2BytesFromNdisBuffer
 				    (PacketInfo.pFirstBuffer, LENGTH_802_3 + 6,
 				     &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
@@ -1095,17 +1095,17 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 				Protocol = (USHORT) ((Byte0 << 8) + Byte1);
 				LlcSnapLen = 8;
 			}
-			// always AC_BE for non-IP packet
+			/* always AC_BE for non-IP packet */
 			if (Protocol != 0x0800)
 				break;
 
-			// get IP header
+			/* get IP header */
 			if (Sniff2BytesFromNdisBuffer
 			    (PacketInfo.pFirstBuffer, LENGTH_802_3 + LlcSnapLen,
 			     &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
 				break;
 
-			// return AC_BE if packet is not IPv4
+			/* return AC_BE if packet is not IPv4 */
 			if ((Byte0 & 0xf0) != 0x40)
 				break;
 
@@ -1113,8 +1113,8 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 			UserPriority = (Byte1 & 0xe0) >> 5;
 			QueIdx = MapUserPriorityToAccessCategory[UserPriority];
 
-			// TODO: have to check ACM bit. apply TSPEC if ACM is ON
-			// TODO: downgrade UP & QueIdx before passing ACM
+			/* TODO: have to check ACM bit. apply TSPEC if ACM is ON */
+			/* TODO: downgrade UP & QueIdx before passing ACM */
 			/*
 			   Under WMM ACM control, we dont need to check the bit;
 			   Or when a TSPEC is built for VO but we will change to issue
@@ -1129,7 +1129,7 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 
 	RTMP_SET_PACKET_UP(pPacket, UserPriority);
 
-	// Make sure SendTxWait queue resource won't be used by other threads
+	/* Make sure SendTxWait queue resource won't be used by other threads */
 	RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
 	if (pAd->TxSwQueue[QueIdx].Number >= MAX_PACKETS_IN_QUEUE) {
 		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
@@ -1144,14 +1144,14 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 
 	if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE) &&
 	    IS_HT_STA(pEntry)) {
-		//PMAC_TABLE_ENTRY pMacEntry = &pAd->MacTab.Content[BSSID_WCID];
+		/*PMAC_TABLE_ENTRY pMacEntry = &pAd->MacTab.Content[BSSID_WCID]; */
 		if (((pEntry->TXBAbitmap & (1 << UserPriority)) == 0) &&
 		    ((pEntry->BADeclineBitmap & (1 << UserPriority)) == 0) &&
 		    (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)
-		    // For IOT compatibility, if
-		    // 1. It is Ralink chip or
-		    // 2. It is OPEN or AES mode,
-		    // then BA session can be bulit.
+		    /* For IOT compatibility, if */
+		    /* 1. It is Ralink chip or */
+		    /* 2. It is OPEN or AES mode, */
+		    /* then BA session can be bulit. */
 		    && ((pEntry->ValidAsCLI && pAd->MlmeAux.APRalinkIe != 0x0)
 			|| (pEntry->WepStatus != Ndis802_11WEPEnabled
 			    && pEntry->WepStatus !=
@@ -1162,7 +1162,7 @@ NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 		}
 	}
 
-	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;	// TODO: for debug only. to be removed
+	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;	/* TODO: for debug only. to be removed */
 	return NDIS_STATUS_SUCCESS;
 }
 
@@ -1238,7 +1238,7 @@ NDIS_STATUS RTMPFreeTXDRequest(IN PRTMP_ADAPTER pAd,
 
 	return (Status);
 }
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 /*
 	Actually, this function used to check if the TxHardware Queue still has frame need to send.
@@ -1248,7 +1248,7 @@ NDIS_STATUS RTMPFreeTXDRequest(IN PRTMP_ADAPTER pAd,
 			       IN UCHAR QueIdx,
 			       IN UCHAR NumberRequired, IN PUCHAR FreeNumberIs)
 {
-	//ULONG         FreeNumber = 0;
+	/*ULONG         FreeNumber = 0; */
 	NDIS_STATUS Status = NDIS_STATUS_FAILURE;
 	unsigned long IrqFlags;
 	HT_TX_CONTEXT *pHTTXContext;
@@ -1287,7 +1287,7 @@ NDIS_STATUS RTMPFreeTXDRequest(IN PRTMP_ADAPTER pAd,
 
 	return (Status);
 }
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 
 VOID RTMPSendDisassociationFrame(IN PRTMP_ADAPTER pAd)
 {
@@ -1300,7 +1300,7 @@ VOID RTMPSendNullFrame(IN PRTMP_ADAPTER pAd,
 	ULONG Length;
 	PHEADER_802_11 pHeader_802_11;
 
-	// WPA 802.1x secured port control
+	/* WPA 802.1x secured port control */
 	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
 	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
 	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
@@ -1334,21 +1334,21 @@ VOID RTMPSendNullFrame(IN PRTMP_ADAPTER pAd,
 	pAd->Sequence++;
 	pHeader_802_11->Sequence = pAd->Sequence;
 
-	// Prepare QosNull function frame
+	/* Prepare QosNull function frame */
 	if (bQosNull) {
 		pHeader_802_11->FC.SubType = SUBTYPE_QOS_NULL;
 
-		// copy QOS control bytes
+		/* copy QOS control bytes */
 		NullFrame[Length] = 0;
 		NullFrame[Length + 1] = 0;
-		Length += 2;	// if pad with 2 bytes for alignment, APSD will fail
+		Length += 2;	/* if pad with 2 bytes for alignment, APSD will fail */
 	}
 
 	HAL_KickOutNullFrameTx(pAd, 0, NullFrame, Length);
 
 }
 
-// IRQL = DISPATCH_LEVEL
+/* IRQL = DISPATCH_LEVEL */
 VOID RTMPSendRTSFrame(IN PRTMP_ADAPTER pAd,
 		      IN PUCHAR pDA,
 		      IN unsigned int NextMpduSize,
@@ -1358,19 +1358,19 @@ VOID RTMPSendRTSFrame(IN PRTMP_ADAPTER pAd,
 {
 }
 
-// --------------------------------------------------------
-//  FIND ENCRYPT KEY AND DECIDE CIPHER ALGORITHM
-//              Find the WPA key, either Group or Pairwise Key
-//              LEAP + TKIP also use WPA key.
-// --------------------------------------------------------
-// Decide WEP bit and cipher suite to be used. Same cipher suite should be used for whole fragment burst
-// In Cisco CCX 2.0 Leap Authentication
-//                 WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey
-//                 Instead of the SharedKey, SharedKey Length may be Zero.
+/* -------------------------------------------------------- */
+/*  FIND ENCRYPT KEY AND DECIDE CIPHER ALGORITHM */
+/*              Find the WPA key, either Group or Pairwise Key */
+/*              LEAP + TKIP also use WPA key. */
+/* -------------------------------------------------------- */
+/* Decide WEP bit and cipher suite to be used. Same cipher suite should be used for whole fragment burst */
+/* In Cisco CCX 2.0 Leap Authentication */
+/*                 WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey */
+/*                 Instead of the SharedKey, SharedKey Length may be Zero. */
 VOID STAFindCipherAlgorithm(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
-	NDIS_802_11_ENCRYPTION_STATUS Cipher;	// To indicate cipher used for this packet
-	UCHAR CipherAlg = CIPHER_NONE;	// cipher alogrithm
+	NDIS_802_11_ENCRYPTION_STATUS Cipher;	/* To indicate cipher used for this packet */
+	UCHAR CipherAlg = CIPHER_NONE;	/* cipher alogrithm */
 	UCHAR KeyIdx = 0xff;
 	PUCHAR pSrcBufVA;
 	PCIPHER_KEY pKey = NULL;
@@ -1378,17 +1378,17 @@ VOID STAFindCipherAlgorithm(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 	pSrcBufVA = GET_OS_PKT_DATAPTR(pTxBlk->pPacket);
 
 	{
-		// Select Cipher
+		/* Select Cipher */
 		if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))
-			Cipher = pAd->StaCfg.GroupCipher;	// Cipher for Multicast or Broadcast
+			Cipher = pAd->StaCfg.GroupCipher;	/* Cipher for Multicast or Broadcast */
 		else
-			Cipher = pAd->StaCfg.PairCipher;	// Cipher for Unicast
+			Cipher = pAd->StaCfg.PairCipher;	/* Cipher for Unicast */
 
 		if (RTMP_GET_PACKET_EAPOL(pTxBlk->pPacket)) {
 			ASSERT(pAd->SharedKey[BSS0][0].CipherAlg <=
 			       CIPHER_CKIP128);
 
-			// 4-way handshaking frame must be clear
+			/* 4-way handshaking frame must be clear */
 			if (!(TX_BLK_TEST_FLAG(pTxBlk, fTX_bClearEAPFrame))
 			    && (pAd->SharedKey[BSS0][0].CipherAlg)
 			    && (pAd->SharedKey[BSS0][0].KeyLen)) {
@@ -1399,7 +1399,7 @@ VOID STAFindCipherAlgorithm(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			KeyIdx = pAd->StaCfg.DefaultKeyId;
 		} else if ((Cipher == Ndis802_11Encryption2Enabled) ||
 			   (Cipher == Ndis802_11Encryption3Enabled)) {
-			if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))	// multicast
+			if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))	/* multicast */
 				KeyIdx = pAd->StaCfg.DefaultKeyId;
 			else if (pAd->SharedKey[BSS0][0].KeyLen)
 				KeyIdx = 0;
@@ -1419,7 +1419,7 @@ VOID STAFindCipherAlgorithm(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			  WPA_802_1X_PORT_NOT_SECURED))
 			CipherAlg = CIPHER_NONE;
 		else {
-			//Header_802_11.FC.Wep = 1;
+			/*Header_802_11.FC.Wep = 1; */
 			CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
 			pKey = &pAd->SharedKey[BSS0][KeyIdx];
 		}
@@ -1433,11 +1433,11 @@ VOID STABuildCommon802_11Header(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
 	HEADER_802_11 *pHeader_802_11;
 
-	//
-	// MAKE A COMMON 802.11 HEADER
-	//
+	/* */
+	/* MAKE A COMMON 802.11 HEADER */
+	/* */
 
-	// normal wlan header size : 24 octets
+	/* normal wlan header size : 24 octets */
 	pTxBlk->MpduHeaderLen = sizeof(HEADER_802_11);
 
 	pHeader_802_11 =
@@ -1469,7 +1469,7 @@ VOID STABuildCommon802_11Header(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 		}
 	} else {
 		pHeader_802_11->Sequence = pAd->Sequence;
-		pAd->Sequence = (pAd->Sequence + 1) & MAXSEQ;	// next sequence
+		pAd->Sequence = (pAd->Sequence + 1) & MAXSEQ;	/* next sequence */
 	}
 
 	pHeader_802_11->Frag = 0;
@@ -1501,9 +1501,9 @@ VOID STABuildCommon802_11Header(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 	if (pTxBlk->CipherAlg != CIPHER_NONE)
 		pHeader_802_11->FC.Wep = 1;
 
-	// -----------------------------------------------------------------
-	// STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later.
-	// -----------------------------------------------------------------
+	/* ----------------------------------------------------------------- */
+	/* STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later. */
+	/* ----------------------------------------------------------------- */
 	if (pAd->CommonCfg.bAPSDForcePowerSave)
 		pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
 	else
@@ -1519,26 +1519,26 @@ VOID STABuildCache802_11Header(IN RTMP_ADAPTER * pAd,
 	pHeader80211 = (PHEADER_802_11) pHeader;
 	pMacEntry = pTxBlk->pMacEntry;
 
-	//
-	// Update the cached 802.11 HEADER
-	//
+	/* */
+	/* Update the cached 802.11 HEADER */
+	/* */
 
-	// normal wlan header size : 24 octets
+	/* normal wlan header size : 24 octets */
 	pTxBlk->MpduHeaderLen = sizeof(HEADER_802_11);
 
-	// More Bit
+	/* More Bit */
 	pHeader80211->FC.MoreData = TX_BLK_TEST_FLAG(pTxBlk, fTX_bMoreData);
 
-	// Sequence
+	/* Sequence */
 	pHeader80211->Sequence = pMacEntry->TxSeq[pTxBlk->UserPriority];
 	pMacEntry->TxSeq[pTxBlk->UserPriority] =
 	    (pMacEntry->TxSeq[pTxBlk->UserPriority] + 1) & MAXSEQ;
 
 	{
-		// Check if the frame can be sent through DLS direct link interface
-		// If packet can be sent through DLS, then force aggregation disable. (Hard to determine peer STA's capability)
+		/* Check if the frame can be sent through DLS direct link interface */
+		/* If packet can be sent through DLS, then force aggregation disable. (Hard to determine peer STA's capability) */
 
-		// The addr3 of normal packet send from DS is Dest Mac address.
+		/* The addr3 of normal packet send from DS is Dest Mac address. */
 		if (ADHOC_ON(pAd))
 			COPY_MAC_ADDR(pHeader80211->Addr3,
 				      pAd->CommonCfg.Bssid);
@@ -1547,9 +1547,9 @@ VOID STABuildCache802_11Header(IN RTMP_ADAPTER * pAd,
 				      pTxBlk->pSrcBufHeader);
 	}
 
-	// -----------------------------------------------------------------
-	// STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later.
-	// -----------------------------------------------------------------
+	/* ----------------------------------------------------------------- */
+	/* STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later. */
+	/* ----------------------------------------------------------------- */
 	if (pAd->CommonCfg.bAPSDForcePowerSave)
 		pHeader80211->FC.PwrMgmt = PWR_SAVE;
 	else
@@ -1571,29 +1571,29 @@ static inline PUCHAR STA_Build_ARalink_Frame_Header(IN RTMP_ADAPTER * pAd,
 	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
 	pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
-	// steal "order" bit to mark "aggregation"
+	/* steal "order" bit to mark "aggregation" */
 	pHeader_802_11->FC.Order = 1;
 
-	// skip common header
+	/* skip common header */
 	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
 	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
-		//
-		// build QOS Control bytes
-		//
+		/* */
+		/* build QOS Control bytes */
+		/* */
 		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
 
 		*(pHeaderBufPtr + 1) = 0;
 		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 	}
-	// padding at front of LLC header. LLC header should at 4-bytes aligment.
+	/* padding at front of LLC header. LLC header should at 4-bytes aligment. */
 	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
 	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
-	// For RA Aggregation,
-	// put the 2nd MSDU length(extra 2-byte field) after QOS_CONTROL in little endian format
+	/* For RA Aggregation, */
+	/* put the 2nd MSDU length(extra 2-byte field) after QOS_CONTROL in little endian format */
 	pQEntry = pTxBlk->TxPacketList.Head;
 	pNextPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
 	nextBufLen = GET_OS_PKT_LEN(pNextPacket);
@@ -1613,7 +1613,7 @@ static inline PUCHAR STA_Build_ARalink_Frame_Header(IN RTMP_ADAPTER * pAd,
 static inline PUCHAR STA_Build_AMSDU_Frame_Header(IN RTMP_ADAPTER * pAd,
 						  IN TX_BLK * pTxBlk)
 {
-	PUCHAR pHeaderBufPtr;	//, pSaveBufPtr;
+	PUCHAR pHeaderBufPtr;	/*, pSaveBufPtr; */
 	HEADER_802_11 *pHeader_802_11;
 
 	STAFindCipherAlgorithm(pAd, pTxBlk);
@@ -1622,31 +1622,31 @@ static inline PUCHAR STA_Build_AMSDU_Frame_Header(IN RTMP_ADAPTER * pAd,
 	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
 	pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
-	// skip common header
+	/* skip common header */
 	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
-	//
-	// build QOS Control bytes
-	//
+	/* */
+	/* build QOS Control bytes */
+	/* */
 	*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
 
-	//
-	// A-MSDU packet
-	//
+	/* */
+	/* A-MSDU packet */
+	/* */
 	*pHeaderBufPtr |= 0x80;
 
 	*(pHeaderBufPtr + 1) = 0;
 	pHeaderBufPtr += 2;
 	pTxBlk->MpduHeaderLen += 2;
 
-	//pSaveBufPtr = pHeaderBufPtr;
+	/*pSaveBufPtr = pHeaderBufPtr; */
 
-	//
-	// padding at front of LLC header
-	// LLC header should locate at 4-octets aligment
-	//
-	// @@@ MpduHeaderLen excluding padding @@@
-	//
+	/* */
+	/* padding at front of LLC header */
+	/* LLC header should locate at 4-octets aligment */
+	/* */
+	/* @@@ MpduHeaderLen excluding padding @@@ */
+	/* */
 	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
 	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
@@ -1680,7 +1680,7 @@ VOID STA_AMPDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 
 		pMacEntry = pTxBlk->pMacEntry;
 		if (pMacEntry->isCached) {
-			// NOTE: Please make sure the size of pMacEntry->CachedBuf[] is smaller than pTxBlk->HeaderBuf[]!!!!
+			/* NOTE: Please make sure the size of pMacEntry->CachedBuf[] is smaller than pTxBlk->HeaderBuf[]!!!! */
 			NdisMoveMemory((PUCHAR) & pTxBlk->
 				       HeaderBuf[TXINFO_SIZE],
 				       (PUCHAR) & pMacEntry->CachedBuf[0],
@@ -1699,26 +1699,26 @@ VOID STA_AMPDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 
 		pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
-		// skip common header
+		/* skip common header */
 		pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
-		//
-		// build QOS Control bytes
-		//
+		/* */
+		/* build QOS Control bytes */
+		/* */
 		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
 		*(pHeaderBufPtr + 1) = 0;
 		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 
-		//
-		// build HTC+
-		// HTC control filed following QoS field
-		//
+		/* */
+		/* build HTC+ */
+		/* HTC control filed following QoS field */
+		/* */
 		if ((pAd->CommonCfg.bRdg == TRUE)
 		    && CLIENT_STATUS_TEST_FLAG(pTxBlk->pMacEntry,
 					       fCLIENT_STATUS_RDG_CAPABLE)) {
 			if (pMacEntry->isCached == FALSE) {
-				// mark HTC bit
+				/* mark HTC bit */
 				pHeader_802_11->FC.Order = 1;
 
 				NdisZeroMemory(pHeaderBufPtr, 4);
@@ -1727,33 +1727,33 @@ VOID STA_AMPDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			pHeaderBufPtr += 4;
 			pTxBlk->MpduHeaderLen += 4;
 		}
-		//pTxBlk->MpduHeaderLen = pHeaderBufPtr - pTxBlk->HeaderBuf - TXWI_SIZE - TXINFO_SIZE;
+		/*pTxBlk->MpduHeaderLen = pHeaderBufPtr - pTxBlk->HeaderBuf - TXWI_SIZE - TXINFO_SIZE; */
 		ASSERT(pTxBlk->MpduHeaderLen >= 24);
 
-		// skip 802.3 header
+		/* skip 802.3 header */
 		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
 		pTxBlk->SrcBufLen -= LENGTH_802_3;
 
-		// skip vlan tag
+		/* skip vlan tag */
 		if (bVLANPkt) {
 			pTxBlk->pSrcBufData += LENGTH_802_1Q;
 			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
 		}
-		//
-		// padding at front of LLC header
-		// LLC header should locate at 4-octets aligment
-		//
-		// @@@ MpduHeaderLen excluding padding @@@
-		//
+		/* */
+		/* padding at front of LLC header */
+		/* LLC header should locate at 4-octets aligment */
+		/* */
+		/* @@@ MpduHeaderLen excluding padding @@@ */
+		/* */
 		pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 		pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
 		pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
 		{
 
-			//
-			// Insert LLC-SNAP encapsulation - 8 octets
-			//
+			/* */
+			/* Insert LLC-SNAP encapsulation - 8 octets */
+			/* */
 			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->
 							    pSrcBufData - 2,
 							    pTxBlk->
@@ -1762,7 +1762,7 @@ VOID STA_AMPDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 				NdisMoveMemory(pHeaderBufPtr,
 					       pTxBlk->pExtraLlcSnapEncap, 6);
 				pHeaderBufPtr += 6;
-				// get 2 octets (TypeofLen)
+				/* get 2 octets (TypeofLen) */
 				NdisMoveMemory(pHeaderBufPtr,
 					       pTxBlk->pSrcBufData - 2, 2);
 				pHeaderBufPtr += 2;
@@ -1795,7 +1795,7 @@ VOID STA_AMPDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			pMacEntry->isCached = TRUE;
 		}
 
-		// calculate Transmitted AMPDU count and ByteCount
+		/* calculate Transmitted AMPDU count and ByteCount */
 		{
 			pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.
 			    LowPart++;
@@ -1803,13 +1803,13 @@ VOID STA_AMPDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			    QuadPart += pTxBlk->SrcBufLen;
 		}
 
-		//FreeNumber = GET_TXRING_FREENO(pAd, QueIdx);
+		/*FreeNumber = GET_TXRING_FREENO(pAd, QueIdx); */
 
 		HAL_WriteTxResource(pAd, pTxBlk, TRUE, &FreeNumber);
 
-		//
-		// Kick out Tx
-		//
+		/* */
+		/* Kick out Tx */
+		/* */
 		if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
 			HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 
@@ -1823,7 +1823,7 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
 	PUCHAR pHeaderBufPtr;
 	USHORT FreeNumber;
-	USHORT subFramePayloadLen = 0;	// AMSDU Subframe length without AMSDU-Header / Padding.
+	USHORT subFramePayloadLen = 0;	/* AMSDU Subframe length without AMSDU-Header / Padding. */
 	USHORT totalMPDUSize = 0;
 	UCHAR *subFrameHeader;
 	UCHAR padding = 0;
@@ -1848,11 +1848,11 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 		bVLANPkt =
 		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
 
-		// skip 802.3 header
+		/* skip 802.3 header */
 		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
 		pTxBlk->SrcBufLen -= LENGTH_802_3;
 
-		// skip vlan tag
+		/* skip vlan tag */
 		if (bVLANPkt) {
 			pTxBlk->pSrcBufData += LENGTH_802_1Q;
 			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
@@ -1862,7 +1862,7 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			pHeaderBufPtr =
 			    STA_Build_AMSDU_Frame_Header(pAd, pTxBlk);
 
-			// NOTE: TxWI->MPDUtotalByteCount will be updated after final frame was handled.
+			/* NOTE: TxWI->MPDUtotalByteCount will be updated after final frame was handled. */
 			RTMPWriteTxWI_Data(pAd,
 					   (PTXWI_STRUC) (&pTxBlk->
 							  HeaderBuf
@@ -1881,10 +1881,10 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			pTxBlk->MpduHeaderLen = padding;
 		}
 
-		//
-		// A-MSDU subframe
-		//   DA(6)+SA(6)+Length(2) + LLC/SNAP Encap
-		//
+		/* */
+		/* A-MSDU subframe */
+		/*   DA(6)+SA(6)+Length(2) + LLC/SNAP Encap */
+		/* */
 		subFrameHeader = pHeaderBufPtr;
 		subFramePayloadLen = pTxBlk->SrcBufLen;
 
@@ -1893,9 +1893,9 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 		pHeaderBufPtr += LENGTH_AMSDU_SUBFRAMEHEAD;
 		pTxBlk->MpduHeaderLen += LENGTH_AMSDU_SUBFRAMEHEAD;
 
-		//
-		// Insert LLC-SNAP encapsulation - 8 octets
-		//
+		/* */
+		/* Insert LLC-SNAP encapsulation - 8 octets */
+		/* */
 		EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->pSrcBufData - 2,
 						    pTxBlk->pExtraLlcSnapEncap);
 
@@ -1905,14 +1905,14 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			NdisMoveMemory(pHeaderBufPtr,
 				       pTxBlk->pExtraLlcSnapEncap, 6);
 			pHeaderBufPtr += 6;
-			// get 2 octets (TypeofLen)
+			/* get 2 octets (TypeofLen) */
 			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData - 2,
 				       2);
 			pHeaderBufPtr += 2;
 			pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 			subFramePayloadLen += LENGTH_802_1_H;
 		}
-		// update subFrame Length field
+		/* update subFrame Length field */
 		subFrameHeader[12] = (subFramePayloadLen & 0xFF00) >> 8;
 		subFrameHeader[13] = subFramePayloadLen & 0xFF;
 
@@ -1932,7 +1932,7 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 		pAd->RalinkCounters.KickTxCount++;
 		pAd->RalinkCounters.OneSecTxDoneCount++;
 
-		// calculate Transmitted AMSDU Count and ByteCount
+		/* calculate Transmitted AMSDU Count and ByteCount */
 		{
 			pAd->RalinkCounters.TransmittedAMSDUCount.u.LowPart++;
 			pAd->RalinkCounters.TransmittedOctetsInAMSDU.QuadPart +=
@@ -1944,9 +1944,9 @@ VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 	HAL_FinalWriteTxResource(pAd, pTxBlk, totalMPDUSize, FirstTx);
 	HAL_LastTxIdx(pAd, pTxBlk->QueIdx, LastTxIdx);
 
-	//
-	// Kick out Tx
-	//
+	/* */
+	/* Kick out Tx */
+	/* */
 	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
 		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 }
@@ -1985,11 +1985,11 @@ VOID STA_Legacy_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 	STAFindCipherAlgorithm(pAd, pTxBlk);
 	STABuildCommon802_11Header(pAd, pTxBlk);
 
-	// skip 802.3 header
+	/* skip 802.3 header */
 	pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
 	pTxBlk->SrcBufLen -= LENGTH_802_3;
 
-	// skip vlan tag
+	/* skip vlan tag */
 	if (bVLANPkt) {
 		pTxBlk->pSrcBufData += LENGTH_802_1Q;
 		pTxBlk->SrcBufLen -= LENGTH_802_1Q;
@@ -1998,13 +1998,13 @@ VOID STA_Legacy_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
 	pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
-	// skip common header
+	/* skip common header */
 	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
 	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
-		//
-		// build QOS Control bytes
-		//
+		/* */
+		/* build QOS Control bytes */
+		/* */
 		*(pHeaderBufPtr) =
 		    ((pTxBlk->UserPriority & 0x0F) | (pAd->CommonCfg.
 						      AckPolicy[pTxBlk->
@@ -2013,20 +2013,20 @@ VOID STA_Legacy_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 	}
-	// The remaining content of MPDU header should locate at 4-octets aligment
+	/* The remaining content of MPDU header should locate at 4-octets aligment */
 	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
 	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
 	{
 
-		//
-		// Insert LLC-SNAP encapsulation - 8 octets
-		//
-		//
-		// if original Ethernet frame contains no LLC/SNAP,
-		// then an extra LLC/SNAP encap is required
-		//
+		/* */
+		/* Insert LLC-SNAP encapsulation - 8 octets */
+		/* */
+		/* */
+		/* if original Ethernet frame contains no LLC/SNAP, */
+		/* then an extra LLC/SNAP encap is required */
+		/* */
 		EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader,
 						   pTxBlk->pExtraLlcSnapEncap);
 		if (pTxBlk->pExtraLlcSnapEncap) {
@@ -2035,9 +2035,9 @@ VOID STA_Legacy_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 			NdisMoveMemory(pHeaderBufPtr,
 				       pTxBlk->pExtraLlcSnapEncap, 6);
 			pHeaderBufPtr += 6;
-			// skip vlan tag
+			/* skip vlan tag */
 			vlan_size = (bVLANPkt) ? LENGTH_802_1Q : 0;
-			// get 2 octets (TypeofLen)
+			/* get 2 octets (TypeofLen) */
 			NdisMoveMemory(pHeaderBufPtr,
 				       pTxBlk->pSrcBufHeader + 12 + vlan_size,
 				       2);
@@ -2047,24 +2047,24 @@ VOID STA_Legacy_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 
 	}
 
-	//
-	// prepare for TXWI
-	// use Wcid as Key Index
-	//
+	/* */
+	/* prepare for TXWI */
+	/* use Wcid as Key Index */
+	/* */
 
 	RTMPWriteTxWI_Data(pAd, (PTXWI_STRUC) (&pTxBlk->HeaderBuf[TXINFO_SIZE]),
 			   pTxBlk);
 
-	//FreeNumber = GET_TXRING_FREENO(pAd, QueIdx);
+	/*FreeNumber = GET_TXRING_FREENO(pAd, QueIdx); */
 
 	HAL_WriteTxResource(pAd, pTxBlk, TRUE, &FreeNumber);
 
 	pAd->RalinkCounters.KickTxCount++;
 	pAd->RalinkCounters.OneSecTxDoneCount++;
 
-	//
-	// Kick out Tx
-	//
+	/* */
+	/* Kick out Tx */
+	/* */
 	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
 		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 }
@@ -2083,7 +2083,7 @@ VOID STA_ARalink_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 
 	ASSERT((pTxBlk->TxPacketList.Number == 2));
 
-	FirstTx = LastTxIdx = 0;	// Is it ok init they as 0?
+	FirstTx = LastTxIdx = 0;	/* Is it ok init they as 0? */
 	while (pTxBlk->TxPacketList.Head) {
 		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
 		pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
@@ -2097,32 +2097,32 @@ VOID STA_ARalink_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 		bVLANPkt =
 		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
 
-		// skip 802.3 header
+		/* skip 802.3 header */
 		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
 		pTxBlk->SrcBufLen -= LENGTH_802_3;
 
-		// skip vlan tag
+		/* skip vlan tag */
 		if (bVLANPkt) {
 			pTxBlk->pSrcBufData += LENGTH_802_1Q;
 			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
 		}
 
-		if (frameNum == 0) {	// For first frame, we need to create the 802.11 header + padding(optional) + RA-AGG-LEN + SNAP Header
+		if (frameNum == 0) {	/* For first frame, we need to create the 802.11 header + padding(optional) + RA-AGG-LEN + SNAP Header */
 
 			pHeaderBufPtr =
 			    STA_Build_ARalink_Frame_Header(pAd, pTxBlk);
 
-			// It's ok write the TxWI here, because the TxWI->MPDUtotalByteCount
-			//      will be updated after final frame was handled.
+			/* It's ok write the TxWI here, because the TxWI->MPDUtotalByteCount */
+			/*      will be updated after final frame was handled. */
 			RTMPWriteTxWI_Data(pAd,
 					   (PTXWI_STRUC) (&pTxBlk->
 							  HeaderBuf
 							  [TXINFO_SIZE]),
 					   pTxBlk);
 
-			//
-			// Insert LLC-SNAP encapsulation - 8 octets
-			//
+			/* */
+			/* Insert LLC-SNAP encapsulation - 8 octets */
+			/* */
 			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->
 							    pSrcBufData - 2,
 							    pTxBlk->
@@ -2132,23 +2132,23 @@ VOID STA_ARalink_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 				NdisMoveMemory(pHeaderBufPtr,
 					       pTxBlk->pExtraLlcSnapEncap, 6);
 				pHeaderBufPtr += 6;
-				// get 2 octets (TypeofLen)
+				/* get 2 octets (TypeofLen) */
 				NdisMoveMemory(pHeaderBufPtr,
 					       pTxBlk->pSrcBufData - 2, 2);
 				pHeaderBufPtr += 2;
 				pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 			}
-		} else {	// For second aggregated frame, we need create the 802.3 header to headerBuf, because PCI will copy it to SDPtr0.
+		} else {	/* For second aggregated frame, we need create the 802.3 header to headerBuf, because PCI will copy it to SDPtr0. */
 
 			pHeaderBufPtr = &pTxBlk->HeaderBuf[0];
 			pTxBlk->MpduHeaderLen = 0;
 
-			// A-Ralink sub-sequent frame header is the same as 802.3 header.
-			//   DA(6)+SA(6)+FrameType(2)
+			/* A-Ralink sub-sequent frame header is the same as 802.3 header. */
+			/*   DA(6)+SA(6)+FrameType(2) */
 			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufHeader,
 				       12);
 			pHeaderBufPtr += 12;
-			// get 2 octets (TypeofLen)
+			/* get 2 octets (TypeofLen) */
 			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData - 2,
 				       2);
 			pHeaderBufPtr += 2;
@@ -2157,7 +2157,7 @@ VOID STA_ARalink_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 
 		totalMPDUSize += pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
 
-		//FreeNumber = GET_TXRING_FREENO(pAd, QueIdx);
+		/*FreeNumber = GET_TXRING_FREENO(pAd, QueIdx); */
 		if (frameNum == 0)
 			FirstTx =
 			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
@@ -2178,9 +2178,9 @@ VOID STA_ARalink_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 	HAL_FinalWriteTxResource(pAd, pTxBlk, totalMPDUSize, FirstTx);
 	HAL_LastTxIdx(pAd, pTxBlk->QueIdx, LastTxIdx);
 
-	//
-	// Kick out Tx
-	//
+	/* */
+	/* Kick out Tx */
+	/* */
 	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
 		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 
@@ -2225,11 +2225,11 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 				     &pTxBlk->pSrcBufHeader,
 				     &pTxBlk->SrcBufLen);
 	}
-	// skip 802.3 header
+	/* skip 802.3 header */
 	pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
 	pTxBlk->SrcBufLen -= LENGTH_802_3;
 
-	// skip vlan tag
+	/* skip vlan tag */
 	if (bVLANPkt) {
 		pTxBlk->pSrcBufData += LENGTH_802_1Q;
 		pTxBlk->SrcBufLen -= LENGTH_802_1Q;
@@ -2238,34 +2238,34 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
 	pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
-	// skip common header
+	/* skip common header */
 	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
 	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
-		//
-		// build QOS Control bytes
-		//
+		/* */
+		/* build QOS Control bytes */
+		/* */
 		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
 
 		*(pHeaderBufPtr + 1) = 0;
 		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 	}
-	//
-	// padding at front of LLC header
-	// LLC header should locate at 4-octets aligment
-	//
+	/* */
+	/* padding at front of LLC header */
+	/* LLC header should locate at 4-octets aligment */
+	/* */
 	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
 	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
-	//
-	// Insert LLC-SNAP encapsulation - 8 octets
-	//
-	//
-	// if original Ethernet frame contains no LLC/SNAP,
-	// then an extra LLC/SNAP encap is required
-	//
+	/* */
+	/* Insert LLC-SNAP encapsulation - 8 octets */
+	/* */
+	/* */
+	/* if original Ethernet frame contains no LLC/SNAP, */
+	/* then an extra LLC/SNAP encap is required */
+	/* */
 	EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader,
 					   pTxBlk->pExtraLlcSnapEncap);
 	if (pTxBlk->pExtraLlcSnapEncap) {
@@ -2273,50 +2273,50 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 
 		NdisMoveMemory(pHeaderBufPtr, pTxBlk->pExtraLlcSnapEncap, 6);
 		pHeaderBufPtr += 6;
-		// skip vlan tag
+		/* skip vlan tag */
 		vlan_size = (bVLANPkt) ? LENGTH_802_1Q : 0;
-		// get 2 octets (TypeofLen)
+		/* get 2 octets (TypeofLen) */
 		NdisMoveMemory(pHeaderBufPtr,
 			       pTxBlk->pSrcBufHeader + 12 + vlan_size, 2);
 		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 	}
 
-	// If TKIP is used and fragmentation is required. Driver has to
-	//      append TKIP MIC at tail of the scatter buffer
-	//      MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC
+	/* If TKIP is used and fragmentation is required. Driver has to */
+	/*      append TKIP MIC at tail of the scatter buffer */
+	/*      MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC */
 	if (pTxBlk->CipherAlg == CIPHER_TKIP) {
 		RTMPCalculateMICValue(pAd, pTxBlk->pPacket,
 				      pTxBlk->pExtraLlcSnapEncap, pTxBlk->pKey,
 				      0);
 
-		// NOTE: DON'T refer the skb->len directly after following copy. Becasue the length is not adjust
-		//                      to correct lenght, refer to pTxBlk->SrcBufLen for the packet length in following progress.
+		/* NOTE: DON'T refer the skb->len directly after following copy. Becasue the length is not adjust */
+		/*                      to correct lenght, refer to pTxBlk->SrcBufLen for the packet length in following progress. */
 		NdisMoveMemory(pTxBlk->pSrcBufData + pTxBlk->SrcBufLen,
 			       &pAd->PrivateInfo.Tx.MIC[0], 8);
-		//skb_put((RTPKT_TO_OSPKT(pTxBlk->pPacket))->tail, 8);
+		/*skb_put((RTPKT_TO_OSPKT(pTxBlk->pPacket))->tail, 8); */
 		pTxBlk->SrcBufLen += 8;
 		pTxBlk->TotalFrameLen += 8;
 		pTxBlk->CipherAlg = CIPHER_TKIP_NO_MIC;
 	}
-	//
-	// calcuate the overhead bytes that encryption algorithm may add. This
-	// affects the calculate of "duration" field
-	//
+	/* */
+	/* calcuate the overhead bytes that encryption algorithm may add. This */
+	/* affects the calculate of "duration" field */
+	/* */
 	if ((pTxBlk->CipherAlg == CIPHER_WEP64)
 	    || (pTxBlk->CipherAlg == CIPHER_WEP128))
-		EncryptionOverhead = 8;	//WEP: IV[4] + ICV[4];
+		EncryptionOverhead = 8;	/*WEP: IV[4] + ICV[4]; */
 	else if (pTxBlk->CipherAlg == CIPHER_TKIP_NO_MIC)
-		EncryptionOverhead = 12;	//TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength
+		EncryptionOverhead = 12;	/*TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength */
 	else if (pTxBlk->CipherAlg == CIPHER_TKIP)
-		EncryptionOverhead = 20;	//TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8]
+		EncryptionOverhead = 20;	/*TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8] */
 	else if (pTxBlk->CipherAlg == CIPHER_AES)
-		EncryptionOverhead = 16;	// AES: IV[4] + EIV[4] + MIC[8]
+		EncryptionOverhead = 16;	/* AES: IV[4] + EIV[4] + MIC[8] */
 	else
 		EncryptionOverhead = 0;
 
 	pTransmit = pTxBlk->pTransmit;
-	// Decide the TX rate
+	/* Decide the TX rate */
 	if (pTransmit->field.MODE == MODE_CCK)
 		pTxBlk->TxRate = pTransmit->field.MCS;
 	else if (pTransmit->field.MODE == MODE_OFDM)
@@ -2324,7 +2324,7 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 	else
 		pTxBlk->TxRate = RATE_6_5;
 
-	// decide how much time an ACK/CTS frame will consume in the air
+	/* decide how much time an ACK/CTS frame will consume in the air */
 	if (pTxBlk->TxRate <= RATE_LAST_OFDM_RATE)
 		AckDuration =
 		    RTMPCalcDuration(pAd,
@@ -2334,7 +2334,7 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 	else
 		AckDuration = RTMPCalcDuration(pAd, RATE_6_5, 14);
 
-	// Init the total payload length of this frame.
+	/* Init the total payload length of this frame. */
 	SrcRemainingBytes = pTxBlk->SrcBufLen;
 
 	pTxBlk->TotalFragNum = 0xff;
@@ -2345,7 +2345,7 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 
 		FreeMpduSize -= pTxBlk->MpduHeaderLen;
 
-		if (SrcRemainingBytes <= FreeMpduSize) {	// this is the last or only fragment
+		if (SrcRemainingBytes <= FreeMpduSize) {	/* this is the last or only fragment */
 
 			pTxBlk->SrcBufLen = SrcRemainingBytes;
 
@@ -2353,9 +2353,9 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 			pHeader_802_11->Duration =
 			    pAd->CommonCfg.Dsifs + AckDuration;
 
-			// Indicate the lower layer that this's the last fragment.
+			/* Indicate the lower layer that this's the last fragment. */
 			pTxBlk->TotalFragNum = fragNum;
-		} else {	// more fragment is required
+		} else {	/* more fragment is required */
 
 			pTxBlk->SrcBufLen = FreeMpduSize;
 
@@ -2384,9 +2384,9 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 		pAd->RalinkCounters.KickTxCount++;
 		pAd->RalinkCounters.OneSecTxDoneCount++;
 
-		// Update the frame number, remaining size of the NDIS packet payload.
+		/* Update the frame number, remaining size of the NDIS packet payload. */
 
-		// space for 802.11 header.
+		/* space for 802.11 header. */
 		if (fragNum == 0 && pTxBlk->pExtraLlcSnapEncap)
 			pTxBlk->MpduHeaderLen -= LENGTH_802_1_H;
 
@@ -2394,13 +2394,13 @@ VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 		SrcRemainingBytes -= pTxBlk->SrcBufLen;
 		pTxBlk->pSrcBufData += pTxBlk->SrcBufLen;
 
-		pHeader_802_11->Frag++;	// increase Frag #
+		pHeader_802_11->Frag++;	/* increase Frag # */
 
 	} while (SrcRemainingBytes > 0);
 
-	//
-	// Kick out Tx
-	//
+	/* */
+	/* Kick out Tx */
+	/* */
 	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
 		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 }
@@ -2440,10 +2440,10 @@ NDIS_STATUS STAHardTransmit(IN PRTMP_ADAPTER pAd,
 	NDIS_PACKET *pPacket;
 	PQUEUE_ENTRY pQEntry;
 
-	// ---------------------------------------------
-	// STEP 0. DO SANITY CHECK AND SOME EARLY PREPARATION.
-	// ---------------------------------------------
-	//
+	/* --------------------------------------------- */
+	/* STEP 0. DO SANITY CHECK AND SOME EARLY PREPARATION. */
+	/* --------------------------------------------- */
+	/* */
 	ASSERT(pTxBlk->TxPacketList.Number);
 	if (pTxBlk->TxPacketList.Head == NULL) {
 		DBGPRINT(RT_DEBUG_ERROR,
@@ -2454,23 +2454,23 @@ NDIS_STATUS STAHardTransmit(IN PRTMP_ADAPTER pAd,
 
 	pPacket = QUEUE_ENTRY_TO_PACKET(pTxBlk->TxPacketList.Head);
 
-	// ------------------------------------------------------------------
-	// STEP 1. WAKE UP PHY
-	//              outgoing frame always wakeup PHY to prevent frame lost and
-	//              turn off PSM bit to improve performance
-	// ------------------------------------------------------------------
-	// not to change PSM bit, just send this frame out?
+	/* ------------------------------------------------------------------ */
+	/* STEP 1. WAKE UP PHY */
+	/*              outgoing frame always wakeup PHY to prevent frame lost and */
+	/*              turn off PSM bit to improve performance */
+	/* ------------------------------------------------------------------ */
+	/* not to change PSM bit, just send this frame out? */
 	if ((pAd->StaCfg.Psm == PWR_SAVE)
 	    && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
 		DBGPRINT_RAW(RT_DEBUG_INFO, ("AsicForceWakeup At HardTx\n"));
 #ifdef RTMP_MAC_PCI
 		AsicForceWakeup(pAd, TRUE);
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 #ifdef RTMP_MAC_USB
 		RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_FORCE_WAKE_UP, NULL, 0);
-#endif // RTMP_MAC_USB //
+#endif /* RTMP_MAC_USB // */
 	}
-	// It should not change PSM bit, when APSD turn on.
+	/* It should not change PSM bit, when APSD turn on. */
 	if ((!
 	     (pAd->CommonCfg.bAPSDCapable
 	      && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
@@ -2504,7 +2504,7 @@ NDIS_STATUS STAHardTransmit(IN PRTMP_ADAPTER pAd,
 		break;
 	default:
 		{
-			// It should not happened!
+			/* It should not happened! */
 			DBGPRINT(RT_DEBUG_ERROR,
 				 ("Send a pacekt was not classified!! It should not happen!\n"));
 			while (pTxBlk->TxPacketList.Number) {
@@ -2544,7 +2544,7 @@ VOID Sta_Announce_or_Forward_802_3_Packet(IN PRTMP_ADAPTER pAd,
 	if (TRUE) {
 		announce_802_3_packet(pAd, pPacket);
 	} else {
-		// release packet
+		/* release packet */
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 	}
 }
diff --git a/drivers/staging/rt2860/sta/sanity.c b/drivers/staging/rt2860/sta/sanity.c
index 3986478..ba6eaf6 100644
--- a/drivers/staging/rt2860/sta/sanity.c
+++ b/drivers/staging/rt2860/sta/sanity.c
@@ -86,7 +86,7 @@ BOOLEAN MlmeStartReqSanity(IN PRTMP_ADAPTER pAd,
 
     ==========================================================================
  */
-BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen, OUT PUCHAR pAddr2, OUT USHORT * pCapabilityInfo, OUT USHORT * pStatus, OUT USHORT * pAid, OUT UCHAR SupRate[], OUT UCHAR * pSupRateLen, OUT UCHAR ExtRate[], OUT UCHAR * pExtRateLen, OUT HT_CAPABILITY_IE * pHtCapability, OUT ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen, OUT PUCHAR pAddr2, OUT USHORT * pCapabilityInfo, OUT USHORT * pStatus, OUT USHORT * pAid, OUT UCHAR SupRate[], OUT UCHAR * pSupRateLen, OUT UCHAR ExtRate[], OUT UCHAR * pExtRateLen, OUT HT_CAPABILITY_IE * pHtCapability, OUT ADD_HT_INFO_IE * pAddHtInfo,	/* AP might use this additional ht info IE */
 			   OUT UCHAR * pHtCapabilityLen,
 			   OUT UCHAR * pAddHtInfoLen,
 			   OUT UCHAR * pNewExtChannelOffset,
@@ -118,10 +118,10 @@ BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen
 	NdisMoveMemory(pAid, &pFrame->Octet[4], 2);
 	Length += 2;
 
-	// Aid already swaped byte order in RTMPFrameEndianChange() for big endian platform
-	*pAid = (*pAid) & 0x3fff;	// AID is low 14-bit
+	/* Aid already swaped byte order in RTMPFrameEndianChange() for big endian platform */
+	*pAid = (*pAid) & 0x3fff;	/* AID is low 14-bit */
 
-	// -- get supported rates from payload and advance the pointer
+	/* -- get supported rates from payload and advance the pointer */
 	IeType = pFrame->Octet[6];
 	*pSupRateLen = pFrame->Octet[7];
 	if ((IeType != IE_SUPP_RATES)
@@ -134,11 +134,11 @@ BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen
 
 	Length = Length + 2 + *pSupRateLen;
 
-	// many AP implement proprietary IEs in non-standard order, we'd better
-	// tolerate mis-ordered IEs to get best compatibility
+	/* many AP implement proprietary IEs in non-standard order, we'd better */
+	/* tolerate mis-ordered IEs to get best compatibility */
 	pEid = (PEID_STRUCT) & pFrame->Octet[8 + (*pSupRateLen)];
 
-	// get variable fields from payload and advance the pointer
+	/* get variable fields from payload and advance the pointer */
 	while ((Length + 2 + pEid->Len) <= MsgLen) {
 		switch (pEid->Eid) {
 		case IE_EXT_SUPP_RATES:
@@ -150,7 +150,7 @@ BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen
 
 		case IE_HT_CAP:
 		case IE_HT_CAP2:
-			if (pEid->Len >= SIZE_HT_CAP_IE)	//Note: allow extension.!!
+			if (pEid->Len >= SIZE_HT_CAP_IE)	/*Note: allow extension.!! */
 			{
 				NdisMoveMemory(pHtCapability, pEid->Octet,
 					       SIZE_HT_CAP_IE);
@@ -172,8 +172,8 @@ BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen
 		case IE_ADD_HT:
 		case IE_ADD_HT2:
 			if (pEid->Len >= sizeof(ADD_HT_INFO_IE)) {
-				// This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only
-				// copy first sizeof(ADD_HT_INFO_IE)
+				/* This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only */
+				/* copy first sizeof(ADD_HT_INFO_IE) */
 				NdisMoveMemory(pAddHtInfo, pEid->Octet,
 					       sizeof(ADD_HT_INFO_IE));
 
@@ -201,31 +201,31 @@ BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen
 			break;
 
 		case IE_VENDOR_SPECIFIC:
-			// handle WME PARAMTER ELEMENT
+			/* handle WME PARAMTER ELEMENT */
 			if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6)
 			    && (pEid->Len == 24)) {
 				PUCHAR ptr;
 				int i;
 
-				// parsing EDCA parameters
+				/* parsing EDCA parameters */
 				pEdcaParm->bValid = TRUE;
-				pEdcaParm->bQAck = FALSE;	// pEid->Octet[0] & 0x10;
-				pEdcaParm->bQueueRequest = FALSE;	// pEid->Octet[0] & 0x20;
-				pEdcaParm->bTxopRequest = FALSE;	// pEid->Octet[0] & 0x40;
-				//pEdcaParm->bMoreDataAck    = FALSE; // pEid->Octet[0] & 0x80;
+				pEdcaParm->bQAck = FALSE;	/* pEid->Octet[0] & 0x10; */
+				pEdcaParm->bQueueRequest = FALSE;	/* pEid->Octet[0] & 0x20; */
+				pEdcaParm->bTxopRequest = FALSE;	/* pEid->Octet[0] & 0x40; */
+				/*pEdcaParm->bMoreDataAck    = FALSE; // pEid->Octet[0] & 0x80; */
 				pEdcaParm->EdcaUpdateCount =
 				    pEid->Octet[6] & 0x0f;
 				pEdcaParm->bAPSDCapable =
 				    (pEid->Octet[6] & 0x80) ? 1 : 0;
 				ptr = (PUCHAR) & pEid->Octet[8];
 				for (i = 0; i < 4; i++) {
-					UCHAR aci = (*ptr & 0x60) >> 5;	// b5~6 is AC INDEX
-					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	// b5 is ACM
-					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	// b0~3 is AIFSN
-					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	// b0~4 is Cwmin
-					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	// b5~8 is Cwmax
-					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	// in unit of 32-us
-					ptr += 4;	// point to next AC
+					UCHAR aci = (*ptr & 0x60) >> 5;	/* b5~6 is AC INDEX */
+					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	/* b5 is ACM */
+					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	/* b0~3 is AIFSN */
+					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	/* b0~4 is Cwmin */
+					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	/* b5~8 is Cwmax */
+					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	/* in unit of 32-us */
+					ptr += 4;	/* point to next AC */
 				}
 			}
 			break;
@@ -280,7 +280,7 @@ BOOLEAN PeerProbeReqSanity(IN PRTMP_ADAPTER pAd,
 
 	Idx = *pSsidLen + 2;
 
-	// -- get supported rates from payload and advance the pointer
+	/* -- get supported rates from payload and advance the pointer */
 	IeType = pFrame->Octet[Idx];
 	RateLen = pFrame->Octet[Idx + 1];
 	if (IeType != IE_SUPP_RATES) {
@@ -319,15 +319,15 @@ BOOLEAN GetTimBit(IN CHAR * Ptr,
 	IdxPtr++;
 	*TimLen = *IdxPtr;
 
-	// get DTIM Count from TIM element
+	/* get DTIM Count from TIM element */
 	IdxPtr++;
 	*DtimCount = *IdxPtr;
 
-	// get DTIM Period from TIM element
+	/* get DTIM Period from TIM element */
 	IdxPtr++;
 	*DtimPeriod = *IdxPtr;
 
-	// get Bitmap Control from TIM element
+	/* get Bitmap Control from TIM element */
 	IdxPtr++;
 	BitCntl = *IdxPtr;
 
@@ -336,20 +336,20 @@ BOOLEAN GetTimBit(IN CHAR * Ptr,
 	else
 		*BcastFlag = FALSE;
 
-	// Parse Partial Virtual Bitmap from TIM element
-	N1 = BitCntl & 0xfe;	// N1 is the first bitmap byte#
-	N2 = *TimLen - 4 + N1;	// N2 is the last bitmap byte#
+	/* Parse Partial Virtual Bitmap from TIM element */
+	N1 = BitCntl & 0xfe;	/* N1 is the first bitmap byte# */
+	N2 = *TimLen - 4 + N1;	/* N2 is the last bitmap byte# */
 
 	if ((Aid < (N1 << 3)) || (Aid >= ((N2 + 1) << 3)))
 		*MessageToMe = FALSE;
 	else {
-		MyByte = (Aid >> 3) - N1;	// my byte position in the bitmap byte-stream
+		MyByte = (Aid >> 3) - N1;	/* my byte position in the bitmap byte-stream */
 		MyBit = Aid % 16 - ((MyByte & 0x01) ? 8 : 0);
 
 		IdxPtr += (MyByte + 1);
 
-		//if (*IdxPtr)
-		//    DBGPRINT(RT_DEBUG_WARN, ("TIM bitmap = 0x%02x\n", *IdxPtr));
+		/*if (*IdxPtr) */
+		/*    DBGPRINT(RT_DEBUG_WARN, ("TIM bitmap = 0x%02x\n", *IdxPtr)); */
 
 		if (*IdxPtr & (0x01 << MyBit))
 			*MessageToMe = TRUE;
diff --git a/drivers/staging/rt2860/sta/sync.c b/drivers/staging/rt2860/sta/sync.c
index 56bb797..12ab2d4 100644
--- a/drivers/staging/rt2860/sta/sync.c
+++ b/drivers/staging/rt2860/sta/sync.c
@@ -37,7 +37,7 @@
 */
 #include "../rt_config.h"
 
-#define ADHOC_ENTRY_BEACON_LOST_TIME	(2*OS_HZ)	// 2 sec
+#define ADHOC_ENTRY_BEACON_LOST_TIME	(2*OS_HZ)	/* 2 sec */
 
 /*
 	==========================================================================
@@ -57,7 +57,7 @@ VOID SyncStateMachineInit(IN PRTMP_ADAPTER pAd,
 			 (STATE_MACHINE_FUNC) Drop, SYNC_IDLE,
 			 SYNC_MACHINE_BASE);
 
-	// column 1
+	/* column 1 */
 	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_SCAN_REQ,
 			      (STATE_MACHINE_FUNC) MlmeScanReqAction);
 	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_JOIN_REQ,
@@ -69,7 +69,7 @@ VOID SyncStateMachineInit(IN PRTMP_ADAPTER pAd,
 	StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_PROBE_REQ,
 			      (STATE_MACHINE_FUNC) PeerProbeReqAction);
 
-	//column 2
+	/*column 2 */
 	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_SCAN_REQ,
 			      (STATE_MACHINE_FUNC) InvalidStateWhenScan);
 	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_JOIN_REQ,
@@ -81,7 +81,7 @@ VOID SyncStateMachineInit(IN PRTMP_ADAPTER pAd,
 	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_BEACON_TIMEOUT,
 			      (STATE_MACHINE_FUNC) BeaconTimeoutAtJoinAction);
 
-	// column 3
+	/* column 3 */
 	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_SCAN_REQ,
 			      (STATE_MACHINE_FUNC) InvalidStateWhenScan);
 	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_JOIN_REQ,
@@ -95,7 +95,7 @@ VOID SyncStateMachineInit(IN PRTMP_ADAPTER pAd,
 	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_SCAN_TIMEOUT,
 			      (STATE_MACHINE_FUNC) ScanTimeoutAction);
 
-	// timer init
+	/* timer init */
 	RTMPInitTimer(pAd, &pAd->MlmeAux.BeaconTimer,
 		      GET_TIMER_FUNCTION(BeaconTimeout), pAd, FALSE);
 	RTMPInitTimer(pAd, &pAd->MlmeAux.ScanTimer,
@@ -119,8 +119,8 @@ VOID BeaconTimeout(IN PVOID SystemSpecific1,
 
 	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BeaconTimeout\n"));
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
 		return;
 
@@ -157,15 +157,15 @@ VOID ScanTimeout(IN PVOID SystemSpecific1,
 {
 	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-	// Do nothing if the driver is starting halt state.
-	// This might happen when timer already been fired before cancel timer with mlmehalt
+	/* Do nothing if the driver is starting halt state. */
+	/* This might happen when timer already been fired before cancel timer with mlmehalt */
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
 		return;
 
 	if (MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_SCAN_TIMEOUT, 0, NULL)) {
 		RTMP_MLME_HANDLER(pAd);
 	} else {
-		// To prevent SyncMachine.CurrState is SCAN_LISTEN forever.
+		/* To prevent SyncMachine.CurrState is SCAN_LISTEN forever. */
 		pAd->MlmeAux.Channel = 0;
 		ScanNextChannel(pAd);
 		if (pAd->CommonCfg.bWirelessEvent) {
@@ -193,14 +193,14 @@ VOID MlmeScanReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	PUCHAR pOutBuffer = NULL;
 	NDIS_STATUS NStatus;
 
-	// Check the total scan tries for one single OID command
-	// If this is the CCX 2.0 Case, skip that!
+	/* Check the total scan tries for one single OID command */
+	/* If this is the CCX 2.0 Case, skip that! */
 	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)) {
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("SYNC - MlmeScanReqAction before Startup\n"));
 		return;
 	}
-	// Increase the scan retry counters.
+	/* Increase the scan retry counters. */
 	pAd->StaCfg.ScanCnt++;
 
 #ifdef RTMP_MAC_PCI
@@ -219,24 +219,24 @@ VOID MlmeScanReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 		}
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// first check the parameter sanity
+	/* first check the parameter sanity */
 	if (MlmeScanReqSanity(pAd,
 			      Elem->Msg,
 			      Elem->MsgLen,
 			      &BssType, (PCHAR) Ssid, &SsidLen, &ScanType)) {
 
-		// Check for channel load and noise hist request
-		// Suspend MSDU only at scan request, not the last two mentioned
-		// Suspend MSDU transmission here
+		/* Check for channel load and noise hist request */
+		/* Suspend MSDU only at scan request, not the last two mentioned */
+		/* Suspend MSDU transmission here */
 		RTMPSuspendMsduTransmission(pAd);
 
-		//
-		// To prevent data lost.
-		// Send an NULL data with turned PSM bit on to current associated AP before SCAN progress.
-		// And should send an NULL data with turned PSM bit off to AP, when scan progress done
-		//
+		/* */
+		/* To prevent data lost. */
+		/* Send an NULL data with turned PSM bit on to current associated AP before SCAN progress. */
+		/* And should send an NULL data with turned PSM bit off to AP, when scan progress done */
+		/* */
 		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
 		    && (INFRA_ON(pAd))) {
 			NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);
@@ -250,7 +250,7 @@ VOID MlmeScanReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				pHdr80211->FC.Type = BTYPE_DATA;
 				pHdr80211->FC.PwrMgmt = PWR_SAVE;
 
-				// Send using priority queue
+				/* Send using priority queue */
 				MiniportMMRequest(pAd, 0, pOutBuffer,
 						  sizeof(HEADER_802_11));
 				DBGPRINT(RT_DEBUG_TRACE,
@@ -262,21 +262,21 @@ VOID MlmeScanReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 		NdisGetSystemUpTime(&Now);
 		pAd->StaCfg.LastScanTime = Now;
-		// reset all the timers
+		/* reset all the timers */
 		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
 
-		// record desired BSS parameters
+		/* record desired BSS parameters */
 		pAd->MlmeAux.BssType = BssType;
 		pAd->MlmeAux.ScanType = ScanType;
 		pAd->MlmeAux.SsidLen = SsidLen;
 		NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
 		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
 
-		// start from the first channel
+		/* start from the first channel */
 		pAd->MlmeAux.Channel = FirstChannel(pAd);
 
-		// Let BBP register at 20MHz to do scan
+		/* Let BBP register at 20MHz to do scan */
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 		BBPValue &= (~0x18);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
@@ -324,18 +324,18 @@ VOID MlmeJoinReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))) {
 		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 	}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 
-	// reset all the timers
+	/* reset all the timers */
 	RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
 	RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
 
 	pBss = &pAd->MlmeAux.SsidBssTab.BssEntry[pInfo->BssIdx];
 
-	// record the desired SSID & BSSID we're waiting for
+	/* record the desired SSID & BSSID we're waiting for */
 	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pBss->Bssid);
 
-	// If AP's SSID is not hidden, it is OK for updating ssid to MlmeAux again.
+	/* If AP's SSID is not hidden, it is OK for updating ssid to MlmeAux again. */
 	if (pBss->Hidden == 0) {
 		RTMPZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
 		NdisMoveMemory(pAd->MlmeAux.Ssid, pBss->Ssid, pBss->SsidLen);
@@ -346,14 +346,14 @@ VOID MlmeJoinReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	pAd->MlmeAux.Channel = pBss->Channel;
 	pAd->MlmeAux.CentralChannel = pBss->CentralChannel;
 
-	// Let BBP register at 20MHz to do scan
+	/* Let BBP register at 20MHz to do scan */
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 	BBPValue &= (~0x18);
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BBP R4 to 20MHz.l\n"));
 
-	// switch channel and waiting for beacon timer
+	/* switch channel and waiting for beacon timer */
 	AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, FALSE);
 	AsicLockChannel(pAd, pAd->MlmeAux.Channel);
 	RTMPSetTimer(&pAd->MlmeAux.BeaconTimer, JOIN_TIMEOUT);
@@ -363,15 +363,15 @@ VOID MlmeJoinReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		     (pAd->MlmeAux.Channel > 14) &&
 		     RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
 		    ) {
-			//
-			// We can't send any Probe request frame to meet 802.11h.
-			//
+			/* */
+			/* We can't send any Probe request frame to meet 802.11h. */
+			/* */
 			if (pBss->Hidden == 0)
 				break;
 		}
-		//
-		// send probe request
-		//
+		/* */
+		/* send probe request */
+		/* */
 		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
 		if (NStatus == NDIS_STATUS_SUCCESS) {
 			if (pAd->MlmeAux.Channel <= 14) {
@@ -380,9 +380,9 @@ VOID MlmeJoinReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				pExtRate = pAd->CommonCfg.ExtRate;
 				ExtRateLen = pAd->CommonCfg.ExtRateLen;
 			} else {
-				//
-				// Overwrite Support Rate, CCK rate are not allowed
-				//
+				/* */
+				/* Overwrite Support Rate, CCK rate are not allowed */
+				/* */
 				pSupRate = ASupRate;
 				SupRateLen = ASupRateLen;
 				ExtRateLen = 0;
@@ -442,14 +442,14 @@ VOID MlmeStartReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	UCHAR Ssid[MAX_LEN_OF_SSID], SsidLen;
 	BOOLEAN TimerCancelled;
 
-	// New for WPA security suites
-	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	/* New for WPA security suites */
+	UCHAR VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
 	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
 	LARGE_INTEGER TimeStamp;
 	BOOLEAN Privacy;
 	USHORT Status;
 
-	// Init Variable IE structure
+	/* Init Variable IE structure */
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
 	TimeStamp.u.LowPart = 0;
@@ -457,20 +457,20 @@ VOID MlmeStartReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	if (MlmeStartReqSanity
 	    (pAd, Elem->Msg, Elem->MsgLen, (PCHAR) Ssid, &SsidLen)) {
-		// reset all the timers
+		/* reset all the timers */
 		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
 
-		//
-		// Start a new IBSS. All IBSS parameters are decided now....
-		//
+		/* */
+		/* Start a new IBSS. All IBSS parameters are decided now.... */
+		/* */
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("MlmeStartReqAction - Start a new IBSS. All IBSS parameters are decided now.... \n"));
 		pAd->MlmeAux.BssType = BSS_ADHOC;
 		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
 		pAd->MlmeAux.SsidLen = SsidLen;
 
-		// generate a radom number as BSSID
+		/* generate a radom number as BSSID */
 		MacAddrRandomBssid(pAd, pAd->MlmeAux.Bssid);
 		DBGPRINT(RT_DEBUG_TRACE,
 			 ("MlmeStartReqAction - generate a radom number as BSSID \n"));
@@ -507,7 +507,7 @@ VOID MlmeStartReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				       &pAd->MlmeAux.HtCapability,
 				       &pAd->MlmeAux.AddHtInfo);
 			pAd->MlmeAux.HtCapabilityLen = sizeof(HT_CAPABILITY_IE);
-			// Not turn pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE here.
+			/* Not turn pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE here. */
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("SYNC -pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE\n"));
 		} else {
@@ -516,7 +516,7 @@ VOID MlmeStartReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.
 				       MCSSet[0], 16);
 		}
-		// temporarily not support QOS in IBSS
+		/* temporarily not support QOS in IBSS */
 		NdisZeroMemory(&pAd->MlmeAux.APEdcaParm, sizeof(EDCA_PARM));
 		NdisZeroMemory(&pAd->MlmeAux.APQbssLoad,
 			       sizeof(QBSS_LOAD_PARM));
@@ -570,17 +570,17 @@ VOID PeerBeaconAtScanAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	QBSS_LOAD_PARM QbssLoad;
 	QOS_CAPABILITY_PARM QosCapability;
 	ULONG RalinkIe;
-	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	UCHAR VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
 	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
 	HT_CAPABILITY_IE HtCapability;
-	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	ADD_HT_INFO_IE AddHtInfo;	/* AP might use this additional ht info IE */
 	UCHAR HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
 	UCHAR AddHtInfoLen;
 	UCHAR NewExtChannelOffset = 0xff;
 
-	// NdisFillMemory(Ssid, MAX_LEN_OF_SSID, 0x00);
+	/* NdisFillMemory(Ssid, MAX_LEN_OF_SSID, 0x00); */
 	pFrame = (PFRAME_802_11) Elem->Msg;
-	// Init Variable IE structure
+	/* Init Variable IE structure */
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
 
@@ -659,7 +659,7 @@ VOID PeerBeaconAtScanAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		}
 
 	}
-	// sanity check fail, ignored
+	/* sanity check fail, ignored */
 }
 
 /*
@@ -688,19 +688,19 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	QBSS_LOAD_PARM QbssLoad;
 	QOS_CAPABILITY_PARM QosCapability;
 	USHORT Status;
-	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	UCHAR VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
 	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
 	ULONG RalinkIe;
 	ULONG Idx;
 	HT_CAPABILITY_IE HtCapability;
-	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	ADD_HT_INFO_IE AddHtInfo;	/* AP might use this additional ht info IE */
 	UCHAR HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
 	UCHAR AddHtInfoLen;
 	UCHAR NewExtChannelOffset = 0xff;
 	UCHAR CentralChannel;
 	BOOLEAN bAllowNrate = FALSE;
 
-	// Init Variable IE structure
+	/* Init Variable IE structure */
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
 	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
@@ -743,18 +743,18 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					&AddHtInfoLen,
 					&AddHtInfo,
 					&NewExtChannelOffset, &LenVIE, pVIE)) {
-		// Disqualify 11b only adhoc when we are in 11g only adhoc mode
+		/* Disqualify 11b only adhoc when we are in 11g only adhoc mode */
 		if ((BssType == BSS_ADHOC)
 		    && (pAd->CommonCfg.PhyMode == PHY_11G)
 		    && ((SupRateLen + ExtRateLen) < 12))
 			return;
 
-		// BEACON from desired BSS/IBSS found. We should be able to decide most
-		// BSS parameters here.
-		// Q. But what happen if this JOIN doesn't conclude a successful ASSOCIATEION?
-		//    Do we need to receover back all parameters belonging to previous BSS?
-		// A. Should be not. There's no back-door recover to previous AP. It still need
-		//    a new JOIN-AUTH-ASSOC sequence.
+		/* BEACON from desired BSS/IBSS found. We should be able to decide most */
+		/* BSS parameters here. */
+		/* Q. But what happen if this JOIN doesn't conclude a successful ASSOCIATEION? */
+		/*    Do we need to receover back all parameters belonging to previous BSS? */
+		/* A. Should be not. There's no back-door recover to previous AP. It still need */
+		/*    a new JOIN-AUTH-ASSOC sequence. */
 		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Bssid)) {
 			DBGPRINT(RT_DEBUG_TRACE,
 				 ("SYNC - receive desired BEACON at JoinWaitBeacon... Channel = %d\n",
@@ -762,7 +762,7 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,
 					&TimerCancelled);
 
-			// Update RSSI to prevent No signal display when cards first initialized
+			/* Update RSSI to prevent No signal display when cards first initialized */
 			pAd->StaCfg.RssiSample.LastRssi0 =
 			    ConvertToRssi(pAd, Elem->Rssi0, RSSI_0);
 			pAd->StaCfg.RssiSample.LastRssi1 =
@@ -782,10 +782,10 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			pAd->StaCfg.RssiSample.AvgRssi2X8 =
 			    pAd->StaCfg.RssiSample.AvgRssi2 << 3;
 
-			//
-			// We need to check if SSID only set to any, then we can record the current SSID.
-			// Otherwise will cause hidden SSID association failed.
-			//
+			/* */
+			/* We need to check if SSID only set to any, then we can record the current SSID. */
+			/* Otherwise will cause hidden SSID association failed. */
+			/* */
 			if (pAd->MlmeAux.SsidLen == 0) {
 				NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid,
 					       SsidLen);
@@ -858,9 +858,9 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						    CapabilityInfo;
 					}
 				} else {
-					//
-					// Multiple SSID case, used correct CapabilityInfo
-					//
+					/* */
+					/* Multiple SSID case, used correct CapabilityInfo */
+					/* */
 					CapabilityInfo =
 					    pAd->ScanTab.BssEntry[Idx].
 					    CapabilityInfo;
@@ -877,8 +877,8 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			pAd->MlmeAux.CfpMaxDuration = Cf.CfpMaxDuration;
 			pAd->MlmeAux.APRalinkIe = RalinkIe;
 
-			// Copy AP's supported rate to MlmeAux for creating assoication request
-			// Also filter out not supported rate
+			/* Copy AP's supported rate to MlmeAux for creating assoication request */
+			/* Also filter out not supported rate */
 			pAd->MlmeAux.SupRateLen = SupRateLen;
 			NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate,
 				       SupRateLen);
@@ -905,14 +905,14 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 			RTMPZeroMemory(&pAd->MlmeAux.HtCapability,
 				       SIZE_HT_CAP_IE);
-			// filter out un-supported ht rates
+			/* filter out un-supported ht rates */
 			if (((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
 			    && ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 				&& (bAllowNrate))) {
 				RTMPMoveMemory(&pAd->MlmeAux.AddHtInfo,
 					       &AddHtInfo, SIZE_ADD_HT_INFO_IE);
 
-				// StaActive.SupportedHtPhy.MCSSet stores Peer AP's 11n Rx capability
+				/* StaActive.SupportedHtPhy.MCSSet stores Peer AP's 11n Rx capability */
 				NdisMoveMemory(pAd->StaActive.SupportedPhyInfo.
 					       MCSSet, HtCapability.MCSSet, 16);
 				pAd->MlmeAux.NewExtChannelOffset =
@@ -925,7 +925,7 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					    bPreNHt = TRUE;
 				RTMPCheckHt(pAd, BSSID_WCID, &HtCapability,
 					    &AddHtInfo);
-				// Copy AP Parameter to StaActive.  This is also in LinkUp.
+				/* Copy AP Parameter to StaActive.  This is also in LinkUp. */
 				DBGPRINT(RT_DEBUG_TRACE,
 					 ("PeerBeaconAtJoinAction! (MpduDensity=%d, MaxRAmpduFactor=%d, BW=%d)\n",
 					  pAd->StaActive.SupportedHtPhy.
@@ -936,7 +936,7 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 				if (AddHtInfoLen > 0) {
 					CentralChannel = AddHtInfo.ControlChan;
-					// Check again the Bandwidth capability of this AP.
+					/* Check again the Bandwidth capability of this AP. */
 					if ((AddHtInfo.ControlChan > 2)
 					    && (AddHtInfo.AddHtInfo.
 						ExtChanOffset == EXTCHA_BELOW)
@@ -952,7 +952,7 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						CentralChannel =
 						    AddHtInfo.ControlChan + 2;
 					}
-					// Check Error .
+					/* Check Error . */
 					if (pAd->MlmeAux.CentralChannel !=
 					    CentralChannel)
 						DBGPRINT(RT_DEBUG_ERROR,
@@ -970,7 +970,7 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				}
 
 			} else {
-				// To prevent error, let legacy AP must have same CentralChannel and Channel.
+				/* To prevent error, let legacy AP must have same CentralChannel and Channel. */
 				if ((HtCapabilityLen == 0)
 				    && (PreNHtCapabilityLen == 0))
 					pAd->MlmeAux.CentralChannel =
@@ -988,7 +988,7 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 			RTMPUpdateMlmeRate(pAd);
 
-			// copy QOS related information
+			/* copy QOS related information */
 			if ((pAd->CommonCfg.bWmmCapable)
 			    || (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 			    ) {
@@ -1015,10 +1015,10 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				  pAd->MlmeAux.ExtRateLen));
 
 			if (AironetCellPowerLimit != 0xFF) {
-				//We need to change our TxPower for CCX 2.0 AP Control of Client Transmit Power
+				/*We need to change our TxPower for CCX 2.0 AP Control of Client Transmit Power */
 				ChangeToCellPowerLimit(pAd,
 						       AironetCellPowerLimit);
-			} else	//Used the default TX Power Percentage.
+			} else	/*Used the default TX Power Percentage. */
 				pAd->CommonCfg.TxPowerPercentage =
 				    pAd->CommonCfg.TxPowerDefault;
 
@@ -1027,9 +1027,9 @@ VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF,
 				    2, &Status);
 		}
-		// not to me BEACON, ignored
+		/* not to me BEACON, ignored */
 	}
-	// sanity check fail, ignore this frame
+	/* sanity check fail, ignore this frame */
 }
 
 /*
@@ -1062,11 +1062,11 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	QBSS_LOAD_PARM QbssLoad;
 	QOS_CAPABILITY_PARM QosCapability;
 	ULONG RalinkIe;
-	// New for WPA security suites
-	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	/* New for WPA security suites */
+	UCHAR VarIE[MAX_VIE_LEN];	/* Total VIE length = MAX_VIE_LEN - -5 */
 	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
 	HT_CAPABILITY_IE HtCapability;
-	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	ADD_HT_INFO_IE AddHtInfo;	/* AP might use this additional ht info IE */
 	UCHAR HtCapabilityLen, PreNHtCapabilityLen;
 	UCHAR AddHtInfoLen;
 	UCHAR NewExtChannelOffset = 0xff;
@@ -1075,7 +1075,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	    ))
 		return;
 
-	// Init Variable IE structure
+	/* Init Variable IE structure */
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
 	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
@@ -1132,27 +1132,27 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		    SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid,
 			       pAd->CommonCfg.SsidLen) ? TRUE : FALSE;
 
-		// ignore BEACON not for my SSID
+		/* ignore BEACON not for my SSID */
 		if ((!is_my_ssid) && (!is_my_bssid))
 			return;
 
-		// It means STA waits disassoc completely from this AP, ignores this beacon.
+		/* It means STA waits disassoc completely from this AP, ignores this beacon. */
 		if (pAd->Mlme.CntlMachine.CurrState == CNTL_WAIT_DISASSOC)
 			return;
 
-		// Copy Control channel for this BSSID.
+		/* Copy Control channel for this BSSID. */
 		if (AddHtInfoLen != 0)
 			Channel = AddHtInfo.ControlChan;
 
 		if ((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
 			HtCapabilityLen = SIZE_HT_CAP_IE;
 
-		//
-		// Housekeeping "SsidBssTab" table for later-on ROAMing usage.
-		//
+		/* */
+		/* Housekeeping "SsidBssTab" table for later-on ROAMing usage. */
+		/* */
 		Bssidx = BssTableSearch(&pAd->ScanTab, Bssid, Channel);
 		if (Bssidx == BSS_NOT_FOUND) {
-			// discover new AP of this network, create BSS entry
+			/* discover new AP of this network, create BSS entry */
 			Bssidx =
 			    BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, Ssid,
 					     SsidLen, BssType, BeaconPeriod,
@@ -1165,7 +1165,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					     CkipFlag, &EdcaParm,
 					     &QosCapability, &QbssLoad, LenVIE,
 					     pVIE);
-			if (Bssidx == BSS_NOT_FOUND)	// return if BSS table full
+			if (Bssidx == BSS_NOT_FOUND)	/* return if BSS table full */
 				return;
 
 			NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].PTSF,
@@ -1179,16 +1179,16 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0)
 		    && (Channel != NewChannel)) {
-			// Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection).
-			// In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results.
+			/* Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection). */
+			/* In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results. */
 			AsicSwitchChannel(pAd, 1, FALSE);
 			AsicLockChannel(pAd, 1);
 			LinkDown(pAd, FALSE);
 			MlmeQueueInit(&pAd->Mlme.Queue);
 			BssTableInit(&pAd->ScanTab);
-			RTMPusecDelay(1000000);	// use delay to prevent STA do reassoc
+			RTMPusecDelay(1000000);	/* use delay to prevent STA do reassoc */
 
-			// channel sanity check
+			/* channel sanity check */
 			for (index = 0; index < pAd->ChannelListNum; index++) {
 				if (pAd->ChannelList[index].Channel ==
 				    NewChannel) {
@@ -1211,17 +1211,17 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				DBGPRINT_ERR(("PeerBeacon(can not find New Channel=%d in ChannelList[%d]\n", pAd->CommonCfg.Channel, pAd->ChannelListNum));
 			}
 		}
-		// if the ssid matched & bssid unmatched, we should select the bssid with large value.
-		// This might happened when two STA start at the same time
+		/* if the ssid matched & bssid unmatched, we should select the bssid with large value. */
+		/* This might happened when two STA start at the same time */
 		if ((!is_my_bssid) && ADHOC_ON(pAd)) {
 			INT i;
 
-			// Add the safeguard against the mismatch of adhoc wep status
+			/* Add the safeguard against the mismatch of adhoc wep status */
 			if (pAd->StaCfg.WepStatus !=
 			    pAd->ScanTab.BssEntry[Bssidx].WepStatus) {
 				return;
 			}
-			// collapse into the ADHOC network which has bigger BSSID value.
+			/* collapse into the ADHOC network which has bigger BSSID value. */
 			for (i = 0; i < 6; i++) {
 				if (Bssid[i] > pAd->CommonCfg.Bssid[i]) {
 					DBGPRINT(RT_DEBUG_TRACE,
@@ -1233,8 +1233,8 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					COPY_MAC_ADDR(pAd->CommonCfg.Bssid,
 						      Bssid);
 					AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
-					MakeIbssBeacon(pAd);	// re-build BEACON frame
-					AsicEnableIbssSync(pAd);	// copy BEACON frame to on-chip memory
+					MakeIbssBeacon(pAd);	/* re-build BEACON frame */
+					AsicEnableIbssSync(pAd);	/* copy BEACON frame to on-chip memory */
 					is_my_bssid = TRUE;
 					break;
 				} else if (Bssid[i] < pAd->CommonCfg.Bssid[i])
@@ -1244,12 +1244,12 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 		NdisGetSystemUpTime(&Now);
 		pBss = &pAd->ScanTab.BssEntry[Bssidx];
-		pBss->Rssi = RealRssi;	// lastest RSSI
-		pBss->LastBeaconRxTime = Now;	// last RX timestamp
+		pBss->Rssi = RealRssi;	/* lastest RSSI */
+		pBss->LastBeaconRxTime = Now;	/* last RX timestamp */
 
-		//
-		// BEACON from my BSSID - either IBSS or INFRA network
-		//
+		/* */
+		/* BEACON from my BSSID - either IBSS or INFRA network */
+		/* */
 		if (is_my_bssid) {
 			RXWI_STRUC RxWI;
 
@@ -1263,17 +1263,17 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 			Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, &RxWI);
 			if (AironetCellPowerLimit != 0xFF) {
-				//
-				// We get the Cisco (ccx) "TxPower Limit" required
-				// Changed to appropriate TxPower Limit for Ciso Compatible Extensions
-				//
+				/* */
+				/* We get the Cisco (ccx) "TxPower Limit" required */
+				/* Changed to appropriate TxPower Limit for Ciso Compatible Extensions */
+				/* */
 				ChangeToCellPowerLimit(pAd,
 						       AironetCellPowerLimit);
 			} else {
-				//
-				// AironetCellPowerLimit equal to 0xFF means the Cisco (ccx) "TxPower Limit" not exist.
-				// Used the default TX Power Percentage, that set from UI.
-				//
+				/* */
+				/* AironetCellPowerLimit equal to 0xFF means the Cisco (ccx) "TxPower Limit" not exist. */
+				/* Used the default TX Power Percentage, that set from UI. */
+				/* */
 				pAd->CommonCfg.TxPowerPercentage =
 				    pAd->CommonCfg.TxPowerDefault;
 			}
@@ -1283,7 +1283,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				UCHAR idx;
 				MAC_TABLE_ENTRY *pEntry;
 
-				// supported rates array may not be sorted. sort it and find the maximum rate
+				/* supported rates array may not be sorted. sort it and find the maximum rate */
 				for (idx = 0; idx < SupRateLen; idx++) {
 					if (MaxSupportedRateIn500Kbps <
 					    (SupRate[idx] & 0x7f))
@@ -1298,11 +1298,11 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						    ExtRate[idx] & 0x7f;
 				}
 
-				// look up the existing table
+				/* look up the existing table */
 				pEntry = MacTableLookup(pAd, Addr2);
 
-				// Ad-hoc mode is using MAC address as BA session. So we need to continuously find newly joined adhoc station by receiving beacon.
-				// To prevent always check this, we use wcid == RESERVED_WCID to recognize it as newly joined adhoc station.
+				/* Ad-hoc mode is using MAC address as BA session. So we need to continuously find newly joined adhoc station by receiving beacon. */
+				/* To prevent always check this, we use wcid == RESERVED_WCID to recognize it as newly joined adhoc station. */
 				if ((ADHOC_ON(pAd)
 				     && (Elem->Wcid == RESERVED_WCID))
 				    || (pEntry
@@ -1311,7 +1311,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					  ADHOC_ENTRY_BEACON_LOST_TIME) <
 					 Now))) {
 					if (pEntry == NULL)
-						// Another adhoc joining, add to our MAC table.
+						/* Another adhoc joining, add to our MAC table. */
 						pEntry =
 						    MacTableInsertEntry(pAd,
 									Addr2,
@@ -1345,7 +1345,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				if (pEntry && pEntry->ValidAsCLI)
 					pEntry->LastBeaconRxTime = Now;
 
-				// At least another peer in this IBSS, declare MediaState as CONNECTED
+				/* At least another peer in this IBSS, declare MediaState as CONNECTED */
 				if (!OPSTATUS_TEST_FLAG
 				    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
 					OPSTATUS_SET_FLAG(pAd,
@@ -1357,10 +1357,10 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					pAd->ExtraInfo = GENERAL_LINK_UP;
 					AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
 
-					// 2003/03/12 - john
-					// Make sure this entry in "ScanTab" table, thus complies to Microsoft's policy that
-					// "site survey" result should always include the current connected network.
-					//
+					/* 2003/03/12 - john */
+					/* Make sure this entry in "ScanTab" table, thus complies to Microsoft's policy that */
+					/* "site survey" result should always include the current connected network. */
+					/* */
 					Bssidx =
 					    BssTableSearch(&pAd->ScanTab, Bssid,
 							   Channel);
@@ -1404,12 +1404,12 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 			if (INFRA_ON(pAd)) {
 				BOOLEAN bUseShortSlot, bUseBGProtection;
 
-				// decide to use/change to -
-				//      1. long slot (20 us) or short slot (9 us) time
-				//      2. turn on/off RTS/CTS and/or CTS-to-self protection
-				//      3. short preamble
+				/* decide to use/change to - */
+				/*      1. long slot (20 us) or short slot (9 us) time */
+				/*      2. turn on/off RTS/CTS and/or CTS-to-self protection */
+				/*      3. short preamble */
 
-				//bUseShortSlot = pAd->CommonCfg.bUseShortSlotTime && CAP_IS_SHORT_SLOT(CapabilityInfo);
+				/*bUseShortSlot = pAd->CommonCfg.bUseShortSlotTime && CAP_IS_SHORT_SLOT(CapabilityInfo); */
 				bUseShortSlot =
 				    CAP_IS_SHORT_SLOT(CapabilityInfo);
 				if (bUseShortSlot !=
@@ -1417,11 +1417,11 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						       fOP_STATUS_SHORT_SLOT_INUSED))
 					AsicSetSlotTime(pAd, bUseShortSlot);
 
-				bUseBGProtection = (pAd->CommonCfg.UseBGProtection == 1) ||	// always use
+				bUseBGProtection = (pAd->CommonCfg.UseBGProtection == 1) ||	/* always use */
 				    ((pAd->CommonCfg.UseBGProtection == 0)
 				     && ERP_IS_USE_PROTECTION(Erp));
 
-				if (pAd->CommonCfg.Channel > 14)	// always no BG protection in A-band. falsely happened when switching A/G band to a dual-band AP
+				if (pAd->CommonCfg.Channel > 14)	/* always no BG protection in A-band. falsely happened when switching A/G band to a dual-band AP */
 					bUseBGProtection = FALSE;
 
 				if (bUseBGProtection !=
@@ -1472,7 +1472,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						 ("SYNC - AP changed B/G protection to %d\n",
 						  bUseBGProtection));
 				}
-				// check Ht protection mode. and adhere to the Non-GF device indication by AP.
+				/* check Ht protection mode. and adhere to the Non-GF device indication by AP. */
 				if ((AddHtInfoLen != 0) &&
 				    ((AddHtInfo.AddHtInfo2.OperaionMode !=
 				      pAd->MlmeAux.AddHtInfo.AddHtInfo2.
@@ -1532,7 +1532,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						  EdcaParm.EdcaUpdateCount));
 					AsicSetEdcaParm(pAd, &EdcaParm);
 				}
-				// copy QOS related information
+				/* copy QOS related information */
 				NdisMoveMemory(&pAd->CommonCfg.APQbssLoad,
 					       &QbssLoad,
 					       sizeof(QBSS_LOAD_PARM));
@@ -1540,28 +1540,28 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					       &QosCapability,
 					       sizeof(QOS_CAPABILITY_PARM));
 			}
-			// only INFRASTRUCTURE mode support power-saving feature
+			/* only INFRASTRUCTURE mode support power-saving feature */
 			if ((INFRA_ON(pAd) && (pAd->StaCfg.Psm == PWR_SAVE))
 			    || (pAd->CommonCfg.bAPSDForcePowerSave)) {
 				UCHAR FreeNumber;
-				//  1. AP has backlogged unicast-to-me frame, stay AWAKE, send PSPOLL
-				//  2. AP has backlogged broadcast/multicast frame and we want those frames, stay AWAKE
-				//  3. we have outgoing frames in TxRing or MgmtRing, better stay AWAKE
-				//  4. Psm change to PWR_SAVE, but AP not been informed yet, we better stay AWAKE
-				//  5. otherwise, put PHY back to sleep to save battery.
+				/*  1. AP has backlogged unicast-to-me frame, stay AWAKE, send PSPOLL */
+				/*  2. AP has backlogged broadcast/multicast frame and we want those frames, stay AWAKE */
+				/*  3. we have outgoing frames in TxRing or MgmtRing, better stay AWAKE */
+				/*  4. Psm change to PWR_SAVE, but AP not been informed yet, we better stay AWAKE */
+				/*  5. otherwise, put PHY back to sleep to save battery. */
 				if (MessageToMe) {
 #ifdef RTMP_MAC_PCI
 					if (OPSTATUS_TEST_FLAG
 					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
-						// Restore to correct BBP R3 value
+						/* Restore to correct BBP R3 value */
 						if (pAd->Antenna.field.RxPath >
 						    1)
 							RTMP_BBP_IO_WRITE8_BY_REG_ID
 							    (pAd, BBP_R3,
 							     pAd->StaCfg.BBPR3);
-						// Turn clk to 80Mhz.
+						/* Turn clk to 80Mhz. */
 					}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 					if (pAd->CommonCfg.bAPSDCapable
 					    && pAd->CommonCfg.APEdcaParm.
 					    bAPSDCapable
@@ -1587,7 +1587,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 							    (pAd, BBP_R3,
 							     pAd->StaCfg.BBPR3);
 					}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 				} else
 				    if ((pAd->TxSwQueue[QID_AC_BK].Number != 0)
 					|| (pAd->TxSwQueue[QID_AC_BE].Number !=
@@ -1617,8 +1617,8 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 					 (pAd, QID_MGMT, MGMT_RING_SIZE - 1,
 					  &FreeNumber) !=
 					 NDIS_STATUS_SUCCESS)) {
-					// TODO: consider scheduled HCCA. might not be proper to use traditional DTIM-based power-saving scheme
-					// can we cheat here (i.e. just check MGMT & AC_BE) for better performance?
+					/* TODO: consider scheduled HCCA. might not be proper to use traditional DTIM-based power-saving scheme */
+					/* can we cheat here (i.e. just check MGMT & AC_BE) for better performance? */
 #ifdef RTMP_MAC_PCI
 					if (OPSTATUS_TEST_FLAG
 					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
@@ -1628,7 +1628,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 							    (pAd, BBP_R3,
 							     pAd->StaCfg.BBPR3);
 					}
-#endif // RTMP_MAC_PCI //
+#endif /* RTMP_MAC_PCI // */
 				} else {
 					if ((pAd->CommonCfg.
 					     bACMAPSDTr[QID_AC_VO])
@@ -1678,7 +1678,7 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 						if (!OPSTATUS_TEST_FLAG
 						    (pAd, fOP_STATUS_DOZE)) {
-							// Set a flag to go to sleep . Then after parse this RxDoneInterrupt, will go to sleep mode.
+							/* Set a flag to go to sleep . Then after parse this RxDoneInterrupt, will go to sleep mode. */
 							pAd->
 							    ThisTbttNumToNextWakeUp
 							    =
@@ -1692,9 +1692,9 @@ VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				}
 			}
 		}
-		// not my BSSID, ignore it
+		/* not my BSSID, ignore it */
 	}
-	// sanity check fail, ignore this frame
+	/* sanity check fail, ignore this frame */
 }
 
 /*
@@ -1728,12 +1728,12 @@ VOID PeerProbeReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 		if ((SsidLen == 0)
 		    || SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid,
 				  pAd->CommonCfg.SsidLen)) {
-			// allocate and send out ProbeRsp frame
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+			/* allocate and send out ProbeRsp frame */
+			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 			if (NStatus != NDIS_STATUS_SUCCESS)
 				return;
 
-			//pAd->StaCfg.AtimWin = 0;  // ??????
+			/*pAd->StaCfg.AtimWin = 0;  // ?????? */
 
 			Privacy =
 			    (pAd->StaCfg.WepStatus ==
@@ -1774,7 +1774,7 @@ VOID PeerProbeReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 						  END_OF_ARGS);
 				FrameLen += tmp;
 			}
-			// If adhoc secruity is set for WPA-None, append the cipher suite IE
+			/* If adhoc secruity is set for WPA-None, append the cipher suite IE */
 			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
 				ULONG tmp;
 				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
@@ -1792,7 +1792,7 @@ VOID PeerProbeReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 				HtLen = sizeof(pAd->CommonCfg.HtCapability);
 				AddHtLen = sizeof(pAd->CommonCfg.AddHTInfo);
 				NewExtLen = 1;
-				//New extension channel offset IE is included in Beacon, Probe Rsp or channel Switch Announcement Frame
+				/*New extension channel offset IE is included in Beacon, Probe Rsp or channel Switch Announcement Frame */
 				if (pAd->bBroadComHT == TRUE) {
 					MakeOutgoingFrame(pOutBuffer + FrameLen,
 							  &TmpLen, 1, &WpaIe, 4,
@@ -1852,14 +1852,14 @@ VOID ScanTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	pAd->MlmeAux.Channel = NextChannel(pAd, pAd->MlmeAux.Channel);
 
-	// Only one channel scanned for CISCO beacon request
+	/* Only one channel scanned for CISCO beacon request */
 	if ((pAd->MlmeAux.ScanType == SCAN_CISCO_ACTIVE) ||
 	    (pAd->MlmeAux.ScanType == SCAN_CISCO_PASSIVE) ||
 	    (pAd->MlmeAux.ScanType == SCAN_CISCO_NOISE) ||
 	    (pAd->MlmeAux.ScanType == SCAN_CISCO_CHANNEL_LOAD))
 		pAd->MlmeAux.Channel = 0;
 
-	// this routine will stop if pAd->MlmeAux.Channel == 0
+	/* this routine will stop if pAd->MlmeAux.Channel == 0 */
 	ScanNextChannel(pAd);
 }
 
@@ -1942,12 +1942,12 @@ VOID EnqueueProbeRequest(IN PRTMP_ADAPTER pAd)
 
 	DBGPRINT(RT_DEBUG_TRACE, ("force out a ProbeRequest ...\n"));
 
-	NState = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	NState = MlmeAllocateMemory(pAd, &pOutBuffer);	/*Get an unused nonpaged memory */
 	if (NState == NDIS_STATUS_SUCCESS) {
 		MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0,
 				 BROADCAST_ADDR, BROADCAST_ADDR);
 
-		// this ProbeRequest explicitly specify SSID to reduce unwanted ProbeResponse
+		/* this ProbeRequest explicitly specify SSID to reduce unwanted ProbeResponse */
 		MakeOutgoingFrame(pOutBuffer, &FrameLen,
 				  sizeof(HEADER_802_11), &Hdr80211,
 				  1, &SsidIe,
diff --git a/drivers/staging/rt2860/sta/wpa.c b/drivers/staging/rt2860/sta/wpa.c
index 0a45643..15ed01e 100644
--- a/drivers/staging/rt2860/sta/wpa.c
+++ b/drivers/staging/rt2860/sta/wpa.c
@@ -63,7 +63,7 @@ VOID RTMPReportMicError(IN PRTMP_ADAPTER pAd, IN PCIPHER_KEY pWpaKey)
 	ULONG Now;
 	UCHAR unicastKey = (pWpaKey->Type == PAIRWISE_KEY ? 1 : 0);
 
-	// Record Last MIC error time and count
+	/* Record Last MIC error time and count */
 	NdisGetSystemUpTime(&Now);
 	if (pAd->StaCfg.MicErrCnt == 0) {
 		pAd->StaCfg.MicErrCnt++;
@@ -71,7 +71,7 @@ VOID RTMPReportMicError(IN PRTMP_ADAPTER pAd, IN PCIPHER_KEY pWpaKey)
 		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
 	} else if (pAd->StaCfg.MicErrCnt == 1) {
 		if ((pAd->StaCfg.LastMicErrorTime + (60 * OS_HZ)) < Now) {
-			// Update Last MIC error time, this did not violate two MIC errors within 60 seconds
+			/* Update Last MIC error time, this did not violate two MIC errors within 60 seconds */
 			pAd->StaCfg.LastMicErrorTime = Now;
 		} else {
 
@@ -83,23 +83,23 @@ VOID RTMPReportMicError(IN PRTMP_ADAPTER pAd, IN PCIPHER_KEY pWpaKey)
 						      BSS0, 0);
 
 			pAd->StaCfg.LastMicErrorTime = Now;
-			// Violate MIC error counts, MIC countermeasures kicks in
+			/* Violate MIC error counts, MIC countermeasures kicks in */
 			pAd->StaCfg.MicErrCnt++;
-			// We shall block all reception
-			// We shall clean all Tx ring and disassoicate from AP after next EAPOL frame
-			//
-			// No necessary to clean all Tx ring, on RTMPHardTransmit will stop sending non-802.1X EAPOL packets
-			// if pAd->StaCfg.MicErrCnt greater than 2.
-			//
-			// RTMPRingCleanUp(pAd, QID_AC_BK);
-			// RTMPRingCleanUp(pAd, QID_AC_BE);
-			// RTMPRingCleanUp(pAd, QID_AC_VI);
-			// RTMPRingCleanUp(pAd, QID_AC_VO);
-			// RTMPRingCleanUp(pAd, QID_HCCA);
+			/* We shall block all reception */
+			/* We shall clean all Tx ring and disassoicate from AP after next EAPOL frame */
+			/* */
+			/* No necessary to clean all Tx ring, on RTMPHardTransmit will stop sending non-802.1X EAPOL packets */
+			/* if pAd->StaCfg.MicErrCnt greater than 2. */
+			/* */
+			/* RTMPRingCleanUp(pAd, QID_AC_BK); */
+			/* RTMPRingCleanUp(pAd, QID_AC_BE); */
+			/* RTMPRingCleanUp(pAd, QID_AC_VI); */
+			/* RTMPRingCleanUp(pAd, QID_AC_VO); */
+			/* RTMPRingCleanUp(pAd, QID_HCCA); */
 		}
 	} else {
-		// MIC error count >= 2
-		// This should not happen
+		/* MIC error count >= 2 */
+		/* This should not happen */
 		;
 	}
 	MlmeEnqueue(pAd,
@@ -112,7 +112,7 @@ VOID RTMPReportMicError(IN PRTMP_ADAPTER pAd, IN PCIPHER_KEY pWpaKey)
 }
 
 #define	LENGTH_EAP_H    4
-// If the received frame is EAP-Packet ,find out its EAP-Code (Request(0x01), Response(0x02), Success(0x03), Failure(0x04)).
+/* If the received frame is EAP-Packet ,find out its EAP-Code (Request(0x01), Response(0x02), Success(0x03), Failure(0x04)). */
 INT WpaCheckEapCode(IN PRTMP_ADAPTER pAd,
 		    IN PUCHAR pFrame, IN USHORT FrameLen, IN USHORT OffSet)
 {
@@ -123,11 +123,11 @@ INT WpaCheckEapCode(IN PRTMP_ADAPTER pAd,
 	if (FrameLen < OffSet + LENGTH_EAPOL_H + LENGTH_EAP_H)
 		return result;
 
-	pData = pFrame + OffSet;	// skip offset bytes
+	pData = pFrame + OffSet;	/* skip offset bytes */
 
-	if (*(pData + 1) == EAPPacket)	// 802.1x header - Packet Type
+	if (*(pData + 1) == EAPPacket)	/* 802.1x header - Packet Type */
 	{
-		result = *(pData + 4);	// EAP header - Code
+		result = *(pData + 4);	/* EAP header - Code */
 	}
 
 	return result;
@@ -161,7 +161,7 @@ VOID WpaMicFailureReportFrame(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 	bUnicast = (Elem->Msg[0] == 1 ? TRUE : FALSE);
 	pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
 
-	// init 802.3 header and Fill Packet
+	/* init 802.3 header and Fill Packet */
 	MAKE_802_3_HEADER(Header802_3, pAd->CommonCfg.Bssid,
 			  pAd->CurrentAddress, EAPOL);
 
@@ -171,59 +171,59 @@ VOID WpaMicFailureReportFrame(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 
 	Packet.KeyDesc.Type = WPA1_KEY_DESC;
 
-	// Request field presented
+	/* Request field presented */
 	Packet.KeyDesc.KeyInfo.Request = 1;
 
 	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {
 		Packet.KeyDesc.KeyInfo.KeyDescVer = 2;
-	} else			// TKIP
+	} else			/* TKIP */
 	{
 		Packet.KeyDesc.KeyInfo.KeyDescVer = 1;
 	}
 
 	Packet.KeyDesc.KeyInfo.KeyType = (bUnicast ? PAIRWISEKEY : GROUPKEY);
 
-	// KeyMic field presented
+	/* KeyMic field presented */
 	Packet.KeyDesc.KeyInfo.KeyMic = 1;
 
-	// Error field presented
+	/* Error field presented */
 	Packet.KeyDesc.KeyInfo.Error = 1;
 
-	// Update packet length after decide Key data payload
+	/* Update packet length after decide Key data payload */
 	SET_UINT16_TO_ARRARY(Packet.Body_Len, LEN_EAPOL_KEY_MSG)
-	    // Key Replay Count
+	    /* Key Replay Count */
 	    NdisMoveMemory(Packet.KeyDesc.ReplayCounter,
 			   pAd->StaCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
 	inc_byte_array(pAd->StaCfg.ReplayCounter, 8);
 
-	// Convert to little-endian format.
+	/* Convert to little-endian format. */
 	*((USHORT *) & Packet.KeyDesc.KeyInfo) =
 	    cpu2le16(*((USHORT *) & Packet.KeyDesc.KeyInfo));
 
-	MlmeAllocateMemory(pAd, (PUCHAR *) & pOutBuffer);	// allocate memory
+	MlmeAllocateMemory(pAd, (PUCHAR *) & pOutBuffer);	/* allocate memory */
 	if (pOutBuffer == NULL) {
 		return;
 	}
-	// Prepare EAPOL frame for MIC calculation
-	// Be careful, only EAPOL frame is counted for MIC calculation
+	/* Prepare EAPOL frame for MIC calculation */
+	/* Be careful, only EAPOL frame is counted for MIC calculation */
 	MakeOutgoingFrame(pOutBuffer, &FrameLen,
 			  CONV_ARRARY_TO_UINT16(Packet.Body_Len) + 4, &Packet,
 			  END_OF_ARGS);
 
-	// Prepare and Fill MIC value
+	/* Prepare and Fill MIC value */
 	NdisZeroMemory(Mic, sizeof(Mic));
-	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {	// AES
+	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {	/* AES */
 		UCHAR digest[20] = { 0 };
 		HMAC_SHA1(pAd->StaCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen,
 			  digest, SHA1_DIGEST_SIZE);
 		NdisMoveMemory(Mic, digest, LEN_KEY_DESC_MIC);
-	} else {		// TKIP
+	} else {		/* TKIP */
 		HMAC_MD5(pAd->StaCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen,
 			 Mic, MD5_DIGEST_SIZE);
 	}
 	NdisMoveMemory(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
 
-	// copy frame to Tx ring and send MIC failure report frame to authenticator
+	/* copy frame to Tx ring and send MIC failure report frame to authenticator */
 	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID],
 			  Header802_3, LENGTH_802_3,
 			  (PUCHAR) & Packet,
@@ -262,7 +262,7 @@ VOID WpaDisassocApAndBlockAssoc(IN PVOID SystemSpecific1,
 	RTMP_ADAPTER *pAd = (PRTMP_ADAPTER) FunctionContext;
 	MLME_DISASSOC_REQ_STRUCT DisassocReq;
 
-	// disassoc from current AP first
+	/* disassoc from current AP first */
 	DBGPRINT(RT_DEBUG_TRACE,
 		 ("RTMPReportMicError - disassociate with current AP after sending second continuous EAPOL frame\n"));
 	DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
@@ -281,12 +281,12 @@ VOID WpaStaPairwiseKeySetting(IN PRTMP_ADAPTER pAd)
 
 	pEntry = &pAd->MacTab.Content[BSSID_WCID];
 
-	// Pairwise key shall use key#0
+	/* Pairwise key shall use key#0 */
 	pSharedKey = &pAd->SharedKey[BSS0][0];
 
 	NdisMoveMemory(pAd->StaCfg.PTK, pEntry->PTK, LEN_PTK);
 
-	// Prepare pair-wise key information into shared key table
+	/* Prepare pair-wise key information into shared key table */
 	NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 	pSharedKey->KeyLen = LEN_TKIP_EK;
 	NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32], LEN_TKIP_EK);
@@ -295,7 +295,7 @@ VOID WpaStaPairwiseKeySetting(IN PRTMP_ADAPTER pAd)
 	NdisMoveMemory(pSharedKey->TxMic,
 		       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
 
-	// Decide its ChiperAlg
+	/* Decide its ChiperAlg */
 	if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
 		pSharedKey->CipherAlg = CIPHER_TKIP;
 	else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
@@ -303,7 +303,7 @@ VOID WpaStaPairwiseKeySetting(IN PRTMP_ADAPTER pAd)
 	else
 		pSharedKey->CipherAlg = CIPHER_NONE;
 
-	// Update these related information to MAC_TABLE_ENTRY
+	/* Update these related information to MAC_TABLE_ENTRY */
 	NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32],
 		       LEN_TKIP_EK);
 	NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48],
@@ -312,7 +312,7 @@ VOID WpaStaPairwiseKeySetting(IN PRTMP_ADAPTER pAd)
 		       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
 	pEntry->PairwiseKey.CipherAlg = pSharedKey->CipherAlg;
 
-	// Update pairwise key information to ASIC Shared Key Table
+	/* Update pairwise key information to ASIC Shared Key Table */
 	AsicAddSharedKeyEntry(pAd,
 			      BSS0,
 			      0,
@@ -320,7 +320,7 @@ VOID WpaStaPairwiseKeySetting(IN PRTMP_ADAPTER pAd)
 			      pSharedKey->Key,
 			      pSharedKey->TxMic, pSharedKey->RxMic);
 
-	// Update ASIC WCID attribute table and IVEIV table
+	/* Update ASIC WCID attribute table and IVEIV table */
 	RTMPAddWcidAttributeEntry(pAd, BSS0, 0, pSharedKey->CipherAlg, pEntry);
 	STA_PORT_SECURED(pAd);
 	pAd->IndicateMediaState = NdisMediaStateConnected;
@@ -336,7 +336,7 @@ VOID WpaStaGroupKeySetting(IN PRTMP_ADAPTER pAd)
 
 	pSharedKey = &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId];
 
-	// Prepare pair-wise key information into shared key table
+	/* Prepare pair-wise key information into shared key table */
 	NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 	pSharedKey->KeyLen = LEN_TKIP_EK;
 	NdisMoveMemory(pSharedKey->Key, pAd->StaCfg.GTK, LEN_TKIP_EK);
@@ -345,7 +345,7 @@ VOID WpaStaGroupKeySetting(IN PRTMP_ADAPTER pAd)
 	NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24],
 		       LEN_TKIP_TXMICK);
 
-	// Update Shared Key CipherAlg
+	/* Update Shared Key CipherAlg */
 	pSharedKey->CipherAlg = CIPHER_NONE;
 	if (pAd->StaCfg.GroupCipher == Ndis802_11Encryption2Enabled)
 		pSharedKey->CipherAlg = CIPHER_TKIP;
@@ -356,7 +356,7 @@ VOID WpaStaGroupKeySetting(IN PRTMP_ADAPTER pAd)
 	else if (pAd->StaCfg.GroupCipher == Ndis802_11GroupWEP104Enabled)
 		pSharedKey->CipherAlg = CIPHER_WEP128;
 
-	// Update group key information to ASIC Shared Key Table
+	/* Update group key information to ASIC Shared Key Table */
 	AsicAddSharedKeyEntry(pAd,
 			      BSS0,
 			      pAd->StaCfg.DefaultKeyId,
@@ -364,7 +364,7 @@ VOID WpaStaGroupKeySetting(IN PRTMP_ADAPTER pAd)
 			      pSharedKey->Key,
 			      pSharedKey->TxMic, pSharedKey->RxMic);
 
-	// Update ASIC WCID attribute table and IVEIV table
+	/* Update ASIC WCID attribute table and IVEIV table */
 	RTMPAddWcidAttributeEntry(pAd,
 				  BSS0,
 				  pAd->StaCfg.DefaultKeyId,
-- 
1.7.1

