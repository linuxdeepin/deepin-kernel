From 8d4698ccd2f45af1a84920f8ca0ae90e452c1c2d Mon Sep 17 00:00:00 2001
From: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date: Fri, 11 Dec 2009 12:23:14 -0800
Subject: [PATCH 20/42] Staging: rt28x0: run sta/*.c files through Lindent

commit 0f65bec15b2184dcf98dbdbf03187057de842eb5 upstream.

Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rt2860/sta/assoc.c     | 1579 ++++++++++++----------
 drivers/staging/rt2860/sta/auth.c      |  621 +++++----
 drivers/staging/rt2860/sta/auth_rsp.c  |  124 +-
 drivers/staging/rt2860/sta/connect.c   | 2348 +++++++++++++++++---------------
 drivers/staging/rt2860/sta/rtmp_data.c | 2196 +++++++++++++++---------------
 drivers/staging/rt2860/sta/sanity.c    |  489 ++++----
 drivers/staging/rt2860/sta/sync.c      | 2094 ++++++++++++++++-------------
 drivers/staging/rt2860/sta/wpa.c       |  272 ++--
 8 files changed, 5085 insertions(+), 4638 deletions(-)

diff --git a/drivers/staging/rt2860/sta/assoc.c b/drivers/staging/rt2860/sta/assoc.c
index a67e213..e977416 100644
--- a/drivers/staging/rt2860/sta/assoc.c
+++ b/drivers/staging/rt2860/sta/assoc.c
@@ -36,31 +36,31 @@
 */
 #include "../rt_config.h"
 
-UCHAR	CipherWpaTemplate[] = {
-		0xdd, 					// WPA IE
-		0x16,					// Length
-		0x00, 0x50, 0xf2, 0x01,	// oui
-		0x01, 0x00,				// Version
-		0x00, 0x50, 0xf2, 0x02,	// Multicast
-		0x01, 0x00,				// Number of unicast
-		0x00, 0x50, 0xf2, 0x02,	// unicast
-		0x01, 0x00,				// number of authentication method
-		0x00, 0x50, 0xf2, 0x01	// authentication
-		};
-
-UCHAR	CipherWpa2Template[] = {
-		0x30,					// RSN IE
-		0x14,					// Length
-		0x01, 0x00,				// Version
-		0x00, 0x0f, 0xac, 0x02,	// group cipher, TKIP
-		0x01, 0x00,				// number of pairwise
-		0x00, 0x0f, 0xac, 0x02,	// unicast
-		0x01, 0x00,				// number of authentication method
-		0x00, 0x0f, 0xac, 0x02,	// authentication
-		0x00, 0x00,				// RSN capability
-		};
-
-UCHAR	Ccx2IeInfo[] = { 0x00, 0x40, 0x96, 0x03, 0x02};
+UCHAR CipherWpaTemplate[] = {
+	0xdd,			// WPA IE
+	0x16,			// Length
+	0x00, 0x50, 0xf2, 0x01,	// oui
+	0x01, 0x00,		// Version
+	0x00, 0x50, 0xf2, 0x02,	// Multicast
+	0x01, 0x00,		// Number of unicast
+	0x00, 0x50, 0xf2, 0x02,	// unicast
+	0x01, 0x00,		// number of authentication method
+	0x00, 0x50, 0xf2, 0x01	// authentication
+};
+
+UCHAR CipherWpa2Template[] = {
+	0x30,			// RSN IE
+	0x14,			// Length
+	0x01, 0x00,		// Version
+	0x00, 0x0f, 0xac, 0x02,	// group cipher, TKIP
+	0x01, 0x00,		// number of pairwise
+	0x00, 0x0f, 0xac, 0x02,	// unicast
+	0x01, 0x00,		// number of authentication method
+	0x00, 0x0f, 0xac, 0x02,	// authentication
+	0x00, 0x00,		// RSN capability
+};
+
+UCHAR Ccx2IeInfo[] = { 0x00, 0x40, 0x96, 0x03, 0x02 };
 
 /*
 	==========================================================================
@@ -73,55 +73,84 @@ UCHAR	Ccx2IeInfo[] = { 0x00, 0x40, 0x96, 0x03, 0x02};
 
 	==========================================================================
  */
-VOID AssocStateMachineInit(
-	IN	PRTMP_ADAPTER	pAd,
-	IN  STATE_MACHINE *S,
-	OUT STATE_MACHINE_FUNC Trans[])
+VOID AssocStateMachineInit(IN PRTMP_ADAPTER pAd,
+			   IN STATE_MACHINE * S, OUT STATE_MACHINE_FUNC Trans[])
 {
-	StateMachineInit(S, Trans, MAX_ASSOC_STATE, MAX_ASSOC_MSG, (STATE_MACHINE_FUNC)Drop, ASSOC_IDLE, ASSOC_MACHINE_BASE);
+	StateMachineInit(S, Trans, MAX_ASSOC_STATE, MAX_ASSOC_MSG,
+			 (STATE_MACHINE_FUNC) Drop, ASSOC_IDLE,
+			 ASSOC_MACHINE_BASE);
 
 	// first column
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)MlmeAssocReqAction);
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)MlmeReassocReqAction);
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)MlmeDisassocReqAction);
-	StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_ASSOC_REQ,
+			      (STATE_MACHINE_FUNC) MlmeAssocReqAction);
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_REASSOC_REQ,
+			      (STATE_MACHINE_FUNC) MlmeReassocReqAction);
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_MLME_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC) MlmeDisassocReqAction);
+	StateMachineSetAction(S, ASSOC_IDLE, MT2_PEER_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC) PeerDisassocAction);
 
 	// second column
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP, (STATE_MACHINE_FUNC)PeerAssocRspAction);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenReassoc);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC)
+			      InvalidStateWhenDisassociate);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC) PeerDisassocAction);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP,
+			      (STATE_MACHINE_FUNC) PeerAssocRspAction);
 	//
 	// Patch 3Com AP MOde:3CRWE454G72
 	// We send Assoc request frame to this AP, it always send Reassoc Rsp not Associate Rsp.
 	//
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP, (STATE_MACHINE_FUNC)PeerAssocRspAction);
-	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT, (STATE_MACHINE_FUNC)AssocTimeoutAction);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP,
+			      (STATE_MACHINE_FUNC) PeerAssocRspAction);
+	StateMachineSetAction(S, ASSOC_WAIT_RSP, MT2_ASSOC_TIMEOUT,
+			      (STATE_MACHINE_FUNC) AssocTimeoutAction);
 
 	// third column
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP, (STATE_MACHINE_FUNC)PeerReassocRspAction);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenReassoc);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC)
+			      InvalidStateWhenDisassociate);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC) PeerDisassocAction);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_REASSOC_RSP,
+			      (STATE_MACHINE_FUNC) PeerReassocRspAction);
 	//
 	// Patch, AP doesn't send Reassociate Rsp frame to Station.
 	//
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP, (STATE_MACHINE_FUNC)PeerReassocRspAction);
-	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT, (STATE_MACHINE_FUNC)ReassocTimeoutAction);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_PEER_ASSOC_RSP,
+			      (STATE_MACHINE_FUNC) PeerReassocRspAction);
+	StateMachineSetAction(S, REASSOC_WAIT_RSP, MT2_REASSOC_TIMEOUT,
+			      (STATE_MACHINE_FUNC) ReassocTimeoutAction);
 
 	// fourth column
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAssoc);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenReassoc);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenDisassociate);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ, (STATE_MACHINE_FUNC)PeerDisassocAction);
-	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT, (STATE_MACHINE_FUNC)DisassocTimeoutAction);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_ASSOC_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenAssoc);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_REASSOC_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenReassoc);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_MLME_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC)
+			      InvalidStateWhenDisassociate);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_PEER_DISASSOC_REQ,
+			      (STATE_MACHINE_FUNC) PeerDisassocAction);
+	StateMachineSetAction(S, DISASSOC_WAIT_RSP, MT2_DISASSOC_TIMEOUT,
+			      (STATE_MACHINE_FUNC) DisassocTimeoutAction);
 
 	// initialize the timer
-	RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer, GET_TIMER_FUNCTION(AssocTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer, GET_TIMER_FUNCTION(ReassocTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.DisassocTimer, GET_TIMER_FUNCTION(DisassocTimeout), pAd, FALSE);
+	RTMPInitTimer(pAd, &pAd->MlmeAux.AssocTimer,
+		      GET_TIMER_FUNCTION(AssocTimeout), pAd, FALSE);
+	RTMPInitTimer(pAd, &pAd->MlmeAux.ReassocTimer,
+		      GET_TIMER_FUNCTION(ReassocTimeout), pAd, FALSE);
+	RTMPInitTimer(pAd, &pAd->MlmeAux.DisassocTimer,
+		      GET_TIMER_FUNCTION(DisassocTimeout), pAd, FALSE);
 }
 
 /*
@@ -137,15 +166,15 @@ VOID AssocStateMachineInit(
 	==========================================================================
  */
 VOID AssocTimeout(IN PVOID SystemSpecific1,
-				 IN PVOID FunctionContext,
-				 IN PVOID SystemSpecific2,
-				 IN PVOID SystemSpecific3)
+		  IN PVOID FunctionContext,
+		  IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_ASSOC_TIMEOUT, 0, NULL);
@@ -165,15 +194,15 @@ VOID AssocTimeout(IN PVOID SystemSpecific1,
 	==========================================================================
  */
 VOID ReassocTimeout(IN PVOID SystemSpecific1,
-					IN PVOID FunctionContext,
-					IN PVOID SystemSpecific2,
-					IN PVOID SystemSpecific3)
+		    IN PVOID FunctionContext,
+		    IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_REASSOC_TIMEOUT, 0, NULL);
@@ -193,15 +222,15 @@ VOID ReassocTimeout(IN PVOID SystemSpecific1,
 	==========================================================================
  */
 VOID DisassocTimeout(IN PVOID SystemSpecific1,
-					IN PVOID FunctionContext,
-					IN PVOID SystemSpecific2,
-					IN PVOID SystemSpecific3)
+		     IN PVOID FunctionContext,
+		     IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_DISASSOC_TIMEOUT, 0, NULL);
@@ -230,136 +259,145 @@ VOID DisassocTimeout(IN PVOID SystemSpecific1,
 
 	==========================================================================
  */
-VOID MlmeAssocReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeAssocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR			ApAddr[6];
-	HEADER_802_11	AssocHdr;
-	UCHAR			WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
-	USHORT			ListenIntv;
-	ULONG			Timeout;
-	USHORT			CapabilityInfo;
-	BOOLEAN			TimerCancelled;
-	PUCHAR			pOutBuffer = NULL;
-	NDIS_STATUS		NStatus;
-	ULONG			FrameLen = 0;
-	ULONG			tmp;
-	USHORT			VarIesOffset;
-	USHORT			Status;
+	UCHAR ApAddr[6];
+	HEADER_802_11 AssocHdr;
+	UCHAR WmeIe[9] =
+	    { IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01,
+       0x00 };
+	USHORT ListenIntv;
+	ULONG Timeout;
+	USHORT CapabilityInfo;
+	BOOLEAN TimerCancelled;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	ULONG FrameLen = 0;
+	ULONG tmp;
+	USHORT VarIesOffset;
+	USHORT Status;
 
 	// Block all authentication request durning WPA block period
-	if (pAd->StaCfg.bBlockAssoc == TRUE)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - Block Assoc request durning WPA block period!\n"));
+	if (pAd->StaCfg.bBlockAssoc == TRUE) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - Block Assoc request durning WPA block period!\n"));
 		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 		Status = MLME_STATE_MACHINE_REJECT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2,
+			    &Status);
 	}
 	// check sanity first
-	else if (MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
-	{
+	else if (MlmeAssocReqSanity
+		 (pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo,
+		  &Timeout, &ListenIntv)) {
 		RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &TimerCancelled);
 		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
 
 		// Get an unused nonpaged memory
 		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
-		if (NStatus != NDIS_STATUS_SUCCESS)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("ASSOC - MlmeAssocReqAction() allocate memory failed \n"));
+		if (NStatus != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("ASSOC - MlmeAssocReqAction() allocate memory failed \n"));
 			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 			Status = MLME_FAIL_NO_RESOURCE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
+				    MT2_ASSOC_CONF, 2, &Status);
 			return;
 		}
-
 		// Add by James 03/06/27
-		pAd->StaCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+		pAd->StaCfg.AssocInfo.Length =
+		    sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
 		// Association don't need to report MAC address
 		pAd->StaCfg.AssocInfo.AvailableRequestFixedIEs =
-			NDIS_802_11_AI_REQFI_CAPABILITIES | NDIS_802_11_AI_REQFI_LISTENINTERVAL;
-		pAd->StaCfg.AssocInfo.RequestFixedIEs.Capabilities = CapabilityInfo;
-		pAd->StaCfg.AssocInfo.RequestFixedIEs.ListenInterval = ListenIntv;
+		    NDIS_802_11_AI_REQFI_CAPABILITIES |
+		    NDIS_802_11_AI_REQFI_LISTENINTERVAL;
+		pAd->StaCfg.AssocInfo.RequestFixedIEs.Capabilities =
+		    CapabilityInfo;
+		pAd->StaCfg.AssocInfo.RequestFixedIEs.ListenInterval =
+		    ListenIntv;
 		// Only reassociate need this
 		//COPY_MAC_ADDR(pAd->StaCfg.AssocInfo.RequestFixedIEs.CurrentAPAddress, ApAddr);
-		pAd->StaCfg.AssocInfo.OffsetRequestIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+		pAd->StaCfg.AssocInfo.OffsetRequestIEs =
+		    sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
 
-        NdisZeroMemory(pAd->StaCfg.ReqVarIEs, MAX_VIE_LEN);
+		NdisZeroMemory(pAd->StaCfg.ReqVarIEs, MAX_VIE_LEN);
 		// First add SSID
 		VarIesOffset = 0;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SsidIe, 1);
+		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SsidIe,
+			       1);
 		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SsidLen, 1);
+		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
+			       &pAd->MlmeAux.SsidLen, 1);
 		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
+			       pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
 		VarIesOffset += pAd->MlmeAux.SsidLen;
 
 		// Second add Supported rates
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SupRateIe, 1);
+		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &SupRateIe,
+			       1);
 		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &pAd->MlmeAux.SupRateLen, 1);
+		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
+			       &pAd->MlmeAux.SupRateLen, 1);
 		VarIesOffset += 1;
-		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
+		NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
+			       pAd->MlmeAux.SupRate, pAd->MlmeAux.SupRateLen);
 		VarIesOffset += pAd->MlmeAux.SupRateLen;
 		// End Add by James
 
-        if ((pAd->CommonCfg.Channel > 14) &&
-            (pAd->CommonCfg.bIEEE80211H == TRUE))
-            CapabilityInfo |= 0x0100;
+		if ((pAd->CommonCfg.Channel > 14) &&
+		    (pAd->CommonCfg.bIEEE80211H == TRUE))
+			CapabilityInfo |= 0x0100;
 
 		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - Send ASSOC request...\n"));
-		MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, ApAddr, ApAddr);
+		MgtMacHeaderInit(pAd, &AssocHdr, SUBTYPE_ASSOC_REQ, 0, ApAddr,
+				 ApAddr);
 
 		// Build basic frame first
-		MakeOutgoingFrame(pOutBuffer,				&FrameLen,
-						  sizeof(HEADER_802_11),	&AssocHdr,
-						  2,						&CapabilityInfo,
-						  2,						&ListenIntv,
-						  1,						&SsidIe,
-						  1,						&pAd->MlmeAux.SsidLen,
-						  pAd->MlmeAux.SsidLen, 	pAd->MlmeAux.Ssid,
-						  1,						&SupRateIe,
-						  1,						&pAd->MlmeAux.SupRateLen,
-						  pAd->MlmeAux.SupRateLen,  pAd->MlmeAux.SupRate,
-						  END_OF_ARGS);
-
-		if (pAd->MlmeAux.ExtRateLen != 0)
-		{
-			MakeOutgoingFrame(pOutBuffer + FrameLen,    &tmp,
-							  1,                        &ExtRateIe,
-							  1,                        &pAd->MlmeAux.ExtRateLen,
-							  pAd->MlmeAux.ExtRateLen,  pAd->MlmeAux.ExtRate,
-							  END_OF_ARGS);
+		MakeOutgoingFrame(pOutBuffer, &FrameLen,
+				  sizeof(HEADER_802_11), &AssocHdr,
+				  2, &CapabilityInfo,
+				  2, &ListenIntv,
+				  1, &SsidIe,
+				  1, &pAd->MlmeAux.SsidLen,
+				  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid,
+				  1, &SupRateIe,
+				  1, &pAd->MlmeAux.SupRateLen,
+				  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
+				  END_OF_ARGS);
+
+		if (pAd->MlmeAux.ExtRateLen != 0) {
+			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+					  1, &ExtRateIe,
+					  1, &pAd->MlmeAux.ExtRateLen,
+					  pAd->MlmeAux.ExtRateLen,
+					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
 			FrameLen += tmp;
 		}
-
 		// HT
-		if ((pAd->MlmeAux.HtCapabilityLen > 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
-		{
+		if ((pAd->MlmeAux.HtCapabilityLen > 0)
+		    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
 			ULONG TmpLen;
 			UCHAR HtLen;
-			UCHAR BROADCOM[4] = {0x0, 0x90, 0x4c, 0x33};
-			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE)
-			{
+			UCHAR BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
+			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE) {
 				HtLen = SIZE_HT_CAP_IE + 4;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &TmpLen,
-							  1,                                &WpaIe,
-							  1,                                &HtLen,
-							  4,                                &BROADCOM[0],
-							 pAd->MlmeAux.HtCapabilityLen,          &pAd->MlmeAux.HtCapability,
-							  END_OF_ARGS);
-			}
-			else
-			{
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &TmpLen,
-							  1,                                &HtCapIe,
-							  1,                                &pAd->MlmeAux.HtCapabilityLen,
-							 pAd->MlmeAux.HtCapabilityLen,          &pAd->MlmeAux.HtCapability,
-							  END_OF_ARGS);
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 1, &WpaIe, 1, &HtLen,
+						  4, &BROADCOM[0],
+						  pAd->MlmeAux.HtCapabilityLen,
+						  &pAd->MlmeAux.HtCapability,
+						  END_OF_ARGS);
+			} else {
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 1, &HtCapIe, 1,
+						  &pAd->MlmeAux.HtCapabilityLen,
+						  pAd->MlmeAux.HtCapabilityLen,
+						  &pAd->MlmeAux.HtCapability,
+						  END_OF_ARGS);
 			}
 			FrameLen += TmpLen;
 		}
-
 		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION
 		// Case I: (Aggregation + Piggy-Back)
 		// 1. user enable aggregation, AND
@@ -368,63 +406,60 @@ VOID MlmeAssocReqAction(
 		// Case II: (Aggregation)
 		// 1. user enable aggregation, AND
 		// 2. AP annouces it's AGGREGATION-capable in BEACON
-		if (pAd->CommonCfg.bAggregationCapable)
-		{
-			if ((pAd->CommonCfg.bPiggyBackCapable) && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3))
-			{
+		if (pAd->CommonCfg.bAggregationCapable) {
+			if ((pAd->CommonCfg.bPiggyBackCapable)
+			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
 				ULONG TmpLen;
-				UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x03, 0x00, 0x00, 0x00};
-				MakeOutgoingFrame(pOutBuffer+FrameLen,           &TmpLen,
-								  9,                             RalinkIe,
-								  END_OF_ARGS);
+				UCHAR RalinkIe[9] =
+				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
+			    0x03, 0x00, 0x00, 0x00 };
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 9, RalinkIe,
+						  END_OF_ARGS);
 				FrameLen += TmpLen;
-			}
-			else if (pAd->MlmeAux.APRalinkIe & 0x00000001)
-			{
+			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
 				ULONG TmpLen;
-				UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00};
-				MakeOutgoingFrame(pOutBuffer+FrameLen,           &TmpLen,
-								  9,                             RalinkIe,
-								  END_OF_ARGS);
+				UCHAR RalinkIe[9] =
+				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
+			    0x01, 0x00, 0x00, 0x00 };
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 9, RalinkIe,
+						  END_OF_ARGS);
 				FrameLen += TmpLen;
 			}
-		}
-		else
-		{
+		} else {
 			ULONG TmpLen;
-			UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x06, 0x00, 0x00, 0x00};
-			MakeOutgoingFrame(pOutBuffer+FrameLen,		 &TmpLen,
-							  9,						 RalinkIe,
-							  END_OF_ARGS);
+			UCHAR RalinkIe[9] =
+			    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x06,
+		    0x00, 0x00, 0x00 };
+			MakeOutgoingFrame(pOutBuffer + FrameLen, &TmpLen, 9,
+					  RalinkIe, END_OF_ARGS);
 			FrameLen += TmpLen;
 		}
 
-		if (pAd->MlmeAux.APEdcaParm.bValid)
-		{
-			if (pAd->CommonCfg.bAPSDCapable && pAd->MlmeAux.APEdcaParm.bAPSDCapable)
-			{
+		if (pAd->MlmeAux.APEdcaParm.bValid) {
+			if (pAd->CommonCfg.bAPSDCapable
+			    && pAd->MlmeAux.APEdcaParm.bAPSDCapable) {
 				QBSS_STA_INFO_PARM QosInfo;
 
-				NdisZeroMemory(&QosInfo, sizeof(QBSS_STA_INFO_PARM));
+				NdisZeroMemory(&QosInfo,
+					       sizeof(QBSS_STA_INFO_PARM));
 				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.bAPSDAC_BE;
 				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.bAPSDAC_BK;
 				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.bAPSDAC_VI;
 				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.bAPSDAC_VO;
-				QosInfo.MaxSPLength = pAd->CommonCfg.MaxSPLength;
-				WmeIe[8] |= *(PUCHAR)&QosInfo;
-			}
-			else
-			{
-                // The Parameter Set Count is set to ¡§0¡¨ in the association request frames
-                // WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
+				QosInfo.MaxSPLength =
+				    pAd->CommonCfg.MaxSPLength;
+				WmeIe[8] |= *(PUCHAR) & QosInfo;
+			} else {
+				// The Parameter Set Count is set to ¡§0¡¨ in the association request frames
+				// WmeIe[8] |= (pAd->MlmeAux.APEdcaParm.EdcaUpdateCount & 0x0f);
 			}
 
-			MakeOutgoingFrame(pOutBuffer + FrameLen,    &tmp,
-							  9,                        &WmeIe[0],
-							  END_OF_ARGS);
+			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+					  9, &WmeIe[0], END_OF_ARGS);
 			FrameLen += tmp;
 		}
-
 		//
 		// Let WPA(#221) Element ID on the end of this association frame.
 		// Otherwise some AP will fail on parsing Element ID and set status fail on Assoc Rsp.
@@ -432,94 +467,107 @@ VOID MlmeAssocReqAction(
 		// This happens on AP (Model No:Linksys WRK54G)
 		//
 		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-            (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
-            (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-            (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
-			)
-            )
-		{
+		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
+		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+		    )
+		    ) {
 			UCHAR RSNIe = IE_WPA;
 
-			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK) ||
-                (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2))
-			{
+			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+			    || (pAd->StaCfg.AuthMode ==
+				Ndis802_11AuthModeWPA2)) {
 				RSNIe = IE_WPA2;
 			}
 
-			if ((pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_ENABLE) &&
-				(pAd->StaCfg.bRSN_IE_FromWpaSupplicant == FALSE))
-            RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, BSS0);
+			if ((pAd->StaCfg.WpaSupplicantUP !=
+			     WPA_SUPPLICANT_ENABLE)
+			    && (pAd->StaCfg.bRSN_IE_FromWpaSupplicant == FALSE))
+				RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode,
+					      pAd->StaCfg.WepStatus, BSS0);
 
-            // Check for WPA PMK cache list
-			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
-			{
-			    INT     idx;
-                BOOLEAN FoundPMK = FALSE;
+			// Check for WPA PMK cache list
+			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) {
+				INT idx;
+				BOOLEAN FoundPMK = FALSE;
 				// Search chched PMKID, append it if existed
-				for (idx = 0; idx < PMKID_NO; idx++)
-				{
-					if (NdisEqualMemory(ApAddr, &pAd->StaCfg.SavedPMK[idx].BSSID, 6))
-					{
+				for (idx = 0; idx < PMKID_NO; idx++) {
+					if (NdisEqualMemory
+					    (ApAddr,
+					     &pAd->StaCfg.SavedPMK[idx].BSSID,
+					     6)) {
 						FoundPMK = TRUE;
 						break;
 					}
 				}
-				if (FoundPMK)
-				{
+				if (FoundPMK) {
 					// Set PMK number
-					*(PUSHORT) &pAd->StaCfg.RSN_IE[pAd->StaCfg.RSNIE_Len] = 1;
-					NdisMoveMemory(&pAd->StaCfg.RSN_IE[pAd->StaCfg.RSNIE_Len + 2], &pAd->StaCfg.SavedPMK[idx].PMKID, 16);
-                    pAd->StaCfg.RSNIE_Len += 18;
+					*(PUSHORT) & pAd->StaCfg.RSN_IE[pAd->
+									StaCfg.
+									RSNIE_Len]
+					    = 1;
+					NdisMoveMemory(&pAd->StaCfg.
+						       RSN_IE[pAd->StaCfg.
+							      RSNIE_Len + 2],
+						       &pAd->StaCfg.
+						       SavedPMK[idx].PMKID, 16);
+					pAd->StaCfg.RSNIE_Len += 18;
 				}
 			}
 
-			if ((pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_ENABLE) &&
-				(pAd->StaCfg.bRSN_IE_FromWpaSupplicant == TRUE))
-			{
-				MakeOutgoingFrame(pOutBuffer + FrameLen,    		&tmp,
-		                        	pAd->StaCfg.RSNIE_Len,			pAd->StaCfg.RSN_IE,
-		                        	END_OF_ARGS);
-			}
-			else
-			{
-				MakeOutgoingFrame(pOutBuffer + FrameLen,    		&tmp,
-				              		1,                              &RSNIe,
-		                        	1,                              &pAd->StaCfg.RSNIE_Len,
-		                        	pAd->StaCfg.RSNIE_Len,			pAd->StaCfg.RSN_IE,
-		                        	END_OF_ARGS);
+			if ((pAd->StaCfg.WpaSupplicantUP ==
+			     WPA_SUPPLICANT_ENABLE)
+			    && (pAd->StaCfg.bRSN_IE_FromWpaSupplicant ==
+				TRUE)) {
+				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+						  pAd->StaCfg.RSNIE_Len,
+						  pAd->StaCfg.RSN_IE,
+						  END_OF_ARGS);
+			} else {
+				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+						  1, &RSNIe,
+						  1, &pAd->StaCfg.RSNIE_Len,
+						  pAd->StaCfg.RSNIE_Len,
+						  pAd->StaCfg.RSN_IE,
+						  END_OF_ARGS);
 			}
 
 			FrameLen += tmp;
 
-			if ((pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_ENABLE) ||
-				(pAd->StaCfg.bRSN_IE_FromWpaSupplicant == FALSE))
-			{
-	            // Append Variable IE
-	            NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &RSNIe, 1);
-	            VarIesOffset += 1;
-	            NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, &pAd->StaCfg.RSNIE_Len, 1);
-	            VarIesOffset += 1;
+			if ((pAd->StaCfg.WpaSupplicantUP !=
+			     WPA_SUPPLICANT_ENABLE)
+			    || (pAd->StaCfg.bRSN_IE_FromWpaSupplicant ==
+				FALSE)) {
+				// Append Variable IE
+				NdisMoveMemory(pAd->StaCfg.ReqVarIEs +
+					       VarIesOffset, &RSNIe, 1);
+				VarIesOffset += 1;
+				NdisMoveMemory(pAd->StaCfg.ReqVarIEs +
+					       VarIesOffset,
+					       &pAd->StaCfg.RSNIE_Len, 1);
+				VarIesOffset += 1;
 			}
-			NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset, pAd->StaCfg.RSN_IE, pAd->StaCfg.RSNIE_Len);
+			NdisMoveMemory(pAd->StaCfg.ReqVarIEs + VarIesOffset,
+				       pAd->StaCfg.RSN_IE,
+				       pAd->StaCfg.RSNIE_Len);
 			VarIesOffset += pAd->StaCfg.RSNIE_Len;
 
 			// Set Variable IEs Length
 			pAd->StaCfg.ReqVarIELen = VarIesOffset;
 		}
 
-
 		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer);
 
 		RTMPSetTimer(&pAd->MlmeAux.AssocTimer, Timeout);
 		pAd->Mlme.AssocMachine.CurrState = ASSOC_WAIT_RSP;
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("ASSOC - MlmeAssocReqAction() sanity check failed. BUG!!!!!! \n"));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - MlmeAssocReqAction() sanity check failed. BUG!!!!!! \n"));
 		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2,
+			    &Status);
 	}
 
 }
@@ -541,121 +589,117 @@ VOID MlmeAssocReqAction(
 
 	==========================================================================
  */
-VOID MlmeReassocReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeReassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR			ApAddr[6];
-	HEADER_802_11	ReassocHdr;
-	UCHAR			WmeIe[9] = {IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
-	USHORT			CapabilityInfo, ListenIntv;
-	ULONG			Timeout;
-	ULONG			FrameLen = 0;
-	BOOLEAN			TimerCancelled;
-	NDIS_STATUS		NStatus;
-	ULONG			tmp;
-	PUCHAR			pOutBuffer = NULL;
-	USHORT			Status;
+	UCHAR ApAddr[6];
+	HEADER_802_11 ReassocHdr;
+	UCHAR WmeIe[9] =
+	    { IE_VENDOR_SPECIFIC, 0x07, 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01,
+       0x00 };
+	USHORT CapabilityInfo, ListenIntv;
+	ULONG Timeout;
+	ULONG FrameLen = 0;
+	BOOLEAN TimerCancelled;
+	NDIS_STATUS NStatus;
+	ULONG tmp;
+	PUCHAR pOutBuffer = NULL;
+	USHORT Status;
 
 	// Block all authentication request durning WPA block period
-	if (pAd->StaCfg.bBlockAssoc == TRUE)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - Block ReAssoc request durning WPA block period!\n"));
+	if (pAd->StaCfg.bBlockAssoc == TRUE) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - Block ReAssoc request durning WPA block period!\n"));
 		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 		Status = MLME_STATE_MACHINE_REJECT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2,
+			    &Status);
 	}
 	// the parameters are the same as the association
-	else if(MlmeAssocReqSanity(pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo, &Timeout, &ListenIntv))
-	{
+	else if (MlmeAssocReqSanity
+		 (pAd, Elem->Msg, Elem->MsgLen, ApAddr, &CapabilityInfo,
+		  &Timeout, &ListenIntv)) {
 		RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &TimerCancelled);
 
-		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-		if(NStatus != NDIS_STATUS_SUCCESS)
-		{
-			DBGPRINT(RT_DEBUG_TRACE,("ASSOC - MlmeReassocReqAction() allocate memory failed \n"));
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("ASSOC - MlmeReassocReqAction() allocate memory failed \n"));
 			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 			Status = MLME_FAIL_NO_RESOURCE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
+				    MT2_REASSOC_CONF, 2, &Status);
 			return;
 		}
 
 		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, ApAddr);
 
 		// make frame, use bssid as the AP address??
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - Send RE-ASSOC request...\n"));
-		MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0, ApAddr, ApAddr);
-		MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-						  sizeof(HEADER_802_11),    &ReassocHdr,
-						  2,                        &CapabilityInfo,
-						  2,                        &ListenIntv,
-						  MAC_ADDR_LEN,             ApAddr,
-						  1,                        &SsidIe,
-						  1,                        &pAd->MlmeAux.SsidLen,
-						  pAd->MlmeAux.SsidLen,     pAd->MlmeAux.Ssid,
-						  1,                        &SupRateIe,
-						  1,						&pAd->MlmeAux.SupRateLen,
-						  pAd->MlmeAux.SupRateLen,  pAd->MlmeAux.SupRate,
-						  END_OF_ARGS);
-
-		if (pAd->MlmeAux.ExtRateLen != 0)
-		{
-			MakeOutgoingFrame(pOutBuffer + FrameLen,        &tmp,
-							  1,                            &ExtRateIe,
-							  1,                            &pAd->MlmeAux.ExtRateLen,
-							  pAd->MlmeAux.ExtRateLen,	    pAd->MlmeAux.ExtRate,
-							  END_OF_ARGS);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - Send RE-ASSOC request...\n"));
+		MgtMacHeaderInit(pAd, &ReassocHdr, SUBTYPE_REASSOC_REQ, 0,
+				 ApAddr, ApAddr);
+		MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(HEADER_802_11),
+				  &ReassocHdr, 2, &CapabilityInfo, 2,
+				  &ListenIntv, MAC_ADDR_LEN, ApAddr, 1, &SsidIe,
+				  1, &pAd->MlmeAux.SsidLen,
+				  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid, 1,
+				  &SupRateIe, 1, &pAd->MlmeAux.SupRateLen,
+				  pAd->MlmeAux.SupRateLen, pAd->MlmeAux.SupRate,
+				  END_OF_ARGS);
+
+		if (pAd->MlmeAux.ExtRateLen != 0) {
+			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+					  1, &ExtRateIe,
+					  1, &pAd->MlmeAux.ExtRateLen,
+					  pAd->MlmeAux.ExtRateLen,
+					  pAd->MlmeAux.ExtRate, END_OF_ARGS);
 			FrameLen += tmp;
 		}
 
-		if (pAd->MlmeAux.APEdcaParm.bValid)
-		{
-			if (pAd->CommonCfg.bAPSDCapable && pAd->MlmeAux.APEdcaParm.bAPSDCapable)
-			{
+		if (pAd->MlmeAux.APEdcaParm.bValid) {
+			if (pAd->CommonCfg.bAPSDCapable
+			    && pAd->MlmeAux.APEdcaParm.bAPSDCapable) {
 				QBSS_STA_INFO_PARM QosInfo;
 
-				NdisZeroMemory(&QosInfo, sizeof(QBSS_STA_INFO_PARM));
+				NdisZeroMemory(&QosInfo,
+					       sizeof(QBSS_STA_INFO_PARM));
 				QosInfo.UAPSD_AC_BE = pAd->CommonCfg.bAPSDAC_BE;
 				QosInfo.UAPSD_AC_BK = pAd->CommonCfg.bAPSDAC_BK;
 				QosInfo.UAPSD_AC_VI = pAd->CommonCfg.bAPSDAC_VI;
 				QosInfo.UAPSD_AC_VO = pAd->CommonCfg.bAPSDAC_VO;
-				QosInfo.MaxSPLength = pAd->CommonCfg.MaxSPLength;
-				WmeIe[8] |= *(PUCHAR)&QosInfo;
+				QosInfo.MaxSPLength =
+				    pAd->CommonCfg.MaxSPLength;
+				WmeIe[8] |= *(PUCHAR) & QosInfo;
 			}
 
-			MakeOutgoingFrame(pOutBuffer + FrameLen,    &tmp,
-							  9,                        &WmeIe[0],
-							  END_OF_ARGS);
+			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+					  9, &WmeIe[0], END_OF_ARGS);
 			FrameLen += tmp;
 		}
-
 		// HT
-		if ((pAd->MlmeAux.HtCapabilityLen > 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
-		{
+		if ((pAd->MlmeAux.HtCapabilityLen > 0)
+		    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
 			ULONG TmpLen;
 			UCHAR HtLen;
-			UCHAR BROADCOM[4] = {0x0, 0x90, 0x4c, 0x33};
-			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE)
-			{
+			UCHAR BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
+			if (pAd->StaActive.SupportedPhyInfo.bPreNHt == TRUE) {
 				HtLen = SIZE_HT_CAP_IE + 4;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &TmpLen,
-							  1,                                &WpaIe,
-							  1,                                &HtLen,
-							  4,                                &BROADCOM[0],
-							 pAd->MlmeAux.HtCapabilityLen,          &pAd->MlmeAux.HtCapability,
-							  END_OF_ARGS);
-			}
-			else
-			{
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &TmpLen,
-							  1,                                &HtCapIe,
-							  1,                                &pAd->MlmeAux.HtCapabilityLen,
-							 pAd->MlmeAux.HtCapabilityLen,          &pAd->MlmeAux.HtCapability,
-							  END_OF_ARGS);
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 1, &WpaIe, 1, &HtLen,
+						  4, &BROADCOM[0],
+						  pAd->MlmeAux.HtCapabilityLen,
+						  &pAd->MlmeAux.HtCapability,
+						  END_OF_ARGS);
+			} else {
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 1, &HtCapIe, 1,
+						  &pAd->MlmeAux.HtCapabilityLen,
+						  pAd->MlmeAux.HtCapabilityLen,
+						  &pAd->MlmeAux.HtCapability,
+						  END_OF_ARGS);
 			}
 			FrameLen += TmpLen;
 		}
-
 		// add Ralink proprietary IE to inform AP this STA is going to use AGGREGATION or PIGGY-BACK+AGGREGATION
 		// Case I: (Aggregation + Piggy-Back)
 		// 1. user enable aggregation, AND
@@ -664,49 +708,49 @@ VOID MlmeReassocReqAction(
 		// Case II: (Aggregation)
 		// 1. user enable aggregation, AND
 		// 2. AP annouces it's AGGREGATION-capable in BEACON
-		if (pAd->CommonCfg.bAggregationCapable)
-		{
-			if ((pAd->CommonCfg.bPiggyBackCapable) && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3))
-			{
+		if (pAd->CommonCfg.bAggregationCapable) {
+			if ((pAd->CommonCfg.bPiggyBackCapable)
+			    && ((pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)) {
 				ULONG TmpLen;
-				UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x03, 0x00, 0x00, 0x00};
-				MakeOutgoingFrame(pOutBuffer+FrameLen,           &TmpLen,
-								  9,                             RalinkIe,
-								  END_OF_ARGS);
+				UCHAR RalinkIe[9] =
+				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
+			    0x03, 0x00, 0x00, 0x00 };
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 9, RalinkIe,
+						  END_OF_ARGS);
 				FrameLen += TmpLen;
-			}
-			else if (pAd->MlmeAux.APRalinkIe & 0x00000001)
-			{
+			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
 				ULONG TmpLen;
-				UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x01, 0x00, 0x00, 0x00};
-				MakeOutgoingFrame(pOutBuffer+FrameLen,           &TmpLen,
-								  9,                             RalinkIe,
-								  END_OF_ARGS);
+				UCHAR RalinkIe[9] =
+				    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43,
+			    0x01, 0x00, 0x00, 0x00 };
+				MakeOutgoingFrame(pOutBuffer + FrameLen,
+						  &TmpLen, 9, RalinkIe,
+						  END_OF_ARGS);
 				FrameLen += TmpLen;
 			}
-		}
-		else
-		{
+		} else {
 			ULONG TmpLen;
-			UCHAR RalinkIe[9] = {IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x04, 0x00, 0x00, 0x00};
-			MakeOutgoingFrame(pOutBuffer+FrameLen,		 &TmpLen,
-							  9,						 RalinkIe,
-							  END_OF_ARGS);
+			UCHAR RalinkIe[9] =
+			    { IE_VENDOR_SPECIFIC, 7, 0x00, 0x0c, 0x43, 0x04,
+		    0x00, 0x00, 0x00 };
+			MakeOutgoingFrame(pOutBuffer + FrameLen, &TmpLen, 9,
+					  RalinkIe, END_OF_ARGS);
 			FrameLen += TmpLen;
 		}
 
 		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer);
 
-		RTMPSetTimer(&pAd->MlmeAux.ReassocTimer, Timeout); /* in mSec */
+		RTMPSetTimer(&pAd->MlmeAux.ReassocTimer, Timeout);	/* in mSec */
 		pAd->Mlme.AssocMachine.CurrState = REASSOC_WAIT_RSP;
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("ASSOC - MlmeReassocReqAction() sanity check failed. BUG!!!! \n"));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - MlmeReassocReqAction() sanity check failed. BUG!!!! \n"));
 		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2,
+			    &Status);
 	}
 }
 
@@ -721,52 +765,50 @@ VOID MlmeReassocReqAction(
 
 	==========================================================================
  */
-VOID MlmeDisassocReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeDisassocReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	PMLME_DISASSOC_REQ_STRUCT pDisassocReq;
-	HEADER_802_11         DisassocHdr;
-	PHEADER_802_11        pDisassocHdr;
-	PUCHAR                pOutBuffer = NULL;
-	ULONG                 FrameLen = 0;
-	NDIS_STATUS           NStatus;
-	BOOLEAN               TimerCancelled;
-	ULONG                 Timeout = 500;
-	USHORT                Status;
-
+	HEADER_802_11 DisassocHdr;
+	PHEADER_802_11 pDisassocHdr;
+	PUCHAR pOutBuffer = NULL;
+	ULONG FrameLen = 0;
+	NDIS_STATUS NStatus;
+	BOOLEAN TimerCancelled;
+	ULONG Timeout = 500;
+	USHORT Status;
 
 	// skip sanity check
-	pDisassocReq = (PMLME_DISASSOC_REQ_STRUCT)(Elem->Msg);
+	pDisassocReq = (PMLME_DISASSOC_REQ_STRUCT) (Elem->Msg);
 
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-	if (NStatus != NDIS_STATUS_SUCCESS)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - MlmeDisassocReqAction() allocate memory failed\n"));
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - MlmeDisassocReqAction() allocate memory failed\n"));
 		pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 		Status = MLME_FAIL_NO_RESOURCE;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2,
+			    &Status);
 		return;
 	}
 
-
-
 	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &TimerCancelled);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - Send DISASSOC request[BSSID::%02x:%02x:%02x:%02x:%02x:%02x (Reason=%d)\n",
-				pDisassocReq->Addr[0], pDisassocReq->Addr[1], pDisassocReq->Addr[2],
-				pDisassocReq->Addr[3], pDisassocReq->Addr[4], pDisassocReq->Addr[5], pDisassocReq->Reason));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("ASSOC - Send DISASSOC request[BSSID::%02x:%02x:%02x:%02x:%02x:%02x (Reason=%d)\n",
+		  pDisassocReq->Addr[0], pDisassocReq->Addr[1],
+		  pDisassocReq->Addr[2], pDisassocReq->Addr[3],
+		  pDisassocReq->Addr[4], pDisassocReq->Addr[5],
+		  pDisassocReq->Reason));
 	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pDisassocReq->Addr, pDisassocReq->Addr);	// patch peap ttls switching issue
-	MakeOutgoingFrame(pOutBuffer,           &FrameLen,
-					  sizeof(HEADER_802_11),&DisassocHdr,
-					  2,                    &pDisassocReq->Reason,
-					  END_OF_ARGS);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen,
+			  sizeof(HEADER_802_11), &DisassocHdr,
+			  2, &pDisassocReq->Reason, END_OF_ARGS);
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 
 	// To patch Instance and Buffalo(N) AP
 	// Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine
 	// Therefore, we send both of them.
-	pDisassocHdr = (PHEADER_802_11)pOutBuffer;
+	pDisassocHdr = (PHEADER_802_11) pOutBuffer;
 	pDisassocHdr->FC.SubType = SUBTYPE_DEAUTH;
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 
@@ -775,10 +817,9 @@ VOID MlmeDisassocReqAction(
 	pAd->StaCfg.DisassocReason = REASON_DISASSOC_STA_LEAVING;
 	COPY_MAC_ADDR(pAd->StaCfg.DisassocSta, pDisassocReq->Addr);
 
-	RTMPSetTimer(&pAd->MlmeAux.DisassocTimer, Timeout); /* in mSec */
+	RTMPSetTimer(&pAd->MlmeAux.DisassocTimer, Timeout);	/* in mSec */
 	pAd->Mlme.AssocMachine.CurrState = DISASSOC_WAIT_RSP;
 
-
 	RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
 
 }
@@ -794,71 +835,81 @@ VOID MlmeDisassocReqAction(
 
 	==========================================================================
  */
-VOID PeerAssocRspAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerAssocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT        CapabilityInfo, Status, Aid;
-	UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
-	UCHAR         ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
-	UCHAR         Addr2[MAC_ADDR_LEN];
-	BOOLEAN       TimerCancelled;
-	UCHAR         CkipFlag;
-	EDCA_PARM     EdcaParm;
-	HT_CAPABILITY_IE		HtCapability;
-	ADD_HT_INFO_IE		AddHtInfo;	// AP might use this additional ht info IE
-	UCHAR			HtCapabilityLen = 0;
-	UCHAR			AddHtInfoLen;
-	UCHAR			NewExtChannelOffset = 0xff;
-
-	if (PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen,
-		&HtCapability,&AddHtInfo, &HtCapabilityLen,&AddHtInfoLen,&NewExtChannelOffset, &EdcaParm, &CkipFlag))
-	{
+	USHORT CapabilityInfo, Status, Aid;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
+	UCHAR ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
+	UCHAR Addr2[MAC_ADDR_LEN];
+	BOOLEAN TimerCancelled;
+	UCHAR CkipFlag;
+	EDCA_PARM EdcaParm;
+	HT_CAPABILITY_IE HtCapability;
+	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	UCHAR HtCapabilityLen = 0;
+	UCHAR AddHtInfoLen;
+	UCHAR NewExtChannelOffset = 0xff;
+
+	if (PeerAssocRspSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status,
+	     &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &HtCapability,
+	     &AddHtInfo, &HtCapabilityLen, &AddHtInfoLen, &NewExtChannelOffset,
+	     &EdcaParm, &CkipFlag)) {
 		// The frame is for me ?
-		if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("PeerAssocRspAction():ASSOC - receive ASSOC_RSP to me (status=%d)\n", Status));
-			DBGPRINT(RT_DEBUG_TRACE, ("PeerAssocRspAction():MacTable [%d].AMsduSize = %d. ClientStatusFlags = 0x%lx \n",Elem->Wcid, pAd->MacTab.Content[BSSID_WCID].AMsduSize, pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
-			RTMPCancelTimer(&pAd->MlmeAux.AssocTimer, &TimerCancelled);
-
-
-			if(Status == MLME_SUCCESS)
-			{
-				UCHAR			MaxSupportedRateIn500Kbps = 0;
-				UCHAR			idx;
+		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PeerAssocRspAction():ASSOC - receive ASSOC_RSP to me (status=%d)\n",
+				  Status));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PeerAssocRspAction():MacTable [%d].AMsduSize = %d. ClientStatusFlags = 0x%lx \n",
+				  Elem->Wcid,
+				  pAd->MacTab.Content[BSSID_WCID].AMsduSize,
+				  pAd->MacTab.Content[BSSID_WCID].
+				  ClientStatusFlags));
+			RTMPCancelTimer(&pAd->MlmeAux.AssocTimer,
+					&TimerCancelled);
+
+			if (Status == MLME_SUCCESS) {
+				UCHAR MaxSupportedRateIn500Kbps = 0;
+				UCHAR idx;
 
 				// supported rates array may not be sorted. sort it and find the maximum rate
-			    for (idx=0; idx<SupRateLen; idx++)
-                {
-			        if (MaxSupportedRateIn500Kbps < (SupRate[idx] & 0x7f))
-			            MaxSupportedRateIn500Kbps = SupRate[idx] & 0x7f;
-			    }
-
-				for (idx=0; idx<ExtRateLen; idx++)
-			    {
-			        if (MaxSupportedRateIn500Kbps < (ExtRate[idx] & 0x7f))
-			            MaxSupportedRateIn500Kbps = ExtRate[idx] & 0x7f;
-                }
+				for (idx = 0; idx < SupRateLen; idx++) {
+					if (MaxSupportedRateIn500Kbps <
+					    (SupRate[idx] & 0x7f))
+						MaxSupportedRateIn500Kbps =
+						    SupRate[idx] & 0x7f;
+				}
+
+				for (idx = 0; idx < ExtRateLen; idx++) {
+					if (MaxSupportedRateIn500Kbps <
+					    (ExtRate[idx] & 0x7f))
+						MaxSupportedRateIn500Kbps =
+						    ExtRate[idx] & 0x7f;
+				}
 				// go to procedure listed on page 376
-				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen,
-					&EdcaParm, &HtCapability, HtCapabilityLen, &AddHtInfo);
+				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid,
+					      SupRate, SupRateLen, ExtRate,
+					      ExtRateLen, &EdcaParm,
+					      &HtCapability, HtCapabilityLen,
+					      &AddHtInfo);
 
 				StaAddMacTableEntry(pAd,
-									&pAd->MacTab.Content[BSSID_WCID],
-									MaxSupportedRateIn500Kbps,
-									&HtCapability,
-									HtCapabilityLen,
-									&AddHtInfo,
-									AddHtInfoLen,
-									CapabilityInfo);
+						    &pAd->MacTab.
+						    Content[BSSID_WCID],
+						    MaxSupportedRateIn500Kbps,
+						    &HtCapability,
+						    HtCapabilityLen, &AddHtInfo,
+						    AddHtInfoLen,
+						    CapabilityInfo);
 			}
 			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
+				    MT2_ASSOC_CONF, 2, &Status);
 		}
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - PeerAssocRspAction() sanity check fail\n"));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - PeerAssocRspAction() sanity check fail\n"));
 	}
 }
 
@@ -873,55 +924,62 @@ VOID PeerAssocRspAction(
 
 	==========================================================================
  */
-VOID PeerReassocRspAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerReassocRspAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT      CapabilityInfo;
-	USHORT      Status;
-	USHORT      Aid;
-	UCHAR       SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
-	UCHAR       ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
-	UCHAR       Addr2[MAC_ADDR_LEN];
-	UCHAR       CkipFlag;
-	BOOLEAN     TimerCancelled;
-	EDCA_PARM   EdcaParm;
-	HT_CAPABILITY_IE		HtCapability;
-	ADD_HT_INFO_IE		AddHtInfo;	// AP might use this additional ht info IE
-	UCHAR			HtCapabilityLen;
-	UCHAR			AddHtInfoLen;
-	UCHAR			NewExtChannelOffset = 0xff;
-
-	if(PeerAssocRspSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status, &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen,
-								&HtCapability,	&AddHtInfo, &HtCapabilityLen, &AddHtInfoLen,&NewExtChannelOffset, &EdcaParm, &CkipFlag))
-	{
-		if(MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid)) // The frame is for me ?
+	USHORT CapabilityInfo;
+	USHORT Status;
+	USHORT Aid;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES], SupRateLen;
+	UCHAR ExtRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRateLen;
+	UCHAR Addr2[MAC_ADDR_LEN];
+	UCHAR CkipFlag;
+	BOOLEAN TimerCancelled;
+	EDCA_PARM EdcaParm;
+	HT_CAPABILITY_IE HtCapability;
+	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	UCHAR HtCapabilityLen;
+	UCHAR AddHtInfoLen;
+	UCHAR NewExtChannelOffset = 0xff;
+
+	if (PeerAssocRspSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &CapabilityInfo, &Status,
+	     &Aid, SupRate, &SupRateLen, ExtRate, &ExtRateLen, &HtCapability,
+	     &AddHtInfo, &HtCapabilityLen, &AddHtInfoLen, &NewExtChannelOffset,
+	     &EdcaParm, &CkipFlag)) {
+		if (MAC_ADDR_EQUAL(Addr2, pAd->MlmeAux.Bssid))	// The frame is for me ?
 		{
-			DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - receive REASSOC_RSP to me (status=%d)\n", Status));
-			RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer, &TimerCancelled);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("ASSOC - receive REASSOC_RSP to me (status=%d)\n",
+				  Status));
+			RTMPCancelTimer(&pAd->MlmeAux.ReassocTimer,
+					&TimerCancelled);
 
-			if(Status == MLME_SUCCESS)
-			{
+			if (Status == MLME_SUCCESS) {
 				// go to procedure listed on page 376
-				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid, SupRate, SupRateLen, ExtRate, ExtRateLen,
-					 &EdcaParm, &HtCapability, HtCapabilityLen, &AddHtInfo);
-
+				AssocPostProc(pAd, Addr2, CapabilityInfo, Aid,
+					      SupRate, SupRateLen, ExtRate,
+					      ExtRateLen, &EdcaParm,
+					      &HtCapability, HtCapabilityLen,
+					      &AddHtInfo);
 
-                {
-                    wext_notify_event_assoc(pAd);
-                    RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, &pAd->MlmeAux.Bssid[0], NULL, 0);
-                }
-
-			}
+				{
+					wext_notify_event_assoc(pAd);
+					RtmpOSWrielessEventSend(pAd, SIOCGIWAP,
+								-1,
+								&pAd->MlmeAux.
+								Bssid[0], NULL,
+								0);
+				}
 
-				// CkipFlag is no use for reassociate
-				pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
-				MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
 			}
+			// CkipFlag is no use for reassociate
+			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
+				    MT2_REASSOC_CONF, 2, &Status);
 		}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - PeerReassocRspAction() sanity check fail\n"));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - PeerReassocRspAction() sanity check fail\n"));
 	}
 
 }
@@ -936,30 +994,18 @@ VOID PeerReassocRspAction(
 
 	==========================================================================
  */
-VOID AssocPostProc(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR pAddr2,
-	IN USHORT CapabilityInfo,
-	IN USHORT Aid,
-	IN UCHAR SupRate[],
-	IN UCHAR SupRateLen,
-	IN UCHAR ExtRate[],
-	IN UCHAR ExtRateLen,
-	IN PEDCA_PARM pEdcaParm,
-	IN HT_CAPABILITY_IE		*pHtCapability,
-	IN UCHAR HtCapabilityLen,
-	IN ADD_HT_INFO_IE		*pAddHtInfo)	// AP might use this additional ht info IE
+VOID AssocPostProc(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr2, IN USHORT CapabilityInfo, IN USHORT Aid, IN UCHAR SupRate[], IN UCHAR SupRateLen, IN UCHAR ExtRate[], IN UCHAR ExtRateLen, IN PEDCA_PARM pEdcaParm, IN HT_CAPABILITY_IE * pHtCapability, IN UCHAR HtCapabilityLen, IN ADD_HT_INFO_IE * pAddHtInfo)	// AP might use this additional ht info IE
 {
 	ULONG Idx;
 
 	pAd->MlmeAux.BssType = BSS_INFRA;
 	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pAddr2);
 	pAd->MlmeAux.Aid = Aid;
-	pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+	pAd->MlmeAux.CapabilityInfo =
+	    CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
 
 	// Some HT AP might lost WMM IE. We add WMM ourselves. beacuase HT requires QoS on.
-	if ((HtCapabilityLen > 0) && (pEdcaParm->bValid == FALSE))
-	{
+	if ((HtCapabilityLen > 0) && (pEdcaParm->bValid == FALSE)) {
 		pEdcaParm->bValid = TRUE;
 		pEdcaParm->Aifsn[0] = 3;
 		pEdcaParm->Aifsn[1] = 7;
@@ -976,10 +1022,10 @@ VOID AssocPostProc(
 		pEdcaParm->Cwmax[2] = 4;
 		pEdcaParm->Cwmax[3] = 3;
 
-		pEdcaParm->Txop[0]  = 0;
-		pEdcaParm->Txop[1]  = 0;
-		pEdcaParm->Txop[2]  = 96;
-		pEdcaParm->Txop[3]  = 48;
+		pEdcaParm->Txop[0] = 0;
+		pEdcaParm->Txop[1] = 0;
+		pEdcaParm->Txop[2] = 96;
+		pEdcaParm->Txop[3] = 48;
 
 	}
 
@@ -995,75 +1041,94 @@ VOID AssocPostProc(
 	NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
 	RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
 
-	if (HtCapabilityLen > 0)
-	{
+	if (HtCapabilityLen > 0) {
 		RTMPCheckHt(pAd, BSSID_WCID, pHtCapability, pAddHtInfo);
 	}
-	DBGPRINT(RT_DEBUG_TRACE, ("AssocPostProc===>  AP.AMsduSize = %d. ClientStatusFlags = 0x%lx \n", pAd->MacTab.Content[BSSID_WCID].AMsduSize, pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AssocPostProc===>  AP.AMsduSize = %d. ClientStatusFlags = 0x%lx \n",
+		  pAd->MacTab.Content[BSSID_WCID].AMsduSize,
+		  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
 
-	DBGPRINT(RT_DEBUG_TRACE, ("AssocPostProc===>    (Mmps=%d, AmsduSize=%d, )\n",
-		pAd->MacTab.Content[BSSID_WCID].MmpsMode, pAd->MacTab.Content[BSSID_WCID].AMsduSize));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AssocPostProc===>    (Mmps=%d, AmsduSize=%d, )\n",
+		  pAd->MacTab.Content[BSSID_WCID].MmpsMode,
+		  pAd->MacTab.Content[BSSID_WCID].AMsduSize));
 
 	// Set New WPA information
 	Idx = BssTableSearch(&pAd->ScanTab, pAddr2, pAd->MlmeAux.Channel);
-	if (Idx == BSS_NOT_FOUND)
-	{
+	if (Idx == BSS_NOT_FOUND) {
 		DBGPRINT_ERR(("ASSOC - Can't find BSS after receiving Assoc response\n"));
-	}
-	else
-	{
+	} else {
 		// Init variable
 		pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = 0;
-		NdisZeroMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE, MAX_LEN_OF_RSNIE);
+		NdisZeroMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE,
+			       MAX_LEN_OF_RSNIE);
 
 		// Store appropriate RSN_IE for WPA SM negotiation later
-		if ((pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) && (pAd->ScanTab.BssEntry[Idx].VarIELen != 0))
-		{
-			PUCHAR              pVIE;
-			USHORT              len;
-			PEID_STRUCT         pEid;
+		if ((pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
+		    && (pAd->ScanTab.BssEntry[Idx].VarIELen != 0)) {
+			PUCHAR pVIE;
+			USHORT len;
+			PEID_STRUCT pEid;
 
 			pVIE = pAd->ScanTab.BssEntry[Idx].VarIEs;
-			len	 = pAd->ScanTab.BssEntry[Idx].VarIELen;
+			len = pAd->ScanTab.BssEntry[Idx].VarIELen;
 			//KH need to check again
 			// Don't allow to go to sleep mode if authmode is WPA-related.
 			//This can make Authentication process more smoothly.
 			RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 
-			while (len > 0)
-			{
+			while (len > 0) {
 				pEid = (PEID_STRUCT) pVIE;
 				// For WPA/WPAPSK
-				if ((pEid->Eid == IE_WPA) && (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
-					&& (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA || pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
-				{
-					NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE, pVIE, (pEid->Len + 2));
-					pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = (pEid->Len + 2);
-					DBGPRINT(RT_DEBUG_TRACE, ("AssocPostProc===> Store RSN_IE for WPA SM negotiation \n"));
+				if ((pEid->Eid == IE_WPA)
+				    &&
+				    (NdisEqualMemory(pEid->Octet, WPA_OUI, 4))
+				    && (pAd->StaCfg.AuthMode ==
+					Ndis802_11AuthModeWPA
+					|| pAd->StaCfg.AuthMode ==
+					Ndis802_11AuthModeWPAPSK)) {
+					NdisMoveMemory(pAd->MacTab.
+						       Content[BSSID_WCID].
+						       RSN_IE, pVIE,
+						       (pEid->Len + 2));
+					pAd->MacTab.Content[BSSID_WCID].
+					    RSNIE_Len = (pEid->Len + 2);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("AssocPostProc===> Store RSN_IE for WPA SM negotiation \n"));
 				}
 				// For WPA2/WPA2PSK
-				else if ((pEid->Eid == IE_RSN) && (NdisEqualMemory(pEid->Octet + 2, RSN_OUI, 3))
-					&& (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2 || pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
-				{
-					NdisMoveMemory(pAd->MacTab.Content[BSSID_WCID].RSN_IE, pVIE, (pEid->Len + 2));
-					pAd->MacTab.Content[BSSID_WCID].RSNIE_Len = (pEid->Len + 2);
-					DBGPRINT(RT_DEBUG_TRACE, ("AssocPostProc===> Store RSN_IE for WPA2 SM negotiation \n"));
+				else if ((pEid->Eid == IE_RSN)
+					 &&
+					 (NdisEqualMemory
+					  (pEid->Octet + 2, RSN_OUI, 3))
+					 && (pAd->StaCfg.AuthMode ==
+					     Ndis802_11AuthModeWPA2
+					     || pAd->StaCfg.AuthMode ==
+					     Ndis802_11AuthModeWPA2PSK)) {
+					NdisMoveMemory(pAd->MacTab.
+						       Content[BSSID_WCID].
+						       RSN_IE, pVIE,
+						       (pEid->Len + 2));
+					pAd->MacTab.Content[BSSID_WCID].
+					    RSNIE_Len = (pEid->Len + 2);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("AssocPostProc===> Store RSN_IE for WPA2 SM negotiation \n"));
 				}
 
 				pVIE += (pEid->Len + 2);
-				len  -= (pEid->Len + 2);
+				len -= (pEid->Len + 2);
 			}
 
-
 		}
 
-		if (pAd->MacTab.Content[BSSID_WCID].RSNIE_Len == 0)
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("AssocPostProc===> no RSN_IE \n"));
-		}
-		else
-		{
-			hex_dump("RSN_IE", pAd->MacTab.Content[BSSID_WCID].RSN_IE, pAd->MacTab.Content[BSSID_WCID].RSNIE_Len);
+		if (pAd->MacTab.Content[BSSID_WCID].RSNIE_Len == 0) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("AssocPostProc===> no RSN_IE \n"));
+		} else {
+			hex_dump("RSN_IE",
+				 pAd->MacTab.Content[BSSID_WCID].RSN_IE,
+				 pAd->MacTab.Content[BSSID_WCID].RSNIE_Len);
 		}
 	}
 }
@@ -1079,36 +1144,36 @@ VOID AssocPostProc(
 
 	==========================================================================
  */
-VOID PeerDisassocAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerDisassocAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR         Addr2[MAC_ADDR_LEN];
-	USHORT        Reason;
+	UCHAR Addr2[MAC_ADDR_LEN];
+	USHORT Reason;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - PeerDisassocAction()\n"));
-	if(PeerDisassocSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - PeerDisassocAction() Reason = %d\n", Reason));
-		if (INFRA_ON(pAd) && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, Addr2))
-		{
-
-			if (pAd->CommonCfg.bWirelessEvent)
-			{
-				RTMPSendWirelessEvent(pAd, IW_DISASSOC_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+	if (PeerDisassocSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - PeerDisassocAction() Reason = %d\n",
+			  Reason));
+		if (INFRA_ON(pAd)
+		    && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, Addr2)) {
+
+			if (pAd->CommonCfg.bWirelessEvent) {
+				RTMPSendWirelessEvent(pAd,
+						      IW_DISASSOC_EVENT_FLAG,
+						      pAd->MacTab.
+						      Content[BSSID_WCID].Addr,
+						      BSS0, 0);
 			}
 
-
 			LinkDown(pAd, TRUE);
 			pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 
-
-			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
+			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
+						0);
 		}
-	}
-	else
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - PeerDisassocAction() sanity check fail\n"));
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("ASSOC - PeerDisassocAction() sanity check fail\n"));
 	}
 
 }
@@ -1124,11 +1189,9 @@ VOID PeerDisassocAction(
 
 	==========================================================================
  */
-VOID AssocTimeoutAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID AssocTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT  Status;
+	USHORT Status;
 	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - AssocTimeoutAction\n"));
 	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 	Status = MLME_REJ_TIMEOUT;
@@ -1144,11 +1207,9 @@ VOID AssocTimeoutAction(
 
 	==========================================================================
  */
-VOID ReassocTimeoutAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID ReassocTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT  Status;
+	USHORT Status;
 	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - ReassocTimeoutAction\n"));
 	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 	Status = MLME_REJ_TIMEOUT;
@@ -1164,51 +1225,49 @@ VOID ReassocTimeoutAction(
 
 	==========================================================================
  */
-VOID DisassocTimeoutAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID DisassocTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT  Status;
+	USHORT Status;
 	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - DisassocTimeoutAction\n"));
 	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 	Status = MLME_SUCCESS;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2,
+		    &Status);
 }
 
-VOID InvalidStateWhenAssoc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID InvalidStateWhenAssoc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT  Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - InvalidStateWhenAssoc(state=%ld), reset ASSOC state machine\n",
-		pAd->Mlme.AssocMachine.CurrState));
+	USHORT Status;
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("ASSOC - InvalidStateWhenAssoc(state=%ld), reset ASSOC state machine\n",
+		  pAd->Mlme.AssocMachine.CurrState));
 	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 	Status = MLME_STATE_MACHINE_REJECT;
 	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_ASSOC_CONF, 2, &Status);
 }
 
-VOID InvalidStateWhenReassoc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID InvalidStateWhenReassoc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	USHORT Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - InvalidStateWhenReassoc(state=%ld), reset ASSOC state machine\n",
-		pAd->Mlme.AssocMachine.CurrState));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("ASSOC - InvalidStateWhenReassoc(state=%ld), reset ASSOC state machine\n",
+		  pAd->Mlme.AssocMachine.CurrState));
 	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 	Status = MLME_STATE_MACHINE_REJECT;
 	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_REASSOC_CONF, 2, &Status);
 }
 
-VOID InvalidStateWhenDisassociate(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID InvalidStateWhenDisassociate(IN PRTMP_ADAPTER pAd,
+				  IN MLME_QUEUE_ELEM * Elem)
 {
 	USHORT Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - InvalidStateWhenDisassoc(state=%ld), reset ASSOC state machine\n",
-		pAd->Mlme.AssocMachine.CurrState));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("ASSOC - InvalidStateWhenDisassoc(state=%ld), reset ASSOC state machine\n",
+		  pAd->Mlme.AssocMachine.CurrState));
 	pAd->Mlme.AssocMachine.CurrState = ASSOC_IDLE;
 	Status = MLME_STATE_MACHINE_REJECT;
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2, &Status);
+	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DISASSOC_CONF, 2,
+		    &Status);
 }
 
 /*
@@ -1224,33 +1283,31 @@ VOID InvalidStateWhenDisassociate(
 
 	==========================================================================
  */
-VOID Cls3errAction(
-	IN PRTMP_ADAPTER pAd,
-	IN PUCHAR        pAddr)
+VOID Cls3errAction(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr)
 {
-	HEADER_802_11         DisassocHdr;
-	PHEADER_802_11        pDisassocHdr;
-	PUCHAR                pOutBuffer = NULL;
-	ULONG                 FrameLen = 0;
-	NDIS_STATUS           NStatus;
-	USHORT                Reason = REASON_CLS3ERR;
-
-	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
+	HEADER_802_11 DisassocHdr;
+	PHEADER_802_11 pDisassocHdr;
+	PUCHAR pOutBuffer = NULL;
+	ULONG FrameLen = 0;
+	NDIS_STATUS NStatus;
+	USHORT Reason = REASON_CLS3ERR;
+
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
 	if (NStatus != NDIS_STATUS_SUCCESS)
 		return;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("ASSOC - Class 3 Error, Send DISASSOC frame\n"));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("ASSOC - Class 3 Error, Send DISASSOC frame\n"));
 	MgtMacHeaderInit(pAd, &DisassocHdr, SUBTYPE_DISASSOC, 0, pAddr, pAd->CommonCfg.Bssid);	// patch peap ttls switching issue
-	MakeOutgoingFrame(pOutBuffer,           &FrameLen,
-					  sizeof(HEADER_802_11),&DisassocHdr,
-					  2,                    &Reason,
-					  END_OF_ARGS);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen,
+			  sizeof(HEADER_802_11), &DisassocHdr,
+			  2, &Reason, END_OF_ARGS);
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 
 	// To patch Instance and Buffalo(N) AP
 	// Driver has to send deauth to Instance AP, but Buffalo(N) needs to send disassoc to reset Authenticator's state machine
 	// Therefore, we send both of them.
-	pDisassocHdr = (PHEADER_802_11)pOutBuffer;
+	pDisassocHdr = (PHEADER_802_11) pOutBuffer;
 	pDisassocHdr->FC.SubType = SUBTYPE_DEAUTH;
 	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 
@@ -1260,206 +1317,248 @@ VOID Cls3errAction(
 	COPY_MAC_ADDR(pAd->StaCfg.DisassocSta, pAddr);
 }
 
-
-int wext_notify_event_assoc(
-	IN  RTMP_ADAPTER *pAd)
+int wext_notify_event_assoc(IN RTMP_ADAPTER * pAd)
 {
-    char custom[IW_CUSTOM_MAX] = {0};
+	char custom[IW_CUSTOM_MAX] = { 0 };
 
-    if (pAd->StaCfg.ReqVarIELen <= IW_CUSTOM_MAX)
-    {
-		NdisMoveMemory(custom, pAd->StaCfg.ReqVarIEs, pAd->StaCfg.ReqVarIELen);
-		RtmpOSWrielessEventSend(pAd, IWEVASSOCREQIE, -1, NULL, custom, pAd->StaCfg.ReqVarIELen);
-    }
-    else
-        DBGPRINT(RT_DEBUG_TRACE, ("pAd->StaCfg.ReqVarIELen > MAX_CUSTOM_LEN\n"));
+	if (pAd->StaCfg.ReqVarIELen <= IW_CUSTOM_MAX) {
+		NdisMoveMemory(custom, pAd->StaCfg.ReqVarIEs,
+			       pAd->StaCfg.ReqVarIELen);
+		RtmpOSWrielessEventSend(pAd, IWEVASSOCREQIE, -1, NULL, custom,
+					pAd->StaCfg.ReqVarIELen);
+	} else
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("pAd->StaCfg.ReqVarIELen > MAX_CUSTOM_LEN\n"));
 
 	return 0;
 
 }
 
-
-BOOLEAN StaAddMacTableEntry(
-	IN  PRTMP_ADAPTER		pAd,
-	IN  PMAC_TABLE_ENTRY	pEntry,
-	IN  UCHAR				MaxSupportedRateIn500Kbps,
-	IN  HT_CAPABILITY_IE	*pHtCapability,
-	IN  UCHAR				HtCapabilityLen,
-	IN  ADD_HT_INFO_IE		*pAddHtInfo,
-	IN  UCHAR				AddHtInfoLen,
-	IN  USHORT        		CapabilityInfo)
+BOOLEAN StaAddMacTableEntry(IN PRTMP_ADAPTER pAd,
+			    IN PMAC_TABLE_ENTRY pEntry,
+			    IN UCHAR MaxSupportedRateIn500Kbps,
+			    IN HT_CAPABILITY_IE * pHtCapability,
+			    IN UCHAR HtCapabilityLen,
+			    IN ADD_HT_INFO_IE * pAddHtInfo,
+			    IN UCHAR AddHtInfoLen, IN USHORT CapabilityInfo)
 {
-	UCHAR            MaxSupportedRate = RATE_11;
+	UCHAR MaxSupportedRate = RATE_11;
 
 	if (ADHOC_ON(pAd))
 		CLIENT_STATUS_CLEAR_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE);
 
-	switch (MaxSupportedRateIn500Kbps)
-    {
-        case 108: MaxSupportedRate = RATE_54;   break;
-        case 96:  MaxSupportedRate = RATE_48;   break;
-        case 72:  MaxSupportedRate = RATE_36;   break;
-        case 48:  MaxSupportedRate = RATE_24;   break;
-        case 36:  MaxSupportedRate = RATE_18;   break;
-        case 24:  MaxSupportedRate = RATE_12;   break;
-        case 18:  MaxSupportedRate = RATE_9;    break;
-        case 12:  MaxSupportedRate = RATE_6;    break;
-        case 22:  MaxSupportedRate = RATE_11;   break;
-        case 11:  MaxSupportedRate = RATE_5_5;  break;
-        case 4:   MaxSupportedRate = RATE_2;    break;
-        case 2:   MaxSupportedRate = RATE_1;    break;
-        default:  MaxSupportedRate = RATE_11;   break;
-    }
-
-    if ((pAd->CommonCfg.PhyMode == PHY_11G) && (MaxSupportedRate < RATE_FIRST_OFDM_RATE))
-        return FALSE;
+	switch (MaxSupportedRateIn500Kbps) {
+	case 108:
+		MaxSupportedRate = RATE_54;
+		break;
+	case 96:
+		MaxSupportedRate = RATE_48;
+		break;
+	case 72:
+		MaxSupportedRate = RATE_36;
+		break;
+	case 48:
+		MaxSupportedRate = RATE_24;
+		break;
+	case 36:
+		MaxSupportedRate = RATE_18;
+		break;
+	case 24:
+		MaxSupportedRate = RATE_12;
+		break;
+	case 18:
+		MaxSupportedRate = RATE_9;
+		break;
+	case 12:
+		MaxSupportedRate = RATE_6;
+		break;
+	case 22:
+		MaxSupportedRate = RATE_11;
+		break;
+	case 11:
+		MaxSupportedRate = RATE_5_5;
+		break;
+	case 4:
+		MaxSupportedRate = RATE_2;
+		break;
+	case 2:
+		MaxSupportedRate = RATE_1;
+		break;
+	default:
+		MaxSupportedRate = RATE_11;
+		break;
+	}
+
+	if ((pAd->CommonCfg.PhyMode == PHY_11G)
+	    && (MaxSupportedRate < RATE_FIRST_OFDM_RATE))
+		return FALSE;
 
 	// 11n only
-	if (((pAd->CommonCfg.PhyMode == PHY_11N_2_4G) || (pAd->CommonCfg.PhyMode == PHY_11N_5G))&& (HtCapabilityLen == 0))
+	if (((pAd->CommonCfg.PhyMode == PHY_11N_2_4G)
+	     || (pAd->CommonCfg.PhyMode == PHY_11N_5G))
+	    && (HtCapabilityLen == 0))
 		return FALSE;
 
 	if (!pEntry)
-        return FALSE;
+		return FALSE;
 
 	NdisAcquireSpinLock(&pAd->MacTabLock);
-	if (pEntry)
-	{
+	if (pEntry) {
 		pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
 		if ((MaxSupportedRate < RATE_FIRST_OFDM_RATE) ||
-			(pAd->CommonCfg.PhyMode == PHY_11B))
-		{
+		    (pAd->CommonCfg.PhyMode == PHY_11B)) {
 			pEntry->RateLen = 4;
 			if (MaxSupportedRate >= RATE_FIRST_OFDM_RATE)
 				MaxSupportedRate = RATE_11;
-		}
-		else
+		} else
 			pEntry->RateLen = 12;
 
 		pEntry->MaxHTPhyMode.word = 0;
 		pEntry->MinHTPhyMode.word = 0;
 		pEntry->HTPhyMode.word = 0;
 		pEntry->MaxSupportedRate = MaxSupportedRate;
-		if (pEntry->MaxSupportedRate < RATE_FIRST_OFDM_RATE)
-		{
+		if (pEntry->MaxSupportedRate < RATE_FIRST_OFDM_RATE) {
 			pEntry->MaxHTPhyMode.field.MODE = MODE_CCK;
-			pEntry->MaxHTPhyMode.field.MCS = pEntry->MaxSupportedRate;
+			pEntry->MaxHTPhyMode.field.MCS =
+			    pEntry->MaxSupportedRate;
 			pEntry->MinHTPhyMode.field.MODE = MODE_CCK;
-			pEntry->MinHTPhyMode.field.MCS = pEntry->MaxSupportedRate;
+			pEntry->MinHTPhyMode.field.MCS =
+			    pEntry->MaxSupportedRate;
 			pEntry->HTPhyMode.field.MODE = MODE_CCK;
 			pEntry->HTPhyMode.field.MCS = pEntry->MaxSupportedRate;
-		}
-		else
-		{
+		} else {
 			pEntry->MaxHTPhyMode.field.MODE = MODE_OFDM;
-			pEntry->MaxHTPhyMode.field.MCS = OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
+			pEntry->MaxHTPhyMode.field.MCS =
+			    OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
 			pEntry->MinHTPhyMode.field.MODE = MODE_OFDM;
-			pEntry->MinHTPhyMode.field.MCS = OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
+			pEntry->MinHTPhyMode.field.MCS =
+			    OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
 			pEntry->HTPhyMode.field.MODE = MODE_OFDM;
-			pEntry->HTPhyMode.field.MCS = OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
+			pEntry->HTPhyMode.field.MCS =
+			    OfdmRateToRxwiMCS[pEntry->MaxSupportedRate];
 		}
 		pEntry->CapabilityInfo = CapabilityInfo;
-		CLIENT_STATUS_CLEAR_FLAG(pEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE);
-		CLIENT_STATUS_CLEAR_FLAG(pEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE);
+		CLIENT_STATUS_CLEAR_FLAG(pEntry,
+					 fCLIENT_STATUS_AGGREGATION_CAPABLE);
+		CLIENT_STATUS_CLEAR_FLAG(pEntry,
+					 fCLIENT_STATUS_PIGGYBACK_CAPABLE);
 	}
 
 	NdisZeroMemory(&pEntry->HTCapability, sizeof(pEntry->HTCapability));
 	// If this Entry supports 802.11n, upgrade to HT rate.
-	if ((HtCapabilityLen != 0) && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
-	{
-		UCHAR	j, bitmask; //k,bitmask;
-		CHAR    i;
+	if ((HtCapabilityLen != 0)
+	    && (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
+		UCHAR j, bitmask;	//k,bitmask;
+		CHAR i;
 
 		if (ADHOC_ON(pAd))
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE);
-		if ((pHtCapability->HtCapInfo.GF) && (pAd->CommonCfg.DesiredHtPhy.GF))
-		{
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_WMM_CAPABLE);
+		if ((pHtCapability->HtCapInfo.GF)
+		    && (pAd->CommonCfg.DesiredHtPhy.GF)) {
 			pEntry->MaxHTPhyMode.field.MODE = MODE_HTGREENFIELD;
-		}
-		else
-		{
+		} else {
 			pEntry->MaxHTPhyMode.field.MODE = MODE_HTMIX;
 			pAd->MacTab.fAnyStationNonGF = TRUE;
 			pAd->CommonCfg.AddHTInfo.AddHtInfo2.NonGfPresent = 1;
 		}
 
 		if ((pHtCapability->HtCapInfo.ChannelWidth) &&
-			(pAd->CommonCfg.DesiredHtPhy.ChannelWidth) &&
-			((pAd->StaCfg.BssType == BSS_INFRA) || ((pAd->StaCfg.BssType == BSS_ADHOC) && (pAddHtInfo->AddHtInfo.ExtChanOffset == pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset))))
-		{
-			pEntry->MaxHTPhyMode.field.BW= BW_40;
-			pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor40)&(pHtCapability->HtCapInfo.ShortGIfor40));
-		}
-		else
-		{
+		    (pAd->CommonCfg.DesiredHtPhy.ChannelWidth) &&
+		    ((pAd->StaCfg.BssType == BSS_INFRA)
+		     || ((pAd->StaCfg.BssType == BSS_ADHOC)
+			 && (pAddHtInfo->AddHtInfo.ExtChanOffset ==
+			     pAd->CommonCfg.AddHTInfo.AddHtInfo.
+			     ExtChanOffset)))) {
+			pEntry->MaxHTPhyMode.field.BW = BW_40;
+			pEntry->MaxHTPhyMode.field.ShortGI =
+			    ((pAd->CommonCfg.DesiredHtPhy.
+			      ShortGIfor40) & (pHtCapability->HtCapInfo.
+					       ShortGIfor40));
+		} else {
 			pEntry->MaxHTPhyMode.field.BW = BW_20;
-			pEntry->MaxHTPhyMode.field.ShortGI = ((pAd->CommonCfg.DesiredHtPhy.ShortGIfor20)&(pHtCapability->HtCapInfo.ShortGIfor20));
+			pEntry->MaxHTPhyMode.field.ShortGI =
+			    ((pAd->CommonCfg.DesiredHtPhy.
+			      ShortGIfor20) & (pHtCapability->HtCapInfo.
+					       ShortGIfor20));
 			pAd->MacTab.fAnyStation20Only = TRUE;
 		}
 
 		// 3*3
-		if (pAd->MACVersion >= RALINK_2883_VERSION && pAd->MACVersion < RALINK_3070_VERSION)
-			pEntry->MaxHTPhyMode.field.TxBF = pAd->CommonCfg.RegTransmitSetting.field.TxBF;
+		if (pAd->MACVersion >= RALINK_2883_VERSION
+		    && pAd->MACVersion < RALINK_3070_VERSION)
+			pEntry->MaxHTPhyMode.field.TxBF =
+			    pAd->CommonCfg.RegTransmitSetting.field.TxBF;
 
 		// find max fixed rate
-		for (i=23; i>=0; i--) // 3*3
+		for (i = 23; i >= 0; i--)	// 3*3
 		{
-			j = i/8;
-			bitmask = (1<<(i-(j*8)));
-			if ((pAd->StaCfg.DesiredHtPhyInfo.MCSSet[j] & bitmask) && (pHtCapability->MCSSet[j] & bitmask))
-			{
+			j = i / 8;
+			bitmask = (1 << (i - (j * 8)));
+			if ((pAd->StaCfg.DesiredHtPhyInfo.MCSSet[j] & bitmask)
+			    && (pHtCapability->MCSSet[j] & bitmask)) {
 				pEntry->MaxHTPhyMode.field.MCS = i;
 				break;
 			}
-			if (i==0)
+			if (i == 0)
 				break;
 		}
 
-
-		if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO)
-		{
-			if (pAd->StaCfg.DesiredTransmitSetting.field.MCS == 32)
-			{
+		if (pAd->StaCfg.DesiredTransmitSetting.field.MCS != MCS_AUTO) {
+			if (pAd->StaCfg.DesiredTransmitSetting.field.MCS == 32) {
 				// Fix MCS as HT Duplicated Mode
 				pEntry->MaxHTPhyMode.field.BW = 1;
 				pEntry->MaxHTPhyMode.field.MODE = MODE_HTMIX;
 				pEntry->MaxHTPhyMode.field.STBC = 0;
 				pEntry->MaxHTPhyMode.field.ShortGI = 0;
 				pEntry->MaxHTPhyMode.field.MCS = 32;
-			}
-			else if (pEntry->MaxHTPhyMode.field.MCS > pAd->StaCfg.HTPhyMode.field.MCS)
-			{
+			} else if (pEntry->MaxHTPhyMode.field.MCS >
+				   pAd->StaCfg.HTPhyMode.field.MCS) {
 				// STA supports fixed MCS
-				pEntry->MaxHTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
+				pEntry->MaxHTPhyMode.field.MCS =
+				    pAd->StaCfg.HTPhyMode.field.MCS;
 			}
 		}
 
-		pEntry->MaxHTPhyMode.field.STBC = (pHtCapability->HtCapInfo.RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
+		pEntry->MaxHTPhyMode.field.STBC =
+		    (pHtCapability->HtCapInfo.
+		     RxSTBC & (pAd->CommonCfg.DesiredHtPhy.TxSTBC));
 		pEntry->MpduDensity = pHtCapability->HtCapParm.MpduDensity;
-		pEntry->MaxRAmpduFactor = pHtCapability->HtCapParm.MaxRAmpduFactor;
-		pEntry->MmpsMode = (UCHAR)pHtCapability->HtCapInfo.MimoPs;
-		pEntry->AMsduSize = (UCHAR)pHtCapability->HtCapInfo.AMsduSize;
+		pEntry->MaxRAmpduFactor =
+		    pHtCapability->HtCapParm.MaxRAmpduFactor;
+		pEntry->MmpsMode = (UCHAR) pHtCapability->HtCapInfo.MimoPs;
+		pEntry->AMsduSize = (UCHAR) pHtCapability->HtCapInfo.AMsduSize;
 		pEntry->HTPhyMode.word = pEntry->MaxHTPhyMode.word;
 
-		if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_AMSDU_INUSED);
+		if (pAd->CommonCfg.DesiredHtPhy.AmsduEnable
+		    && (pAd->CommonCfg.REGBACapability.field.AutoBA == FALSE))
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_AMSDU_INUSED);
 		if (pHtCapability->HtCapInfo.ShortGIfor20)
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_SGI20_CAPABLE);
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_SGI20_CAPABLE);
 		if (pHtCapability->HtCapInfo.ShortGIfor40)
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_SGI40_CAPABLE);
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_SGI40_CAPABLE);
 		if (pHtCapability->HtCapInfo.TxSTBC)
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_TxSTBC_CAPABLE);
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_TxSTBC_CAPABLE);
 		if (pHtCapability->HtCapInfo.RxSTBC)
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_RxSTBC_CAPABLE);
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_RxSTBC_CAPABLE);
 		if (pHtCapability->ExtHtCapInfo.PlusHTC)
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_HTC_CAPABLE);
-		if (pAd->CommonCfg.bRdg && pHtCapability->ExtHtCapInfo.RDGSupport)
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_RDG_CAPABLE);
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_HTC_CAPABLE);
+		if (pAd->CommonCfg.bRdg
+		    && pHtCapability->ExtHtCapInfo.RDGSupport)
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_RDG_CAPABLE);
 		if (pHtCapability->ExtHtCapInfo.MCSFeedback == 0x03)
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_MCSFEEDBACK_CAPABLE);
-		NdisMoveMemory(&pEntry->HTCapability, pHtCapability, HtCapabilityLen);
-	}
-	else
-	{
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_MCSFEEDBACK_CAPABLE);
+		NdisMoveMemory(&pEntry->HTCapability, pHtCapability,
+			       HtCapabilityLen);
+	} else {
 		pAd->MacTab.fAnyStationIsLegacy = TRUE;
 	}
 
@@ -1467,22 +1566,22 @@ BOOLEAN StaAddMacTableEntry(
 	pEntry->CurrTxRate = pEntry->MaxSupportedRate;
 
 	// Set asic auto fall back
-	if (pAd->StaCfg.bAutoTxRateSwitch == TRUE)
-	{
-		PUCHAR					pTable;
-		UCHAR					TableSize = 0;
+	if (pAd->StaCfg.bAutoTxRateSwitch == TRUE) {
+		PUCHAR pTable;
+		UCHAR TableSize = 0;
 
-		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize, &pEntry->CurrTxRateIndex);
+		MlmeSelectTxRateTable(pAd, pEntry, &pTable, &TableSize,
+				      &pEntry->CurrTxRateIndex);
 		pEntry->bAutoTxRateSwitch = TRUE;
-	}
-	else
-	{
-		pEntry->HTPhyMode.field.MODE	= pAd->StaCfg.HTPhyMode.field.MODE;
-		pEntry->HTPhyMode.field.MCS	= pAd->StaCfg.HTPhyMode.field.MCS;
+	} else {
+		pEntry->HTPhyMode.field.MODE = pAd->StaCfg.HTPhyMode.field.MODE;
+		pEntry->HTPhyMode.field.MCS = pAd->StaCfg.HTPhyMode.field.MCS;
 		pEntry->bAutoTxRateSwitch = FALSE;
 
 		// If the legacy mode is set, overwrite the transmit setting of this entry.
-		RTMPUpdateLegacyTxSetting((UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
+		RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.
+					  DesiredTransmitSetting.field.
+					  FixedTxMode, pEntry);
 	}
 
 	pEntry->PortSecured = WPA_802_1X_PORT_SECURED;
@@ -1493,14 +1592,14 @@ BOOLEAN StaAddMacTableEntry(
 
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
-    {
-        union iwreq_data    wrqu;
-        wext_notify_event_assoc(pAd);
+	{
+		union iwreq_data wrqu;
+		wext_notify_event_assoc(pAd);
 
-        memset(wrqu.ap_addr.sa_data, 0, MAC_ADDR_LEN);
-        memcpy(wrqu.ap_addr.sa_data, pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
-        wireless_send_event(pAd->net_dev, SIOCGIWAP, &wrqu, NULL);
+		memset(wrqu.ap_addr.sa_data, 0, MAC_ADDR_LEN);
+		memcpy(wrqu.ap_addr.sa_data, pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
+		wireless_send_event(pAd->net_dev, SIOCGIWAP, &wrqu, NULL);
 
-    }
+	}
 	return TRUE;
 }
diff --git a/drivers/staging/rt2860/sta/auth.c b/drivers/staging/rt2860/sta/auth.c
index 7fb0760..8b75b46 100644
--- a/drivers/staging/rt2860/sta/auth.c
+++ b/drivers/staging/rt2860/sta/auth.c
@@ -55,27 +55,35 @@
     ==========================================================================
  */
 
-void AuthStateMachineInit(
-    IN PRTMP_ADAPTER pAd,
-    IN STATE_MACHINE *Sm,
-    OUT STATE_MACHINE_FUNC Trans[])
+void AuthStateMachineInit(IN PRTMP_ADAPTER pAd,
+			  IN STATE_MACHINE * Sm, OUT STATE_MACHINE_FUNC Trans[])
 {
-    StateMachineInit(Sm, Trans, MAX_AUTH_STATE, MAX_AUTH_MSG, (STATE_MACHINE_FUNC)Drop, AUTH_REQ_IDLE, AUTH_MACHINE_BASE);
-
-    // the first column
-    StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)MlmeAuthReqAction);
-
-    // the second column
-    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAuth);
-    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_PEER_AUTH_EVEN, (STATE_MACHINE_FUNC)PeerAuthRspAtSeq2Action);
-    StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_AUTH_TIMEOUT, (STATE_MACHINE_FUNC)AuthTimeoutAction);
-
-    // the third column
-    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_MLME_AUTH_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenAuth);
-    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_PEER_AUTH_EVEN, (STATE_MACHINE_FUNC)PeerAuthRspAtSeq4Action);
-    StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_AUTH_TIMEOUT, (STATE_MACHINE_FUNC)AuthTimeoutAction);
-
-	RTMPInitTimer(pAd, &pAd->MlmeAux.AuthTimer, GET_TIMER_FUNCTION(AuthTimeout), pAd, FALSE);
+	StateMachineInit(Sm, Trans, MAX_AUTH_STATE, MAX_AUTH_MSG,
+			 (STATE_MACHINE_FUNC) Drop, AUTH_REQ_IDLE,
+			 AUTH_MACHINE_BASE);
+
+	// the first column
+	StateMachineSetAction(Sm, AUTH_REQ_IDLE, MT2_MLME_AUTH_REQ,
+			      (STATE_MACHINE_FUNC) MlmeAuthReqAction);
+
+	// the second column
+	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_MLME_AUTH_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenAuth);
+	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_PEER_AUTH_EVEN,
+			      (STATE_MACHINE_FUNC) PeerAuthRspAtSeq2Action);
+	StateMachineSetAction(Sm, AUTH_WAIT_SEQ2, MT2_AUTH_TIMEOUT,
+			      (STATE_MACHINE_FUNC) AuthTimeoutAction);
+
+	// the third column
+	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_MLME_AUTH_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenAuth);
+	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_PEER_AUTH_EVEN,
+			      (STATE_MACHINE_FUNC) PeerAuthRspAtSeq4Action);
+	StateMachineSetAction(Sm, AUTH_WAIT_SEQ4, MT2_AUTH_TIMEOUT,
+			      (STATE_MACHINE_FUNC) AuthTimeoutAction);
+
+	RTMPInitTimer(pAd, &pAd->MlmeAux.AuthTimer,
+		      GET_TIMER_FUNCTION(AuthTimeout), pAd, FALSE);
 }
 
 /*
@@ -87,31 +95,28 @@ void AuthStateMachineInit(
 
     ==========================================================================
  */
-VOID AuthTimeout(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3)
+VOID AuthTimeout(IN PVOID SystemSpecific1,
+		 IN PVOID FunctionContext,
+		 IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-    RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-    DBGPRINT(RT_DEBUG_TRACE,("AUTH - AuthTimeout\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("AUTH - AuthTimeout\n"));
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
-	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
+	if (RTMP_TEST_FLAG
+	    (pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS | fRTMP_ADAPTER_NIC_NOT_EXIST))
 		return;
 
 	// send a de-auth to reset AP's state machine (Patch AP-Dir635)
 	if (pAd->Mlme.AuthMachine.CurrState == AUTH_WAIT_SEQ2)
 		Cls2errAction(pAd, pAd->MlmeAux.Bssid);
 
-
-    MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_AUTH_TIMEOUT, 0, NULL);
-    RTMP_MLME_HANDLER(pAd);
+	MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_AUTH_TIMEOUT, 0, NULL);
+	RTMP_MLME_HANDLER(pAd);
 }
 
-
 /*
     ==========================================================================
     Description:
@@ -120,20 +125,19 @@ VOID AuthTimeout(
 
     ==========================================================================
  */
-VOID MlmeAuthReqAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeAuthReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	if (AUTH_ReqSend(pAd, Elem, &pAd->MlmeAux.AuthTimer, "AUTH", 1, NULL, 0))
-        pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ2;
-    else
-    {
+	if (AUTH_ReqSend
+	    (pAd, Elem, &pAd->MlmeAux.AuthTimer, "AUTH", 1, NULL, 0))
+		pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ2;
+	else {
 		USHORT Status;
 
-        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-        Status = MLME_INVALID_FORMAT;
-        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-    }
+		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+		Status = MLME_INVALID_FORMAT;
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2,
+			    &Status);
+	}
 }
 
 /*
@@ -144,101 +148,130 @@ VOID MlmeAuthReqAction(
 
     ==========================================================================
  */
-VOID PeerAuthRspAtSeq2Action(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID PeerAuthRspAtSeq2Action(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-    UCHAR         Addr2[MAC_ADDR_LEN];
-    USHORT        Seq, Status, RemoteStatus, Alg;
-    UCHAR         ChlgText[CIPHER_TEXT_LEN];
-    UCHAR         CyperChlgText[CIPHER_TEXT_LEN + 8 + 8];
-    UCHAR         Element[2];
-    HEADER_802_11 AuthHdr;
-    BOOLEAN       TimerCancelled;
-    PUCHAR        pOutBuffer = NULL;
-    NDIS_STATUS   NStatus;
-    ULONG         FrameLen = 0;
-    USHORT        Status2;
-
-    if (PeerAuthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status, (PCHAR)ChlgText))
-    {
-        if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 2)
-        {
-            DBGPRINT(RT_DEBUG_TRACE, ("AUTH - Receive AUTH_RSP seq#2 to me (Alg=%d, Status=%d)\n", Alg, Status));
-            RTMPCancelTimer(&pAd->MlmeAux.AuthTimer, &TimerCancelled);
-
-            if (Status == MLME_SUCCESS)
-            {
-                // Authentication Mode "LEAP" has allow for CCX 1.X
-                if (pAd->MlmeAux.Alg == Ndis802_11AuthModeOpen)
-                {
-                    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-                    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-                }
-                else
-                {
-                    // 2. shared key, need to be challenged
-                    Seq++;
-                    RemoteStatus = MLME_SUCCESS;
+	UCHAR Addr2[MAC_ADDR_LEN];
+	USHORT Seq, Status, RemoteStatus, Alg;
+	UCHAR ChlgText[CIPHER_TEXT_LEN];
+	UCHAR CyperChlgText[CIPHER_TEXT_LEN + 8 + 8];
+	UCHAR Element[2];
+	HEADER_802_11 AuthHdr;
+	BOOLEAN TimerCancelled;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	ULONG FrameLen = 0;
+	USHORT Status2;
+
+	if (PeerAuthSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status,
+	     (PCHAR) ChlgText)) {
+		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 2) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("AUTH - Receive AUTH_RSP seq#2 to me (Alg=%d, Status=%d)\n",
+				  Alg, Status));
+			RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,
+					&TimerCancelled);
+
+			if (Status == MLME_SUCCESS) {
+				// Authentication Mode "LEAP" has allow for CCX 1.X
+				if (pAd->MlmeAux.Alg == Ndis802_11AuthModeOpen) {
+					pAd->Mlme.AuthMachine.CurrState =
+					    AUTH_REQ_IDLE;
+					MlmeEnqueue(pAd,
+						    MLME_CNTL_STATE_MACHINE,
+						    MT2_AUTH_CONF, 2, &Status);
+				} else {
+					// 2. shared key, need to be challenged
+					Seq++;
+					RemoteStatus = MLME_SUCCESS;
 
 					// Get an unused nonpaged memory
-                    NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
-                    if(NStatus != NDIS_STATUS_SUCCESS)
-                    {
-                        DBGPRINT(RT_DEBUG_TRACE, ("AUTH - PeerAuthRspAtSeq2Action() allocate memory fail\n"));
-                        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-                        Status2 = MLME_FAIL_NO_RESOURCE;
-                        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status2);
-                        return;
-                    }
-
-                    DBGPRINT(RT_DEBUG_TRACE, ("AUTH - Send AUTH request seq#3...\n"));
-                    MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr2, pAd->MlmeAux.Bssid);
-                    AuthHdr.FC.Wep = 1;
-                    // Encrypt challenge text & auth information
-                    RTMPInitWepEngine(
-                    	pAd,
-                    	pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].Key,
-                    	pAd->StaCfg.DefaultKeyId,
-                    	pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId].KeyLen,
-                    	CyperChlgText);
-
-					Alg = cpu2le16(*(USHORT *)&Alg);
-					Seq = cpu2le16(*(USHORT *)&Seq);
-					RemoteStatus= cpu2le16(*(USHORT *)&RemoteStatus);
-
-					RTMPEncryptData(pAd, (PUCHAR) &Alg, CyperChlgText + 4, 2);
-					RTMPEncryptData(pAd, (PUCHAR) &Seq, CyperChlgText + 6, 2);
-					RTMPEncryptData(pAd, (PUCHAR) &RemoteStatus, CyperChlgText + 8, 2);
+					NStatus =
+					    MlmeAllocateMemory(pAd,
+							       &pOutBuffer);
+					if (NStatus != NDIS_STATUS_SUCCESS) {
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("AUTH - PeerAuthRspAtSeq2Action() allocate memory fail\n"));
+						pAd->Mlme.AuthMachine.
+						    CurrState = AUTH_REQ_IDLE;
+						Status2 = MLME_FAIL_NO_RESOURCE;
+						MlmeEnqueue(pAd,
+							    MLME_CNTL_STATE_MACHINE,
+							    MT2_AUTH_CONF, 2,
+							    &Status2);
+						return;
+					}
+
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("AUTH - Send AUTH request seq#3...\n"));
+					MgtMacHeaderInit(pAd, &AuthHdr,
+							 SUBTYPE_AUTH, 0, Addr2,
+							 pAd->MlmeAux.Bssid);
+					AuthHdr.FC.Wep = 1;
+					// Encrypt challenge text & auth information
+					RTMPInitWepEngine(pAd,
+							  pAd->
+							  SharedKey[BSS0][pAd->
+									  StaCfg.
+									  DefaultKeyId].
+							  Key,
+							  pAd->StaCfg.
+							  DefaultKeyId,
+							  pAd->
+							  SharedKey[BSS0][pAd->
+									  StaCfg.
+									  DefaultKeyId].
+							  KeyLen,
+							  CyperChlgText);
+
+					Alg = cpu2le16(*(USHORT *) & Alg);
+					Seq = cpu2le16(*(USHORT *) & Seq);
+					RemoteStatus =
+					    cpu2le16(*(USHORT *) &
+						     RemoteStatus);
+
+					RTMPEncryptData(pAd, (PUCHAR) & Alg,
+							CyperChlgText + 4, 2);
+					RTMPEncryptData(pAd, (PUCHAR) & Seq,
+							CyperChlgText + 6, 2);
+					RTMPEncryptData(pAd,
+							(PUCHAR) & RemoteStatus,
+							CyperChlgText + 8, 2);
 					Element[0] = 16;
 					Element[1] = 128;
-					RTMPEncryptData(pAd, Element, CyperChlgText + 10, 2);
-					RTMPEncryptData(pAd, ChlgText, CyperChlgText + 12, 128);
+					RTMPEncryptData(pAd, Element,
+							CyperChlgText + 10, 2);
+					RTMPEncryptData(pAd, ChlgText,
+							CyperChlgText + 12,
+							128);
 					RTMPSetICV(pAd, CyperChlgText + 140);
-                    MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-                                      sizeof(HEADER_802_11),    &AuthHdr,
-                                      CIPHER_TEXT_LEN + 16,     CyperChlgText,
-                                      END_OF_ARGS);
-                    MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-                	MlmeFreeMemory(pAd, pOutBuffer);
-
-                    RTMPSetTimer(&pAd->MlmeAux.AuthTimer, AUTH_TIMEOUT);
-                    pAd->Mlme.AuthMachine.CurrState = AUTH_WAIT_SEQ4;
-                }
-            }
-            else
-            {
-                pAd->StaCfg.AuthFailReason = Status;
-                COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
-                pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-                MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-            }
-        }
-    }
-    else
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("AUTH - PeerAuthSanity() sanity check fail\n"));
-    }
+					MakeOutgoingFrame(pOutBuffer, &FrameLen,
+							  sizeof(HEADER_802_11),
+							  &AuthHdr,
+							  CIPHER_TEXT_LEN + 16,
+							  CyperChlgText,
+							  END_OF_ARGS);
+					MiniportMMRequest(pAd, 0, pOutBuffer,
+							  FrameLen);
+					MlmeFreeMemory(pAd, pOutBuffer);
+
+					RTMPSetTimer(&pAd->MlmeAux.AuthTimer,
+						     AUTH_TIMEOUT);
+					pAd->Mlme.AuthMachine.CurrState =
+					    AUTH_WAIT_SEQ4;
+				}
+			} else {
+				pAd->StaCfg.AuthFailReason = Status;
+				COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
+				pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+				MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE,
+					    MT2_AUTH_CONF, 2, &Status);
+			}
+		}
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("AUTH - PeerAuthSanity() sanity check fail\n"));
+	}
 }
 
 /*
@@ -249,36 +282,35 @@ VOID PeerAuthRspAtSeq2Action(
 
     ==========================================================================
  */
-VOID PeerAuthRspAtSeq4Action(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID PeerAuthRspAtSeq4Action(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-    UCHAR         Addr2[MAC_ADDR_LEN];
-    USHORT        Alg, Seq, Status;
-    CHAR          ChlgText[CIPHER_TEXT_LEN];
-    BOOLEAN       TimerCancelled;
-
-    if(PeerAuthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status, ChlgText))
-    {
-        if(MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 4)
-        {
-            DBGPRINT(RT_DEBUG_TRACE, ("AUTH - Receive AUTH_RSP seq#4 to me\n"));
-            RTMPCancelTimer(&pAd->MlmeAux.AuthTimer, &TimerCancelled);
-
-            if (Status != MLME_SUCCESS)
-            {
-                pAd->StaCfg.AuthFailReason = Status;
-                COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
-            }
-
-            pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-        }
-    }
-    else
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("AUTH - PeerAuthRspAtSeq4Action() sanity check fail\n"));
-    }
+	UCHAR Addr2[MAC_ADDR_LEN];
+	USHORT Alg, Seq, Status;
+	CHAR ChlgText[CIPHER_TEXT_LEN];
+	BOOLEAN TimerCancelled;
+
+	if (PeerAuthSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, &Alg, &Seq, &Status,
+	     ChlgText)) {
+		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Addr2) && Seq == 4) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("AUTH - Receive AUTH_RSP seq#4 to me\n"));
+			RTMPCancelTimer(&pAd->MlmeAux.AuthTimer,
+					&TimerCancelled);
+
+			if (Status != MLME_SUCCESS) {
+				pAd->StaCfg.AuthFailReason = Status;
+				COPY_MAC_ADDR(pAd->StaCfg.AuthFailSta, Addr2);
+			}
+
+			pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF,
+				    2, &Status);
+		}
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("AUTH - PeerAuthRspAtSeq4Action() sanity check fail\n"));
+	}
 }
 
 /*
@@ -289,47 +321,49 @@ VOID PeerAuthRspAtSeq4Action(
 
     ==========================================================================
  */
-VOID MlmeDeauthReqAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeDeauthReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-    MLME_DEAUTH_REQ_STRUCT *pInfo;
-    HEADER_802_11 DeauthHdr;
-    PUCHAR        pOutBuffer = NULL;
-    NDIS_STATUS   NStatus;
-    ULONG         FrameLen = 0;
-    USHORT        Status;
-
-    pInfo = (MLME_DEAUTH_REQ_STRUCT *)Elem->Msg;
-
-    NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-    if (NStatus != NDIS_STATUS_SUCCESS)
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("AUTH - MlmeDeauthReqAction() allocate memory fail\n"));
-        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-        Status = MLME_FAIL_NO_RESOURCE;
-        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2, &Status);
-        return;
-    }
-
-    DBGPRINT(RT_DEBUG_TRACE, ("AUTH - Send DE-AUTH request (Reason=%d)...\n", pInfo->Reason));
-    MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pInfo->Addr, pAd->MlmeAux.Bssid);
-    MakeOutgoingFrame(pOutBuffer,           &FrameLen,
-                      sizeof(HEADER_802_11),&DeauthHdr,
-                      2,                    &pInfo->Reason,
-                      END_OF_ARGS);
-    MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
+	MLME_DEAUTH_REQ_STRUCT *pInfo;
+	HEADER_802_11 DeauthHdr;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	ULONG FrameLen = 0;
+	USHORT Status;
+
+	pInfo = (MLME_DEAUTH_REQ_STRUCT *) Elem->Msg;
+
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("AUTH - MlmeDeauthReqAction() allocate memory fail\n"));
+		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+		Status = MLME_FAIL_NO_RESOURCE;
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2,
+			    &Status);
+		return;
+	}
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AUTH - Send DE-AUTH request (Reason=%d)...\n",
+		  pInfo->Reason));
+	MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pInfo->Addr,
+			 pAd->MlmeAux.Bssid);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(HEADER_802_11),
+			  &DeauthHdr, 2, &pInfo->Reason, END_OF_ARGS);
+	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
 
-    pAd->StaCfg.DeauthReason = pInfo->Reason;
-    COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pInfo->Addr);
-    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-    Status = MLME_SUCCESS;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2, &Status);
+	pAd->StaCfg.DeauthReason = pInfo->Reason;
+	COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pInfo->Addr);
+	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+	Status = MLME_SUCCESS;
+	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_DEAUTH_CONF, 2, &Status);
 
 	// send wireless event - for deauthentication
 	if (pAd->CommonCfg.bWirelessEvent)
-		RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+		RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG,
+				      pAd->MacTab.Content[BSSID_WCID].Addr,
+				      BSS0, 0);
 }
 
 /*
@@ -340,15 +374,13 @@ VOID MlmeDeauthReqAction(
 
     ==========================================================================
  */
-VOID AuthTimeoutAction(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID AuthTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, ("AUTH - AuthTimeoutAction\n"));
-    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-    Status = MLME_REJ_TIMEOUT;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+	USHORT Status;
+	DBGPRINT(RT_DEBUG_TRACE, ("AUTH - AuthTimeoutAction\n"));
+	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+	Status = MLME_REJ_TIMEOUT;
+	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
 }
 
 /*
@@ -359,15 +391,15 @@ VOID AuthTimeoutAction(
 
     ==========================================================================
  */
-VOID InvalidStateWhenAuth(
-    IN PRTMP_ADAPTER pAd,
-    IN MLME_QUEUE_ELEM *Elem)
+VOID InvalidStateWhenAuth(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-    USHORT Status;
-    DBGPRINT(RT_DEBUG_TRACE, ("AUTH - InvalidStateWhenAuth (state=%ld), reset AUTH state machine\n", pAd->Mlme.AuthMachine.CurrState));
-    pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-    Status = MLME_STATE_MACHINE_REJECT;
-    MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
+	USHORT Status;
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AUTH - InvalidStateWhenAuth (state=%ld), reset AUTH state machine\n",
+		  pAd->Mlme.AuthMachine.CurrState));
+	pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+	Status = MLME_STATE_MACHINE_REJECT;
+	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
 }
 
 /*
@@ -382,109 +414,104 @@ VOID InvalidStateWhenAuth(
 
     ==========================================================================
  */
-VOID Cls2errAction(
-    IN PRTMP_ADAPTER pAd,
-    IN PUCHAR pAddr)
+VOID Cls2errAction(IN PRTMP_ADAPTER pAd, IN PUCHAR pAddr)
 {
-    HEADER_802_11 DeauthHdr;
-    PUCHAR        pOutBuffer = NULL;
-    NDIS_STATUS   NStatus;
-    ULONG         FrameLen = 0;
-    USHORT        Reason = REASON_CLS2ERR;
-
-    NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-    if (NStatus != NDIS_STATUS_SUCCESS)
-        return;
-
-    DBGPRINT(RT_DEBUG_TRACE, ("AUTH - Class 2 error, Send DEAUTH frame...\n"));
-    MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pAddr, pAd->MlmeAux.Bssid);
-    MakeOutgoingFrame(pOutBuffer,           &FrameLen,
-                      sizeof(HEADER_802_11),&DeauthHdr,
-                      2,                    &Reason,
-                      END_OF_ARGS);
-    MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
+	HEADER_802_11 DeauthHdr;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+	ULONG FrameLen = 0;
+	USHORT Reason = REASON_CLS2ERR;
+
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	if (NStatus != NDIS_STATUS_SUCCESS)
+		return;
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AUTH - Class 2 error, Send DEAUTH frame...\n"));
+	MgtMacHeaderInit(pAd, &DeauthHdr, SUBTYPE_DEAUTH, 0, pAddr,
+			 pAd->MlmeAux.Bssid);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(HEADER_802_11),
+			  &DeauthHdr, 2, &Reason, END_OF_ARGS);
+	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
 
-    pAd->StaCfg.DeauthReason = Reason;
-    COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pAddr);
+	pAd->StaCfg.DeauthReason = Reason;
+	COPY_MAC_ADDR(pAd->StaCfg.DeauthSta, pAddr);
 }
 
-BOOLEAN	AUTH_ReqSend(
-	IN  PRTMP_ADAPTER		pAd,
-	IN  PMLME_QUEUE_ELEM	pElem,
-	IN  PRALINK_TIMER_STRUCT pAuthTimer,
-	IN  PSTRING				pSMName,
-	IN  USHORT				SeqNo,
-	IN  PUCHAR				pNewElement,
-	IN  ULONG				ElementLen)
+BOOLEAN AUTH_ReqSend(IN PRTMP_ADAPTER pAd,
+		     IN PMLME_QUEUE_ELEM pElem,
+		     IN PRALINK_TIMER_STRUCT pAuthTimer,
+		     IN PSTRING pSMName,
+		     IN USHORT SeqNo,
+		     IN PUCHAR pNewElement, IN ULONG ElementLen)
 {
-	USHORT             Alg, Seq, Status;
-	UCHAR              Addr[6];
-    ULONG              Timeout;
-    HEADER_802_11      AuthHdr;
-    BOOLEAN            TimerCancelled;
-    NDIS_STATUS        NStatus;
-    PUCHAR             pOutBuffer = NULL;
-    ULONG              FrameLen = 0, tmp = 0;
+	USHORT Alg, Seq, Status;
+	UCHAR Addr[6];
+	ULONG Timeout;
+	HEADER_802_11 AuthHdr;
+	BOOLEAN TimerCancelled;
+	NDIS_STATUS NStatus;
+	PUCHAR pOutBuffer = NULL;
+	ULONG FrameLen = 0, tmp = 0;
 
 	// Block all authentication request durning WPA block period
-	if (pAd->StaCfg.bBlockAssoc == TRUE)
-	{
-        DBGPRINT(RT_DEBUG_TRACE, ("%s - Block Auth request durning WPA block period!\n", pSMName));
-        pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-        Status = MLME_STATE_MACHINE_REJECT;
-        MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-	}
-    else if(MlmeAuthReqSanity(pAd, pElem->Msg, pElem->MsgLen, Addr, &Timeout, &Alg))
-    {
-	/* reset timer */
+	if (pAd->StaCfg.bBlockAssoc == TRUE) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s - Block Auth request durning WPA block period!\n",
+			  pSMName));
+		pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+		Status = MLME_STATE_MACHINE_REJECT;
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2,
+			    &Status);
+	} else
+	    if (MlmeAuthReqSanity
+		(pAd, pElem->Msg, pElem->MsgLen, Addr, &Timeout, &Alg)) {
+		/* reset timer */
 		RTMPCancelTimer(pAuthTimer, &TimerCancelled);
 
-        COPY_MAC_ADDR(pAd->MlmeAux.Bssid, Addr);
-        pAd->MlmeAux.Alg  = Alg;
-        Seq = SeqNo;
-        Status = MLME_SUCCESS;
-
-        NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-        if(NStatus != NDIS_STATUS_SUCCESS)
-        {
-            DBGPRINT(RT_DEBUG_TRACE, ("%s - MlmeAuthReqAction(Alg:%d) allocate memory failed\n", pSMName, Alg));
-            pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
-            Status = MLME_FAIL_NO_RESOURCE;
-            MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF, 2, &Status);
-            return FALSE;
-        }
-
-        DBGPRINT(RT_DEBUG_TRACE, ("%s - Send AUTH request seq#1 (Alg=%d)...\n", pSMName, Alg));
-        MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr, pAd->MlmeAux.Bssid);
-        MakeOutgoingFrame(pOutBuffer,           &FrameLen,
-                          sizeof(HEADER_802_11),&AuthHdr,
-                          2,                    &Alg,
-                          2,                    &Seq,
-                          2,                    &Status,
-                          END_OF_ARGS);
-
-		if (pNewElement && ElementLen)
-		{
-			MakeOutgoingFrame(pOutBuffer+FrameLen,	&tmp,
-							  ElementLen,			pNewElement,
+		COPY_MAC_ADDR(pAd->MlmeAux.Bssid, Addr);
+		pAd->MlmeAux.Alg = Alg;
+		Seq = SeqNo;
+		Status = MLME_SUCCESS;
+
+		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+		if (NStatus != NDIS_STATUS_SUCCESS) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("%s - MlmeAuthReqAction(Alg:%d) allocate memory failed\n",
+				  pSMName, Alg));
+			pAd->Mlme.AuthMachine.CurrState = AUTH_REQ_IDLE;
+			Status = MLME_FAIL_NO_RESOURCE;
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_AUTH_CONF,
+				    2, &Status);
+			return FALSE;
+		}
+
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("%s - Send AUTH request seq#1 (Alg=%d)...\n", pSMName,
+			  Alg));
+		MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, Addr,
+				 pAd->MlmeAux.Bssid);
+		MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(HEADER_802_11),
+				  &AuthHdr, 2, &Alg, 2, &Seq, 2, &Status,
 				  END_OF_ARGS);
+
+		if (pNewElement && ElementLen) {
+			MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+					  ElementLen, pNewElement, END_OF_ARGS);
 			FrameLen += tmp;
 		}
 
-        MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
-	MlmeFreeMemory(pAd, pOutBuffer);
+		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
+		MlmeFreeMemory(pAd, pOutBuffer);
 
 		RTMPSetTimer(pAuthTimer, Timeout);
 		return TRUE;
-    }
-    else
-    {
-        DBGPRINT_ERR(("%s - MlmeAuthReqAction() sanity check failed\n", pSMName));
+	} else {
+		DBGPRINT_ERR(("%s - MlmeAuthReqAction() sanity check failed\n",
+			      pSMName));
 		return FALSE;
-    }
+	}
 
 	return TRUE;
 }
-
-
diff --git a/drivers/staging/rt2860/sta/auth_rsp.c b/drivers/staging/rt2860/sta/auth_rsp.c
index 9c2fde4..3f383c5 100644
--- a/drivers/staging/rt2860/sta/auth_rsp.c
+++ b/drivers/staging/rt2860/sta/auth_rsp.c
@@ -47,18 +47,21 @@
 
     ==========================================================================
  */
-VOID AuthRspStateMachineInit(
-    IN PRTMP_ADAPTER pAd,
-    IN PSTATE_MACHINE Sm,
-    IN STATE_MACHINE_FUNC Trans[])
+VOID AuthRspStateMachineInit(IN PRTMP_ADAPTER pAd,
+			     IN PSTATE_MACHINE Sm,
+			     IN STATE_MACHINE_FUNC Trans[])
 {
-    StateMachineInit(Sm, Trans, MAX_AUTH_RSP_STATE, MAX_AUTH_RSP_MSG, (STATE_MACHINE_FUNC)Drop, AUTH_RSP_IDLE, AUTH_RSP_MACHINE_BASE);
+	StateMachineInit(Sm, Trans, MAX_AUTH_RSP_STATE, MAX_AUTH_RSP_MSG,
+			 (STATE_MACHINE_FUNC) Drop, AUTH_RSP_IDLE,
+			 AUTH_RSP_MACHINE_BASE);
 
-    // column 1
-    StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_PEER_DEAUTH, (STATE_MACHINE_FUNC)PeerDeauthAction);
+	// column 1
+	StateMachineSetAction(Sm, AUTH_RSP_IDLE, MT2_PEER_DEAUTH,
+			      (STATE_MACHINE_FUNC) PeerDeauthAction);
 
-    // column 2
-    StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_PEER_DEAUTH, (STATE_MACHINE_FUNC)PeerDeauthAction);
+	// column 2
+	StateMachineSetAction(Sm, AUTH_RSP_WAIT_CHAL, MT2_PEER_DEAUTH,
+			      (STATE_MACHINE_FUNC) PeerDeauthAction);
 
 }
 
@@ -70,39 +73,32 @@ VOID AuthRspStateMachineInit(
 
     ==========================================================================
 */
-VOID PeerAuthSimpleRspGenAndSend(
-    IN PRTMP_ADAPTER pAd,
-    IN PHEADER_802_11 pHdr80211,
-    IN USHORT Alg,
-    IN USHORT Seq,
-    IN USHORT Reason,
-    IN USHORT Status)
+VOID PeerAuthSimpleRspGenAndSend(IN PRTMP_ADAPTER pAd,
+				 IN PHEADER_802_11 pHdr80211,
+				 IN USHORT Alg,
+				 IN USHORT Seq,
+				 IN USHORT Reason, IN USHORT Status)
 {
-    HEADER_802_11     AuthHdr;
-    ULONG             FrameLen = 0;
-    PUCHAR            pOutBuffer = NULL;
-    NDIS_STATUS       NStatus;
-
-    if (Reason != MLME_SUCCESS)
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("Peer AUTH fail...\n"));
-        return;
-    }
-
+	HEADER_802_11 AuthHdr;
+	ULONG FrameLen = 0;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
+
+	if (Reason != MLME_SUCCESS) {
+		DBGPRINT(RT_DEBUG_TRACE, ("Peer AUTH fail...\n"));
+		return;
+	}
 	//Get an unused nonpaged memory
-    NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
-    if (NStatus != NDIS_STATUS_SUCCESS)
-        return;
-
-    DBGPRINT(RT_DEBUG_TRACE, ("Send AUTH response (seq#2)...\n"));
-    MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, pHdr80211->Addr2, pAd->MlmeAux.Bssid);
-    MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-                      sizeof(HEADER_802_11),    &AuthHdr,
-                      2,                        &Alg,
-                      2,                        &Seq,
-                      2,                        &Reason,
-                      END_OF_ARGS);
-    MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
+	NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
+	if (NStatus != NDIS_STATUS_SUCCESS)
+		return;
+
+	DBGPRINT(RT_DEBUG_TRACE, ("Send AUTH response (seq#2)...\n"));
+	MgtMacHeaderInit(pAd, &AuthHdr, SUBTYPE_AUTH, 0, pHdr80211->Addr2,
+			 pAd->MlmeAux.Bssid);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen, sizeof(HEADER_802_11),
+			  &AuthHdr, 2, &Alg, 2, &Seq, 2, &Reason, END_OF_ARGS);
+	MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 	MlmeFreeMemory(pAd, pOutBuffer);
 }
 
@@ -114,35 +110,33 @@ VOID PeerAuthSimpleRspGenAndSend(
 
     ==========================================================================
 */
-VOID PeerDeauthAction(
-    IN PRTMP_ADAPTER pAd,
-    IN PMLME_QUEUE_ELEM Elem)
+VOID PeerDeauthAction(IN PRTMP_ADAPTER pAd, IN PMLME_QUEUE_ELEM Elem)
 {
-    UCHAR       Addr2[MAC_ADDR_LEN];
-    USHORT      Reason;
-
-    if (PeerDeauthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason))
-    {
-        if (INFRA_ON(pAd)
-			&& MAC_ADDR_EQUAL(Addr2, pAd->CommonCfg.Bssid)
-			)
-        {
-            DBGPRINT(RT_DEBUG_TRACE,("AUTH_RSP - receive DE-AUTH from our AP (Reason=%d)\n", Reason));
+	UCHAR Addr2[MAC_ADDR_LEN];
+	USHORT Reason;
 
+	if (PeerDeauthSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, &Reason)) {
+		if (INFRA_ON(pAd)
+		    && MAC_ADDR_EQUAL(Addr2, pAd->CommonCfg.Bssid)
+		    ) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("AUTH_RSP - receive DE-AUTH from our AP (Reason=%d)\n",
+				  Reason));
 
-		RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
-
+			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL,
+						0);
 
 			// send wireless event - for deauthentication
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
-
-            LinkDown(pAd, TRUE);
-        }
-    }
-    else
-    {
-        DBGPRINT(RT_DEBUG_TRACE,("AUTH_RSP - PeerDeauthAction() sanity check fail\n"));
-    }
+				RTMPSendWirelessEvent(pAd, IW_DEAUTH_EVENT_FLAG,
+						      pAd->MacTab.
+						      Content[BSSID_WCID].Addr,
+						      BSS0, 0);
+
+			LinkDown(pAd, TRUE);
+		}
+	} else {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("AUTH_RSP - PeerDeauthAction() sanity check fail\n"));
+	}
 }
-
diff --git a/drivers/staging/rt2860/sta/connect.c b/drivers/staging/rt2860/sta/connect.c
index 43edd8e..dc8b2d5 100644
--- a/drivers/staging/rt2860/sta/connect.c
+++ b/drivers/staging/rt2860/sta/connect.c
@@ -36,27 +36,31 @@
 */
 #include "../rt_config.h"
 
-UCHAR	CipherSuiteWpaNoneTkip[] = {
-		0x00, 0x50, 0xf2, 0x01,	// oui
-		0x01, 0x00,				// Version
-		0x00, 0x50, 0xf2, 0x02,	// Multicast
-		0x01, 0x00,				// Number of unicast
-		0x00, 0x50, 0xf2, 0x02,	// unicast
-		0x01, 0x00,				// number of authentication method
-		0x00, 0x50, 0xf2, 0x00	// authentication
-		};
-UCHAR	CipherSuiteWpaNoneTkipLen = (sizeof(CipherSuiteWpaNoneTkip) / sizeof(UCHAR));
-
-UCHAR	CipherSuiteWpaNoneAes[] = {
-		0x00, 0x50, 0xf2, 0x01,	// oui
-		0x01, 0x00,				// Version
-		0x00, 0x50, 0xf2, 0x04,	// Multicast
-		0x01, 0x00,				// Number of unicast
-		0x00, 0x50, 0xf2, 0x04,	// unicast
-		0x01, 0x00,				// number of authentication method
-		0x00, 0x50, 0xf2, 0x00	// authentication
-		};
-UCHAR	CipherSuiteWpaNoneAesLen = (sizeof(CipherSuiteWpaNoneAes) / sizeof(UCHAR));
+UCHAR CipherSuiteWpaNoneTkip[] = {
+	0x00, 0x50, 0xf2, 0x01,	// oui
+	0x01, 0x00,		// Version
+	0x00, 0x50, 0xf2, 0x02,	// Multicast
+	0x01, 0x00,		// Number of unicast
+	0x00, 0x50, 0xf2, 0x02,	// unicast
+	0x01, 0x00,		// number of authentication method
+	0x00, 0x50, 0xf2, 0x00	// authentication
+};
+
+UCHAR CipherSuiteWpaNoneTkipLen =
+    (sizeof(CipherSuiteWpaNoneTkip) / sizeof(UCHAR));
+
+UCHAR CipherSuiteWpaNoneAes[] = {
+	0x00, 0x50, 0xf2, 0x01,	// oui
+	0x01, 0x00,		// Version
+	0x00, 0x50, 0xf2, 0x04,	// Multicast
+	0x01, 0x00,		// Number of unicast
+	0x00, 0x50, 0xf2, 0x04,	// unicast
+	0x01, 0x00,		// number of authentication method
+	0x00, 0x50, 0xf2, 0x00	// authentication
+};
+
+UCHAR CipherSuiteWpaNoneAesLen =
+    (sizeof(CipherSuiteWpaNoneAes) / sizeof(UCHAR));
 
 // The following MACRO is called after 1. starting an new IBSS, 2. succesfully JOIN an IBSS,
 // or 3. succesfully ASSOCIATE to a BSS, 4. successfully RE_ASSOCIATE to a BSS
@@ -98,10 +102,8 @@ UCHAR	CipherSuiteWpaNoneAesLen = (sizeof(CipherSuiteWpaNoneAes) / sizeof(UCHAR))
 
 	==========================================================================
 */
-VOID MlmeCntlInit(
-	IN PRTMP_ADAPTER pAd,
-	IN STATE_MACHINE *S,
-	OUT STATE_MACHINE_FUNC Trans[])
+VOID MlmeCntlInit(IN PRTMP_ADAPTER pAd,
+		  IN STATE_MACHINE * S, OUT STATE_MACHINE_FUNC Trans[])
 {
 	// Control state machine differs from other state machines, the interface
 	// follows the standard interface
@@ -116,22 +118,20 @@ VOID MlmeCntlInit(
 
 	==========================================================================
 */
-VOID MlmeCntlMachinePerformAction(
-	IN PRTMP_ADAPTER pAd,
-	IN STATE_MACHINE *S,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeCntlMachinePerformAction(IN PRTMP_ADAPTER pAd,
+				  IN STATE_MACHINE * S,
+				  IN MLME_QUEUE_ELEM * Elem)
 {
-	switch(pAd->Mlme.CntlMachine.CurrState)
-	{
-		case CNTL_IDLE:
-				CntlIdleProc(pAd, Elem);
-			break;
-		case CNTL_WAIT_DISASSOC:
-			CntlWaitDisassocProc(pAd, Elem);
-			break;
-		case CNTL_WAIT_JOIN:
-			CntlWaitJoinProc(pAd, Elem);
-			break;
+	switch (pAd->Mlme.CntlMachine.CurrState) {
+	case CNTL_IDLE:
+		CntlIdleProc(pAd, Elem);
+		break;
+	case CNTL_WAIT_DISASSOC:
+		CntlWaitDisassocProc(pAd, Elem);
+		break;
+	case CNTL_WAIT_JOIN:
+		CntlWaitJoinProc(pAd, Elem);
+		break;
 
 		// CNTL_WAIT_REASSOC is the only state in CNTL machine that does
 		// not triggered directly or indirectly by "RTMPSetInformation(OID_xxx)".
@@ -139,89 +139,87 @@ VOID MlmeCntlMachinePerformAction(
 		// rule. Which means NDIS may SET OID in the middle of ROAMing attempts.
 		// Current approach is to block new SET request at RTMPSetInformation()
 		// when CntlMachine.CurrState is not CNTL_IDLE
-		case CNTL_WAIT_REASSOC:
-			CntlWaitReassocProc(pAd, Elem);
-			break;
-
-		case CNTL_WAIT_START:
-			CntlWaitStartProc(pAd, Elem);
-			break;
-		case CNTL_WAIT_AUTH:
-			CntlWaitAuthProc(pAd, Elem);
-			break;
-		case CNTL_WAIT_AUTH2:
-			CntlWaitAuthProc2(pAd, Elem);
-			break;
-		case CNTL_WAIT_ASSOC:
-			CntlWaitAssocProc(pAd, Elem);
-			break;
+	case CNTL_WAIT_REASSOC:
+		CntlWaitReassocProc(pAd, Elem);
+		break;
+
+	case CNTL_WAIT_START:
+		CntlWaitStartProc(pAd, Elem);
+		break;
+	case CNTL_WAIT_AUTH:
+		CntlWaitAuthProc(pAd, Elem);
+		break;
+	case CNTL_WAIT_AUTH2:
+		CntlWaitAuthProc2(pAd, Elem);
+		break;
+	case CNTL_WAIT_ASSOC:
+		CntlWaitAssocProc(pAd, Elem);
+		break;
+
+	case CNTL_WAIT_OID_LIST_SCAN:
+		if (Elem->MsgType == MT2_SCAN_CONF) {
+			// Resume TxRing after SCANING complete. We hope the out-of-service time
+			// won't be too long to let upper layer time-out the waiting frames
+			RTMPResumeMsduTransmission(pAd);
 
-		case CNTL_WAIT_OID_LIST_SCAN:
-			if(Elem->MsgType == MT2_SCAN_CONF)
-			{
-				// Resume TxRing after SCANING complete. We hope the out-of-service time
-				// won't be too long to let upper layer time-out the waiting frames
-				RTMPResumeMsduTransmission(pAd);
-
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 
-                //
-				// Set LED status to previous status.
-				//
-				if (pAd->bLedOnScanning)
-				{
-					pAd->bLedOnScanning = FALSE;
-					RTMPSetLED(pAd, pAd->LedStatus);
-				}
+			//
+			// Set LED status to previous status.
+			//
+			if (pAd->bLedOnScanning) {
+				pAd->bLedOnScanning = FALSE;
+				RTMPSetLED(pAd, pAd->LedStatus);
 			}
-			break;
+		}
+		break;
 
-		case CNTL_WAIT_OID_DISASSOC:
-			if (Elem->MsgType == MT2_DISASSOC_CONF)
-			{
-				LinkDown(pAd, FALSE);
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			}
-			break;
+	case CNTL_WAIT_OID_DISASSOC:
+		if (Elem->MsgType == MT2_DISASSOC_CONF) {
+			LinkDown(pAd, FALSE);
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+		}
+		break;
 #ifdef RTMP_MAC_USB
 		//
 		// This state is for that we want to connect to an AP but
 		// it didn't find on BSS List table. So we need to scan the air first,
 		// after that we can try to connect to the desired AP if available.
 		//
-		case CNTL_WAIT_SCAN_FOR_CONNECT:
-			if(Elem->MsgType == MT2_SCAN_CONF)
-			{
-				// Resume TxRing after SCANING complete. We hope the out-of-service time
-				// won't be too long to let upper layer time-out the waiting frames
-				RTMPResumeMsduTransmission(pAd);
+	case CNTL_WAIT_SCAN_FOR_CONNECT:
+		if (Elem->MsgType == MT2_SCAN_CONF) {
+			// Resume TxRing after SCANING complete. We hope the out-of-service time
+			// won't be too long to let upper layer time-out the waiting frames
+			RTMPResumeMsduTransmission(pAd);
 #ifdef CCX_SUPPORT
-				if (pAd->StaCfg.CCXReqType != MSRN_TYPE_UNUSED)
-				{
-					// Cisco scan request is finished, prepare beacon report
-					MlmeEnqueue(pAd, AIRONET_STATE_MACHINE, MT2_AIRONET_SCAN_DONE, 0, NULL);
-				}
+			if (pAd->StaCfg.CCXReqType != MSRN_TYPE_UNUSED) {
+				// Cisco scan request is finished, prepare beacon report
+				MlmeEnqueue(pAd, AIRONET_STATE_MACHINE,
+					    MT2_AIRONET_SCAN_DONE, 0, NULL);
+			}
 #endif // CCX_SUPPORT //
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
+			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 
-				//
-				// Check if we can connect to.
-				//
-				BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab, (CHAR *) pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
-				if (pAd->MlmeAux.SsidBssTab.BssNr > 0)
-				{
-					MlmeAutoReconnectLastSSID(pAd);
-				}
+			//
+			// Check if we can connect to.
+			//
+			BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab,
+					 (CHAR *) pAd->MlmeAux.
+					 AutoReconnectSsid,
+					 pAd->MlmeAux.AutoReconnectSsidLen);
+			if (pAd->MlmeAux.SsidBssTab.BssNr > 0) {
+				MlmeAutoReconnectLastSSID(pAd);
 			}
-			break;
+		}
+		break;
 #endif // RTMP_MAC_USB //
-		default:
-			DBGPRINT_ERR(("!ERROR! CNTL - Illegal message type(=%ld)", Elem->MsgType));
-			break;
+	default:
+		DBGPRINT_ERR(("!ERROR! CNTL - Illegal message type(=%ld)",
+			      Elem->MsgType));
+		break;
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -230,94 +228,95 @@ VOID MlmeCntlMachinePerformAction(
 
 	==========================================================================
 */
-VOID CntlIdleProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlIdleProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	MLME_DISASSOC_REQ_STRUCT   DisassocReq;
+	MLME_DISASSOC_REQ_STRUCT DisassocReq;
 
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
 		return;
 
-	switch(Elem->MsgType)
-	{
-		case OID_802_11_SSID:
-			CntlOidSsidProc(pAd, Elem);
-			break;
+	switch (Elem->MsgType) {
+	case OID_802_11_SSID:
+		CntlOidSsidProc(pAd, Elem);
+		break;
 
-		case OID_802_11_BSSID:
-			CntlOidRTBssidProc(pAd,Elem);
-			break;
+	case OID_802_11_BSSID:
+		CntlOidRTBssidProc(pAd, Elem);
+		break;
 
-		case OID_802_11_BSSID_LIST_SCAN:
-			CntlOidScanProc(pAd,Elem);
-			break;
+	case OID_802_11_BSSID_LIST_SCAN:
+		CntlOidScanProc(pAd, Elem);
+		break;
 
-		case OID_802_11_DISASSOCIATE:
-			DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
-
-            if (pAd->StaCfg.WpaSupplicantUP != WPA_SUPPLICANT_ENABLE_WITH_WEB_UI)
-            {
-    			// Set the AutoReconnectSsid to prevent it reconnect to old SSID
-    			// Since calling this indicate user don't want to connect to that SSID anymore.
-    			pAd->MlmeAux.AutoReconnectSsidLen= 32;
-    			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.AutoReconnectSsidLen);
-            }
-			break;
+	case OID_802_11_DISASSOCIATE:
+		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
+				 REASON_DISASSOC_STA_LEAVING);
+		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+			    sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_DISASSOC;
+
+		if (pAd->StaCfg.WpaSupplicantUP !=
+		    WPA_SUPPLICANT_ENABLE_WITH_WEB_UI) {
+			// Set the AutoReconnectSsid to prevent it reconnect to old SSID
+			// Since calling this indicate user don't want to connect to that SSID anymore.
+			pAd->MlmeAux.AutoReconnectSsidLen = 32;
+			NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid,
+				       pAd->MlmeAux.AutoReconnectSsidLen);
+		}
+		break;
 
-		case MT2_MLME_ROAMING_REQ:
-			CntlMlmeRoamingProc(pAd, Elem);
-			break;
+	case MT2_MLME_ROAMING_REQ:
+		CntlMlmeRoamingProc(pAd, Elem);
+		break;
 
-        case OID_802_11_MIC_FAILURE_REPORT_FRAME:
-            WpaMicFailureReportFrame(pAd, Elem);
-            break;
+	case OID_802_11_MIC_FAILURE_REPORT_FRAME:
+		WpaMicFailureReportFrame(pAd, Elem);
+		break;
 
-		default:
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Illegal message in CntlIdleProc(MsgType=%ld)\n",Elem->MsgType));
-			break;
+	default:
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("CNTL - Illegal message in CntlIdleProc(MsgType=%ld)\n",
+			  Elem->MsgType));
+		break;
 	}
 }
 
-VOID CntlOidScanProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlOidScanProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	MLME_SCAN_REQ_STRUCT       ScanReq;
-	ULONG                      BssIdx = BSS_NOT_FOUND;
-	BSS_ENTRY                  CurrBss;
-
-
+	MLME_SCAN_REQ_STRUCT ScanReq;
+	ULONG BssIdx = BSS_NOT_FOUND;
+	BSS_ENTRY CurrBss;
 
 	// record current BSS if network is connected.
 	// 2003-2-13 do not include current IBSS if this is the only STA in this IBSS.
-	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-	{
-		BssIdx = BssSsidTableSearch(&pAd->ScanTab, pAd->CommonCfg.Bssid, (PUCHAR)pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen, pAd->CommonCfg.Channel);
-		if (BssIdx != BSS_NOT_FOUND)
-		{
-			NdisMoveMemory(&CurrBss, &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
+		BssIdx =
+		    BssSsidTableSearch(&pAd->ScanTab, pAd->CommonCfg.Bssid,
+				       (PUCHAR) pAd->CommonCfg.Ssid,
+				       pAd->CommonCfg.SsidLen,
+				       pAd->CommonCfg.Channel);
+		if (BssIdx != BSS_NOT_FOUND) {
+			NdisMoveMemory(&CurrBss, &pAd->ScanTab.BssEntry[BssIdx],
+				       sizeof(BSS_ENTRY));
 		}
 	}
-
 	// clean up previous SCAN result, add current BSS back to table if any
 	BssTableInit(&pAd->ScanTab);
-	if (BssIdx != BSS_NOT_FOUND)
-	{
+	if (BssIdx != BSS_NOT_FOUND) {
 		// DDK Note: If the NIC is associated with a particular BSSID and SSID
 		//    that are not contained in the list of BSSIDs generated by this scan, the
 		//    BSSID description of the currently associated BSSID and SSID should be
 		//    appended to the list of BSSIDs in the NIC's database.
 		// To ensure this, we append this BSS as the first entry in SCAN result
-		NdisMoveMemory(&pAd->ScanTab.BssEntry[0], &CurrBss, sizeof(BSS_ENTRY));
+		NdisMoveMemory(&pAd->ScanTab.BssEntry[0], &CurrBss,
+			       sizeof(BSS_ENTRY));
 		pAd->ScanTab.BssNr = 1;
 	}
 
-	ScanParmFill(pAd, &ScanReq, (PSTRING) Elem->Msg, Elem->MsgLen, BSS_ANY, SCAN_ACTIVE);
+	ScanParmFill(pAd, &ScanReq, (PSTRING) Elem->Msg, Elem->MsgLen, BSS_ANY,
+		     SCAN_ACTIVE);
 	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
-		sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+		    sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
 	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
 }
 
@@ -330,19 +329,16 @@ VOID CntlOidScanProc(
 
 	==========================================================================
 */
-VOID CntlOidSsidProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM * Elem)
+VOID CntlOidSsidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	PNDIS_802_11_SSID          pOidSsid = (NDIS_802_11_SSID *)Elem->Msg;
-	MLME_DISASSOC_REQ_STRUCT   DisassocReq;
-	ULONG					   Now;
-
+	PNDIS_802_11_SSID pOidSsid = (NDIS_802_11_SSID *) Elem->Msg;
+	MLME_DISASSOC_REQ_STRUCT DisassocReq;
+	ULONG Now;
 
 	// Step 1. record the desired user settings to MlmeAux
 	NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
 	NdisMoveMemory(pAd->MlmeAux.Ssid, pOidSsid->Ssid, pOidSsid->SsidLength);
-	pAd->MlmeAux.SsidLen = (UCHAR)pOidSsid->SsidLength;
+	pAd->MlmeAux.SsidLen = (UCHAR) pOidSsid->SsidLength;
 	NdisZeroMemory(pAd->MlmeAux.Bssid, MAC_ADDR_LEN);
 	pAd->MlmeAux.BssType = pAd->StaCfg.BssType;
 
@@ -352,83 +348,97 @@ VOID CntlOidSsidProc(
 	// Update Reconnect Ssid, that user desired to connect.
 	//
 	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
-	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->MlmeAux.Ssid,
+		       pAd->MlmeAux.SsidLen);
 	pAd->MlmeAux.AutoReconnectSsidLen = pAd->MlmeAux.SsidLen;
 
 	// step 2. find all matching BSS in the lastest SCAN result (inBssTab)
 	//    & log them into MlmeAux.SsidBssTab for later-on iteration. Sort by RSSI order
-	BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab, (PCHAR)pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
+	BssTableSsidSort(pAd, &pAd->MlmeAux.SsidBssTab,
+			 (PCHAR) pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():CNTL - %d BSS of %d BSS match the desire (%d)SSID - %s\n",
-			pAd->MlmeAux.SsidBssTab.BssNr, pAd->ScanTab.BssNr, pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("CntlOidSsidProc():CNTL - %d BSS of %d BSS match the desire (%d)SSID - %s\n",
+		  pAd->MlmeAux.SsidBssTab.BssNr, pAd->ScanTab.BssNr,
+		  pAd->MlmeAux.SsidLen, pAd->MlmeAux.Ssid));
 	NdisGetSystemUpTime(&Now);
 
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) &&
-		(pAd->CommonCfg.SsidLen == pAd->MlmeAux.SsidBssTab.BssEntry[0].SsidLen) &&
-		NdisEqualMemory(pAd->CommonCfg.Ssid, pAd->MlmeAux.SsidBssTab.BssEntry[0].Ssid, pAd->CommonCfg.SsidLen) &&
-		MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid, pAd->MlmeAux.SsidBssTab.BssEntry[0].Bssid))
-	{
+	    (pAd->CommonCfg.SsidLen ==
+	     pAd->MlmeAux.SsidBssTab.BssEntry[0].SsidLen)
+	    && NdisEqualMemory(pAd->CommonCfg.Ssid,
+			       pAd->MlmeAux.SsidBssTab.BssEntry[0].Ssid,
+			       pAd->CommonCfg.SsidLen)
+	    && MAC_ADDR_EQUAL(pAd->CommonCfg.Bssid,
+			      pAd->MlmeAux.SsidBssTab.BssEntry[0].Bssid)) {
 		// Case 1. already connected with an AP who has the desired SSID
 		//         with highest RSSI
 
 		// Add checking Mode "LEAP" for CCX 1.0
 		if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-			 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-			 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
-			 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-			 ) &&
-			(pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
-		{
+		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+		     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+		    ) &&
+		    (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) {
 			// case 1.1 For WPA, WPA-PSK, if the 1x port is not secured, we have to redo
 			//          connection process
-			DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
-			DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
+			DisassocParmFill(pAd, &DisassocReq,
+					 pAd->CommonCfg.Bssid,
+					 REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
+				    MT2_MLME_DISASSOC_REQ,
+				    sizeof(MLME_DISASSOC_REQ_STRUCT),
+				    &DisassocReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-		}
-		else if (pAd->bConfigChanged == TRUE)
-		{
+		} else if (pAd->bConfigChanged == TRUE) {
 			// case 1.2 Important Config has changed, we have to reconnect to the same AP
-			DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():CNTL - disassociate with current AP Because config changed...\n"));
-			DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CntlOidSsidProc():CNTL - disassociate with current AP Because config changed...\n"));
+			DisassocParmFill(pAd, &DisassocReq,
+					 pAd->CommonCfg.Bssid,
+					 REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
+				    MT2_MLME_DISASSOC_REQ,
+				    sizeof(MLME_DISASSOC_REQ_STRUCT),
+				    &DisassocReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-		}
-		else
-		{
+		} else {
 			// case 1.3. already connected to the SSID with highest RSSI.
-			DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():CNTL - already with this BSSID. ignore this SET_SSID request\n"));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CntlOidSsidProc():CNTL - already with this BSSID. ignore this SET_SSID request\n"));
 			//
 			// (HCT 12.1) 1c_wlan_mediaevents required
 			// media connect events are indicated when associating with the same AP
 			//
-			if (INFRA_ON(pAd))
-			{
+			if (INFRA_ON(pAd)) {
 				//
 				// Since MediaState already is NdisMediaStateConnected
 				// We just indicate the connect event again to meet the WHQL required.
 				//
-				pAd->IndicateMediaState = NdisMediaStateConnected;
+				pAd->IndicateMediaState =
+				    NdisMediaStateConnected;
 				RTMP_IndicateMediaState(pAd);
-                pAd->ExtraInfo = GENERAL_LINK_UP;   // Update extra information to link is up
+				pAd->ExtraInfo = GENERAL_LINK_UP;	// Update extra information to link is up
 			}
 
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, &pAd->MlmeAux.Bssid[0], NULL, 0);
+			RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1,
+						&pAd->MlmeAux.Bssid[0], NULL,
+						0);
 		}
-	}
-	else if (INFRA_ON(pAd))
-	{
+	} else if (INFRA_ON(pAd)) {
 		//
 		// For RT61
 		// [88888] OID_802_11_SSID should have returned NDTEST_WEP_AP2(Returned: )
 		// RT61 may lost SSID, and not connect to NDTEST_WEP_AP2 and will connect to NDTEST_WEP_AP2 by Autoreconnect
 		// But media status is connected, so the SSID not report correctly.
 		//
-		if (!SSID_EQUAL(pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen))
-		{
+		if (!SSID_EQUAL
+		    (pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen,
+		     pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen)) {
 			//
 			// Different SSID means not Roaming case, so we let LinkDown() to Indicate a disconnect event.
 			//
@@ -440,49 +450,53 @@ VOID CntlOidSsidProc(
 		//    disassociate with the current associated AP,
 		//    then perform a new association with this new SSID, no matter the
 		//    new/old SSID are the same or not.
-		DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
-		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("CntlOidSsidProc():CNTL - disassociate with current AP...\n"));
+		DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
+				 REASON_DISASSOC_STA_LEAVING);
 		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-					sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			    sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-	}
-	else
-	{
-		if (ADHOC_ON(pAd))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():CNTL - drop current ADHOC\n"));
+	} else {
+		if (ADHOC_ON(pAd)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CntlOidSsidProc():CNTL - drop current ADHOC\n"));
 			LinkDown(pAd, FALSE);
-			OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+			OPSTATUS_CLEAR_FLAG(pAd,
+					    fOP_STATUS_MEDIA_STATE_CONNECTED);
 			pAd->IndicateMediaState = NdisMediaStateDisconnected;
 			RTMP_IndicateMediaState(pAd);
-            pAd->ExtraInfo = GENERAL_LINK_DOWN;
-			DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():NDIS_STATUS_MEDIA_DISCONNECT Event C!\n"));
+			pAd->ExtraInfo = GENERAL_LINK_DOWN;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CntlOidSsidProc():NDIS_STATUS_MEDIA_DISCONNECT Event C!\n"));
 		}
 
 		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0) &&
-			(pAd->StaCfg.bAutoReconnect == TRUE) &&
-			(pAd->MlmeAux.BssType == BSS_INFRA) &&
-			(MlmeValidateSSID(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen) == TRUE)
-			)
-		{
-			MLME_SCAN_REQ_STRUCT       ScanReq;
-
-			DBGPRINT(RT_DEBUG_TRACE, ("CntlOidSsidProc():CNTL - No matching BSS, start a new scan\n"));
-			ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
+		    (pAd->StaCfg.bAutoReconnect == TRUE) &&
+		    (pAd->MlmeAux.BssType == BSS_INFRA) &&
+		    (MlmeValidateSSID(pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen)
+		     == TRUE)
+		    ) {
+			MLME_SCAN_REQ_STRUCT ScanReq;
+
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CntlOidSsidProc():CNTL - No matching BSS, start a new scan\n"));
+			ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid,
+				     pAd->MlmeAux.SsidLen, BSS_ANY,
+				     SCAN_ACTIVE);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
+				    sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+			pAd->Mlme.CntlMachine.CurrState =
+			    CNTL_WAIT_OID_LIST_SCAN;
 			// Reset Missed scan number
 			pAd->StaCfg.LastScanTime = Now;
-		}
-		else
-		{
+		} else {
 			pAd->MlmeAux.BssIdx = 0;
 			IterateOnBssTab(pAd);
 		}
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -491,14 +505,12 @@ VOID CntlOidSsidProc(
 
 	==========================================================================
 */
-VOID CntlOidRTBssidProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM * Elem)
+VOID CntlOidRTBssidProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	ULONG       BssIdx;
-	PUCHAR      pOidBssid = (PUCHAR)Elem->Msg;
-	MLME_DISASSOC_REQ_STRUCT    DisassocReq;
-	MLME_JOIN_REQ_STRUCT        JoinReq;
+	ULONG BssIdx;
+	PUCHAR pOidBssid = (PUCHAR) Elem->Msg;
+	MLME_DISASSOC_REQ_STRUCT DisassocReq;
+	MLME_JOIN_REQ_STRUCT JoinReq;
 
 	// record user desired settings
 	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pOidBssid);
@@ -506,110 +518,149 @@ VOID CntlOidRTBssidProc(
 
 	// find the desired BSS in the latest SCAN result table
 	BssIdx = BssTableSearch(&pAd->ScanTab, pOidBssid, pAd->MlmeAux.Channel);
-	if (BssIdx == BSS_NOT_FOUND)
-	{
-		MLME_SCAN_REQ_STRUCT       ScanReq;
+	if (BssIdx == BSS_NOT_FOUND) {
+		MLME_SCAN_REQ_STRUCT ScanReq;
 
-		DBGPRINT(RT_DEBUG_TRACE, ("CNTL - BSSID not found. reply NDIS_STATUS_NOT_ACCEPTED\n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("CNTL - BSSID not found. reply NDIS_STATUS_NOT_ACCEPTED\n"));
 		//pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 
-		DBGPRINT(RT_DEBUG_TRACE, ("CNTL - BSSID not found. start a new scan\n"));
-		ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
-		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ, sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("CNTL - BSSID not found. start a new scan\n"));
+		ScanParmFill(pAd, &ScanReq, (PSTRING) pAd->MlmeAux.Ssid,
+			     pAd->MlmeAux.SsidLen, BSS_ANY, SCAN_ACTIVE);
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_SCAN_REQ,
+			    sizeof(MLME_SCAN_REQ_STRUCT), &ScanReq);
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_OID_LIST_SCAN;
 		// Reset Missed scan number
 		NdisGetSystemUpTime(&pAd->StaCfg.LastScanTime);
 		return;
 	}
-
 	//
 	// Update Reconnect Ssid, that user desired to connect.
 	//
 	NdisZeroMemory(pAd->MlmeAux.AutoReconnectSsid, MAX_LEN_OF_SSID);
-	pAd->MlmeAux.AutoReconnectSsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->ScanTab.BssEntry[BssIdx].SsidLen);
+	pAd->MlmeAux.AutoReconnectSsidLen =
+	    pAd->ScanTab.BssEntry[BssIdx].SsidLen;
+	NdisMoveMemory(pAd->MlmeAux.AutoReconnectSsid,
+		       pAd->ScanTab.BssEntry[BssIdx].Ssid,
+		       pAd->ScanTab.BssEntry[BssIdx].SsidLen);
 
 	// copy the matched BSS entry from ScanTab to MlmeAux.SsidBssTab. Why?
 	// Because we need this entry to become the JOIN target in later on SYNC state machine
 	pAd->MlmeAux.BssIdx = 0;
 	pAd->MlmeAux.SsidBssTab.BssNr = 1;
-	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab.BssEntry[0], &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
+	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab.BssEntry[0],
+		       &pAd->ScanTab.BssEntry[BssIdx], sizeof(BSS_ENTRY));
 
 	// Add SSID into MlmeAux for site surey joining hidden SSID
 	pAd->MlmeAux.SsidLen = pAd->ScanTab.BssEntry[BssIdx].SsidLen;
-	NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid, pAd->MlmeAux.SsidLen);
+	NdisMoveMemory(pAd->MlmeAux.Ssid, pAd->ScanTab.BssEntry[BssIdx].Ssid,
+		       pAd->MlmeAux.SsidLen);
 
 	{
-		if (INFRA_ON(pAd))
-		{
+		if (INFRA_ON(pAd)) {
 			// disassoc from current AP first
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - disassociate with current AP ...\n"));
-			DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_DISASSOC_STA_LEAVING);
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
-						sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - disassociate with current AP ...\n"));
+			DisassocParmFill(pAd, &DisassocReq,
+					 pAd->CommonCfg.Bssid,
+					 REASON_DISASSOC_STA_LEAVING);
+			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
+				    MT2_MLME_DISASSOC_REQ,
+				    sizeof(MLME_DISASSOC_REQ_STRUCT),
+				    &DisassocReq);
 
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
-		}
-		else
-		{
-			if (ADHOC_ON(pAd))
-			{
-				DBGPRINT(RT_DEBUG_TRACE, ("CNTL - drop current ADHOC\n"));
+		} else {
+			if (ADHOC_ON(pAd)) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("CNTL - drop current ADHOC\n"));
 				LinkDown(pAd, FALSE);
-				OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
-				pAd->IndicateMediaState = NdisMediaStateDisconnected;
+				OPSTATUS_CLEAR_FLAG(pAd,
+						    fOP_STATUS_MEDIA_STATE_CONNECTED);
+				pAd->IndicateMediaState =
+				    NdisMediaStateDisconnected;
 				RTMP_IndicateMediaState(pAd);
-                pAd->ExtraInfo = GENERAL_LINK_DOWN;
-				DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_DISCONNECT Event C!\n"));
+				pAd->ExtraInfo = GENERAL_LINK_DOWN;
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("NDIS_STATUS_MEDIA_DISCONNECT Event C!\n"));
 			}
-
 			// Change the wepstatus to original wepstatus
-			pAd->StaCfg.WepStatus   = pAd->StaCfg.OrigWepStatus;
-			pAd->StaCfg.PairCipher  = pAd->StaCfg.OrigWepStatus;
+			pAd->StaCfg.WepStatus = pAd->StaCfg.OrigWepStatus;
+			pAd->StaCfg.PairCipher = pAd->StaCfg.OrigWepStatus;
 			pAd->StaCfg.GroupCipher = pAd->StaCfg.OrigWepStatus;
 
 			// Check cipher suite, AP must have more secured cipher than station setting
 			// Set the Pairwise and Group cipher to match the intended AP setting
 			// We can only connect to AP with less secured cipher setting
-			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
-			{
-				pAd->StaCfg.GroupCipher = pAd->ScanTab.BssEntry[BssIdx].WPA.GroupCipher;
-
-				if (pAd->StaCfg.WepStatus == pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipher)
-					pAd->StaCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipher;
-				else if (pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipherAux != Ndis802_11WEPDisabled)
-					pAd->StaCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA.PairCipherAux;
+			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+			    || (pAd->StaCfg.AuthMode ==
+				Ndis802_11AuthModeWPAPSK)) {
+				pAd->StaCfg.GroupCipher =
+				    pAd->ScanTab.BssEntry[BssIdx].WPA.
+				    GroupCipher;
+
+				if (pAd->StaCfg.WepStatus ==
+				    pAd->ScanTab.BssEntry[BssIdx].WPA.
+				    PairCipher)
+					pAd->StaCfg.PairCipher =
+					    pAd->ScanTab.BssEntry[BssIdx].WPA.
+					    PairCipher;
+				else if (pAd->ScanTab.BssEntry[BssIdx].WPA.
+					 PairCipherAux != Ndis802_11WEPDisabled)
+					pAd->StaCfg.PairCipher =
+					    pAd->ScanTab.BssEntry[BssIdx].WPA.
+					    PairCipherAux;
 				else	// There is no PairCipher Aux, downgrade our capability to TKIP
-					pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
-			}
-			else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
-			{
-				pAd->StaCfg.GroupCipher = pAd->ScanTab.BssEntry[BssIdx].WPA2.GroupCipher;
-
-				if (pAd->StaCfg.WepStatus == pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipher)
-					pAd->StaCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipher;
-				else if (pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipherAux != Ndis802_11WEPDisabled)
-					pAd->StaCfg.PairCipher = pAd->ScanTab.BssEntry[BssIdx].WPA2.PairCipherAux;
+					pAd->StaCfg.PairCipher =
+					    Ndis802_11Encryption2Enabled;
+			} else
+			    if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+				|| (pAd->StaCfg.AuthMode ==
+				    Ndis802_11AuthModeWPA2PSK)) {
+				pAd->StaCfg.GroupCipher =
+				    pAd->ScanTab.BssEntry[BssIdx].WPA2.
+				    GroupCipher;
+
+				if (pAd->StaCfg.WepStatus ==
+				    pAd->ScanTab.BssEntry[BssIdx].WPA2.
+				    PairCipher)
+					pAd->StaCfg.PairCipher =
+					    pAd->ScanTab.BssEntry[BssIdx].WPA2.
+					    PairCipher;
+				else if (pAd->ScanTab.BssEntry[BssIdx].WPA2.
+					 PairCipherAux != Ndis802_11WEPDisabled)
+					pAd->StaCfg.PairCipher =
+					    pAd->ScanTab.BssEntry[BssIdx].WPA2.
+					    PairCipherAux;
 				else	// There is no PairCipher Aux, downgrade our capability to TKIP
-					pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
+					pAd->StaCfg.PairCipher =
+					    Ndis802_11Encryption2Enabled;
 
 				// RSN capability
-				pAd->StaCfg.RsnCapability = pAd->ScanTab.BssEntry[BssIdx].WPA2.RsnCapability;
+				pAd->StaCfg.RsnCapability =
+				    pAd->ScanTab.BssEntry[BssIdx].WPA2.
+				    RsnCapability;
 			}
-
 			// Set Mix cipher flag
-			pAd->StaCfg.bMixCipher = (pAd->StaCfg.PairCipher == pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
+			pAd->StaCfg.bMixCipher =
+			    (pAd->StaCfg.PairCipher ==
+			     pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
 			/*if (pAd->StaCfg.bMixCipher == TRUE)
-			{
-				// If mix cipher, re-build RSNIE
-				RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
-			}*/
+			   {
+			   // If mix cipher, re-build RSNIE
+			   RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
+			   } */
 			// No active association, join the BSS immediately
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - joining %02x:%02x:%02x:%02x:%02x:%02x ...\n",
-				pOidBssid[0],pOidBssid[1],pOidBssid[2],pOidBssid[3],pOidBssid[4],pOidBssid[5]));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - joining %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+				  pOidBssid[0], pOidBssid[1], pOidBssid[2],
+				  pOidBssid[3], pOidBssid[4], pOidBssid[5]));
 
 			JoinParmFill(pAd, &JoinReq, pAd->MlmeAux.BssIdx);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ, sizeof(MLME_JOIN_REQ_STRUCT), &JoinReq);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ,
+				    sizeof(MLME_JOIN_REQ_STRUCT), &JoinReq);
 
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
 		}
@@ -624,13 +675,11 @@ VOID CntlOidRTBssidProc(
 // or been corrupted by other "SET OID"?
 //
 // IRQL = DISPATCH_LEVEL
-VOID CntlMlmeRoamingProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlMlmeRoamingProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	UCHAR BBPValue = 0;
 
-	DBGPRINT(RT_DEBUG_TRACE,("CNTL - Roaming in MlmeAux.RoamTab...\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Roaming in MlmeAux.RoamTab...\n"));
 
 	{
 		//Let BBP register at 20MHz to do (fast) roaming.
@@ -638,16 +687,16 @@ VOID CntlMlmeRoamingProc(
 		BBPValue &= (~0x18);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
 
-	NdisMoveMemory(&pAd->MlmeAux.SsidBssTab, &pAd->MlmeAux.RoamTab, sizeof(pAd->MlmeAux.RoamTab));
-	pAd->MlmeAux.SsidBssTab.BssNr = pAd->MlmeAux.RoamTab.BssNr;
+		NdisMoveMemory(&pAd->MlmeAux.SsidBssTab, &pAd->MlmeAux.RoamTab,
+			       sizeof(pAd->MlmeAux.RoamTab));
+		pAd->MlmeAux.SsidBssTab.BssNr = pAd->MlmeAux.RoamTab.BssNr;
 
-	BssTableSortByRssi(&pAd->MlmeAux.SsidBssTab);
-	pAd->MlmeAux.BssIdx = 0;
-	IterateOnBssTab(pAd);
+		BssTableSortByRssi(&pAd->MlmeAux.SsidBssTab);
+		pAd->MlmeAux.BssIdx = 0;
+		IterateOnBssTab(pAd);
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -656,34 +705,35 @@ VOID CntlMlmeRoamingProc(
 
 	==========================================================================
 */
-VOID CntlWaitDisassocProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlWaitDisassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	MLME_START_REQ_STRUCT     StartReq;
+	MLME_START_REQ_STRUCT StartReq;
 
-	if (Elem->MsgType == MT2_DISASSOC_CONF)
-	{
+	if (Elem->MsgType == MT2_DISASSOC_CONF) {
 		DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Dis-associate successful\n"));
 
-	    if (pAd->CommonCfg.bWirelessEvent)
-		{
-			RTMPSendWirelessEvent(pAd, IW_DISASSOC_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+		if (pAd->CommonCfg.bWirelessEvent) {
+			RTMPSendWirelessEvent(pAd, IW_DISASSOC_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
 		}
 
 		LinkDown(pAd, FALSE);
 
 		// case 1. no matching BSS, and user wants ADHOC, so we just start a new one
-		if ((pAd->MlmeAux.SsidBssTab.BssNr==0) && (pAd->StaCfg.BssType == BSS_ADHOC))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - No matching BSS, start a new ADHOC (Ssid=%s)...\n",pAd->MlmeAux.Ssid));
-			StartParmFill(pAd, &StartReq, (PCHAR)pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
-			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ, sizeof(MLME_START_REQ_STRUCT), &StartReq);
+		if ((pAd->MlmeAux.SsidBssTab.BssNr == 0)
+		    && (pAd->StaCfg.BssType == BSS_ADHOC)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - No matching BSS, start a new ADHOC (Ssid=%s)...\n",
+				  pAd->MlmeAux.Ssid));
+			StartParmFill(pAd, &StartReq, (PCHAR) pAd->MlmeAux.Ssid,
+				      pAd->MlmeAux.SsidLen);
+			MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
+				    sizeof(MLME_START_REQ_STRUCT), &StartReq);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
 		}
 		// case 2. try each matched BSS
-		else
-		{
+		else {
 			pAd->MlmeAux.BssIdx = 0;
 
 			IterateOnBssTab(pAd);
@@ -699,66 +749,74 @@ VOID CntlWaitDisassocProc(
 
 	==========================================================================
 */
-VOID CntlWaitJoinProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlWaitJoinProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT                      Reason;
-	MLME_AUTH_REQ_STRUCT        AuthReq;
+	USHORT Reason;
+	MLME_AUTH_REQ_STRUCT AuthReq;
 
-	if (Elem->MsgType == MT2_JOIN_CONF)
-	{
+	if (Elem->MsgType == MT2_JOIN_CONF) {
 		NdisMoveMemory(&Reason, Elem->Msg, sizeof(USHORT));
-		if (Reason == MLME_SUCCESS)
-		{
+		if (Reason == MLME_SUCCESS) {
 			// 1. joined an IBSS, we are pretty much done here
-			if (pAd->MlmeAux.BssType == BSS_ADHOC)
-			{
-			    //
+			if (pAd->MlmeAux.BssType == BSS_ADHOC) {
+				//
 				// 5G bands rules of Japan:
 				// Ad hoc must be disabled in W53(ch52,56,60,64) channels.
 				//
-				if ( (pAd->CommonCfg.bIEEE80211H == 1) &&
-                      RadarChannelCheck(pAd, pAd->CommonCfg.Channel)
-				   )
-				{
-					pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-					DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Channel=%d, Join adhoc on W53(52,56,60,64) Channels are not accepted\n", pAd->CommonCfg.Channel));
+				if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+				    RadarChannelCheck(pAd,
+						      pAd->CommonCfg.Channel)
+				    ) {
+					pAd->Mlme.CntlMachine.CurrState =
+					    CNTL_IDLE;
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("CNTL - Channel=%d, Join adhoc on W53(52,56,60,64) Channels are not accepted\n",
+						  pAd->CommonCfg.Channel));
 					return;
 				}
 
 				LinkUp(pAd, BSS_ADHOC);
 				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-				DBGPRINT(RT_DEBUG_TRACE, ("CNTL - join the IBSS = %02x:%02x:%02x:%02x:%02x:%02x ...\n",
-				pAd->CommonCfg.Bssid[0],pAd->CommonCfg.Bssid[1],pAd->CommonCfg.Bssid[2],
-				pAd->CommonCfg.Bssid[3],pAd->CommonCfg.Bssid[4],pAd->CommonCfg.Bssid[5]));
-
-                pAd->IndicateMediaState = NdisMediaStateConnected;
-                pAd->ExtraInfo = GENERAL_LINK_UP;
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("CNTL - join the IBSS = %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+					  pAd->CommonCfg.Bssid[0],
+					  pAd->CommonCfg.Bssid[1],
+					  pAd->CommonCfg.Bssid[2],
+					  pAd->CommonCfg.Bssid[3],
+					  pAd->CommonCfg.Bssid[4],
+					  pAd->CommonCfg.Bssid[5]));
+
+				pAd->IndicateMediaState =
+				    NdisMediaStateConnected;
+				pAd->ExtraInfo = GENERAL_LINK_UP;
 			}
 			// 2. joined a new INFRA network, start from authentication
-			else
-			{
+			else {
 				{
 					// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
-					if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared) ||
-						(pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
-					{
-						AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, AUTH_MODE_KEY);
+					if ((pAd->StaCfg.AuthMode ==
+					     Ndis802_11AuthModeShared)
+					    || (pAd->StaCfg.AuthMode ==
+						Ndis802_11AuthModeAutoSwitch)) {
+						AuthParmFill(pAd, &AuthReq,
+							     pAd->MlmeAux.Bssid,
+							     AUTH_MODE_KEY);
+					} else {
+						AuthParmFill(pAd, &AuthReq,
+							     pAd->MlmeAux.Bssid,
+							     AUTH_MODE_OPEN);
 					}
-					else
-					{
-						AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, AUTH_MODE_OPEN);
-				}
-				MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ,
-							sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+					MlmeEnqueue(pAd, AUTH_STATE_MACHINE,
+						    MT2_MLME_AUTH_REQ,
+						    sizeof
+						    (MLME_AUTH_REQ_STRUCT),
+						    &AuthReq);
 				}
 
-				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH;
+				pAd->Mlme.CntlMachine.CurrState =
+				    CNTL_WAIT_AUTH;
 			}
-		}
-		else
-		{
+		} else {
 			// 3. failed, try next BSS
 			pAd->MlmeAux.BssIdx++;
 			IterateOnBssTab(pAd);
@@ -766,7 +824,6 @@ VOID CntlWaitJoinProc(
 	}
 }
 
-
 /*
 	==========================================================================
 	Description:
@@ -775,73 +832,86 @@ VOID CntlWaitJoinProc(
 
 	==========================================================================
 */
-VOID CntlWaitStartProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlWaitStartProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT      Result;
+	USHORT Result;
 
-	if (Elem->MsgType == MT2_START_CONF)
-	{
+	if (Elem->MsgType == MT2_START_CONF) {
 		NdisMoveMemory(&Result, Elem->Msg, sizeof(USHORT));
-		if (Result == MLME_SUCCESS)
-		{
-		    //
+		if (Result == MLME_SUCCESS) {
+			//
 			// 5G bands rules of Japan:
 			// Ad hoc must be disabled in W53(ch52,56,60,64) channels.
 			//
-			if ( (pAd->CommonCfg.bIEEE80211H == 1) &&
-                  RadarChannelCheck(pAd, pAd->CommonCfg.Channel)
-			   )
-			{
+			if ((pAd->CommonCfg.bIEEE80211H == 1) &&
+			    RadarChannelCheck(pAd, pAd->CommonCfg.Channel)
+			    ) {
 				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-				DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Channel=%d, Start adhoc on W53(52,56,60,64) Channels are not accepted\n", pAd->CommonCfg.Channel));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("CNTL - Channel=%d, Start adhoc on W53(52,56,60,64) Channels are not accepted\n",
+					  pAd->CommonCfg.Channel));
 				return;
 			}
-			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.MCSSet[0], 16);
-			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-			{
+			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.
+				       MCSSet[0], 16);
+			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
 				N_ChannelCheck(pAd);
 				SetCommonHT(pAd);
-				NdisMoveMemory(&pAd->MlmeAux.AddHtInfo, &pAd->CommonCfg.AddHTInfo, sizeof(ADD_HT_INFO_IE));
-				RTMPCheckHt(pAd, BSSID_WCID, &pAd->CommonCfg.HtCapability, &pAd->CommonCfg.AddHTInfo);
-				pAd->StaActive.SupportedPhyInfo.bHtEnable = TRUE;
-				NdisMoveMemory(&pAd->StaActive.SupportedPhyInfo.MCSSet[0], &pAd->CommonCfg.HtCapability.MCSSet[0], 16);
-				COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
-
-				if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) &&
-					(pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset == EXTCHA_ABOVE))
-				{
-					pAd->MlmeAux.CentralChannel = pAd->CommonCfg.Channel + 2;
+				NdisMoveMemory(&pAd->MlmeAux.AddHtInfo,
+					       &pAd->CommonCfg.AddHTInfo,
+					       sizeof(ADD_HT_INFO_IE));
+				RTMPCheckHt(pAd, BSSID_WCID,
+					    &pAd->CommonCfg.HtCapability,
+					    &pAd->CommonCfg.AddHTInfo);
+				pAd->StaActive.SupportedPhyInfo.bHtEnable =
+				    TRUE;
+				NdisMoveMemory(&pAd->StaActive.SupportedPhyInfo.
+					       MCSSet[0],
+					       &pAd->CommonCfg.HtCapability.
+					       MCSSet[0], 16);
+				COPY_HTSETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG
+				    (pAd);
+
+				if ((pAd->CommonCfg.HtCapability.HtCapInfo.
+				     ChannelWidth == BW_40)
+				    && (pAd->CommonCfg.AddHTInfo.AddHtInfo.
+					ExtChanOffset == EXTCHA_ABOVE)) {
+					pAd->MlmeAux.CentralChannel =
+					    pAd->CommonCfg.Channel + 2;
+				} else
+				    if ((pAd->CommonCfg.HtCapability.HtCapInfo.
+					 ChannelWidth == BW_40)
+					&& (pAd->CommonCfg.AddHTInfo.AddHtInfo.
+					    ExtChanOffset == EXTCHA_BELOW)) {
+					pAd->MlmeAux.CentralChannel =
+					    pAd->CommonCfg.Channel - 2;
 				}
-				else if ((pAd->CommonCfg.HtCapability.HtCapInfo.ChannelWidth  == BW_40) &&
-						 (pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset == EXTCHA_BELOW))
-				{
-					pAd->MlmeAux.CentralChannel = pAd->CommonCfg.Channel - 2;
-				}
-			}
-			else
-			{
-				pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
+			} else {
+				pAd->StaActive.SupportedPhyInfo.bHtEnable =
+				    FALSE;
 			}
 			LinkUp(pAd, BSS_ADHOC);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 			// Before send beacon, driver need do radar detection
-			if ((pAd->CommonCfg.Channel > 14 )
-				&& (pAd->CommonCfg.bIEEE80211H == 1)
-				&& RadarChannelCheck(pAd, pAd->CommonCfg.Channel))
-			{
-				pAd->CommonCfg.RadarDetect.RDMode = RD_SILENCE_MODE;
+			if ((pAd->CommonCfg.Channel > 14)
+			    && (pAd->CommonCfg.bIEEE80211H == 1)
+			    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
+				pAd->CommonCfg.RadarDetect.RDMode =
+				    RD_SILENCE_MODE;
 				pAd->CommonCfg.RadarDetect.RDCount = 0;
 			}
 
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - start a new IBSS = %02x:%02x:%02x:%02x:%02x:%02x ...\n",
-				pAd->CommonCfg.Bssid[0],pAd->CommonCfg.Bssid[1],pAd->CommonCfg.Bssid[2],
-				pAd->CommonCfg.Bssid[3],pAd->CommonCfg.Bssid[4],pAd->CommonCfg.Bssid[5]));
-		}
-		else
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Start IBSS fail. BUG!!!!!\n"));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - start a new IBSS = %02x:%02x:%02x:%02x:%02x:%02x ...\n",
+				  pAd->CommonCfg.Bssid[0],
+				  pAd->CommonCfg.Bssid[1],
+				  pAd->CommonCfg.Bssid[2],
+				  pAd->CommonCfg.Bssid[3],
+				  pAd->CommonCfg.Bssid[4],
+				  pAd->CommonCfg.Bssid[5]));
+		} else {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - Start IBSS fail. BUG!!!!!\n"));
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
 		}
 	}
@@ -855,50 +925,55 @@ VOID CntlWaitStartProc(
 
 	==========================================================================
 */
-VOID CntlWaitAuthProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlWaitAuthProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT                       Reason;
-	MLME_ASSOC_REQ_STRUCT        AssocReq;
-	MLME_AUTH_REQ_STRUCT         AuthReq;
+	USHORT Reason;
+	MLME_ASSOC_REQ_STRUCT AssocReq;
+	MLME_AUTH_REQ_STRUCT AuthReq;
 
-	if (Elem->MsgType == MT2_AUTH_CONF)
-	{
+	if (Elem->MsgType == MT2_AUTH_CONF) {
 		NdisMoveMemory(&Reason, Elem->Msg, sizeof(USHORT));
-		if (Reason == MLME_SUCCESS)
-		{
+		if (Reason == MLME_SUCCESS) {
 			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH OK\n"));
-			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid, pAd->MlmeAux.CapabilityInfo,
-						  ASSOC_TIMEOUT, pAd->StaCfg.DefaultListenCount);
+			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid,
+				      pAd->MlmeAux.CapabilityInfo,
+				      ASSOC_TIMEOUT,
+				      pAd->StaCfg.DefaultListenCount);
 
 			{
-				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_ASSOC_REQ,
-							sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
+				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
+					    MT2_MLME_ASSOC_REQ,
+					    sizeof(MLME_ASSOC_REQ_STRUCT),
+					    &AssocReq);
 
-				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
+				pAd->Mlme.CntlMachine.CurrState =
+				    CNTL_WAIT_ASSOC;
 			}
-		}
-		else
-		{
+		} else {
 			// This fail may because of the AP already keep us in its MAC table without
 			// ageing-out. The previous authentication attempt must have let it remove us.
 			// so try Authentication again may help. For D-Link DWL-900AP+ compatibility.
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH FAIL, try again...\n"));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - AUTH FAIL, try again...\n"));
 
 			{
-				if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeShared) ||
-					(pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch))
-				{
+				if ((pAd->StaCfg.AuthMode ==
+				     Ndis802_11AuthModeShared)
+				    || (pAd->StaCfg.AuthMode ==
+					Ndis802_11AuthModeAutoSwitch)) {
 					// either Ndis802_11AuthModeShared or Ndis802_11AuthModeAutoSwitch, try shared key first
-					AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, AUTH_MODE_KEY);
+					AuthParmFill(pAd, &AuthReq,
+						     pAd->MlmeAux.Bssid,
+						     AUTH_MODE_KEY);
+				} else {
+					AuthParmFill(pAd, &AuthReq,
+						     pAd->MlmeAux.Bssid,
+						     AUTH_MODE_OPEN);
 				}
-				else
-				{
-					AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, AUTH_MODE_OPEN);
-			}
-			MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ,
-						sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
+				MlmeEnqueue(pAd, AUTH_STATE_MACHINE,
+					    MT2_MLME_AUTH_REQ,
+					    sizeof(MLME_AUTH_REQ_STRUCT),
+					    &AuthReq);
 
 			}
 			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
@@ -914,46 +989,49 @@ VOID CntlWaitAuthProc(
 
 	==========================================================================
 */
-VOID CntlWaitAuthProc2(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlWaitAuthProc2(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT                       Reason;
-	MLME_ASSOC_REQ_STRUCT        AssocReq;
-	MLME_AUTH_REQ_STRUCT         AuthReq;
+	USHORT Reason;
+	MLME_ASSOC_REQ_STRUCT AssocReq;
+	MLME_AUTH_REQ_STRUCT AuthReq;
 
-	if (Elem->MsgType == MT2_AUTH_CONF)
-	{
+	if (Elem->MsgType == MT2_AUTH_CONF) {
 		NdisMoveMemory(&Reason, Elem->Msg, sizeof(USHORT));
-		if (Reason == MLME_SUCCESS)
-		{
+		if (Reason == MLME_SUCCESS) {
 			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH OK\n"));
-			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid, pAd->MlmeAux.CapabilityInfo,
-						  ASSOC_TIMEOUT, pAd->StaCfg.DefaultListenCount);
+			AssocParmFill(pAd, &AssocReq, pAd->MlmeAux.Bssid,
+				      pAd->MlmeAux.CapabilityInfo,
+				      ASSOC_TIMEOUT,
+				      pAd->StaCfg.DefaultListenCount);
 			{
-			MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_ASSOC_REQ,
-						sizeof(MLME_ASSOC_REQ_STRUCT), &AssocReq);
+				MlmeEnqueue(pAd, ASSOC_STATE_MACHINE,
+					    MT2_MLME_ASSOC_REQ,
+					    sizeof(MLME_ASSOC_REQ_STRUCT),
+					    &AssocReq);
 
-			pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_ASSOC;
-		}
-		}
-		else
-		{
-			if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeAutoSwitch) &&
-				 (pAd->MlmeAux.Alg == Ndis802_11AuthModeShared))
-			{
-				DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH FAIL, try OPEN system...\n"));
-				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid, Ndis802_11AuthModeOpen);
-				MlmeEnqueue(pAd, AUTH_STATE_MACHINE, MT2_MLME_AUTH_REQ,
-							sizeof(MLME_AUTH_REQ_STRUCT), &AuthReq);
-
-				pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_AUTH2;
+				pAd->Mlme.CntlMachine.CurrState =
+				    CNTL_WAIT_ASSOC;
 			}
-			else
-			{
+		} else {
+			if ((pAd->StaCfg.AuthMode ==
+			     Ndis802_11AuthModeAutoSwitch)
+			    && (pAd->MlmeAux.Alg == Ndis802_11AuthModeShared)) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("CNTL - AUTH FAIL, try OPEN system...\n"));
+				AuthParmFill(pAd, &AuthReq, pAd->MlmeAux.Bssid,
+					     Ndis802_11AuthModeOpen);
+				MlmeEnqueue(pAd, AUTH_STATE_MACHINE,
+					    MT2_MLME_AUTH_REQ,
+					    sizeof(MLME_AUTH_REQ_STRUCT),
+					    &AuthReq);
+
+				pAd->Mlme.CntlMachine.CurrState =
+				    CNTL_WAIT_AUTH2;
+			} else {
 				// not success, try next BSS
-				DBGPRINT(RT_DEBUG_TRACE, ("CNTL - AUTH FAIL, give up; try next BSS\n"));
-				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE; //???????
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("CNTL - AUTH FAIL, give up; try next BSS\n"));
+				pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;	//???????
 				pAd->MlmeAux.BssIdx++;
 				IterateOnBssTab(pAd);
 			}
@@ -969,30 +1047,30 @@ VOID CntlWaitAuthProc2(
 
 	==========================================================================
 */
-VOID CntlWaitAssocProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlWaitAssocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT      Reason;
+	USHORT Reason;
 
-	if (Elem->MsgType == MT2_ASSOC_CONF)
-	{
+	if (Elem->MsgType == MT2_ASSOC_CONF) {
 		NdisMoveMemory(&Reason, Elem->Msg, sizeof(USHORT));
-		if (Reason == MLME_SUCCESS)
-		{
-			if (pAd->CommonCfg.bWirelessEvent)
-			{
-				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+		if (Reason == MLME_SUCCESS) {
+			if (pAd->CommonCfg.bWirelessEvent) {
+				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG,
+						      pAd->MacTab.
+						      Content[BSSID_WCID].Addr,
+						      BSS0, 0);
 			}
 
 			LinkUp(pAd, BSS_INFRA);
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Association successful on BSS #%ld\n",pAd->MlmeAux.BssIdx));
-		}
-		else
-		{
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - Association successful on BSS #%ld\n",
+				  pAd->MlmeAux.BssIdx));
+		} else {
 			// not success, try next BSS
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Association fails on BSS #%ld\n",pAd->MlmeAux.BssIdx));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - Association fails on BSS #%ld\n",
+				  pAd->MlmeAux.BssIdx));
 			pAd->MlmeAux.BssIdx++;
 			IterateOnBssTab(pAd);
 		}
@@ -1007,21 +1085,19 @@ VOID CntlWaitAssocProc(
 
 	==========================================================================
 */
-VOID CntlWaitReassocProc(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID CntlWaitReassocProc(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	USHORT      Result;
+	USHORT Result;
 
-	if (Elem->MsgType == MT2_REASSOC_CONF)
-	{
+	if (Elem->MsgType == MT2_REASSOC_CONF) {
 		NdisMoveMemory(&Result, Elem->Msg, sizeof(USHORT));
-		if (Result == MLME_SUCCESS)
-		{
+		if (Result == MLME_SUCCESS) {
 			// send wireless event - for association
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
-
+				RTMPSendWirelessEvent(pAd, IW_ASSOC_EVENT_FLAG,
+						      pAd->MacTab.
+						      Content[BSSID_WCID].Addr,
+						      BSS0, 0);
 
 			//
 			// NDIS requires a new Link UP indication but no Link Down for RE-ASSOC
@@ -1029,23 +1105,23 @@ VOID CntlWaitReassocProc(
 			LinkUp(pAd, BSS_INFRA);
 
 			pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Re-assocition successful on BSS #%ld\n", pAd->MlmeAux.RoamIdx));
-		}
-		else
-		{
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - Re-assocition successful on BSS #%ld\n",
+				  pAd->MlmeAux.RoamIdx));
+		} else {
 			// reassoc failed, try to pick next BSS in the BSS Table
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - Re-assocition fails on BSS #%ld\n", pAd->MlmeAux.RoamIdx));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - Re-assocition fails on BSS #%ld\n",
+				  pAd->MlmeAux.RoamIdx));
 			{
-			pAd->MlmeAux.RoamIdx++;
-			IterateOnBssTab2(pAd);
+				pAd->MlmeAux.RoamIdx++;
+				IterateOnBssTab2(pAd);
+			}
 		}
 	}
-	}
 }
 
-
-VOID	AdhocTurnOnQos(
-	IN  PRTMP_ADAPTER pAd)
+VOID AdhocTurnOnQos(IN PRTMP_ADAPTER pAd)
 {
 #define AC0_DEF_TXOP		0
 #define AC1_DEF_TXOP		0
@@ -1053,8 +1129,7 @@ VOID	AdhocTurnOnQos(
 #define AC3_DEF_TXOP		47
 
 	// Turn on QOs if use HT rate.
-	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE)
-	{
+	if (pAd->CommonCfg.APEdcaParm.bValid == FALSE) {
 		pAd->CommonCfg.APEdcaParm.bValid = TRUE;
 		pAd->CommonCfg.APEdcaParm.Aifsn[0] = 3;
 		pAd->CommonCfg.APEdcaParm.Aifsn[1] = 7;
@@ -1071,10 +1146,10 @@ VOID	AdhocTurnOnQos(
 		pAd->CommonCfg.APEdcaParm.Cwmax[2] = 4;
 		pAd->CommonCfg.APEdcaParm.Cwmax[3] = 3;
 
-		pAd->CommonCfg.APEdcaParm.Txop[0]  = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[1]  = 0;
-		pAd->CommonCfg.APEdcaParm.Txop[2]  = AC2_DEF_TXOP;
-		pAd->CommonCfg.APEdcaParm.Txop[3]  = AC3_DEF_TXOP;
+		pAd->CommonCfg.APEdcaParm.Txop[0] = 0;
+		pAd->CommonCfg.APEdcaParm.Txop[1] = 0;
+		pAd->CommonCfg.APEdcaParm.Txop[2] = AC2_DEF_TXOP;
+		pAd->CommonCfg.APEdcaParm.Txop[3] = AC3_DEF_TXOP;
 	}
 	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
 }
@@ -1087,27 +1162,23 @@ VOID	AdhocTurnOnQos(
 
 	==========================================================================
 */
-VOID LinkUp(
-	IN PRTMP_ADAPTER pAd,
-	IN UCHAR BssType)
+VOID LinkUp(IN PRTMP_ADAPTER pAd, IN UCHAR BssType)
 {
-	ULONG	Now;
-	UINT32	Data;
-	BOOLEAN	Cancelled;
-	UCHAR	Value = 0, idx = 0, HashIdx = 0;
+	ULONG Now;
+	UINT32 Data;
+	BOOLEAN Cancelled;
+	UCHAR Value = 0, idx = 0, HashIdx = 0;
 	MAC_TABLE_ENTRY *pEntry = NULL, *pCurrEntry = NULL;
 
 	// Init ChannelQuality to prevent DEAD_CQI at initial LinkUp
 	pAd->Mlme.ChannelQuality = 50;
 
 	pEntry = MacTableLookup(pAd, pAd->CommonCfg.Bssid);
-	if (pEntry)
-	{
+	if (pEntry) {
 		MacTableDeleteEntry(pAd, pEntry->Aid, pEntry->Addr);
 		pEntry = NULL;
 	}
 
-
 	pEntry = &pAd->MacTab.Content[BSSID_WCID];
 
 	//
@@ -1119,7 +1190,7 @@ VOID LinkUp(
 	// To prevent DisassocTimeoutAction to call Link down after we link up,
 	// cancel the DisassocTimer no matter what it start or not.
 	//
-	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer,  &Cancelled);
+	RTMPCancelTimer(&pAd->MlmeAux.DisassocTimer, &Cancelled);
 
 	COPY_SETTINGS_FROM_MLME_AUX_TO_ACTIVE_CFG(pAd);
 
@@ -1129,39 +1200,30 @@ VOID LinkUp(
 	// Before power save before link up function, We will force use 1R.
 	// So after link up, check Rx antenna # again.
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
-	if(pAd->Antenna.field.RxPath == 3)
-	{
+	if (pAd->Antenna.field.RxPath == 3) {
 		Value |= (0x10);
-	}
-	else if(pAd->Antenna.field.RxPath == 2)
-	{
+	} else if (pAd->Antenna.field.RxPath == 2) {
 		Value |= (0x8);
-	}
-	else if(pAd->Antenna.field.RxPath == 1)
-	{
+	} else if (pAd->Antenna.field.RxPath == 1) {
 		Value |= (0x0);
 	}
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 	pAd->StaCfg.BBPR3 = Value;
 #endif // RTMP_MAC_PCI //
 
-	if (BssType == BSS_ADHOC)
-	{
+	if (BssType == BSS_ADHOC) {
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_ADHOC_ON);
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_INFRA_ON);
 
-
 		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
 			AdhocTurnOnQos(pAd);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("!!!Adhoc LINK UP !!! \n" ));
-	}
-	else
-	{
+		DBGPRINT(RT_DEBUG_TRACE, ("!!!Adhoc LINK UP !!! \n"));
+	} else {
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_INFRA_ON);
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_ADHOC_ON);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("!!!Infra LINK UP !!! \n" ));
+		DBGPRINT(RT_DEBUG_TRACE, ("!!!Infra LINK UP !!! \n"));
 	}
 
 	// 3*3
@@ -1172,8 +1234,8 @@ VOID LinkUp(
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, Value);
 
 	// Change to AP channel
-    if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel) && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
-	{
+	if ((pAd->CommonCfg.CentralChannel > pAd->CommonCfg.Channel)
+	    && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40)) {
 		// Must using 40MHz.
 		pAd->CommonCfg.BBPCurrentBW = BW_40;
 		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
@@ -1189,29 +1251,30 @@ VOID LinkUp(
 		Value &= (~0x20);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 #ifdef RTMP_MAC_PCI
-            pAd->StaCfg.BBPR3 = Value;
+		pAd->StaCfg.BBPR3 = Value;
 #endif // RTMP_MAC_PCI //
 
 		RTMP_IO_READ32(pAd, TX_BAND_CFG, &Data);
 		Data &= 0xfffffffe;
 		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Data);
 
-		if (pAd->MACVersion == 0x28600100)
-		{
+		if (pAd->MACVersion == 0x28600100) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x1A);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R70, 0x0A);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x16);
-            DBGPRINT(RT_DEBUG_TRACE, ("!!!rt2860C !!! \n" ));
+			DBGPRINT(RT_DEBUG_TRACE, ("!!!rt2860C !!! \n"));
 		}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("!!!40MHz Lower LINK UP !!! Control Channel at Below. Central = %d \n", pAd->CommonCfg.CentralChannel ));
-	}
-	else if ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel) && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth == BW_40))
-    {
-	    // Must using 40MHz.
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("!!!40MHz Lower LINK UP !!! Control Channel at Below. Central = %d \n",
+			  pAd->CommonCfg.CentralChannel));
+	} else if ((pAd->CommonCfg.CentralChannel < pAd->CommonCfg.Channel)
+		   && (pAd->MlmeAux.HtCapability.HtCapInfo.ChannelWidth ==
+		       BW_40)) {
+		// Must using 40MHz.
 		pAd->CommonCfg.BBPCurrentBW = BW_40;
 		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
-	    AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
+		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
 
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &Value);
 		Value &= (~0x18);
@@ -1223,25 +1286,24 @@ VOID LinkUp(
 		RTMP_IO_WRITE32(pAd, TX_BAND_CFG, Data);
 
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R3, &Value);
-	    Value |= (0x20);
+		Value |= (0x20);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 #ifdef RTMP_MAC_PCI
-            pAd->StaCfg.BBPR3 = Value;
+		pAd->StaCfg.BBPR3 = Value;
 #endif // RTMP_MAC_PCI //
 
-		if (pAd->MACVersion == 0x28600100)
-		{
+		if (pAd->MACVersion == 0x28600100) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x1A);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R70, 0x0A);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x16);
-			    DBGPRINT(RT_DEBUG_TRACE, ("!!!rt2860C !!! \n" ));
+			DBGPRINT(RT_DEBUG_TRACE, ("!!!rt2860C !!! \n"));
 		}
 
-	    DBGPRINT(RT_DEBUG_TRACE, ("!!! 40MHz Upper LINK UP !!! Control Channel at UpperCentral = %d \n", pAd->CommonCfg.CentralChannel ));
-    }
-    else
-    {
-	    pAd->CommonCfg.BBPCurrentBW = BW_20;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("!!! 40MHz Upper LINK UP !!! Control Channel at UpperCentral = %d \n",
+			  pAd->CommonCfg.CentralChannel));
+	} else {
+		pAd->CommonCfg.BBPCurrentBW = BW_20;
 		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
 		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
 		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
@@ -1258,80 +1320,82 @@ VOID LinkUp(
 		Value &= (~0x20);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, Value);
 #ifdef RTMP_MAC_PCI
-            pAd->StaCfg.BBPR3 = Value;
+		pAd->StaCfg.BBPR3 = Value;
 #endif // RTMP_MAC_PCI //
 
-		if (pAd->MACVersion == 0x28600100)
-		{
+		if (pAd->MACVersion == 0x28600100) {
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R69, 0x16);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R70, 0x08);
 			RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R73, 0x11);
-            DBGPRINT(RT_DEBUG_TRACE, ("!!!rt2860C !!! \n" ));
+			DBGPRINT(RT_DEBUG_TRACE, ("!!!rt2860C !!! \n"));
 		}
 
-	    DBGPRINT(RT_DEBUG_TRACE, ("!!! 20MHz LINK UP !!! \n" ));
-    }
+		DBGPRINT(RT_DEBUG_TRACE, ("!!! 20MHz LINK UP !!! \n"));
+	}
 
 	RTMPSetAGCInitValue(pAd, pAd->CommonCfg.BBPCurrentBW);
 
 	//
 	// Save BBP_R66 value, it will be used in RTUSBResumeMsduTransmission
 	//
-	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66, &pAd->BbpTuning.R66CurrentValue);
+	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R66,
+				    &pAd->BbpTuning.R66CurrentValue);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !!! (BssType=%d, AID=%d, ssid=%s, Channel=%d, CentralChannel = %d)\n",
-		BssType, pAd->StaActive.Aid, pAd->CommonCfg.Ssid, pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("!!! LINK UP !!! (BssType=%d, AID=%d, ssid=%s, Channel=%d, CentralChannel = %d)\n",
+		  BssType, pAd->StaActive.Aid, pAd->CommonCfg.Ssid,
+		  pAd->CommonCfg.Channel, pAd->CommonCfg.CentralChannel));
 
-	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !!! (Density =%d, )\n", pAd->MacTab.Content[BSSID_WCID].MpduDensity));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("!!! LINK UP !!! (Density =%d, )\n",
+		  pAd->MacTab.Content[BSSID_WCID].MpduDensity));
 
-		AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
+	AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
 
 	AsicSetSlotTime(pAd, TRUE);
 	AsicSetEdcaParm(pAd, &pAd->CommonCfg.APEdcaParm);
 
 	// Call this for RTS protectionfor legacy rate, we will always enable RTS threshold, but normally it will not hit
-	AsicUpdateProtect(pAd, 0, (OFDMSETPROTECT | CCKSETPROTECT), TRUE, FALSE);
+	AsicUpdateProtect(pAd, 0, (OFDMSETPROTECT | CCKSETPROTECT), TRUE,
+			  FALSE);
 
-	if ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE))
-	{
+	if ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)) {
 		// Update HT protectionfor based on AP's operating mode.
-    	if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1)
-    	{
-    		AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,  ALLN_SETPROTECT, FALSE, TRUE);
-    	}
-    	else
-   			AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode,  ALLN_SETPROTECT, FALSE, FALSE);
+		if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1) {
+			AsicUpdateProtect(pAd,
+					  pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+					  OperaionMode, ALLN_SETPROTECT, FALSE,
+					  TRUE);
+		} else
+			AsicUpdateProtect(pAd,
+					  pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+					  OperaionMode, ALLN_SETPROTECT, FALSE,
+					  FALSE);
 	}
 
 	NdisZeroMemory(&pAd->DrsCounters, sizeof(COUNTER_DRS));
 
 	NdisGetSystemUpTime(&Now);
-	pAd->StaCfg.LastBeaconRxTime = Now;   // last RX timestamp
+	pAd->StaCfg.LastBeaconRxTime = Now;	// last RX timestamp
 
 	if ((pAd->CommonCfg.TxPreamble != Rt802_11PreambleLong) &&
-		CAP_IS_SHORT_PREAMBLE_ON(pAd->StaActive.CapabilityInfo))
-	{
+	    CAP_IS_SHORT_PREAMBLE_ON(pAd->StaActive.CapabilityInfo)) {
 		MlmeSetTxPreamble(pAd, Rt802_11PreambleShort);
 	}
 
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
 
-	if (pAd->CommonCfg.RadarDetect.RDMode == RD_SILENCE_MODE)
-	{
+	if (pAd->CommonCfg.RadarDetect.RDMode == RD_SILENCE_MODE) {
 	}
 	pAd->CommonCfg.RadarDetect.RDMode = RD_NORMAL_MODE;
 
-	if (BssType == BSS_ADHOC)
-	{
+	if (BssType == BSS_ADHOC) {
 		MakeIbssBeacon(pAd);
 		if ((pAd->CommonCfg.Channel > 14)
-			&& (pAd->CommonCfg.bIEEE80211H == 1)
-			&& RadarChannelCheck(pAd, pAd->CommonCfg.Channel))
-		{
-			; //Do nothing
-		}
-		else
-		{
+		    && (pAd->CommonCfg.bIEEE80211H == 1)
+		    && RadarChannelCheck(pAd, pAd->CommonCfg.Channel)) {
+			;	//Do nothing
+		} else {
 			AsicEnableIbssSync(pAd);
 		}
 
@@ -1343,82 +1407,92 @@ VOID LinkUp(
 		// If WEP is enabled, add key material and cipherAlg into Asic
 		// Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000)
 
-		if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)
-		{
-			PUCHAR	Key;
-			UCHAR 	CipherAlg;
+		if (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) {
+			PUCHAR Key;
+			UCHAR CipherAlg;
 
-			for (idx=0; idx < SHARE_KEY_NUM; idx++)
-        	{
+			for (idx = 0; idx < SHARE_KEY_NUM; idx++) {
 				CipherAlg = pAd->SharedKey[BSS0][idx].CipherAlg;
-    			Key = pAd->SharedKey[BSS0][idx].Key;
+				Key = pAd->SharedKey[BSS0][idx].Key;
 
-				if (pAd->SharedKey[BSS0][idx].KeyLen > 0)
-				{
+				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
 					// Set key material and cipherAlg to Asic
-    				AsicAddSharedKeyEntry(pAd, BSS0, idx, CipherAlg, Key, NULL, NULL);
+					AsicAddSharedKeyEntry(pAd, BSS0, idx,
+							      CipherAlg, Key,
+							      NULL, NULL);
 
-                    if (idx == pAd->StaCfg.DefaultKeyId)
-					{
+					if (idx == pAd->StaCfg.DefaultKeyId) {
 						// Update WCID attribute table and IVEIV table for this group key table
-						RTMPAddWcidAttributeEntry(pAd, BSS0, idx, CipherAlg, NULL);
+						RTMPAddWcidAttributeEntry(pAd,
+									  BSS0,
+									  idx,
+									  CipherAlg,
+									  NULL);
 					}
 				}
 
-
 			}
 		}
 		// If WPANone is enabled, add key material and cipherAlg into Asic
 		// Fill in Shared Key Table(offset: 0x6c00) and Shared Key Mode(offset: 0x7000)
-		else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
-		{
+		else if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
 			pAd->StaCfg.DefaultKeyId = 0;	// always be zero
 
-            NdisZeroMemory(&pAd->SharedKey[BSS0][0], sizeof(CIPHER_KEY));
-							pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
-			NdisMoveMemory(pAd->SharedKey[BSS0][0].Key, pAd->StaCfg.PMK, LEN_TKIP_EK);
-
-            if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
-            {
-    			NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic, &pAd->StaCfg.PMK[16], LEN_TKIP_RXMICK);
-    			NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic, &pAd->StaCfg.PMK[16], LEN_TKIP_TXMICK);
-            }
-
+			NdisZeroMemory(&pAd->SharedKey[BSS0][0],
+				       sizeof(CIPHER_KEY));
+			pAd->SharedKey[BSS0][0].KeyLen = LEN_TKIP_EK;
+			NdisMoveMemory(pAd->SharedKey[BSS0][0].Key,
+				       pAd->StaCfg.PMK, LEN_TKIP_EK);
+
+			if (pAd->StaCfg.PairCipher ==
+			    Ndis802_11Encryption2Enabled) {
+				NdisMoveMemory(pAd->SharedKey[BSS0][0].RxMic,
+					       &pAd->StaCfg.PMK[16],
+					       LEN_TKIP_RXMICK);
+				NdisMoveMemory(pAd->SharedKey[BSS0][0].TxMic,
+					       &pAd->StaCfg.PMK[16],
+					       LEN_TKIP_TXMICK);
+			}
 			// Decide its ChiperAlg
-			if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
+			if (pAd->StaCfg.PairCipher ==
+			    Ndis802_11Encryption2Enabled)
 				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_TKIP;
-			else if (pAd->StaCfg.PairCipher == Ndis802_11Encryption3Enabled)
+			else if (pAd->StaCfg.PairCipher ==
+				 Ndis802_11Encryption3Enabled)
 				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-			else
-            {
-                DBGPRINT(RT_DEBUG_TRACE, ("Unknow Cipher (=%d), set Cipher to AES\n", pAd->StaCfg.PairCipher));
+			else {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Unknow Cipher (=%d), set Cipher to AES\n",
+					  pAd->StaCfg.PairCipher));
 				pAd->SharedKey[BSS0][0].CipherAlg = CIPHER_AES;
-            }
+			}
 
 			// Set key material and cipherAlg to Asic
 			AsicAddSharedKeyEntry(pAd,
-								  BSS0,
-								  0,
-								  pAd->SharedKey[BSS0][0].CipherAlg,
-								  pAd->SharedKey[BSS0][0].Key,
-								  pAd->SharedKey[BSS0][0].TxMic,
-								  pAd->SharedKey[BSS0][0].RxMic);
-
-            // Update WCID attribute table and IVEIV table for this group key table
-			RTMPAddWcidAttributeEntry(pAd, BSS0, 0, pAd->SharedKey[BSS0][0].CipherAlg, NULL);
+					      BSS0,
+					      0,
+					      pAd->SharedKey[BSS0][0].CipherAlg,
+					      pAd->SharedKey[BSS0][0].Key,
+					      pAd->SharedKey[BSS0][0].TxMic,
+					      pAd->SharedKey[BSS0][0].RxMic);
+
+			// Update WCID attribute table and IVEIV table for this group key table
+			RTMPAddWcidAttributeEntry(pAd, BSS0, 0,
+						  pAd->SharedKey[BSS0][0].
+						  CipherAlg, NULL);
 
 		}
 
-	}
-	else // BSS_INFRA
+	} else			// BSS_INFRA
 	{
 		// Check the new SSID with last SSID
-		while (Cancelled == TRUE)
-		{
-			if (pAd->CommonCfg.LastSsidLen == pAd->CommonCfg.SsidLen)
-			{
-				if (RTMPCompareMemory(pAd->CommonCfg.LastSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.LastSsidLen) == 0)
-				{
+		while (Cancelled == TRUE) {
+			if (pAd->CommonCfg.LastSsidLen ==
+			    pAd->CommonCfg.SsidLen) {
+				if (RTMPCompareMemory
+				    (pAd->CommonCfg.LastSsid,
+				     pAd->CommonCfg.Ssid,
+				     pAd->CommonCfg.LastSsidLen) == 0) {
 					// Link to the old one no linkdown is required.
 					break;
 				}
@@ -1426,8 +1500,9 @@ VOID LinkUp(
 			// Send link down event before set to link up
 			pAd->IndicateMediaState = NdisMediaStateDisconnected;
 			RTMP_IndicateMediaState(pAd);
-            pAd->ExtraInfo = GENERAL_LINK_DOWN;
-			DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_DISCONNECT Event AA!\n"));
+			pAd->ExtraInfo = GENERAL_LINK_DOWN;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("NDIS_STATUS_MEDIA_DISCONNECT Event AA!\n"));
 			break;
 		}
 
@@ -1435,15 +1510,15 @@ VOID LinkUp(
 		// On WPA mode, Remove All Keys if not connect to the last BSSID
 		// Key will be set after 4-way handshake.
 		//
-		if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)
-		{
-			ULONG 		IV;
+		if (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA) {
+			ULONG IV;
 
 			// Remove all WPA keys
 			RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 			RTMPWPARemoveAllKeys(pAd);
 			pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
-			pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
+			pAd->StaCfg.PrivacyFilter =
+			    Ndis802_11PrivFilter8021xWEP;
 
 			// Fixed connection failed with Range Maximizer - 515 AP (Marvell Chip) when security is WPAPSK/TKIP
 			// If IV related values are too large in GroupMsg2, AP would ignore this message.
@@ -1451,7 +1526,6 @@ VOID LinkUp(
 			IV |= (pAd->StaCfg.DefaultKeyId << 30);
 			AsicUpdateWCIDIVEIV(pAd, BSSID_WCID, IV, 0);
 		}
-
 		// NOTE:
 		// the decision of using "short slot time" or not may change dynamically due to
 		// new STA association to the AP. so we have to decide that upon parsing BEACON, not here
@@ -1463,84 +1537,85 @@ VOID LinkUp(
 		ComposePsPoll(pAd);
 		ComposeNullFrame(pAd);
 
-			AsicEnableBssSync(pAd);
+		AsicEnableBssSync(pAd);
 
 		// Add BSSID to WCID search table
 		AsicUpdateRxWCIDTable(pAd, BSSID_WCID, pAd->CommonCfg.Bssid);
 
 		// If WEP is enabled, add paiewise and shared key
-        if (((pAd->StaCfg.WpaSupplicantUP)&&
-             (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)&&
-             (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)) ||
-            ((pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)&&
-              (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled)))
-		{
-			PUCHAR	Key;
-			UCHAR 	CipherAlg;
-
-			for (idx=0; idx < SHARE_KEY_NUM; idx++)
-        	{
+		if (((pAd->StaCfg.WpaSupplicantUP) &&
+		     (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
+		     (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_SECURED)) ||
+		    ((pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE) &&
+		     (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled))) {
+			PUCHAR Key;
+			UCHAR CipherAlg;
+
+			for (idx = 0; idx < SHARE_KEY_NUM; idx++) {
 				CipherAlg = pAd->SharedKey[BSS0][idx].CipherAlg;
-    			Key = pAd->SharedKey[BSS0][idx].Key;
+				Key = pAd->SharedKey[BSS0][idx].Key;
 
-				if (pAd->SharedKey[BSS0][idx].KeyLen > 0)
-				{
+				if (pAd->SharedKey[BSS0][idx].KeyLen > 0) {
 					// Set key material and cipherAlg to Asic
-    				AsicAddSharedKeyEntry(pAd, BSS0, idx, CipherAlg, Key, NULL, NULL);
+					AsicAddSharedKeyEntry(pAd, BSS0, idx,
+							      CipherAlg, Key,
+							      NULL, NULL);
 
-					if (idx == pAd->StaCfg.DefaultKeyId)
-					{
+					if (idx == pAd->StaCfg.DefaultKeyId) {
 						// Assign group key info
-						RTMPAddWcidAttributeEntry(pAd, BSS0, idx, CipherAlg, NULL);
+						RTMPAddWcidAttributeEntry(pAd,
+									  BSS0,
+									  idx,
+									  CipherAlg,
+									  NULL);
 
 						pEntry->Aid = BSSID_WCID;
 						// Assign pairwise key info
-						RTMPAddWcidAttributeEntry(pAd, BSS0, idx, CipherAlg, pEntry);
+						RTMPAddWcidAttributeEntry(pAd,
+									  BSS0,
+									  idx,
+									  CipherAlg,
+									  pEntry);
 					}
 				}
 			}
 		}
-
 		// only INFRASTRUCTURE mode need to indicate connectivity immediately; ADHOC mode
 		// should wait until at least 2 active nodes in this BSSID.
 		OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 
-        // For GUI ++
-		if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA)
-		{
+		// For GUI ++
+		if (pAd->StaCfg.AuthMode < Ndis802_11AuthModeWPA) {
 			pAd->IndicateMediaState = NdisMediaStateConnected;
 			pAd->ExtraInfo = GENERAL_LINK_UP;
 			RTMP_IndicateMediaState(pAd);
-		}
-		else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-				 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
+		} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+			   (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
 		{
-			if (pAd->StaCfg.WpaSupplicantUP == WPA_SUPPLICANT_DISABLE)
-				RTMPSetTimer(&pAd->Mlme.LinkDownTimer, LINK_DOWN_TIMEOUT);
+			if (pAd->StaCfg.WpaSupplicantUP ==
+			    WPA_SUPPLICANT_DISABLE)
+				RTMPSetTimer(&pAd->Mlme.LinkDownTimer,
+					     LINK_DOWN_TIMEOUT);
 		}
-        // --
+		// --
 
 		// Add BSSID in my MAC Table.
-        NdisAcquireSpinLock(&pAd->MacTabLock);
+		NdisAcquireSpinLock(&pAd->MacTabLock);
 		// add this MAC entry into HASH table
-		if (pEntry)
-		{
+		if (pEntry) {
 			HashIdx = MAC_ADDR_HASH_INDEX(pAd->CommonCfg.Bssid);
-			if (pAd->MacTab.Hash[HashIdx] == NULL)
-			{
+			if (pAd->MacTab.Hash[HashIdx] == NULL) {
 				pAd->MacTab.Hash[HashIdx] = pEntry;
-			}
-			else
-			{
+			} else {
 				pCurrEntry = pAd->MacTab.Hash[HashIdx];
-				while (pCurrEntry->pNext != NULL)
-				{
+				while (pCurrEntry->pNext != NULL) {
 					pCurrEntry = pCurrEntry->pNext;
 				}
 				pCurrEntry->pNext = pEntry;
 			}
 		}
-		RTMPMoveMemory(pEntry->Addr, pAd->CommonCfg.Bssid, MAC_ADDR_LEN);
+		RTMPMoveMemory(pEntry->Addr, pAd->CommonCfg.Bssid,
+			       MAC_ADDR_LEN);
 		pEntry->Aid = BSSID_WCID;
 		pEntry->pAd = pAd;
 		pEntry->ValidAsCLI = TRUE;	//Although this is bssid..still set ValidAsCl
@@ -1549,130 +1624,132 @@ VOID LinkUp(
 		pEntry->AuthState = SST_ASSOC;
 		pEntry->AuthMode = pAd->StaCfg.AuthMode;
 		pEntry->WepStatus = pAd->StaCfg.WepStatus;
-		if (pEntry->AuthMode < Ndis802_11AuthModeWPA)
-		{
+		if (pEntry->AuthMode < Ndis802_11AuthModeWPA) {
 			pEntry->WpaState = AS_NOTUSE;
 			pEntry->PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-		}
-		else
-		{
+		} else {
 			pEntry->WpaState = AS_PTKSTART;
 			pEntry->PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
 		}
-        NdisReleaseSpinLock(&pAd->MacTabLock);
+		NdisReleaseSpinLock(&pAd->MacTabLock);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !!!  ClientStatusFlags=%lx)\n",
-			pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("!!! LINK UP !!!  ClientStatusFlags=%lx)\n",
+			  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
 
 		MlmeUpdateTxRates(pAd, TRUE, BSS0);
 		MlmeUpdateHtTxRates(pAd, BSS0);
-		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK UP !! (StaActive.bHtEnable =%d, )\n", pAd->StaActive.SupportedPhyInfo.bHtEnable));
-
-		if (pAd->CommonCfg.bAggregationCapable)
-		{
-			if ((pAd->CommonCfg.bPiggyBackCapable) && (pAd->MlmeAux.APRalinkIe & 0x00000003) == 3)
-			{
-				OPSTATUS_SET_FLAG(pAd, fOP_STATUS_PIGGYBACK_INUSED);
-				OPSTATUS_SET_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
-				CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE);
-				CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_PIGGYBACK_CAPABLE);
-                RTMPSetPiggyBack(pAd, TRUE);
-				DBGPRINT(RT_DEBUG_TRACE, ("Turn on Piggy-Back\n"));
-			}
-			else if (pAd->MlmeAux.APRalinkIe & 0x00000001)
-			{
-				OPSTATUS_SET_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
-				CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_AGGREGATION_CAPABLE);
-				DBGPRINT(RT_DEBUG_TRACE, ("Ralink Aggregation\n"));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("!!! LINK UP !! (StaActive.bHtEnable =%d, )\n",
+			  pAd->StaActive.SupportedPhyInfo.bHtEnable));
+
+		if (pAd->CommonCfg.bAggregationCapable) {
+			if ((pAd->CommonCfg.bPiggyBackCapable)
+			    && (pAd->MlmeAux.APRalinkIe & 0x00000003) == 3) {
+				OPSTATUS_SET_FLAG(pAd,
+						  fOP_STATUS_PIGGYBACK_INUSED);
+				OPSTATUS_SET_FLAG(pAd,
+						  fOP_STATUS_AGGREGATION_INUSED);
+				CLIENT_STATUS_SET_FLAG(pEntry,
+						       fCLIENT_STATUS_AGGREGATION_CAPABLE);
+				CLIENT_STATUS_SET_FLAG(pEntry,
+						       fCLIENT_STATUS_PIGGYBACK_CAPABLE);
+				RTMPSetPiggyBack(pAd, TRUE);
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Turn on Piggy-Back\n"));
+			} else if (pAd->MlmeAux.APRalinkIe & 0x00000001) {
+				OPSTATUS_SET_FLAG(pAd,
+						  fOP_STATUS_AGGREGATION_INUSED);
+				CLIENT_STATUS_SET_FLAG(pEntry,
+						       fCLIENT_STATUS_AGGREGATION_CAPABLE);
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Ralink Aggregation\n"));
 			}
 		}
 
-		if (pAd->MlmeAux.APRalinkIe != 0x0)
-		{
-			if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_RDG_CAPABLE))
-			{
+		if (pAd->MlmeAux.APRalinkIe != 0x0) {
+			if (CLIENT_STATUS_TEST_FLAG
+			    (pEntry, fCLIENT_STATUS_RDG_CAPABLE)) {
 				AsicEnableRDG(pAd);
 			}
 			OPSTATUS_SET_FLAG(pAd, fCLIENT_STATUS_RALINK_CHIPSET);
-			CLIENT_STATUS_SET_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET);
-		}
-		else
-		{
+			CLIENT_STATUS_SET_FLAG(pEntry,
+					       fCLIENT_STATUS_RALINK_CHIPSET);
+		} else {
 			OPSTATUS_CLEAR_FLAG(pAd, fCLIENT_STATUS_RALINK_CHIPSET);
-			CLIENT_STATUS_CLEAR_FLAG(pEntry, fCLIENT_STATUS_RALINK_CHIPSET);
+			CLIENT_STATUS_CLEAR_FLAG(pEntry,
+						 fCLIENT_STATUS_RALINK_CHIPSET);
 		}
 	}
 
-	DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_CONNECT Event B!.BACapability = %x. ClientStatusFlags = %lx\n", pAd->CommonCfg.BACapability.word, pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("NDIS_STATUS_MEDIA_CONNECT Event B!.BACapability = %x. ClientStatusFlags = %lx\n",
+		  pAd->CommonCfg.BACapability.word,
+		  pAd->MacTab.Content[BSSID_WCID].ClientStatusFlags));
 
 	// Set LED
 	RTMPSetLED(pAd, LED_LINK_UP);
 
 	pAd->Mlme.PeriodicRound = 0;
 	pAd->Mlme.OneSecPeriodicRound = 0;
-	pAd->bConfigChanged = FALSE;        // Reset config flag
-	pAd->ExtraInfo = GENERAL_LINK_UP;   // Update extra information to link is up
+	pAd->bConfigChanged = FALSE;	// Reset config flag
+	pAd->ExtraInfo = GENERAL_LINK_UP;	// Update extra information to link is up
 
 	// Set asic auto fall back
 	{
-		PUCHAR					pTable;
-		UCHAR					TableSize = 0;
+		PUCHAR pTable;
+		UCHAR TableSize = 0;
 
-		MlmeSelectTxRateTable(pAd, &pAd->MacTab.Content[BSSID_WCID], &pTable, &TableSize, &pAd->CommonCfg.TxRateIndex);
+		MlmeSelectTxRateTable(pAd, &pAd->MacTab.Content[BSSID_WCID],
+				      &pTable, &TableSize,
+				      &pAd->CommonCfg.TxRateIndex);
 		AsicUpdateAutoFallBackTable(pAd, pTable);
 	}
 
 	NdisAcquireSpinLock(&pAd->MacTabLock);
-    pEntry->HTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
-    pEntry->MaxHTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
-	if (pAd->StaCfg.bAutoTxRateSwitch == FALSE)
-	{
+	pEntry->HTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
+	pEntry->MaxHTPhyMode.word = pAd->StaCfg.HTPhyMode.word;
+	if (pAd->StaCfg.bAutoTxRateSwitch == FALSE) {
 		pEntry->bAutoTxRateSwitch = FALSE;
 
 		if (pEntry->HTPhyMode.field.MCS == 32)
 			pEntry->HTPhyMode.field.ShortGI = GI_800;
 
-		if ((pEntry->HTPhyMode.field.MCS > MCS_7) || (pEntry->HTPhyMode.field.MCS == 32))
+		if ((pEntry->HTPhyMode.field.MCS > MCS_7)
+		    || (pEntry->HTPhyMode.field.MCS == 32))
 			pEntry->HTPhyMode.field.STBC = STBC_NONE;
 
 		// If the legacy mode is set, overwrite the transmit setting of this entry.
 		if (pEntry->HTPhyMode.field.MODE <= MODE_OFDM)
-			RTMPUpdateLegacyTxSetting((UCHAR)pAd->StaCfg.DesiredTransmitSetting.field.FixedTxMode, pEntry);
-	}
-	else
+			RTMPUpdateLegacyTxSetting((UCHAR) pAd->StaCfg.
+						  DesiredTransmitSetting.field.
+						  FixedTxMode, pEntry);
+	} else
 		pEntry->bAutoTxRateSwitch = TRUE;
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
 	//  Let Link Status Page display first initial rate.
-	pAd->LastTxRate = (USHORT)(pEntry->HTPhyMode.word);
+	pAd->LastTxRate = (USHORT) (pEntry->HTPhyMode.word);
 	// Select DAC according to HT or Legacy
-	if (pAd->StaActive.SupportedPhyInfo.MCSSet[0] != 0x00)
-	{
+	if (pAd->StaActive.SupportedPhyInfo.MCSSet[0] != 0x00) {
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &Value);
 		Value &= (~0x18);
-		if (pAd->Antenna.field.TxPath == 2)
-		{
-		    Value |= 0x10;
+		if (pAd->Antenna.field.TxPath == 2) {
+			Value |= 0x10;
 		}
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, Value);
-	}
-	else
-	{
+	} else {
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &Value);
 		Value &= (~0x18);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, Value);
 	}
 
-	if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
-	{
-	}
-	else if (pEntry->MaxRAmpduFactor == 0)
-	{
-	    // If HT AP doesn't support MaxRAmpduFactor = 1, we need to set max PSDU to 0.
-	    // Because our Init value is 1 at MACRegTable.
+	if (pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) {
+	} else if (pEntry->MaxRAmpduFactor == 0) {
+		// If HT AP doesn't support MaxRAmpduFactor = 1, we need to set max PSDU to 0.
+		// Because our Init value is 1 at MACRegTable.
 		RTMP_IO_WRITE32(pAd, MAX_LEN_CFG, 0x0fff);
 	}
-
 	// Patch for Marvel AP to gain high throughput
 	// Need to set as following,
 	// 1. Set txop in register-EDCA_AC0_CFG as 0x60
@@ -1683,34 +1760,31 @@ VOID LinkUp(
 	// Txop can only be modified when RDG is off, WMM is disable and TxBurst is enable
 	//
 	// if 1. Legacy AP WMM on,  or 2. 11n AP, AMPDU disable.  Force turn off burst no matter what bEnableTxBurst is.
-	if (!((pAd->CommonCfg.RxStream == 1)&&(pAd->CommonCfg.TxStream == 1)) &&
-		(pAd->StaCfg.bForceTxBurst == FALSE) &&
-		(((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
-		|| ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE) && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE))))
-	{
+	if (!((pAd->CommonCfg.RxStream == 1) && (pAd->CommonCfg.TxStream == 1))
+	    && (pAd->StaCfg.bForceTxBurst == FALSE)
+	    &&
+	    (((pAd->StaActive.SupportedPhyInfo.bHtEnable == FALSE)
+	      && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED))
+	     || ((pAd->StaActive.SupportedPhyInfo.bHtEnable == TRUE)
+		 && (pAd->CommonCfg.BACapability.field.Policy == BA_NOTUSE)))) {
 		RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-		Data  &= 0xFFFFFF00;
+		Data &= 0xFFFFFF00;
 		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
 
 		RTMP_IO_WRITE32(pAd, PBF_MAX_PCNT, 0x1F3F7F9F);
 		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 1\n"));
-	}
-	else
-	if (pAd->CommonCfg.bEnableTxBurst)
-	{
+	} else if (pAd->CommonCfg.bEnableTxBurst) {
 		RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-		Data  &= 0xFFFFFF00;
-		Data  |= 0x60;
+		Data &= 0xFFFFFF00;
+		Data |= 0x60;
 		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
 		pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = TRUE;
 
 		RTMP_IO_WRITE32(pAd, PBF_MAX_PCNT, 0x1F3FBF9F);
 		DBGPRINT(RT_DEBUG_TRACE, ("Txburst 2\n"));
-	}
-	else
-	{
+	} else {
 		RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &Data);
-		Data  &= 0xFFFFFF00;
+		Data &= 0xFFFFFF00;
 		RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, Data);
 
 		RTMP_IO_WRITE32(pAd, PBF_MAX_PCNT, 0x1F3F7F9F);
@@ -1718,59 +1792,54 @@ VOID LinkUp(
 	}
 
 	// Re-check to turn on TX burst or not.
-	if ((pAd->CommonCfg.IOTestParm.bLastAtheros == TRUE) && ((STA_WEP_ON(pAd))||(STA_TKIP_ON(pAd))))
-	{
+	if ((pAd->CommonCfg.IOTestParm.bLastAtheros == TRUE)
+	    && ((STA_WEP_ON(pAd)) || (STA_TKIP_ON(pAd)))) {
 		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = TRUE;
-		if (pAd->CommonCfg.bEnableTxBurst)
-		{
-		    UINT32 MACValue = 0;
+		if (pAd->CommonCfg.bEnableTxBurst) {
+			UINT32 MACValue = 0;
 			// Force disable  TXOP value in this case. The same action in MLMEUpdateProtect too.
 			// I didn't change PBF_MAX_PCNT setting.
 			RTMP_IO_READ32(pAd, EDCA_AC0_CFG, &MACValue);
-			MACValue  &= 0xFFFFFF00;
+			MACValue &= 0xFFFFFF00;
 			RTMP_IO_WRITE32(pAd, EDCA_AC0_CFG, MACValue);
 			pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = FALSE;
 		}
-	}
-	else
-	{
+	} else {
 		pAd->CommonCfg.IOTestParm.bNextDisableRxBA = FALSE;
 	}
 
 	pAd->CommonCfg.IOTestParm.bLastAtheros = FALSE;
 	COPY_MAC_ADDR(pAd->CommonCfg.LastBssid, pAd->CommonCfg.Bssid);
-	DBGPRINT(RT_DEBUG_TRACE, ("!!!pAd->bNextDisableRxBA= %d \n", pAd->CommonCfg.IOTestParm.bNextDisableRxBA));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("!!!pAd->bNextDisableRxBA= %d \n",
+		  pAd->CommonCfg.IOTestParm.bNextDisableRxBA));
 	// BSSID add in one MAC entry too.  Because in Tx, ASIC need to check Cipher and IV/EIV, BAbitmap
 	// Pther information in MACTab.Content[BSSID_WCID] is not necessary for driver.
 	// Note: As STA, The MACTab.Content[BSSID_WCID]. PairwiseKey and Shared Key for BSS0 are the same.
 
-    if (pAd->StaCfg.WepStatus <= Ndis802_11WEPDisabled)
-    {
+	if (pAd->StaCfg.WepStatus <= Ndis802_11WEPDisabled) {
 		if (pAd->StaCfg.WpaSupplicantUP &&
-			(pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
-			(pAd->StaCfg.IEEE8021X == TRUE))
-			;
-		else
-		{
-        pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilterAcceptAll;
-	}
+		    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
+		    (pAd->StaCfg.IEEE8021X == TRUE)) ;
+		else {
+			pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
+			pAd->StaCfg.PrivacyFilter =
+			    Ndis802_11PrivFilterAcceptAll;
+		}
 	}
 
 	NdisAcquireSpinLock(&pAd->MacTabLock);
 	pEntry->PortSecured = pAd->StaCfg.PortSecured;
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
-    //
+	//
 	// Patch Atheros AP TX will breakdown issue.
 	// AP Model: DLink DWL-8200AP
 	//
-	if (INFRA_ON(pAd) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) && STA_TKIP_ON(pAd))
-	{
+	if (INFRA_ON(pAd) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)
+	    && STA_TKIP_ON(pAd)) {
 		RTMP_IO_WRITE32(pAd, RX_PARSER_CFG, 0x01);
-	}
-	else
-	{
+	} else {
 		RTMP_IO_WRITE32(pAd, RX_PARSER_CFG, 0x00);
 	}
 
@@ -1804,11 +1873,9 @@ VOID LinkUp(
 
 	==========================================================================
 */
-VOID LinkDown(
-	IN PRTMP_ADAPTER pAd,
-	IN  BOOLEAN      IsReqFromAP)
+VOID LinkDown(IN PRTMP_ADAPTER pAd, IN BOOLEAN IsReqFromAP)
 {
-	UCHAR			    i, ByteValue = 0;
+	UCHAR i, ByteValue = 0;
 
 	// Do nothing if monitor mode is on
 	if (MONITOR_ON(pAd))
@@ -1816,45 +1883,43 @@ VOID LinkDown(
 
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_GO_TO_SLEEP_NOW);
 	//Comment the codes, beasue the line 2291 call the same function.
-	//RTMPCancelTimer(&pAd->Mlme.PsPollTimer,		&Cancelled);
+	//RTMPCancelTimer(&pAd->Mlme.PsPollTimer,               &Cancelled);
 	// Not allow go to sleep within linkdown function.
 	RTMP_CLEAR_PSFLAG(pAd, fRTMP_PS_CAN_GO_SLEEP);
 
-    if (pAd->CommonCfg.bWirelessEvent)
-	{
-		RTMPSendWirelessEvent(pAd, IW_STA_LINKDOWN_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+	if (pAd->CommonCfg.bWirelessEvent) {
+		RTMPSendWirelessEvent(pAd, IW_STA_LINKDOWN_EVENT_FLAG,
+				      pAd->MacTab.Content[BSSID_WCID].Addr,
+				      BSS0, 0);
 	}
 
 	DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN !!!\n"));
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED);
 
 #ifdef RTMP_MAC_PCI
-    if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-    {
-	    BOOLEAN Cancelled;
-        pAd->Mlme.bPsPollTimerRunning = FALSE;
-        RTMPCancelTimer(&pAd->Mlme.PsPollTimer,	&Cancelled);
-    }
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) {
+		BOOLEAN Cancelled;
+		pAd->Mlme.bPsPollTimerRunning = FALSE;
+		RTMPCancelTimer(&pAd->Mlme.PsPollTimer, &Cancelled);
+	}
 
 	pAd->bPCIclkOff = FALSE;
 #endif // RTMP_MAC_PCI //
 
-    if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
-||	RTMP_TEST_PSFLAG(pAd, fRTMP_PS_SET_PCI_CLK_OFF_COMMAND)
-		|| RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))
-    {
-        AUTO_WAKEUP_STRUC AutoWakeupCfg;
+	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)
+	    || RTMP_TEST_PSFLAG(pAd, fRTMP_PS_SET_PCI_CLK_OFF_COMMAND)
+	    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)) {
+		AUTO_WAKEUP_STRUC AutoWakeupCfg;
 		AsicForceWakeup(pAd, TRUE);
-        AutoWakeupCfg.word = 0;
-	    RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
-        OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
-    }
-
+		AutoWakeupCfg.word = 0;
+		RTMP_IO_WRITE32(pAd, AUTO_WAKEUP_CFG, AutoWakeupCfg.word);
+		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_DOZE);
+	}
 #ifdef RTMP_MAC_PCI
 	pAd->bPCIclkOff = FALSE;
 #endif // RTMP_MAC_PCI //
 
-	if (ADHOC_ON(pAd))		// Adhoc mode link down
+	if (ADHOC_ON(pAd))	// Adhoc mode link down
 	{
 		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN 1!!!\n"));
 
@@ -1862,11 +1927,12 @@ VOID LinkDown(
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
 		pAd->IndicateMediaState = NdisMediaStateDisconnected;
 		RTMP_IndicateMediaState(pAd);
-        pAd->ExtraInfo = GENERAL_LINK_DOWN;
-		BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid, pAd->CommonCfg.Channel);
-		DBGPRINT(RT_DEBUG_TRACE, ("!!! MacTab.Size=%d !!!\n", pAd->MacTab.Size));
-	}
-	else					// Infra structure mode
+		pAd->ExtraInfo = GENERAL_LINK_DOWN;
+		BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid,
+				    pAd->CommonCfg.Channel);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("!!! MacTab.Size=%d !!!\n", pAd->MacTab.Size));
+	} else			// Infra structure mode
 	{
 		DBGPRINT(RT_DEBUG_TRACE, ("!!! LINK DOWN 2!!!\n"));
 
@@ -1875,25 +1941,25 @@ VOID LinkDown(
 
 		// Saved last SSID for linkup comparison
 		pAd->CommonCfg.LastSsidLen = pAd->CommonCfg.SsidLen;
-		NdisMoveMemory(pAd->CommonCfg.LastSsid, pAd->CommonCfg.Ssid, pAd->CommonCfg.LastSsidLen);
+		NdisMoveMemory(pAd->CommonCfg.LastSsid, pAd->CommonCfg.Ssid,
+			       pAd->CommonCfg.LastSsidLen);
 		COPY_MAC_ADDR(pAd->CommonCfg.LastBssid, pAd->CommonCfg.Bssid);
-		if (pAd->MlmeAux.CurrReqIsFromNdis == TRUE)
-		{
+		if (pAd->MlmeAux.CurrReqIsFromNdis == TRUE) {
 			pAd->IndicateMediaState = NdisMediaStateDisconnected;
 			RTMP_IndicateMediaState(pAd);
-            pAd->ExtraInfo = GENERAL_LINK_DOWN;
-			DBGPRINT(RT_DEBUG_TRACE, ("NDIS_STATUS_MEDIA_DISCONNECT Event A!\n"));
+			pAd->ExtraInfo = GENERAL_LINK_DOWN;
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("NDIS_STATUS_MEDIA_DISCONNECT Event A!\n"));
 			pAd->MlmeAux.CurrReqIsFromNdis = FALSE;
-		}
-		else
-		{
-            //
+		} else {
+			//
 			// If disassociation request is from NDIS, then we don't need to delete BSSID from entry.
 			// Otherwise lost beacon or receive De-Authentication from AP,
 			// then we should delete BSSID from BssTable.
 			// If we don't delete from entry, roaming will fail.
 			//
-			BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid, pAd->CommonCfg.Channel);
+			BssTableDeleteEntry(&pAd->ScanTab, pAd->CommonCfg.Bssid,
+					    pAd->CommonCfg.Channel);
 		}
 
 		// restore back to -
@@ -1902,31 +1968,28 @@ VOID LinkDown(
 		//      3. short preamble
 		OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
 
-
 	}
 
-
-	for (i=1; i<MAX_LEN_OF_MAC_TABLE; i++)
-	{
+	for (i = 1; i < MAX_LEN_OF_MAC_TABLE; i++) {
 		if (pAd->MacTab.Content[i].ValidAsCLI == TRUE)
-			MacTableDeleteEntry(pAd, pAd->MacTab.Content[i].Aid, pAd->MacTab.Content[i].Addr);
+			MacTableDeleteEntry(pAd, pAd->MacTab.Content[i].Aid,
+					    pAd->MacTab.Content[i].Addr);
 	}
 
-	AsicSetSlotTime(pAd, TRUE); //FALSE);
+	AsicSetSlotTime(pAd, TRUE);	//FALSE);
 	AsicSetEdcaParm(pAd, NULL);
 
 	// Set LED
 	RTMPSetLED(pAd, LED_LINK_DOWN);
-    pAd->LedIndicatorStrength = 0xF0;
-    RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, firmware is not done it.
+	pAd->LedIndicatorStrength = 0xF0;
+	RTMPSetSignalLED(pAd, -100);	// Force signal strength Led to be turned off, firmware is not done it.
 
-		AsicDisableSync(pAd);
+	AsicDisableSync(pAd);
 
 	pAd->Mlme.PeriodicRound = 0;
 	pAd->Mlme.OneSecPeriodicRound = 0;
 
-	if (pAd->StaCfg.BssType == BSS_INFRA)
-	{
+	if (pAd->StaCfg.BssType == BSS_INFRA) {
 		// Remove StaCfg Information after link down
 		NdisZeroMemory(pAd->CommonCfg.Bssid, MAC_ADDR_LEN);
 		NdisZeroMemory(pAd->CommonCfg.Ssid, MAX_LEN_OF_SSID);
@@ -1939,36 +2002,29 @@ VOID LinkDown(
 	pAd->MlmeAux.NewExtChannelOffset = 0xff;
 
 	// Reset WPA-PSK state. Only reset when supplicant enabled
-	if (pAd->StaCfg.WpaState != SS_NOTUSE)
-	{
+	if (pAd->StaCfg.WpaState != SS_NOTUSE) {
 		pAd->StaCfg.WpaState = SS_START;
 		// Clear Replay counter
 		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
 
 	}
-
 	//
 	// if link down come from AP, we need to remove all WPA keys on WPA mode.
 	// otherwise will cause 4-way handshaking failed, since the WPA key not empty.
 	//
-	if ((IsReqFromAP) && (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA))
-	{
+	if ((IsReqFromAP) && (pAd->StaCfg.AuthMode >= Ndis802_11AuthModeWPA)) {
 		// Remove all WPA keys
 		RTMPWPARemoveAllKeys(pAd);
 	}
-
 	// 802.1x port control
 
 	// Prevent clear PortSecured here with static WEP
 	// NetworkManger set security policy first then set SSID to connect AP.
 	if (pAd->StaCfg.WpaSupplicantUP &&
-		(pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
-		(pAd->StaCfg.IEEE8021X == FALSE))
-	{
+	    (pAd->StaCfg.WepStatus == Ndis802_11WEPEnabled) &&
+	    (pAd->StaCfg.IEEE8021X == FALSE)) {
 		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
-	}
-	else
-	{
+	} else {
 		pAd->StaCfg.PortSecured = WPA_802_1X_PORT_NOT_SECURED;
 		pAd->StaCfg.PrivacyFilter = Ndis802_11PrivFilter8021xWEP;
 	}
@@ -1980,19 +2036,21 @@ VOID LinkDown(
 
 	pAd->StaCfg.MicErrCnt = 0;
 
-    pAd->IndicateMediaState = NdisMediaStateDisconnected;
+	pAd->IndicateMediaState = NdisMediaStateDisconnected;
 	// Update extra information to link is up
 	pAd->ExtraInfo = GENERAL_LINK_DOWN;
 
-    pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
+	pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
 
 #ifdef RTMP_MAC_USB
 	pAd->bUsbTxBulkAggre = FALSE;
 #endif // RTMP_MAC_USB //
 
 	// Clean association information
-	NdisZeroMemory(&pAd->StaCfg.AssocInfo, sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
-	pAd->StaCfg.AssocInfo.Length = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
+	NdisZeroMemory(&pAd->StaCfg.AssocInfo,
+		       sizeof(NDIS_802_11_ASSOCIATION_INFORMATION));
+	pAd->StaCfg.AssocInfo.Length =
+	    sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
 	pAd->StaCfg.ReqVarIELen = 0;
 	pAd->StaCfg.ResVarIELen = 0;
 
@@ -2013,30 +2071,29 @@ VOID LinkDown(
 	//
 	// After Link down, reset piggy-back setting in ASIC. Disable RDG.
 	//
-	if (pAd->CommonCfg.BBPCurrentBW == BW_40)
-	{
+	if (pAd->CommonCfg.BBPCurrentBW == BW_40) {
 		pAd->CommonCfg.BBPCurrentBW = BW_20;
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &ByteValue);
 		ByteValue &= (~0x18);
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, ByteValue);
 	}
-
 	// Reset DAC
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R1, &ByteValue);
 	ByteValue &= (~0x18);
-	if (pAd->Antenna.field.TxPath == 2)
-	{
+	if (pAd->Antenna.field.TxPath == 2) {
 		ByteValue |= 0x10;
 	}
 	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R1, ByteValue);
 
-	RTMPSetPiggyBack(pAd,FALSE);
+	RTMPSetPiggyBack(pAd, FALSE);
 	OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_PIGGYBACK_INUSED);
 
 	pAd->CommonCfg.BACapability.word = pAd->CommonCfg.REGBACapability.word;
 
 	// Restore all settings in the following.
-	AsicUpdateProtect(pAd, 0, (ALLN_SETPROTECT|CCKSETPROTECT|OFDMSETPROTECT), TRUE, FALSE);
+	AsicUpdateProtect(pAd, 0,
+			  (ALLN_SETPROTECT | CCKSETPROTECT | OFDMSETPROTECT),
+			  TRUE, FALSE);
 	AsicDisableRDG(pAd);
 	pAd->CommonCfg.IOTestParm.bCurrentAtheros = FALSE;
 	pAd->CommonCfg.IOTestParm.bNowAtherosBurstOn = FALSE;
@@ -2050,9 +2107,8 @@ VOID LinkDown(
 	RtmpOSWrielessEventSend(pAd, SIOCGIWAP, -1, NULL, NULL, 0);
 
 #ifdef RT30xx
-	if ((IS_RT30xx(pAd) || IS_RT3090(pAd)||IS_RT3390(pAd))
-		&&(pAd->Antenna.field.RxPath>1||pAd->Antenna.field.TxPath>1))
-	{
+	if ((IS_RT30xx(pAd) || IS_RT3090(pAd) || IS_RT3390(pAd))
+	    && (pAd->Antenna.field.RxPath > 1 || pAd->Antenna.field.TxPath > 1)) {
 		RTMP_ASIC_MMPS_DISABLE(pAd);
 	}
 #endif // RT30xx //
@@ -2066,78 +2122,104 @@ VOID LinkDown(
 
 	==========================================================================
 */
-VOID IterateOnBssTab(
-	IN PRTMP_ADAPTER pAd)
+VOID IterateOnBssTab(IN PRTMP_ADAPTER pAd)
 {
-	MLME_START_REQ_STRUCT   StartReq;
-	MLME_JOIN_REQ_STRUCT    JoinReq;
-	ULONG                   BssIdx;
+	MLME_START_REQ_STRUCT StartReq;
+	MLME_JOIN_REQ_STRUCT JoinReq;
+	ULONG BssIdx;
 
 	// Change the wepstatus to original wepstatus
-	pAd->StaCfg.WepStatus   = pAd->StaCfg.OrigWepStatus;
-	pAd->StaCfg.PairCipher  = pAd->StaCfg.OrigWepStatus;
+	pAd->StaCfg.WepStatus = pAd->StaCfg.OrigWepStatus;
+	pAd->StaCfg.PairCipher = pAd->StaCfg.OrigWepStatus;
 	pAd->StaCfg.GroupCipher = pAd->StaCfg.OrigWepStatus;
 
 	BssIdx = pAd->MlmeAux.BssIdx;
-	if (BssIdx < pAd->MlmeAux.SsidBssTab.BssNr)
-	{
+	if (BssIdx < pAd->MlmeAux.SsidBssTab.BssNr) {
 		// Check cipher suite, AP must have more secured cipher than station setting
 		// Set the Pairwise and Group cipher to match the intended AP setting
 		// We can only connect to AP with less secured cipher setting
-		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK))
-		{
-			pAd->StaCfg.GroupCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.GroupCipher;
-
-			if (pAd->StaCfg.WepStatus == pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipher)
-				pAd->StaCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipher;
-			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipherAux != Ndis802_11WEPDisabled)
-				pAd->StaCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.PairCipherAux;
+		if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA)
+		    || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK)) {
+			pAd->StaCfg.GroupCipher =
+			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.
+			    GroupCipher;
+
+			if (pAd->StaCfg.WepStatus ==
+			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.
+			    PairCipher)
+				pAd->StaCfg.PairCipher =
+				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
+				    WPA.PairCipher;
+			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA.
+				 PairCipherAux != Ndis802_11WEPDisabled)
+				pAd->StaCfg.PairCipher =
+				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
+				    WPA.PairCipherAux;
 			else	// There is no PairCipher Aux, downgrade our capability to TKIP
-				pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
-		}
-		else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) || (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK))
-		{
-			pAd->StaCfg.GroupCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.GroupCipher;
-
-			if (pAd->StaCfg.WepStatus == pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipher)
-				pAd->StaCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipher;
-			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipherAux != Ndis802_11WEPDisabled)
-				pAd->StaCfg.PairCipher = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.PairCipherAux;
+				pAd->StaCfg.PairCipher =
+				    Ndis802_11Encryption2Enabled;
+		} else if ((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2)
+			   || (pAd->StaCfg.AuthMode ==
+			       Ndis802_11AuthModeWPA2PSK)) {
+			pAd->StaCfg.GroupCipher =
+			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
+			    GroupCipher;
+
+			if (pAd->StaCfg.WepStatus ==
+			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
+			    PairCipher)
+				pAd->StaCfg.PairCipher =
+				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
+				    WPA2.PairCipher;
+			else if (pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
+				 PairCipherAux != Ndis802_11WEPDisabled)
+				pAd->StaCfg.PairCipher =
+				    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].
+				    WPA2.PairCipherAux;
 			else	// There is no PairCipher Aux, downgrade our capability to TKIP
-				pAd->StaCfg.PairCipher = Ndis802_11Encryption2Enabled;
+				pAd->StaCfg.PairCipher =
+				    Ndis802_11Encryption2Enabled;
 
 			// RSN capability
-			pAd->StaCfg.RsnCapability = pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.RsnCapability;
+			pAd->StaCfg.RsnCapability =
+			    pAd->MlmeAux.SsidBssTab.BssEntry[BssIdx].WPA2.
+			    RsnCapability;
 		}
-
 		// Set Mix cipher flag
-		pAd->StaCfg.bMixCipher = (pAd->StaCfg.PairCipher == pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
+		pAd->StaCfg.bMixCipher =
+		    (pAd->StaCfg.PairCipher ==
+		     pAd->StaCfg.GroupCipher) ? FALSE : TRUE;
 		/*if (pAd->StaCfg.bMixCipher == TRUE)
-		{
-			// If mix cipher, re-build RSNIE
-			RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
-		}*/
-
-		DBGPRINT(RT_DEBUG_TRACE, ("CNTL - iterate BSS %ld of %d\n", BssIdx, pAd->MlmeAux.SsidBssTab.BssNr));
+		   {
+		   // If mix cipher, re-build RSNIE
+		   RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, 0);
+		   } */
+
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("CNTL - iterate BSS %ld of %d\n", BssIdx,
+			  pAd->MlmeAux.SsidBssTab.BssNr));
 		JoinParmFill(pAd, &JoinReq, BssIdx);
-		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ, sizeof(MLME_JOIN_REQ_STRUCT),
-					&JoinReq);
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_JOIN_REQ,
+			    sizeof(MLME_JOIN_REQ_STRUCT), &JoinReq);
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_JOIN;
-	}
-	else if (pAd->StaCfg.BssType == BSS_ADHOC)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("CNTL - All BSS fail; start a new ADHOC (Ssid=%s)...\n",pAd->MlmeAux.Ssid));
-		StartParmFill(pAd, &StartReq, (PCHAR)pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen);
-		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ, sizeof(MLME_START_REQ_STRUCT), &StartReq);
+	} else if (pAd->StaCfg.BssType == BSS_ADHOC) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("CNTL - All BSS fail; start a new ADHOC (Ssid=%s)...\n",
+			  pAd->MlmeAux.Ssid));
+		StartParmFill(pAd, &StartReq, (PCHAR) pAd->MlmeAux.Ssid,
+			      pAd->MlmeAux.SsidLen);
+		MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_MLME_START_REQ,
+			    sizeof(MLME_START_REQ_STRUCT), &StartReq);
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_START;
-	}
-	else // no more BSS
+	} else			// no more BSS
 	{
 
 		{
-		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - All roaming failed, restore to channel %d, Total BSS[%02d]\n",pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
+			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - All roaming failed, restore to channel %d, Total BSS[%02d]\n",
+				  pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
 		}
 
 		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
@@ -2146,38 +2228,40 @@ VOID IterateOnBssTab(
 
 // for re-association only
 // IRQL = DISPATCH_LEVEL
-VOID IterateOnBssTab2(
-	IN PRTMP_ADAPTER pAd)
+VOID IterateOnBssTab2(IN PRTMP_ADAPTER pAd)
 {
 	MLME_REASSOC_REQ_STRUCT ReassocReq;
-	ULONG                   BssIdx;
-	BSS_ENTRY               *pBss;
+	ULONG BssIdx;
+	BSS_ENTRY *pBss;
 
 	BssIdx = pAd->MlmeAux.RoamIdx;
 	pBss = &pAd->MlmeAux.RoamTab.BssEntry[BssIdx];
 
-	if (BssIdx < pAd->MlmeAux.RoamTab.BssNr)
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("CNTL - iterate BSS %ld of %d\n", BssIdx, pAd->MlmeAux.RoamTab.BssNr));
+	if (BssIdx < pAd->MlmeAux.RoamTab.BssNr) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("CNTL - iterate BSS %ld of %d\n", BssIdx,
+			  pAd->MlmeAux.RoamTab.BssNr));
 
 		AsicSwitchChannel(pAd, pBss->Channel, FALSE);
 		AsicLockChannel(pAd, pBss->Channel);
 
 		// reassociate message has the same structure as associate message
-		AssocParmFill(pAd, &ReassocReq, pBss->Bssid, pBss->CapabilityInfo,
-					  ASSOC_TIMEOUT, pAd->StaCfg.DefaultListenCount);
+		AssocParmFill(pAd, &ReassocReq, pBss->Bssid,
+			      pBss->CapabilityInfo, ASSOC_TIMEOUT,
+			      pAd->StaCfg.DefaultListenCount);
 		MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_REASSOC_REQ,
-					sizeof(MLME_REASSOC_REQ_STRUCT), &ReassocReq);
+			    sizeof(MLME_REASSOC_REQ_STRUCT), &ReassocReq);
 
 		pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_REASSOC;
-	}
-	else // no more BSS
+	} else			// no more BSS
 	{
 
 		{
-		AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-		AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-			DBGPRINT(RT_DEBUG_TRACE, ("CNTL - All roaming failed, restore to channel %d, Total BSS[%02d]\n",pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
+			AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
+			AsicLockChannel(pAd, pAd->CommonCfg.Channel);
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("CNTL - All roaming failed, restore to channel %d, Total BSS[%02d]\n",
+				  pAd->CommonCfg.Channel, pAd->ScanTab.BssNr));
 		}
 
 		pAd->Mlme.CntlMachine.CurrState = CNTL_IDLE;
@@ -2192,10 +2276,8 @@ VOID IterateOnBssTab2(
 
 	==========================================================================
 */
-VOID JoinParmFill(
-	IN PRTMP_ADAPTER pAd,
-	IN OUT MLME_JOIN_REQ_STRUCT *JoinReq,
-	IN ULONG BssIdx)
+VOID JoinParmFill(IN PRTMP_ADAPTER pAd,
+		  IN OUT MLME_JOIN_REQ_STRUCT * JoinReq, IN ULONG BssIdx)
 {
 	JoinReq->BssIdx = BssIdx;
 }
@@ -2208,15 +2290,12 @@ VOID JoinParmFill(
 
 	==========================================================================
 */
-VOID ScanParmFill(
-	IN PRTMP_ADAPTER pAd,
-	IN OUT MLME_SCAN_REQ_STRUCT *ScanReq,
-	IN STRING Ssid[],
-	IN UCHAR SsidLen,
-	IN UCHAR BssType,
-	IN UCHAR ScanType)
+VOID ScanParmFill(IN PRTMP_ADAPTER pAd,
+		  IN OUT MLME_SCAN_REQ_STRUCT * ScanReq,
+		  IN STRING Ssid[],
+		  IN UCHAR SsidLen, IN UCHAR BssType, IN UCHAR ScanType)
 {
-    NdisZeroMemory(ScanReq->Ssid, MAX_LEN_OF_SSID);
+	NdisZeroMemory(ScanReq->Ssid, MAX_LEN_OF_SSID);
 	ScanReq->SsidLen = SsidLen;
 	NdisMoveMemory(ScanReq->Ssid, Ssid, SsidLen);
 	ScanReq->BssType = BssType;
@@ -2231,11 +2310,9 @@ VOID ScanParmFill(
 
 	==========================================================================
 */
-VOID StartParmFill(
-	IN PRTMP_ADAPTER pAd,
-	IN OUT MLME_START_REQ_STRUCT *StartReq,
-	IN CHAR Ssid[],
-	IN UCHAR SsidLen)
+VOID StartParmFill(IN PRTMP_ADAPTER pAd,
+		   IN OUT MLME_START_REQ_STRUCT * StartReq,
+		   IN CHAR Ssid[], IN UCHAR SsidLen)
 {
 	ASSERT(SsidLen <= MAX_LEN_OF_SSID);
 	NdisMoveMemory(StartReq->Ssid, Ssid, SsidLen);
@@ -2250,11 +2327,9 @@ VOID StartParmFill(
 
 	==========================================================================
 */
-VOID AuthParmFill(
-	IN PRTMP_ADAPTER pAd,
-	IN OUT MLME_AUTH_REQ_STRUCT *AuthReq,
-	IN PUCHAR pAddr,
-	IN USHORT Alg)
+VOID AuthParmFill(IN PRTMP_ADAPTER pAd,
+		  IN OUT MLME_AUTH_REQ_STRUCT * AuthReq,
+		  IN PUCHAR pAddr, IN USHORT Alg)
 {
 	COPY_MAC_ADDR(AuthReq->Addr, pAddr);
 	AuthReq->Alg = Alg;
@@ -2270,8 +2345,7 @@ VOID AuthParmFill(
 	==========================================================================
  */
 #ifdef RTMP_MAC_PCI
-VOID ComposePsPoll(
-	IN PRTMP_ADAPTER pAd)
+VOID ComposePsPoll(IN PRTMP_ADAPTER pAd)
 {
 	NdisZeroMemory(&pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
 	pAd->PsPollFrame.FC.Type = BTYPE_CNTL;
@@ -2282,8 +2356,7 @@ VOID ComposePsPoll(
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID ComposeNullFrame(
-	IN PRTMP_ADAPTER pAd)
+VOID ComposeNullFrame(IN PRTMP_ADAPTER pAd)
 {
 	NdisZeroMemory(&pAd->NullFrame, sizeof(HEADER_802_11));
 	pAd->NullFrame.FC.Type = BTYPE_DATA;
@@ -2295,19 +2368,16 @@ VOID ComposeNullFrame(
 }
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
-VOID MlmeCntlConfirm(
-	IN PRTMP_ADAPTER pAd,
-	IN ULONG MsgType,
-	IN USHORT Msg)
+VOID MlmeCntlConfirm(IN PRTMP_ADAPTER pAd, IN ULONG MsgType, IN USHORT Msg)
 {
-	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MsgType, sizeof(USHORT), &Msg);
+	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MsgType, sizeof(USHORT),
+		    &Msg);
 }
 
-VOID ComposePsPoll(
-	IN PRTMP_ADAPTER pAd)
+VOID ComposePsPoll(IN PRTMP_ADAPTER pAd)
 {
-	PTXINFO_STRUC		pTxInfo;
-	PTXWI_STRUC		pTxWI;
+	PTXINFO_STRUC pTxInfo;
+	PTXWI_STRUC pTxWI;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("ComposePsPoll\n"));
 	NdisZeroMemory(&pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
@@ -2319,23 +2389,34 @@ VOID ComposePsPoll(
 	COPY_MAC_ADDR(pAd->PsPollFrame.Bssid, pAd->CommonCfg.Bssid);
 	COPY_MAC_ADDR(pAd->PsPollFrame.Ta, pAd->CurrentAddress);
 
-	RTMPZeroMemory(&pAd->PsPollContext.TransferBuffer->field.WirelessPacket[0], 100);
-	pTxInfo = (PTXINFO_STRUC)&pAd->PsPollContext.TransferBuffer->field.WirelessPacket[0];
-	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT)(sizeof(PSPOLL_FRAME)+TXWI_SIZE), TRUE, EpToQueue[MGMTPIPEIDX], FALSE,  FALSE);
-	pTxWI = (PTXWI_STRUC)&pAd->PsPollContext.TransferBuffer->field.WirelessPacket[TXINFO_SIZE];
-	RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0, BSSID_WCID, (sizeof(PSPOLL_FRAME)),
-		0,  0, (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	RTMPMoveMemory(&pAd->PsPollContext.TransferBuffer->field.WirelessPacket[TXWI_SIZE+TXINFO_SIZE], &pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
+	RTMPZeroMemory(&pAd->PsPollContext.TransferBuffer->field.
+		       WirelessPacket[0], 100);
+	pTxInfo =
+	    (PTXINFO_STRUC) & pAd->PsPollContext.TransferBuffer->field.
+	    WirelessPacket[0];
+	RTMPWriteTxInfo(pAd, pTxInfo,
+			(USHORT) (sizeof(PSPOLL_FRAME) + TXWI_SIZE), TRUE,
+			EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
+	pTxWI =
+	    (PTXWI_STRUC) & pAd->PsPollContext.TransferBuffer->field.
+	    WirelessPacket[TXINFO_SIZE];
+	RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0,
+		      BSSID_WCID, (sizeof(PSPOLL_FRAME)), 0, 0,
+		      (UCHAR) pAd->CommonCfg.MlmeTransmit.field.MCS,
+		      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
+	RTMPMoveMemory(&pAd->PsPollContext.TransferBuffer->field.
+		       WirelessPacket[TXWI_SIZE + TXINFO_SIZE],
+		       &pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
 	// Append 4 extra zero bytes.
-	pAd->PsPollContext.BulkOutSize =  TXINFO_SIZE + TXWI_SIZE + sizeof(PSPOLL_FRAME) + 4;
+	pAd->PsPollContext.BulkOutSize =
+	    TXINFO_SIZE + TXWI_SIZE + sizeof(PSPOLL_FRAME) + 4;
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID ComposeNullFrame(
-	IN PRTMP_ADAPTER pAd)
+VOID ComposeNullFrame(IN PRTMP_ADAPTER pAd)
 {
-	PTXINFO_STRUC		pTxInfo;
-	PTXWI_STRUC		pTxWI;
+	PTXINFO_STRUC pTxInfo;
+	PTXWI_STRUC pTxWI;
 
 	NdisZeroMemory(&pAd->NullFrame, sizeof(HEADER_802_11));
 	pAd->NullFrame.FC.Type = BTYPE_DATA;
@@ -2344,14 +2425,26 @@ VOID ComposeNullFrame(
 	COPY_MAC_ADDR(pAd->NullFrame.Addr1, pAd->CommonCfg.Bssid);
 	COPY_MAC_ADDR(pAd->NullFrame.Addr2, pAd->CurrentAddress);
 	COPY_MAC_ADDR(pAd->NullFrame.Addr3, pAd->CommonCfg.Bssid);
-	RTMPZeroMemory(&pAd->NullContext.TransferBuffer->field.WirelessPacket[0], 100);
-	pTxInfo = (PTXINFO_STRUC)&pAd->NullContext.TransferBuffer->field.WirelessPacket[0];
-	RTMPWriteTxInfo(pAd, pTxInfo, (USHORT)(sizeof(HEADER_802_11)+TXWI_SIZE), TRUE, EpToQueue[MGMTPIPEIDX], FALSE,  FALSE);
-	pTxWI = (PTXWI_STRUC)&pAd->NullContext.TransferBuffer->field.WirelessPacket[TXINFO_SIZE];
-	RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0, BSSID_WCID, (sizeof(HEADER_802_11)),
-		0, 0, (UCHAR)pAd->CommonCfg.MlmeTransmit.field.MCS, IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
-	RTMPMoveMemory(&pAd->NullContext.TransferBuffer->field.WirelessPacket[TXWI_SIZE+TXINFO_SIZE], &pAd->NullFrame, sizeof(HEADER_802_11));
-	pAd->NullContext.BulkOutSize =  TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
+	RTMPZeroMemory(&pAd->NullContext.TransferBuffer->field.
+		       WirelessPacket[0], 100);
+	pTxInfo =
+	    (PTXINFO_STRUC) & pAd->NullContext.TransferBuffer->field.
+	    WirelessPacket[0];
+	RTMPWriteTxInfo(pAd, pTxInfo,
+			(USHORT) (sizeof(HEADER_802_11) + TXWI_SIZE), TRUE,
+			EpToQueue[MGMTPIPEIDX], FALSE, FALSE);
+	pTxWI =
+	    (PTXWI_STRUC) & pAd->NullContext.TransferBuffer->field.
+	    WirelessPacket[TXINFO_SIZE];
+	RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 0,
+		      BSSID_WCID, (sizeof(HEADER_802_11)), 0, 0,
+		      (UCHAR) pAd->CommonCfg.MlmeTransmit.field.MCS,
+		      IFS_BACKOFF, FALSE, &pAd->CommonCfg.MlmeTransmit);
+	RTMPMoveMemory(&pAd->NullContext.TransferBuffer->field.
+		       WirelessPacket[TXWI_SIZE + TXINFO_SIZE], &pAd->NullFrame,
+		       sizeof(HEADER_802_11));
+	pAd->NullContext.BulkOutSize =
+	    TXINFO_SIZE + TXWI_SIZE + sizeof(pAd->NullFrame) + 4;
 }
 #endif // RTMP_MAC_USB //
 
@@ -2365,45 +2458,42 @@ VOID ComposeNullFrame(
 
 	==========================================================================
 */
-ULONG MakeIbssBeacon(
-	IN PRTMP_ADAPTER pAd)
+ULONG MakeIbssBeacon(IN PRTMP_ADAPTER pAd)
 {
-	UCHAR         DsLen = 1, IbssLen = 2;
-	UCHAR         LocalErpIe[3] = {IE_ERP, 1, 0x04};
+	UCHAR DsLen = 1, IbssLen = 2;
+	UCHAR LocalErpIe[3] = { IE_ERP, 1, 0x04 };
 	HEADER_802_11 BcnHdr;
-	USHORT        CapabilityInfo;
+	USHORT CapabilityInfo;
 	LARGE_INTEGER FakeTimestamp;
-	ULONG         FrameLen = 0;
-	PTXWI_STRUC	  pTxWI = &pAd->BeaconTxWI;
-	UCHAR         *pBeaconFrame = pAd->BeaconBuf;
-	BOOLEAN       Privacy;
-	UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR         SupRateLen = 0;
-	UCHAR         ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR         ExtRateLen = 0;
-	UCHAR         RSNIe = IE_WPA;
-
-	if ((pAd->CommonCfg.PhyMode == PHY_11B) && (pAd->CommonCfg.Channel <= 14))
-	{
-		SupRate[0] = 0x82; // 1 mbps
-		SupRate[1] = 0x84; // 2 mbps
-		SupRate[2] = 0x8b; // 5.5 mbps
-		SupRate[3] = 0x96; // 11 mbps
+	ULONG FrameLen = 0;
+	PTXWI_STRUC pTxWI = &pAd->BeaconTxWI;
+	UCHAR *pBeaconFrame = pAd->BeaconBuf;
+	BOOLEAN Privacy;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen = 0;
+	UCHAR ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR ExtRateLen = 0;
+	UCHAR RSNIe = IE_WPA;
+
+	if ((pAd->CommonCfg.PhyMode == PHY_11B)
+	    && (pAd->CommonCfg.Channel <= 14)) {
+		SupRate[0] = 0x82;	// 1 mbps
+		SupRate[1] = 0x84;	// 2 mbps
+		SupRate[2] = 0x8b;	// 5.5 mbps
+		SupRate[3] = 0x96;	// 11 mbps
 		SupRateLen = 4;
 		ExtRateLen = 0;
-	}
-	else if (pAd->CommonCfg.Channel > 14)
-	{
-		SupRate[0]  = 0x8C;    // 6 mbps, in units of 0.5 Mbps, basic rate
-		SupRate[1]  = 0x12;    // 9 mbps, in units of 0.5 Mbps
-		SupRate[2]  = 0x98;    // 12 mbps, in units of 0.5 Mbps, basic rate
-		SupRate[3]  = 0x24;    // 18 mbps, in units of 0.5 Mbps
-		SupRate[4]  = 0xb0;    // 24 mbps, in units of 0.5 Mbps, basic rate
-		SupRate[5]  = 0x48;    // 36 mbps, in units of 0.5 Mbps
-		SupRate[6]  = 0x60;    // 48 mbps, in units of 0.5 Mbps
-		SupRate[7]  = 0x6c;    // 54 mbps, in units of 0.5 Mbps
-		SupRateLen  = 8;
-		ExtRateLen  = 0;
+	} else if (pAd->CommonCfg.Channel > 14) {
+		SupRate[0] = 0x8C;	// 6 mbps, in units of 0.5 Mbps, basic rate
+		SupRate[1] = 0x12;	// 9 mbps, in units of 0.5 Mbps
+		SupRate[2] = 0x98;	// 12 mbps, in units of 0.5 Mbps, basic rate
+		SupRate[3] = 0x24;	// 18 mbps, in units of 0.5 Mbps
+		SupRate[4] = 0xb0;	// 24 mbps, in units of 0.5 Mbps, basic rate
+		SupRate[5] = 0x48;	// 36 mbps, in units of 0.5 Mbps
+		SupRate[6] = 0x60;	// 48 mbps, in units of 0.5 Mbps
+		SupRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		SupRateLen = 8;
+		ExtRateLen = 0;
 
 		//
 		// Also Update MlmeRate & RtsRate for G only & A only
@@ -2411,27 +2501,28 @@ ULONG MakeIbssBeacon(
 		pAd->CommonCfg.MlmeRate = RATE_6;
 		pAd->CommonCfg.RtsRate = RATE_6;
 		pAd->CommonCfg.MlmeTransmit.field.MODE = MODE_OFDM;
-		pAd->CommonCfg.MlmeTransmit.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE = MODE_OFDM;
-		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS = OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
-	}
-	else
-	{
-		SupRate[0] = 0x82; // 1 mbps
-		SupRate[1] = 0x84; // 2 mbps
-		SupRate[2] = 0x8b; // 5.5 mbps
-		SupRate[3] = 0x96; // 11 mbps
+		pAd->CommonCfg.MlmeTransmit.field.MCS =
+		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MODE =
+		    MODE_OFDM;
+		pAd->MacTab.Content[BSS0Mcast_WCID].HTPhyMode.field.MCS =
+		    OfdmRateToRxwiMCS[pAd->CommonCfg.MlmeRate];
+	} else {
+		SupRate[0] = 0x82;	// 1 mbps
+		SupRate[1] = 0x84;	// 2 mbps
+		SupRate[2] = 0x8b;	// 5.5 mbps
+		SupRate[3] = 0x96;	// 11 mbps
 		SupRateLen = 4;
 
-		ExtRate[0]  = 0x0C;    // 6 mbps, in units of 0.5 Mbps,
-		ExtRate[1]  = 0x12;    // 9 mbps, in units of 0.5 Mbps
-		ExtRate[2]  = 0x18;    // 12 mbps, in units of 0.5 Mbps,
-		ExtRate[3]  = 0x24;    // 18 mbps, in units of 0.5 Mbps
-		ExtRate[4]  = 0x30;    // 24 mbps, in units of 0.5 Mbps,
-		ExtRate[5]  = 0x48;    // 36 mbps, in units of 0.5 Mbps
-		ExtRate[6]  = 0x60;    // 48 mbps, in units of 0.5 Mbps
-		ExtRate[7]  = 0x6c;    // 54 mbps, in units of 0.5 Mbps
-		ExtRateLen  = 8;
+		ExtRate[0] = 0x0C;	// 6 mbps, in units of 0.5 Mbps,
+		ExtRate[1] = 0x12;	// 9 mbps, in units of 0.5 Mbps
+		ExtRate[2] = 0x18;	// 12 mbps, in units of 0.5 Mbps,
+		ExtRate[3] = 0x24;	// 18 mbps, in units of 0.5 Mbps
+		ExtRate[4] = 0x30;	// 24 mbps, in units of 0.5 Mbps,
+		ExtRate[5] = 0x48;	// 36 mbps, in units of 0.5 Mbps
+		ExtRate[6] = 0x60;	// 48 mbps, in units of 0.5 Mbps
+		ExtRate[7] = 0x6c;	// 54 mbps, in units of 0.5 Mbps
+		ExtRateLen = 8;
 	}
 
 	pAd->StaActive.SupRateLen = SupRateLen;
@@ -2440,61 +2531,59 @@ ULONG MakeIbssBeacon(
 	NdisMoveMemory(pAd->StaActive.ExtRate, ExtRate, ExtRateLen);
 
 	// compose IBSS beacon frame
-	MgtMacHeaderInit(pAd, &BcnHdr, SUBTYPE_BEACON, 0, BROADCAST_ADDR, pAd->CommonCfg.Bssid);
-	Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
-			  (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
-			  (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
-	CapabilityInfo = CAP_GENERATE(0, 1, Privacy, (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort), 0, 0);
-
-	MakeOutgoingFrame(pBeaconFrame,                &FrameLen,
-					  sizeof(HEADER_802_11),           &BcnHdr,
-					  TIMESTAMP_LEN,                   &FakeTimestamp,
-					  2,                               &pAd->CommonCfg.BeaconPeriod,
-					  2,                               &CapabilityInfo,
-					  1,                               &SsidIe,
-					  1,                               &pAd->CommonCfg.SsidLen,
-					  pAd->CommonCfg.SsidLen,          pAd->CommonCfg.Ssid,
-					  1,                               &SupRateIe,
-					  1,                               &SupRateLen,
-					  SupRateLen,                      SupRate,
-					  1,                               &DsIe,
-					  1,                               &DsLen,
-					  1,                               &pAd->CommonCfg.Channel,
-					  1,                               &IbssIe,
-					  1,                               &IbssLen,
-					  2,                               &pAd->StaActive.AtimWin,
-					  END_OF_ARGS);
+	MgtMacHeaderInit(pAd, &BcnHdr, SUBTYPE_BEACON, 0, BROADCAST_ADDR,
+			 pAd->CommonCfg.Bssid);
+	Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled)
+	    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
+	    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
+	CapabilityInfo =
+	    CAP_GENERATE(0, 1, Privacy,
+			 (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort),
+			 0, 0);
+
+	MakeOutgoingFrame(pBeaconFrame, &FrameLen,
+			  sizeof(HEADER_802_11), &BcnHdr,
+			  TIMESTAMP_LEN, &FakeTimestamp,
+			  2, &pAd->CommonCfg.BeaconPeriod,
+			  2, &CapabilityInfo,
+			  1, &SsidIe,
+			  1, &pAd->CommonCfg.SsidLen,
+			  pAd->CommonCfg.SsidLen, pAd->CommonCfg.Ssid,
+			  1, &SupRateIe,
+			  1, &SupRateLen,
+			  SupRateLen, SupRate,
+			  1, &DsIe,
+			  1, &DsLen,
+			  1, &pAd->CommonCfg.Channel,
+			  1, &IbssIe,
+			  1, &IbssLen, 2, &pAd->StaActive.AtimWin, END_OF_ARGS);
 
 	// add ERP_IE and EXT_RAE IE of in 802.11g
-	if (ExtRateLen)
-	{
-		ULONG	tmp;
-
-		MakeOutgoingFrame(pBeaconFrame + FrameLen,         &tmp,
-						  3,                               LocalErpIe,
-						  1,                               &ExtRateIe,
-						  1,                               &ExtRateLen,
-						  ExtRateLen,                      ExtRate,
-						  END_OF_ARGS);
+	if (ExtRateLen) {
+		ULONG tmp;
+
+		MakeOutgoingFrame(pBeaconFrame + FrameLen, &tmp,
+				  3, LocalErpIe,
+				  1, &ExtRateIe,
+				  1, &ExtRateLen,
+				  ExtRateLen, ExtRate, END_OF_ARGS);
 		FrameLen += tmp;
 	}
-
 	// If adhoc secruity is set for WPA-None, append the cipher suite IE
-	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
-	{
+	if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
 		ULONG tmp;
-        RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus, BSS0);
-
-		MakeOutgoingFrame(pBeaconFrame + FrameLen,        	&tmp,
-						  1,                              	&RSNIe,
-						  1,                            	&pAd->StaCfg.RSNIE_Len,
-						  pAd->StaCfg.RSNIE_Len,      		pAd->StaCfg.RSN_IE,
-						  END_OF_ARGS);
+		RTMPMakeRSNIE(pAd, pAd->StaCfg.AuthMode, pAd->StaCfg.WepStatus,
+			      BSS0);
+
+		MakeOutgoingFrame(pBeaconFrame + FrameLen, &tmp,
+				  1, &RSNIe,
+				  1, &pAd->StaCfg.RSNIE_Len,
+				  pAd->StaCfg.RSNIE_Len, pAd->StaCfg.RSN_IE,
+				  END_OF_ARGS);
 		FrameLen += tmp;
 	}
 
-	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED))
-	{
+	if ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)) {
 		ULONG TmpLen;
 		UCHAR HtLen, HtLen1;
 
@@ -2502,34 +2591,35 @@ ULONG MakeIbssBeacon(
 		HtLen = sizeof(pAd->CommonCfg.HtCapability);
 		HtLen1 = sizeof(pAd->CommonCfg.AddHTInfo);
 
-		MakeOutgoingFrame(pBeaconFrame+FrameLen,	&TmpLen,
-						  1,						&HtCapIe,
-						  1,						&HtLen,
-						  HtLen,					&pAd->CommonCfg.HtCapability,
-						  1,						&AddHtInfoIe,
-						  1,						&HtLen1,
-						  HtLen1,					&pAd->CommonCfg.AddHTInfo,
-						  END_OF_ARGS);
+		MakeOutgoingFrame(pBeaconFrame + FrameLen, &TmpLen,
+				  1, &HtCapIe,
+				  1, &HtLen,
+				  HtLen, &pAd->CommonCfg.HtCapability,
+				  1, &AddHtInfoIe,
+				  1, &HtLen1,
+				  HtLen1, &pAd->CommonCfg.AddHTInfo,
+				  END_OF_ARGS);
 
 		FrameLen += TmpLen;
 	}
-
 	//beacon use reserved WCID 0xff
-    if (pAd->CommonCfg.Channel > 14)
-    {
-	RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE,  TRUE, FALSE, FALSE, TRUE, 0, 0xff, FrameLen,
-		PID_MGMT, PID_BEACON, RATE_1, IFS_HTTXOP, FALSE, &pAd->CommonCfg.MlmeTransmit);
-    }
-    else
-    {
-        // Set to use 1Mbps for Adhoc beacon.
+	if (pAd->CommonCfg.Channel > 14) {
+		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, TRUE, FALSE, FALSE,
+			      TRUE, 0, 0xff, FrameLen, PID_MGMT, PID_BEACON,
+			      RATE_1, IFS_HTTXOP, FALSE,
+			      &pAd->CommonCfg.MlmeTransmit);
+	} else {
+		// Set to use 1Mbps for Adhoc beacon.
 		HTTRANSMIT_SETTING Transmit;
-        Transmit.word = 0;
-        RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE,  TRUE, FALSE, FALSE, TRUE, 0, 0xff, FrameLen,
-    		PID_MGMT, PID_BEACON, RATE_1, IFS_HTTXOP, FALSE, &Transmit);
-    }
+		Transmit.word = 0;
+		RTMPWriteTxWI(pAd, pTxWI, FALSE, FALSE, TRUE, FALSE, FALSE,
+			      TRUE, 0, 0xff, FrameLen, PID_MGMT, PID_BEACON,
+			      RATE_1, IFS_HTTXOP, FALSE, &Transmit);
+	}
 
-    DBGPRINT(RT_DEBUG_TRACE, ("MakeIbssBeacon (len=%ld), SupRateLen=%d, ExtRateLen=%d, Channel=%d, PhyMode=%d\n",
-					FrameLen, SupRateLen, ExtRateLen, pAd->CommonCfg.Channel, pAd->CommonCfg.PhyMode));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("MakeIbssBeacon (len=%ld), SupRateLen=%d, ExtRateLen=%d, Channel=%d, PhyMode=%d\n",
+		  FrameLen, SupRateLen, ExtRateLen, pAd->CommonCfg.Channel,
+		  pAd->CommonCfg.PhyMode));
 	return FrameLen;
 }
diff --git a/drivers/staging/rt2860/sta/rtmp_data.c b/drivers/staging/rt2860/sta/rtmp_data.c
index 0ab3dce..3a93ef6 100644
--- a/drivers/staging/rt2860/sta/rtmp_data.c
+++ b/drivers/staging/rt2860/sta/rtmp_data.c
@@ -36,107 +36,164 @@
 */
 #include "../rt_config.h"
 
-
-
-VOID STARxEAPOLFrameIndicate(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
+VOID STARxEAPOLFrameIndicate(IN PRTMP_ADAPTER pAd,
+			     IN MAC_TABLE_ENTRY * pEntry,
+			     IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
-	PRT28XX_RXD_STRUC	pRxD = &(pRxBlk->RxD);
-	PRXWI_STRUC		pRxWI = pRxBlk->pRxWI;
-	UCHAR			*pTmpBuf;
+	PRT28XX_RXD_STRUC pRxD = &(pRxBlk->RxD);
+	PRXWI_STRUC pRxWI = pRxBlk->pRxWI;
+	UCHAR *pTmpBuf;
 
-	if (pAd->StaCfg.WpaSupplicantUP)
-	{
+	if (pAd->StaCfg.WpaSupplicantUP) {
 		// All EAPoL frames have to pass to upper layer (ex. WPA_SUPPLICANT daemon)
 		// TBD : process fragmented EAPol frames
 		{
 			// In 802.1x mode, if the received frame is EAP-SUCCESS packet, turn on the PortSecured variable
-			if ( pAd->StaCfg.IEEE8021X == TRUE &&
-				 (EAP_CODE_SUCCESS == WpaCheckEapCode(pAd, pRxBlk->pData, pRxBlk->DataSize, LENGTH_802_1_H)))
-			{
-				PUCHAR	Key;
-				UCHAR 	CipherAlg;
-				int     idx = 0;
-
-				DBGPRINT_RAW(RT_DEBUG_TRACE, ("Receive EAP-SUCCESS Packet\n"));
+			if (pAd->StaCfg.IEEE8021X == TRUE &&
+			    (EAP_CODE_SUCCESS ==
+			     WpaCheckEapCode(pAd, pRxBlk->pData,
+					     pRxBlk->DataSize,
+					     LENGTH_802_1_H))) {
+				PUCHAR Key;
+				UCHAR CipherAlg;
+				int idx = 0;
+
+				DBGPRINT_RAW(RT_DEBUG_TRACE,
+					     ("Receive EAP-SUCCESS Packet\n"));
 				//pAd->StaCfg.PortSecured = WPA_802_1X_PORT_SECURED;
 				STA_PORT_SECURED(pAd);
 
-                if (pAd->StaCfg.IEEE8021x_required_keys == FALSE)
-                {
-                    idx = pAd->StaCfg.DesireSharedKeyId;
-                    CipherAlg = pAd->StaCfg.DesireSharedKey[idx].CipherAlg;
-					Key = pAd->StaCfg.DesireSharedKey[idx].Key;
-
-                    if (pAd->StaCfg.DesireSharedKey[idx].KeyLen > 0)
-    				{
+				if (pAd->StaCfg.IEEE8021x_required_keys ==
+				    FALSE) {
+					idx = pAd->StaCfg.DesireSharedKeyId;
+					CipherAlg =
+					    pAd->StaCfg.DesireSharedKey[idx].
+					    CipherAlg;
+					Key =
+					    pAd->StaCfg.DesireSharedKey[idx].
+					    Key;
+
+					if (pAd->StaCfg.DesireSharedKey[idx].
+					    KeyLen > 0) {
 #ifdef RTMP_MAC_PCI
-						MAC_TABLE_ENTRY *pEntry = &pAd->MacTab.Content[BSSID_WCID];
+						MAC_TABLE_ENTRY *pEntry =
+						    &pAd->MacTab.
+						    Content[BSSID_WCID];
 
 						// Set key material and cipherAlg to Asic
-						AsicAddSharedKeyEntry(pAd, BSS0, idx, CipherAlg, Key, NULL, NULL);
+						AsicAddSharedKeyEntry(pAd, BSS0,
+								      idx,
+								      CipherAlg,
+								      Key, NULL,
+								      NULL);
 
 						// Assign group key info
-						RTMPAddWcidAttributeEntry(pAd, BSS0, idx, CipherAlg, NULL);
+						RTMPAddWcidAttributeEntry(pAd,
+									  BSS0,
+									  idx,
+									  CipherAlg,
+									  NULL);
 
 						// Assign pairwise key info
-						RTMPAddWcidAttributeEntry(pAd, BSS0, idx, CipherAlg, pEntry);
-
-                        pAd->IndicateMediaState = NdisMediaStateConnected;
-                        pAd->ExtraInfo = GENERAL_LINK_UP;
+						RTMPAddWcidAttributeEntry(pAd,
+									  BSS0,
+									  idx,
+									  CipherAlg,
+									  pEntry);
+
+						pAd->IndicateMediaState =
+						    NdisMediaStateConnected;
+						pAd->ExtraInfo =
+						    GENERAL_LINK_UP;
 #endif // RTMP_MAC_PCI //
 #ifdef RTMP_MAC_USB
-						union
-						{
-							char buf[sizeof(NDIS_802_11_WEP)+MAX_LEN_OF_KEY- 1];
+						union {
+							char buf[sizeof
+								 (NDIS_802_11_WEP)
+								 +
+								 MAX_LEN_OF_KEY
+								 - 1];
 							NDIS_802_11_WEP keyinfo;
-						}  WepKey;
+						}
+						WepKey;
 						int len;
 
-
-						NdisZeroMemory(&WepKey, sizeof(WepKey));
-						len =pAd->StaCfg.DesireSharedKey[idx].KeyLen;
-
-						NdisMoveMemory(WepKey.keyinfo.KeyMaterial,
-							pAd->StaCfg.DesireSharedKey[idx].Key,
-							pAd->StaCfg.DesireSharedKey[idx].KeyLen);
-
-						WepKey.keyinfo.KeyIndex = 0x80000000 + idx;
+						NdisZeroMemory(&WepKey,
+							       sizeof(WepKey));
+						len =
+						    pAd->StaCfg.
+						    DesireSharedKey[idx].KeyLen;
+
+						NdisMoveMemory(WepKey.keyinfo.
+							       KeyMaterial,
+							       pAd->StaCfg.
+							       DesireSharedKey
+							       [idx].Key,
+							       pAd->StaCfg.
+							       DesireSharedKey
+							       [idx].KeyLen);
+
+						WepKey.keyinfo.KeyIndex =
+						    0x80000000 + idx;
 						WepKey.keyinfo.KeyLength = len;
-						pAd->SharedKey[BSS0][idx].KeyLen =(UCHAR) (len <= 5 ? 5 : 13);
-
-						pAd->IndicateMediaState = NdisMediaStateConnected;
-						pAd->ExtraInfo = GENERAL_LINK_UP;
+						pAd->SharedKey[BSS0][idx].
+						    KeyLen =
+						    (UCHAR) (len <= 5 ? 5 : 13);
+
+						pAd->IndicateMediaState =
+						    NdisMediaStateConnected;
+						pAd->ExtraInfo =
+						    GENERAL_LINK_UP;
 						// need to enqueue cmd to thread
-						RTUSBEnqueueCmdFromNdis(pAd, OID_802_11_ADD_WEP, TRUE, &WepKey, sizeof(WepKey.keyinfo) + len - 1);
+						RTUSBEnqueueCmdFromNdis(pAd,
+									OID_802_11_ADD_WEP,
+									TRUE,
+									&WepKey,
+									sizeof
+									(WepKey.
+									 keyinfo)
+									+ len -
+									1);
 #endif // RTMP_MAC_USB //
 						// For Preventing ShardKey Table is cleared by remove key procedure.
-    					pAd->SharedKey[BSS0][idx].CipherAlg = CipherAlg;
-						pAd->SharedKey[BSS0][idx].KeyLen = pAd->StaCfg.DesireSharedKey[idx].KeyLen;
-						NdisMoveMemory(pAd->SharedKey[BSS0][idx].Key,
-									   pAd->StaCfg.DesireSharedKey[idx].Key,
-									   pAd->StaCfg.DesireSharedKey[idx].KeyLen);
-    				}
+						pAd->SharedKey[BSS0][idx].
+						    CipherAlg = CipherAlg;
+						pAd->SharedKey[BSS0][idx].
+						    KeyLen =
+						    pAd->StaCfg.
+						    DesireSharedKey[idx].KeyLen;
+						NdisMoveMemory(pAd->
+							       SharedKey[BSS0]
+							       [idx].Key,
+							       pAd->StaCfg.
+							       DesireSharedKey
+							       [idx].Key,
+							       pAd->StaCfg.
+							       DesireSharedKey
+							       [idx].KeyLen);
+					}
 				}
 			}
 
 			Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
 			return;
 		}
-	}
-	else
-	{
+	} else {
 		// Special DATA frame that has to pass to MLME
-		//	 1. Cisco Aironet frames for CCX2. We need pass it to MLME for special process
-		//	 2. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
+		//       1. Cisco Aironet frames for CCX2. We need pass it to MLME for special process
+		//       2. EAPOL handshaking frames when driver supplicant enabled, pass to MLME for special process
 		{
 			pTmpBuf = pRxBlk->pData - LENGTH_802_11;
 			NdisMoveMemory(pTmpBuf, pRxBlk->pHeader, LENGTH_802_11);
-			REPORT_MGMT_FRAME_TO_MLME(pAd, pRxWI->WirelessCliID, pTmpBuf, pRxBlk->DataSize + LENGTH_802_11, pRxWI->RSSI0, pRxWI->RSSI1, pRxWI->RSSI2, pRxD->PlcpSignal);
-			DBGPRINT_RAW(RT_DEBUG_TRACE, ("!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n", pRxBlk->DataSize));
+			REPORT_MGMT_FRAME_TO_MLME(pAd, pRxWI->WirelessCliID,
+						  pTmpBuf,
+						  pRxBlk->DataSize +
+						  LENGTH_802_11, pRxWI->RSSI0,
+						  pRxWI->RSSI1, pRxWI->RSSI2,
+						  pRxD->PlcpSignal);
+			DBGPRINT_RAW(RT_DEBUG_TRACE,
+				     ("!!! report EAPOL/AIRONET DATA to MLME (len=%d) !!!\n",
+				      pRxBlk->DataSize));
 		}
 	}
 
@@ -145,126 +202,114 @@ VOID STARxEAPOLFrameIndicate(
 
 }
 
-VOID STARxDataFrameAnnounce(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry,
-	IN	RX_BLK			*pRxBlk,
-	IN	UCHAR			FromWhichBSSID)
+VOID STARxDataFrameAnnounce(IN PRTMP_ADAPTER pAd,
+			    IN MAC_TABLE_ENTRY * pEntry,
+			    IN RX_BLK * pRxBlk, IN UCHAR FromWhichBSSID)
 {
 
 	// non-EAP frame
-	if (!RTMPCheckWPAframe(pAd, pEntry, pRxBlk->pData, pRxBlk->DataSize, FromWhichBSSID))
-	{
+	if (!RTMPCheckWPAframe
+	    (pAd, pEntry, pRxBlk->pData, pRxBlk->DataSize, FromWhichBSSID)) {
 
 		{
 			// drop all non-EAP DATA frame before
 			// this client's Port-Access-Control is secured
-			if (pRxBlk->pHeader->FC.Wep)
-			{
+			if (pRxBlk->pHeader->FC.Wep) {
 				// unsupported cipher suite
-				if (pAd->StaCfg.WepStatus == Ndis802_11EncryptionDisabled)
-				{
+				if (pAd->StaCfg.WepStatus ==
+				    Ndis802_11EncryptionDisabled) {
 					// release packet
-					RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+					RELEASE_NDIS_PACKET(pAd,
+							    pRxBlk->pRxPacket,
+							    NDIS_STATUS_FAILURE);
 					return;
 				}
-			}
-			else
-			{
+			} else {
 				// encryption in-use but receive a non-EAPOL clear text frame, drop it
-				if ((pAd->StaCfg.WepStatus != Ndis802_11EncryptionDisabled) &&
-					(pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
-				{
+				if ((pAd->StaCfg.WepStatus !=
+				     Ndis802_11EncryptionDisabled)
+				    && (pAd->StaCfg.PortSecured ==
+					WPA_802_1X_PORT_NOT_SECURED)) {
 					// release packet
-					RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+					RELEASE_NDIS_PACKET(pAd,
+							    pRxBlk->pRxPacket,
+							    NDIS_STATUS_FAILURE);
 					return;
 				}
 			}
 		}
 		RX_BLK_CLEAR_FLAG(pRxBlk, fRX_EAP);
-		if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_ARALINK))
-		{
+		if (!RX_BLK_TEST_FLAG(pRxBlk, fRX_ARALINK)) {
 			// Normal legacy, AMPDU or AMSDU
-			CmmRxnonRalinkFrameIndicate(pAd, pRxBlk, FromWhichBSSID);
+			CmmRxnonRalinkFrameIndicate(pAd, pRxBlk,
+						    FromWhichBSSID);
 
-		}
-		else
-		{
+		} else {
 			// ARALINK
-			CmmRxRalinkFrameIndicate(pAd, pEntry, pRxBlk, FromWhichBSSID);
+			CmmRxRalinkFrameIndicate(pAd, pEntry, pRxBlk,
+						 FromWhichBSSID);
 		}
-	}
-	else
-	{
+	} else {
 		RX_BLK_SET_FLAG(pRxBlk, fRX_EAP);
 
-		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU) && (pAd->CommonCfg.bDisableReordering == 0))
-		{
+		if (RX_BLK_TEST_FLAG(pRxBlk, fRX_AMPDU)
+		    && (pAd->CommonCfg.bDisableReordering == 0)) {
 			Indicate_AMPDU_Packet(pAd, pRxBlk, FromWhichBSSID);
-		}
-		else
-		{
+		} else {
 			// Determin the destination of the EAP frame
 			//  to WPA state machine or upper layer
-			STARxEAPOLFrameIndicate(pAd, pEntry, pRxBlk, FromWhichBSSID);
+			STARxEAPOLFrameIndicate(pAd, pEntry, pRxBlk,
+						FromWhichBSSID);
 		}
 	}
 }
 
-
 // For TKIP frame, calculate the MIC value
-BOOLEAN STACheckTkipMICValue(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	MAC_TABLE_ENTRY	*pEntry,
-	IN	RX_BLK			*pRxBlk)
+BOOLEAN STACheckTkipMICValue(IN PRTMP_ADAPTER pAd,
+			     IN MAC_TABLE_ENTRY * pEntry, IN RX_BLK * pRxBlk)
 {
-	PHEADER_802_11	pHeader = pRxBlk->pHeader;
-	UCHAR			*pData = pRxBlk->pData;
-	USHORT			DataSize = pRxBlk->DataSize;
-	UCHAR			UserPriority = pRxBlk->UserPriority;
-	PCIPHER_KEY		pWpaKey;
-	UCHAR			*pDA, *pSA;
+	PHEADER_802_11 pHeader = pRxBlk->pHeader;
+	UCHAR *pData = pRxBlk->pData;
+	USHORT DataSize = pRxBlk->DataSize;
+	UCHAR UserPriority = pRxBlk->UserPriority;
+	PCIPHER_KEY pWpaKey;
+	UCHAR *pDA, *pSA;
 
 	pWpaKey = &pAd->SharedKey[BSS0][pRxBlk->pRxWI->KeyIndex];
 
 	pDA = pHeader->Addr1;
-	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_INFRA))
-	{
+	if (RX_BLK_TEST_FLAG(pRxBlk, fRX_INFRA)) {
 		pSA = pHeader->Addr3;
-	}
-	else
-	{
+	} else {
 		pSA = pHeader->Addr2;
 	}
 
 	if (RTMPTkipCompareMICValue(pAd,
-								pData,
-								pDA,
-								pSA,
-								pWpaKey->RxMic,
-								UserPriority,
-								DataSize) == FALSE)
-	{
-		DBGPRINT_RAW(RT_DEBUG_ERROR,("Rx MIC Value error 2\n"));
-
-		if (pAd->StaCfg.WpaSupplicantUP)
-		{
-			WpaSendMicFailureToWpaSupplicant(pAd, (pWpaKey->Type == PAIRWISEKEY) ? TRUE : FALSE);
-		}
-		else
-		{
+				    pData,
+				    pDA,
+				    pSA,
+				    pWpaKey->RxMic,
+				    UserPriority, DataSize) == FALSE) {
+		DBGPRINT_RAW(RT_DEBUG_ERROR, ("Rx MIC Value error 2\n"));
+
+		if (pAd->StaCfg.WpaSupplicantUP) {
+			WpaSendMicFailureToWpaSupplicant(pAd,
+							 (pWpaKey->Type ==
+							  PAIRWISEKEY) ? TRUE :
+							 FALSE);
+		} else {
 			RTMPReportMicError(pAd, pWpaKey);
 		}
 
 		// release packet
-		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket, NDIS_STATUS_FAILURE);
+		RELEASE_NDIS_PACKET(pAd, pRxBlk->pRxPacket,
+				    NDIS_STATUS_FAILURE);
 		return FALSE;
 	}
 
 	return TRUE;
 }
 
-
 //
 // All Rx routines use RX_BLK structure to hande rx events
 // It is very important to build pRxBlk attributes
@@ -273,106 +318,112 @@ BOOLEAN STACheckTkipMICValue(
 //  3. set payload size including LLC to DataSize
 //  4. set some flags with RX_BLK_SET_FLAG()
 //
-VOID STAHandleRxDataFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk)
+VOID STAHandleRxDataFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 {
-	PRT28XX_RXD_STRUC				pRxD = &(pRxBlk->RxD);
-	PRXWI_STRUC						pRxWI = pRxBlk->pRxWI;
-	PHEADER_802_11					pHeader = pRxBlk->pHeader;
-	PNDIS_PACKET					pRxPacket = pRxBlk->pRxPacket;
-	BOOLEAN 						bFragment = FALSE;
-	MAC_TABLE_ENTRY	    			*pEntry = NULL;
-	UCHAR							FromWhichBSSID = BSS0;
-	UCHAR                           UserPriority = 0;
+	PRT28XX_RXD_STRUC pRxD = &(pRxBlk->RxD);
+	PRXWI_STRUC pRxWI = pRxBlk->pRxWI;
+	PHEADER_802_11 pHeader = pRxBlk->pHeader;
+	PNDIS_PACKET pRxPacket = pRxBlk->pRxPacket;
+	BOOLEAN bFragment = FALSE;
+	MAC_TABLE_ENTRY *pEntry = NULL;
+	UCHAR FromWhichBSSID = BSS0;
+	UCHAR UserPriority = 0;
 
 	{
 		// before LINK UP, all DATA frames are rejected
-		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-		{
+		if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
 			// release packet
-			RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+			RELEASE_NDIS_PACKET(pAd, pRxPacket,
+					    NDIS_STATUS_FAILURE);
 			return;
 		}
-
 		// Drop not my BSS frames
-		if (pRxD->MyBss == 0)
-		{
+		if (pRxD->MyBss == 0) {
 			{
 				// release packet
-				RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+				RELEASE_NDIS_PACKET(pAd, pRxPacket,
+						    NDIS_STATUS_FAILURE);
 				return;
 			}
 		}
 
 		pAd->RalinkCounters.RxCountSinceLastNULL++;
-		if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable && (pHeader->FC.SubType & 0x08))
-		{
+		if (pAd->CommonCfg.bAPSDCapable
+		    && pAd->CommonCfg.APEdcaParm.bAPSDCapable
+		    && (pHeader->FC.SubType & 0x08)) {
 			UCHAR *pData;
-			DBGPRINT(RT_DEBUG_INFO,("bAPSDCapable\n"));
+			DBGPRINT(RT_DEBUG_INFO, ("bAPSDCapable\n"));
 
 			// Qos bit 4
-			pData = (PUCHAR)pHeader + LENGTH_802_11;
-			if ((*pData >> 4) & 0x01)
-			{
-				DBGPRINT(RT_DEBUG_INFO,("RxDone- Rcv EOSP frame, driver may fall into sleep\n"));
+			pData = (PUCHAR) pHeader + LENGTH_802_11;
+			if ((*pData >> 4) & 0x01) {
+				DBGPRINT(RT_DEBUG_INFO,
+					 ("RxDone- Rcv EOSP frame, driver may fall into sleep\n"));
 				pAd->CommonCfg.bInServicePeriod = FALSE;
 
 				// Force driver to fall into sleep mode when rcv EOSP frame
-				if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-				{
-					USHORT  TbttNumToNextWakeUp;
-					USHORT  NextDtim = pAd->StaCfg.DtimPeriod;
-					ULONG   Now;
+				if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
+					USHORT TbttNumToNextWakeUp;
+					USHORT NextDtim =
+					    pAd->StaCfg.DtimPeriod;
+					ULONG Now;
 
 					NdisGetSystemUpTime(&Now);
-					NextDtim -= (USHORT)(Now - pAd->StaCfg.LastBeaconRxTime)/pAd->CommonCfg.BeaconPeriod;
-
-					TbttNumToNextWakeUp = pAd->StaCfg.DefaultListenCount;
-					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM) && (TbttNumToNextWakeUp > NextDtim))
+					NextDtim -=
+					    (USHORT) (Now -
+						      pAd->StaCfg.
+						      LastBeaconRxTime) /
+					    pAd->CommonCfg.BeaconPeriod;
+
+					TbttNumToNextWakeUp =
+					    pAd->StaCfg.DefaultListenCount;
+					if (OPSTATUS_TEST_FLAG
+					    (pAd, fOP_STATUS_RECEIVE_DTIM)
+					    && (TbttNumToNextWakeUp > NextDtim))
 						TbttNumToNextWakeUp = NextDtim;
 
 					RTMP_SET_PSM_BIT(pAd, PWR_SAVE);
 					// if WMM-APSD is failed, try to disable following line
-					AsicSleepThenAutoWakeup(pAd, TbttNumToNextWakeUp);
+					AsicSleepThenAutoWakeup(pAd,
+								TbttNumToNextWakeUp);
 				}
 			}
 
-			if ((pHeader->FC.MoreData) && (pAd->CommonCfg.bInServicePeriod))
-			{
-				DBGPRINT(RT_DEBUG_TRACE,("Sending another trigger frame when More Data bit is set to 1\n"));
+			if ((pHeader->FC.MoreData)
+			    && (pAd->CommonCfg.bInServicePeriod)) {
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("Sending another trigger frame when More Data bit is set to 1\n"));
 			}
 		}
-
 		// Drop NULL, CF-ACK(no data), CF-POLL(no data), and CF-ACK+CF-POLL(no data) data frame
-		if ((pHeader->FC.SubType & 0x04)) // bit 2 : no DATA
+		if ((pHeader->FC.SubType & 0x04))	// bit 2 : no DATA
 		{
 			// release packet
-			RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+			RELEASE_NDIS_PACKET(pAd, pRxPacket,
+					    NDIS_STATUS_FAILURE);
 			return;
 		}
+		// Drop not my BSS frame (we can not only check the MyBss bit in RxD)
 
-	    // Drop not my BSS frame (we can not only check the MyBss bit in RxD)
-
-		if (INFRA_ON(pAd))
-		{
+		if (INFRA_ON(pAd)) {
 			// Infrastructure mode, check address 2 for BSSID
-			if (!RTMPEqualMemory(&pHeader->Addr2, &pAd->CommonCfg.Bssid, 6))
-			{
+			if (!RTMPEqualMemory
+			    (&pHeader->Addr2, &pAd->CommonCfg.Bssid, 6)) {
 				// Receive frame not my BSSID
-	            // release packet
-	            RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+				// release packet
+				RELEASE_NDIS_PACKET(pAd, pRxPacket,
+						    NDIS_STATUS_FAILURE);
 				return;
 			}
-		}
-		else	// Ad-Hoc mode or Not associated
+		} else		// Ad-Hoc mode or Not associated
 		{
 			// Ad-Hoc mode, check address 3 for BSSID
-			if (!RTMPEqualMemory(&pHeader->Addr3, &pAd->CommonCfg.Bssid, 6))
-			{
+			if (!RTMPEqualMemory
+			    (&pHeader->Addr3, &pAd->CommonCfg.Bssid, 6)) {
 				// Receive frame not my BSSID
-	            // release packet
-	            RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+				// release packet
+				RELEASE_NDIS_PACKET(pAd, pRxPacket,
+						    NDIS_STATUS_FAILURE);
 				return;
 			}
 		}
@@ -380,39 +431,35 @@ VOID STAHandleRxDataFrame(
 		//
 		// find pEntry
 		//
-		if (pRxWI->WirelessCliID < MAX_LEN_OF_MAC_TABLE)
-		{
+		if (pRxWI->WirelessCliID < MAX_LEN_OF_MAC_TABLE) {
 			pEntry = &pAd->MacTab.Content[pRxWI->WirelessCliID];
-		}
-		else
-		{
+		} else {
 			// 1. release packet if infra mode
 			// 2. new a pEntry if ad-hoc mode
-			RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+			RELEASE_NDIS_PACKET(pAd, pRxPacket,
+					    NDIS_STATUS_FAILURE);
 			return;
 		}
 
 		// infra or ad-hoc
-		if (INFRA_ON(pAd))
-		{
+		if (INFRA_ON(pAd)) {
 			RX_BLK_SET_FLAG(pRxBlk, fRX_INFRA);
 			ASSERT(pRxWI->WirelessCliID == BSSID_WCID);
 		}
-
 		// check Atheros Client
-		if ((pEntry->bIAmBadAtheros == FALSE) &&  (pRxD->AMPDU == 1) && (pHeader->FC.Retry ))
-		{
+		if ((pEntry->bIAmBadAtheros == FALSE) && (pRxD->AMPDU == 1)
+		    && (pHeader->FC.Retry)) {
 			pEntry->bIAmBadAtheros = TRUE;
 			pAd->CommonCfg.IOTestParm.bCurrentAtheros = TRUE;
 			pAd->CommonCfg.IOTestParm.bLastAtheros = TRUE;
-			if (!STA_AES_ON(pAd))
-			{
-				AsicUpdateProtect(pAd, 8, ALLN_SETPROTECT, TRUE, FALSE);
+			if (!STA_AES_ON(pAd)) {
+				AsicUpdateProtect(pAd, 8, ALLN_SETPROTECT, TRUE,
+						  FALSE);
 			}
 		}
 	}
 
-	pRxBlk->pData = (UCHAR *)pHeader;
+	pRxBlk->pData = (UCHAR *) pHeader;
 
 	//
 	// update RxBlk->pData, DataSize
@@ -426,48 +473,41 @@ VOID STAHandleRxDataFrame(
 	}
 
 	// 2. QOS
-	if (pHeader->FC.SubType & 0x08)
-	{
+	if (pHeader->FC.SubType & 0x08) {
 		RX_BLK_SET_FLAG(pRxBlk, fRX_QOS);
 		UserPriority = *(pRxBlk->pData) & 0x0f;
 		// bit 7 in QoS Control field signals the HT A-MSDU format
-		if ((*pRxBlk->pData) & 0x80)
-		{
+		if ((*pRxBlk->pData) & 0x80) {
 			RX_BLK_SET_FLAG(pRxBlk, fRX_AMSDU);
 		}
-
 		// skip QOS contorl field
 		pRxBlk->pData += 2;
-		pRxBlk->DataSize -=2;
+		pRxBlk->DataSize -= 2;
 	}
 	pRxBlk->UserPriority = UserPriority;
 
 	/* check if need to resend PS Poll when received packet with MoreData = 1 */
-	if ((pAd->StaCfg.Psm == PWR_SAVE) && (pHeader->FC.MoreData == 1))
-	{
+	if ((pAd->StaCfg.Psm == PWR_SAVE) && (pHeader->FC.MoreData == 1)) {
 		if ((((UserPriority == 0) || (UserPriority == 3)) &&
-			pAd->CommonCfg.bAPSDAC_BE == 0) ||
-			(((UserPriority == 1) || (UserPriority == 2)) &&
-			pAd->CommonCfg.bAPSDAC_BK == 0) ||
-			(((UserPriority == 4) || (UserPriority == 5)) &&
-			pAd->CommonCfg.bAPSDAC_VI == 0) ||
-			(((UserPriority == 6) || (UserPriority == 7)) &&
-			pAd->CommonCfg.bAPSDAC_VO == 0))
-		{
+		     pAd->CommonCfg.bAPSDAC_BE == 0) ||
+		    (((UserPriority == 1) || (UserPriority == 2)) &&
+		     pAd->CommonCfg.bAPSDAC_BK == 0) ||
+		    (((UserPriority == 4) || (UserPriority == 5)) &&
+		     pAd->CommonCfg.bAPSDAC_VI == 0) ||
+		    (((UserPriority == 6) || (UserPriority == 7)) &&
+		     pAd->CommonCfg.bAPSDAC_VO == 0)) {
 			/* non-UAPSD delivery-enabled AC */
 			RTMP_PS_POLL_ENQUEUE(pAd);
 		}
 	}
-
 	// 3. Order bit: A-Ralink or HTC+
-	if (pHeader->FC.Order)
-	{
+	if (pHeader->FC.Order) {
 #ifdef AGGREGATION_SUPPORT
-		if ((pRxWI->PHYMODE <= MODE_OFDM) && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)))
+		if ((pRxWI->PHYMODE <= MODE_OFDM)
+		    && (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_AGGREGATION_INUSED)))
 		{
 			RX_BLK_SET_FLAG(pRxBlk, fRX_ARALINK);
-		}
-		else
+		} else
 #endif // AGGREGATION_SUPPORT //
 		{
 			RX_BLK_SET_FLAG(pRxBlk, fRX_HTC);
@@ -476,102 +516,93 @@ VOID STAHandleRxDataFrame(
 			pRxBlk->DataSize -= 4;
 		}
 	}
-
 	// 4. skip HW padding
-	if (pRxD->L2PAD)
-	{
+	if (pRxD->L2PAD) {
 		// just move pData pointer
 		// because DataSize excluding HW padding
 		RX_BLK_SET_FLAG(pRxBlk, fRX_PAD);
 		pRxBlk->pData += 2;
 	}
 
-	if (pRxD->BA)
-	{
+	if (pRxD->BA) {
 		RX_BLK_SET_FLAG(pRxBlk, fRX_AMPDU);
 	}
-
 	//
 	// Case I  Process Broadcast & Multicast data frame
 	//
-	if (pRxD->Bcast || pRxD->Mcast)
-	{
+	if (pRxD->Bcast || pRxD->Mcast) {
 		INC_COUNTER64(pAd->WlanCounters.MulticastReceivedFrameCount);
 
 		// Drop Mcast/Bcast frame with fragment bit on
-		if (pHeader->FC.MoreFrag)
-		{
+		if (pHeader->FC.MoreFrag) {
 			// release packet
-			RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+			RELEASE_NDIS_PACKET(pAd, pRxPacket,
+					    NDIS_STATUS_FAILURE);
 			return;
 		}
-
 		// Filter out Bcast frame which AP relayed for us
-		if (pHeader->FC.FrDs && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress))
-		{
+		if (pHeader->FC.FrDs
+		    && MAC_ADDR_EQUAL(pHeader->Addr3, pAd->CurrentAddress)) {
 			// release packet
-			RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+			RELEASE_NDIS_PACKET(pAd, pRxPacket,
+					    NDIS_STATUS_FAILURE);
 			return;
 		}
 
 		Indicate_Legacy_Packet(pAd, pRxBlk, FromWhichBSSID);
 		return;
-	}
-	else if (pRxD->U2M)
-	{
-		pAd->LastRxRate = (USHORT)((pRxWI->MCS) + (pRxWI->BW <<7) + (pRxWI->ShortGI <<8)+ (pRxWI->PHYMODE <<14)) ;
+	} else if (pRxD->U2M) {
+		pAd->LastRxRate =
+		    (USHORT) ((pRxWI->MCS) + (pRxWI->BW << 7) +
+			      (pRxWI->ShortGI << 8) + (pRxWI->PHYMODE << 14));
 
-		if (ADHOC_ON(pAd))
-		{
+		if (ADHOC_ON(pAd)) {
 			pEntry = MacTableLookup(pAd, pHeader->Addr2);
 			if (pEntry)
-				Update_Rssi_Sample(pAd, &pEntry->RssiSample, pRxWI);
+				Update_Rssi_Sample(pAd, &pEntry->RssiSample,
+						   pRxWI);
 		}
 
-
 		Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, pRxWI);
 
-		pAd->StaCfg.LastSNR0 = (UCHAR)(pRxWI->SNR0);
-		pAd->StaCfg.LastSNR1 = (UCHAR)(pRxWI->SNR1);
+		pAd->StaCfg.LastSNR0 = (UCHAR) (pRxWI->SNR0);
+		pAd->StaCfg.LastSNR1 = (UCHAR) (pRxWI->SNR1);
 
 		pAd->RalinkCounters.OneSecRxOkDataCnt++;
 
+		if (!((pHeader->Frag == 0) && (pHeader->FC.MoreFrag == 0))) {
+			// re-assemble the fragmented packets
+			// return complete frame (pRxPacket) or NULL
+			bFragment = TRUE;
+			pRxPacket = RTMPDeFragmentDataFrame(pAd, pRxBlk);
+		}
 
-    	if (!((pHeader->Frag == 0) && (pHeader->FC.MoreFrag == 0)))
-    	{
-    		// re-assemble the fragmented packets
-    		// return complete frame (pRxPacket) or NULL
-    		bFragment = TRUE;
-    		pRxPacket = RTMPDeFragmentDataFrame(pAd, pRxBlk);
-    	}
-
-    	if (pRxPacket)
-    	{
+		if (pRxPacket) {
 			pEntry = &pAd->MacTab.Content[pRxWI->WirelessCliID];
 
-    		// process complete frame
-    		if (bFragment && (pRxD->Decrypted) && (pEntry->WepStatus == Ndis802_11Encryption2Enabled))
-    		{
+			// process complete frame
+			if (bFragment && (pRxD->Decrypted)
+			    && (pEntry->WepStatus ==
+				Ndis802_11Encryption2Enabled)) {
 				// Minus MIC length
 				pRxBlk->DataSize -= 8;
 
-    			// For TKIP frame, calculate the MIC value
-    			if (STACheckTkipMICValue(pAd, pEntry, pRxBlk) == FALSE)
-    			{
-    				return;
-    			}
-    		}
+				// For TKIP frame, calculate the MIC value
+				if (STACheckTkipMICValue(pAd, pEntry, pRxBlk) ==
+				    FALSE) {
+					return;
+				}
+			}
 
-    		STARxDataFrameAnnounce(pAd, pEntry, pRxBlk, FromWhichBSSID);
+			STARxDataFrameAnnounce(pAd, pEntry, pRxBlk,
+					       FromWhichBSSID);
+			return;
+		} else {
+			// just return
+			// because RTMPDeFragmentDataFrame() will release rx packet,
+			// if packet is fragmented
 			return;
-    	}
-    	else
-    	{
-    		// just return
-    		// because RTMPDeFragmentDataFrame() will release rx packet,
-    		// if packet is fragmented
-    		return;
-    	}
+		}
 	}
 
 	ASSERT(0);
@@ -579,25 +610,20 @@ VOID STAHandleRxDataFrame(
 	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
 }
 
-VOID STAHandleRxMgmtFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk)
+VOID STAHandleRxMgmtFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 {
-	PRT28XX_RXD_STRUC	pRxD = &(pRxBlk->RxD);
-	PRXWI_STRUC		pRxWI = pRxBlk->pRxWI;
-	PHEADER_802_11	pHeader = pRxBlk->pHeader;
-	PNDIS_PACKET	pRxPacket = pRxBlk->pRxPacket;
-
-	do
-	{
+	PRT28XX_RXD_STRUC pRxD = &(pRxBlk->RxD);
+	PRXWI_STRUC pRxWI = pRxBlk->pRxWI;
+	PHEADER_802_11 pHeader = pRxBlk->pHeader;
+	PNDIS_PACKET pRxPacket = pRxBlk->pRxPacket;
 
+	do {
 
 		/* check if need to resend PS Poll when received packet with MoreData = 1 */
-		if ((pAd->StaCfg.Psm == PWR_SAVE) && (pHeader->FC.MoreData == 1))
-		{
+		if ((pAd->StaCfg.Psm == PWR_SAVE)
+		    && (pHeader->FC.MoreData == 1)) {
 			/* for UAPSD, all management frames will be VO priority */
-			if (pAd->CommonCfg.bAPSDAC_VO == 0)
-			{
+			if (pAd->CommonCfg.bAPSDAC_VO == 0) {
 				/* non-UAPSD delivery-enabled AC */
 				RTMP_PS_POLL_ENQUEUE(pAd);
 			}
@@ -605,57 +631,54 @@ VOID STAHandleRxMgmtFrame(
 
 		/* TODO: if MoreData == 0, station can go to sleep */
 
-
 		// We should collect RSSI not only U2M data but also my beacon
-		if ((pHeader->FC.SubType == SUBTYPE_BEACON) && (MAC_ADDR_EQUAL(&pAd->CommonCfg.Bssid, &pHeader->Addr2))
-			&& (pAd->RxAnt.EvaluatePeriod == 0))
-		{
+		if ((pHeader->FC.SubType == SUBTYPE_BEACON)
+		    && (MAC_ADDR_EQUAL(&pAd->CommonCfg.Bssid, &pHeader->Addr2))
+		    && (pAd->RxAnt.EvaluatePeriod == 0)) {
 			Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, pRxWI);
 
-			pAd->StaCfg.LastSNR0 = (UCHAR)(pRxWI->SNR0);
-			pAd->StaCfg.LastSNR1 = (UCHAR)(pRxWI->SNR1);
+			pAd->StaCfg.LastSNR0 = (UCHAR) (pRxWI->SNR0);
+			pAd->StaCfg.LastSNR1 = (UCHAR) (pRxWI->SNR1);
 		}
 
-
 		// First check the size, it MUST not exceed the mlme queue size
-		if (pRxWI->MPDUtotalByteCount > MGMT_DMA_BUFFER_SIZE)
-		{
+		if (pRxWI->MPDUtotalByteCount > MGMT_DMA_BUFFER_SIZE) {
 			DBGPRINT_ERR(("STAHandleRxMgmtFrame: frame too large, size = %d \n", pRxWI->MPDUtotalByteCount));
 			break;
 		}
 
-		REPORT_MGMT_FRAME_TO_MLME(pAd, pRxWI->WirelessCliID, pHeader, pRxWI->MPDUtotalByteCount,
-									pRxWI->RSSI0, pRxWI->RSSI1, pRxWI->RSSI2, pRxD->PlcpSignal);
+		REPORT_MGMT_FRAME_TO_MLME(pAd, pRxWI->WirelessCliID, pHeader,
+					  pRxWI->MPDUtotalByteCount,
+					  pRxWI->RSSI0, pRxWI->RSSI1,
+					  pRxWI->RSSI2, pRxD->PlcpSignal);
 	} while (FALSE);
 
 	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_SUCCESS);
 }
 
-VOID STAHandleRxControlFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	RX_BLK			*pRxBlk)
+VOID STAHandleRxControlFrame(IN PRTMP_ADAPTER pAd, IN RX_BLK * pRxBlk)
 {
-	PRXWI_STRUC		pRxWI = pRxBlk->pRxWI;
-	PHEADER_802_11	pHeader = pRxBlk->pHeader;
-	PNDIS_PACKET	pRxPacket = pRxBlk->pRxPacket;
-
-	switch (pHeader->FC.SubType)
-	{
-		case SUBTYPE_BLOCK_ACK_REQ:
-			{
-				CntlEnqueueForRecv(pAd, pRxWI->WirelessCliID, (pRxWI->MPDUtotalByteCount), (PFRAME_BA_REQ)pHeader);
-			}
-			break;
-		case SUBTYPE_BLOCK_ACK:
-		case SUBTYPE_ACK:
-		default:
-			break;
+	PRXWI_STRUC pRxWI = pRxBlk->pRxWI;
+	PHEADER_802_11 pHeader = pRxBlk->pHeader;
+	PNDIS_PACKET pRxPacket = pRxBlk->pRxPacket;
+
+	switch (pHeader->FC.SubType) {
+	case SUBTYPE_BLOCK_ACK_REQ:
+		{
+			CntlEnqueueForRecv(pAd, pRxWI->WirelessCliID,
+					   (pRxWI->MPDUtotalByteCount),
+					   (PFRAME_BA_REQ) pHeader);
+		}
+		break;
+	case SUBTYPE_BLOCK_ACK:
+	case SUBTYPE_ACK:
+	default:
+		break;
 	}
 
 	RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
 }
 
-
 /*
 	========================================================================
 
@@ -675,45 +698,39 @@ VOID STAHandleRxControlFrame(
 		Need to consider QOS DATA format when converting to 802.3
 	========================================================================
 */
-BOOLEAN STARxDoneInterruptHandle(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	BOOLEAN			argc)
+BOOLEAN STARxDoneInterruptHandle(IN PRTMP_ADAPTER pAd, IN BOOLEAN argc)
 {
-	NDIS_STATUS			Status;
-	UINT32			RxProcessed, RxPending;
-	BOOLEAN			bReschedule = FALSE;
-	RT28XX_RXD_STRUC	*pRxD;
-	UCHAR			*pData;
-	PRXWI_STRUC		pRxWI;
-	PNDIS_PACKET	pRxPacket;
-	PHEADER_802_11	pHeader;
-	RX_BLK			RxCell;
+	NDIS_STATUS Status;
+	UINT32 RxProcessed, RxPending;
+	BOOLEAN bReschedule = FALSE;
+	RT28XX_RXD_STRUC *pRxD;
+	UCHAR *pData;
+	PRXWI_STRUC pRxWI;
+	PNDIS_PACKET pRxPacket;
+	PHEADER_802_11 pHeader;
+	RX_BLK RxCell;
 
 	RxProcessed = RxPending = 0;
 
 	// process whole rx ring
-	while (1)
-	{
+	while (1) {
 
 		if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF |
-								fRTMP_ADAPTER_RESET_IN_PROGRESS |
-								fRTMP_ADAPTER_HALT_IN_PROGRESS |
-								fRTMP_ADAPTER_NIC_NOT_EXIST) ||
-			!RTMP_TEST_FLAG(pAd,fRTMP_ADAPTER_START_UP))
-		{
+				   fRTMP_ADAPTER_RESET_IN_PROGRESS |
+				   fRTMP_ADAPTER_HALT_IN_PROGRESS |
+				   fRTMP_ADAPTER_NIC_NOT_EXIST) ||
+		    !RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)) {
 			break;
 		}
-
 #ifdef RTMP_MAC_PCI
-		if (RxProcessed++ > MAX_RX_PROCESS_CNT)
-		{
+		if (RxProcessed++ > MAX_RX_PROCESS_CNT) {
 			// need to reschedule rx handle
 			bReschedule = TRUE;
 			break;
 		}
 #endif // RTMP_MAC_PCI //
 
-		RxProcessed ++; // test
+		RxProcessed++;	// test
 
 		// 1. allocate a new data packet into rx ring to replace received packet
 		//    then processing the received packet
@@ -722,19 +739,19 @@ BOOLEAN STARxDoneInterruptHandle(
 		//    the rx packet must
 		//      a. be indicated to upper layer or
 		//      b. be released if it is discarded
-		pRxPacket = GetPacketFromRxRing(pAd, &(RxCell.RxD), &bReschedule, &RxPending);
-		if (pRxPacket == NULL)
-		{
+		pRxPacket =
+		    GetPacketFromRxRing(pAd, &(RxCell.RxD), &bReschedule,
+					&RxPending);
+		if (pRxPacket == NULL) {
 			// no more packet to process
 			break;
 		}
-
 		// get rx ring descriptor
 		pRxD = &(RxCell.RxD);
 		// get rx data buffer
-		pData	= GET_OS_PKT_DATAPTR(pRxPacket);
-		pRxWI	= (PRXWI_STRUC) pData;
-		pHeader = (PHEADER_802_11) (pData+RXWI_SIZE) ;
+		pData = GET_OS_PKT_DATAPTR(pRxPacket);
+		pRxWI = (PRXWI_STRUC) pData;
+		pHeader = (PHEADER_802_11) (pData + RXWI_SIZE);
 
 		// build RxCell
 		RxCell.pRxWI = pRxWI;
@@ -745,18 +762,19 @@ BOOLEAN STARxDoneInterruptHandle(
 		RxCell.Flags = 0;
 
 		// Increase Total receive byte counter after real data received no mater any error or not
-		pAd->RalinkCounters.ReceivedByteCount +=  pRxWI->MPDUtotalByteCount;
-		pAd->RalinkCounters.OneSecReceivedByteCount +=  pRxWI->MPDUtotalByteCount;
-		pAd->RalinkCounters.RxCount ++;
+		pAd->RalinkCounters.ReceivedByteCount +=
+		    pRxWI->MPDUtotalByteCount;
+		pAd->RalinkCounters.OneSecReceivedByteCount +=
+		    pRxWI->MPDUtotalByteCount;
+		pAd->RalinkCounters.RxCount++;
 
 		INC_COUNTER64(pAd->WlanCounters.ReceivedFragmentCount);
 
 		if (pRxWI->MPDUtotalByteCount < 14)
 			Status = NDIS_STATUS_FAILURE;
 
-        if (MONITOR_ON(pAd))
-		{
-            send_monitor_packets(pAd, &RxCell);
+		if (MONITOR_ON(pAd)) {
+			send_monitor_packets(pAd, &RxCell);
 			break;
 		}
 
@@ -766,40 +784,38 @@ BOOLEAN STARxDoneInterruptHandle(
 		Status = RTMPCheckRxError(pAd, pHeader, pRxWI, pRxD);
 
 		// Handle the received frame
-		if (Status == NDIS_STATUS_SUCCESS)
-		{
-			switch (pHeader->FC.Type)
-			{
+		if (Status == NDIS_STATUS_SUCCESS) {
+			switch (pHeader->FC.Type) {
 				// CASE I, receive a DATA frame
-				case BTYPE_DATA:
+			case BTYPE_DATA:
 				{
 					// process DATA frame
 					STAHandleRxDataFrame(pAd, &RxCell);
 				}
 				break;
 				// CASE II, receive a MGMT frame
-				case BTYPE_MGMT:
+			case BTYPE_MGMT:
 				{
 					STAHandleRxMgmtFrame(pAd, &RxCell);
 				}
 				break;
 				// CASE III. receive a CNTL frame
-				case BTYPE_CNTL:
+			case BTYPE_CNTL:
 				{
 					STAHandleRxControlFrame(pAd, &RxCell);
 				}
 				break;
 				// discard other type
-				default:
-					RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
-					break;
+			default:
+				RELEASE_NDIS_PACKET(pAd, pRxPacket,
+						    NDIS_STATUS_FAILURE);
+				break;
 			}
-		}
-		else
-		{
+		} else {
 			pAd->Counters8023.RxErrors++;
 			// discard this frame
-			RELEASE_NDIS_PACKET(pAd, pRxPacket, NDIS_STATUS_FAILURE);
+			RELEASE_NDIS_PACKET(pAd, pRxPacket,
+					    NDIS_STATUS_FAILURE);
 		}
 	}
 
@@ -817,8 +833,7 @@ BOOLEAN STARxDoneInterruptHandle(
 
 	========================================================================
 */
-VOID	RTMPHandleTwakeupInterrupt(
-	IN PRTMP_ADAPTER pAd)
+VOID RTMPHandleTwakeupInterrupt(IN PRTMP_ADAPTER pAd)
 {
 	AsicForceWakeup(pAd, FALSE);
 }
@@ -841,47 +856,39 @@ Note:
 	You only can put OS-depened & STA related code in here.
 ========================================================================
 */
-VOID STASendPackets(
-	IN	NDIS_HANDLE		MiniportAdapterContext,
-	IN	PPNDIS_PACKET	ppPacketArray,
-	IN	UINT			NumberOfPackets)
+VOID STASendPackets(IN NDIS_HANDLE MiniportAdapterContext,
+		    IN PPNDIS_PACKET ppPacketArray, IN UINT NumberOfPackets)
 {
-	UINT			Index;
-	PRTMP_ADAPTER	pAd = (PRTMP_ADAPTER) MiniportAdapterContext;
-	PNDIS_PACKET	pPacket;
-	BOOLEAN			allowToSend = FALSE;
-
+	UINT Index;
+	PRTMP_ADAPTER pAd = (PRTMP_ADAPTER) MiniportAdapterContext;
+	PNDIS_PACKET pPacket;
+	BOOLEAN allowToSend = FALSE;
 
-	for (Index = 0; Index < NumberOfPackets; Index++)
-	{
+	for (Index = 0; Index < NumberOfPackets; Index++) {
 		pPacket = ppPacketArray[Index];
 
-		do
-		{
-			if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS) ||
-				RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS) ||
-				RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF))
-			{
+		do {
+			if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RESET_IN_PROGRESS)
+			    || RTMP_TEST_FLAG(pAd,
+					      fRTMP_ADAPTER_HALT_IN_PROGRESS)
+			    || RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF)) {
 				// Drop send request since hardware is in reset state
-					break;
-			}
-			else if (!INFRA_ON(pAd) && !ADHOC_ON(pAd))
-			{
+				break;
+			} else if (!INFRA_ON(pAd) && !ADHOC_ON(pAd)) {
 				// Drop send request since there are no physical connection yet
-					break;
-			}
-			else
-			{
+				break;
+			} else {
 				// Record that orignal packet source is from NDIS layer,so that
 				// later on driver knows how to release this NDIS PACKET
-				RTMP_SET_PACKET_WCID(pPacket, 0); // this field is useless when in STA mode
+				RTMP_SET_PACKET_WCID(pPacket, 0);	// this field is useless when in STA mode
 				RTMP_SET_PACKET_SOURCE(pPacket, PKTSRC_NDIS);
-				NDIS_SET_PACKET_STATUS(pPacket, NDIS_STATUS_PENDING);
+				NDIS_SET_PACKET_STATUS(pPacket,
+						       NDIS_STATUS_PENDING);
 				pAd->RalinkCounters.PendingNdisPacketCount++;
 
 				allowToSend = TRUE;
 			}
-		} while(FALSE);
+		} while (FALSE);
 
 		if (allowToSend == TRUE)
 			STASendPacket(pAd, pPacket);
@@ -894,7 +901,6 @@ VOID STASendPackets(
 
 }
 
-
 /*
 ========================================================================
 Routine Description:
@@ -914,72 +920,64 @@ Note:
 	You only can put OS-indepened & STA related code in here.
 ========================================================================
 */
-NDIS_STATUS STASendPacket(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket)
+NDIS_STATUS STASendPacket(IN PRTMP_ADAPTER pAd, IN PNDIS_PACKET pPacket)
 {
-	PACKET_INFO 	PacketInfo;
-	PUCHAR			pSrcBufVA;
-	UINT			SrcBufLen;
-	UINT			AllowFragSize;
-	UCHAR			NumberOfFrag;
-	UCHAR			RTSRequired;
-	UCHAR			QueIdx, UserPriority;
+	PACKET_INFO PacketInfo;
+	PUCHAR pSrcBufVA;
+	UINT SrcBufLen;
+	UINT AllowFragSize;
+	UCHAR NumberOfFrag;
+	UCHAR RTSRequired;
+	UCHAR QueIdx, UserPriority;
 	MAC_TABLE_ENTRY *pEntry = NULL;
-	unsigned int 	IrqFlags;
-	UCHAR			FlgIsIP = 0;
-	UCHAR			Rate;
+	unsigned int IrqFlags;
+	UCHAR FlgIsIP = 0;
+	UCHAR Rate;
 
 	// Prepare packet information structure for buffer descriptor
 	// chained within a single NDIS packet.
 	RTMP_QueryPacketInfo(pPacket, &PacketInfo, &pSrcBufVA, &SrcBufLen);
 
-	if (pSrcBufVA == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("STASendPacket --> pSrcBufVA == NULL !!!SrcBufLen=%x\n",SrcBufLen));
+	if (pSrcBufVA == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("STASendPacket --> pSrcBufVA == NULL !!!SrcBufLen=%x\n",
+			  SrcBufLen));
 		// Resourece is low, system did not allocate virtual address
 		// return NDIS_STATUS_FAILURE directly to upper layer
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 		return NDIS_STATUS_FAILURE;
 	}
 
-
-	if (SrcBufLen < 14)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("STASendPacket --> Ndis Packet buffer error !!!\n"));
+	if (SrcBufLen < 14) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("STASendPacket --> Ndis Packet buffer error !!!\n"));
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 		return (NDIS_STATUS_FAILURE);
 	}
-
 	// In HT rate adhoc mode, A-MPDU is often used. So need to lookup BA Table and MAC Entry.
 	// Note multicast packets in adhoc also use BSSID_WCID index.
 	{
-		if(INFRA_ON(pAd))
-		{
-			{
-			pEntry = &pAd->MacTab.Content[BSSID_WCID];
-			RTMP_SET_PACKET_WCID(pPacket, BSSID_WCID);
-			Rate = pAd->CommonCfg.TxRate;
-		}
-		}
-		else if (ADHOC_ON(pAd))
-		{
-			if (*pSrcBufVA & 0x01)
+		if (INFRA_ON(pAd)) {
 			{
+				pEntry = &pAd->MacTab.Content[BSSID_WCID];
+				RTMP_SET_PACKET_WCID(pPacket, BSSID_WCID);
+				Rate = pAd->CommonCfg.TxRate;
+			}
+		} else if (ADHOC_ON(pAd)) {
+			if (*pSrcBufVA & 0x01) {
 				RTMP_SET_PACKET_WCID(pPacket, MCAST_WCID);
 				pEntry = &pAd->MacTab.Content[MCAST_WCID];
-			}
-			else
-			{
+			} else {
 				pEntry = MacTableLookup(pAd, pSrcBufVA);
 			}
 			Rate = pAd->CommonCfg.TxRate;
 		}
 	}
 
-	if (!pEntry)
-	{
-		DBGPRINT(RT_DEBUG_ERROR,("STASendPacket->Cannot find pEntry(%2x:%2x:%2x:%2x:%2x:%2x) in MacTab!\n", PRINT_MAC(pSrcBufVA)));
+	if (!pEntry) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("STASendPacket->Cannot find pEntry(%2x:%2x:%2x:%2x:%2x:%2x) in MacTab!\n",
+			  PRINT_MAC(pSrcBufVA)));
 		// Resourece is low, system did not allocate virtual address
 		// return NDIS_STATUS_FAILURE directly to upper layer
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
@@ -987,44 +985,39 @@ NDIS_STATUS STASendPacket(
 	}
 
 	if (ADHOC_ON(pAd)
-		)
-	{
-		RTMP_SET_PACKET_WCID(pPacket, (UCHAR)pEntry->Aid);
+	    ) {
+		RTMP_SET_PACKET_WCID(pPacket, (UCHAR) pEntry->Aid);
 	}
-
 	//
 	// Check the Ethernet Frame type of this packet, and set the RTMP_SET_PACKET_SPECIFIC flags.
-	//		Here we set the PACKET_SPECIFIC flags(LLC, VLAN, DHCP/ARP, EAPOL).
+	//              Here we set the PACKET_SPECIFIC flags(LLC, VLAN, DHCP/ARP, EAPOL).
 	RTMPCheckEtherType(pAd, pPacket);
 
-
-
 	//
 	// WPA 802.1x secured port control - drop all non-802.1x frame before port secured
 	//
 	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-		 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-		 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
-		 (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-		  || (pAd->StaCfg.IEEE8021X == TRUE)
-		  )
-		  && ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED) || (pAd->StaCfg.MicErrCnt >= 2))
-		  && (RTMP_GET_PACKET_EAPOL(pPacket)== FALSE)
-		  )
-	{
-		DBGPRINT(RT_DEBUG_TRACE,("STASendPacket --> Drop packet before port secured !!!\n"));
+	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+	     || (pAd->StaCfg.IEEE8021X == TRUE)
+	    )
+	    && ((pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)
+		|| (pAd->StaCfg.MicErrCnt >= 2))
+	    && (RTMP_GET_PACKET_EAPOL(pPacket) == FALSE)
+	    ) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("STASendPacket --> Drop packet before port secured !!!\n"));
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 
 		return (NDIS_STATUS_FAILURE);
 	}
 
-
 	// STEP 1. Decide number of fragments required to deliver this MSDU.
-	//	   The estimation here is not very accurate because difficult to
-	//	   take encryption overhead into consideration here. The result
-	//	   "NumberOfFrag" is then just used to pre-check if enough free
-	//	   TXD are available to hold this MSDU.
-
+	//         The estimation here is not very accurate because difficult to
+	//         take encryption overhead into consideration here. The result
+	//         "NumberOfFrag" is then just used to pre-check if enough free
+	//         TXD are available to hold this MSDU.
 
 	if (*pSrcBufVA & 0x01)	// fragmentation not allowed on multicast & broadcast
 		NumberOfFrag = 1;
@@ -1032,10 +1025,10 @@ NDIS_STATUS STASendPacket(
 		NumberOfFrag = 1;	// Aggregation overwhelms fragmentation
 	else if (CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_AMSDU_INUSED))
 		NumberOfFrag = 1;	// Aggregation overwhelms fragmentation
-	else if ((pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTMIX) || (pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTGREENFIELD))
+	else if ((pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTMIX)
+		 || (pAd->StaCfg.HTPhyMode.field.MODE == MODE_HTGREENFIELD))
 		NumberOfFrag = 1;	// MIMO RATE overwhelms fragmentation
-	else
-	{
+	else {
 		// The calculated "NumberOfFrag" is a rough estimation because of various
 		// encryption/encapsulation overhead not taken into consideration. This number is just
 		// used to make sure enough free TXD are available before fragmentation takes place.
@@ -1045,11 +1038,15 @@ NDIS_STATUS STASendPacket(
 		// resource, and the NDIS packet will be indicated NDIS_STATUS_FAILURE. This should
 		// rarely happen and the penalty is just like a TX RETRY fail. Affordable.
 
-		AllowFragSize = (pAd->CommonCfg.FragmentThreshold) - LENGTH_802_11 - LENGTH_CRC;
-		NumberOfFrag = ((PacketInfo.TotalPacketLength - LENGTH_802_3 + LENGTH_802_1_H) / AllowFragSize) + 1;
+		AllowFragSize =
+		    (pAd->CommonCfg.FragmentThreshold) - LENGTH_802_11 -
+		    LENGTH_CRC;
+		NumberOfFrag =
+		    ((PacketInfo.TotalPacketLength - LENGTH_802_3 +
+		      LENGTH_802_1_H) / AllowFragSize) + 1;
 		// To get accurate number of fragmentation, Minus 1 if the size just match to allowable fragment size
-		if (((PacketInfo.TotalPacketLength - LENGTH_802_3 + LENGTH_802_1_H) % AllowFragSize) == 0)
-		{
+		if (((PacketInfo.TotalPacketLength - LENGTH_802_3 +
+		      LENGTH_802_1_H) % AllowFragSize) == 0) {
 			NumberOfFrag--;
 		}
 	}
@@ -1057,16 +1054,19 @@ NDIS_STATUS STASendPacket(
 	// Save fragment number to Ndis packet reserved field
 	RTMP_SET_PACKET_FRAGMENTS(pPacket, NumberOfFrag);
 
-
 	// STEP 2. Check the requirement of RTS:
-	//	   If multiple fragment required, RTS is required only for the first fragment
-	//	   if the fragment size large than RTS threshold
+	//         If multiple fragment required, RTS is required only for the first fragment
+	//         if the fragment size large than RTS threshold
 	//     For RT28xx, Let ASIC send RTS/CTS
-//	RTMP_SET_PACKET_RTS(pPacket, 0);
+//      RTMP_SET_PACKET_RTS(pPacket, 0);
 	if (NumberOfFrag > 1)
-		RTSRequired = (pAd->CommonCfg.FragmentThreshold > pAd->CommonCfg.RtsThreshold) ? 1 : 0;
+		RTSRequired =
+		    (pAd->CommonCfg.FragmentThreshold >
+		     pAd->CommonCfg.RtsThreshold) ? 1 : 0;
 	else
-		RTSRequired = (PacketInfo.TotalPacketLength > pAd->CommonCfg.RtsThreshold) ? 1 : 0;
+		RTSRequired =
+		    (PacketInfo.TotalPacketLength >
+		     pAd->CommonCfg.RtsThreshold) ? 1 : 0;
 
 	// Save RTS requirement to Ndis packet reserved field
 	RTMP_SET_PACKET_RTS(pPacket, RTSRequired);
@@ -1076,32 +1076,33 @@ NDIS_STATUS STASendPacket(
 	// STEP 3. Traffic classification. outcome = <UserPriority, QueIdx>
 	//
 	UserPriority = 0;
-	QueIdx		 = QID_AC_BE;
+	QueIdx = QID_AC_BE;
 	if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED) &&
-		CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE))
-	{
+	    CLIENT_STATUS_TEST_FLAG(pEntry, fCLIENT_STATUS_WMM_CAPABLE)) {
 		USHORT Protocol;
-		UCHAR  LlcSnapLen = 0, Byte0, Byte1;
-		do
-		{
+		UCHAR LlcSnapLen = 0, Byte0, Byte1;
+		do {
 			// get Ethernet protocol field
-			Protocol = (USHORT)((pSrcBufVA[12] << 8) + pSrcBufVA[13]);
-			if (Protocol <= 1500)
-			{
+			Protocol =
+			    (USHORT) ((pSrcBufVA[12] << 8) + pSrcBufVA[13]);
+			if (Protocol <= 1500) {
 				// get Ethernet protocol field from LLC/SNAP
-				if (Sniff2BytesFromNdisBuffer(PacketInfo.pFirstBuffer, LENGTH_802_3 + 6, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
+				if (Sniff2BytesFromNdisBuffer
+				    (PacketInfo.pFirstBuffer, LENGTH_802_3 + 6,
+				     &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
 					break;
 
-				Protocol = (USHORT)((Byte0 << 8) + Byte1);
+				Protocol = (USHORT) ((Byte0 << 8) + Byte1);
 				LlcSnapLen = 8;
 			}
-
 			// always AC_BE for non-IP packet
 			if (Protocol != 0x0800)
 				break;
 
 			// get IP header
-			if (Sniff2BytesFromNdisBuffer(PacketInfo.pFirstBuffer, LENGTH_802_3 + LlcSnapLen, &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
+			if (Sniff2BytesFromNdisBuffer
+			    (PacketInfo.pFirstBuffer, LENGTH_802_3 + LlcSnapLen,
+			     &Byte0, &Byte1) != NDIS_STATUS_SUCCESS)
 				break;
 
 			// return AC_BE if packet is not IPv4
@@ -1115,61 +1116,56 @@ NDIS_STATUS STASendPacket(
 			// TODO: have to check ACM bit. apply TSPEC if ACM is ON
 			// TODO: downgrade UP & QueIdx before passing ACM
 			/*
-				Under WMM ACM control, we dont need to check the bit;
-				Or when a TSPEC is built for VO but we will change to issue
-				BA session for BE here, so we will not use BA to send VO packets.
-			*/
-			if (pAd->CommonCfg.APEdcaParm.bACM[QueIdx])
-			{
+			   Under WMM ACM control, we dont need to check the bit;
+			   Or when a TSPEC is built for VO but we will change to issue
+			   BA session for BE here, so we will not use BA to send VO packets.
+			 */
+			if (pAd->CommonCfg.APEdcaParm.bACM[QueIdx]) {
 				UserPriority = 0;
-				QueIdx		 = QID_AC_BE;
+				QueIdx = QID_AC_BE;
 			}
 		} while (FALSE);
 	}
 
 	RTMP_SET_PACKET_UP(pPacket, UserPriority);
 
-
-
 	// Make sure SendTxWait queue resource won't be used by other threads
 	RTMP_IRQ_LOCK(&pAd->irq_lock, IrqFlags);
-	if (pAd->TxSwQueue[QueIdx].Number >= MAX_PACKETS_IN_QUEUE)
-	{
+	if (pAd->TxSwQueue[QueIdx].Number >= MAX_PACKETS_IN_QUEUE) {
 		RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 
 		return NDIS_STATUS_FAILURE;
-	}
-	else
-	{
-		InsertTailQueueAc(pAd, pEntry, &pAd->TxSwQueue[QueIdx], PACKET_TO_QUEUE_ENTRY(pPacket));
+	} else {
+		InsertTailQueueAc(pAd, pEntry, &pAd->TxSwQueue[QueIdx],
+				  PACKET_TO_QUEUE_ENTRY(pPacket));
 	}
 	RTMP_IRQ_UNLOCK(&pAd->irq_lock, IrqFlags);
 
-    if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE)&&
-        IS_HT_STA(pEntry))
-	{
-	    //PMAC_TABLE_ENTRY pMacEntry = &pAd->MacTab.Content[BSSID_WCID];
-		if (((pEntry->TXBAbitmap & (1<<UserPriority)) == 0) &&
-            ((pEntry->BADeclineBitmap & (1<<UserPriority)) == 0) &&
-            (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)
-			 // For IOT compatibility, if
-			 // 1. It is Ralink chip or
-			 // 2. It is OPEN or AES mode,
-			 // then BA session can be bulit.
-			 && ((pEntry->ValidAsCLI && pAd->MlmeAux.APRalinkIe != 0x0) ||
-				 (pEntry->WepStatus != Ndis802_11WEPEnabled && pEntry->WepStatus != Ndis802_11Encryption2Enabled))
-			)
-		{
-			BAOriSessionSetUp(pAd, pEntry, UserPriority, 0, 10, FALSE);
+	if ((pAd->CommonCfg.BACapability.field.AutoBA == TRUE) &&
+	    IS_HT_STA(pEntry)) {
+		//PMAC_TABLE_ENTRY pMacEntry = &pAd->MacTab.Content[BSSID_WCID];
+		if (((pEntry->TXBAbitmap & (1 << UserPriority)) == 0) &&
+		    ((pEntry->BADeclineBitmap & (1 << UserPriority)) == 0) &&
+		    (pEntry->PortSecured == WPA_802_1X_PORT_SECURED)
+		    // For IOT compatibility, if
+		    // 1. It is Ralink chip or
+		    // 2. It is OPEN or AES mode,
+		    // then BA session can be bulit.
+		    && ((pEntry->ValidAsCLI && pAd->MlmeAux.APRalinkIe != 0x0)
+			|| (pEntry->WepStatus != Ndis802_11WEPEnabled
+			    && pEntry->WepStatus !=
+			    Ndis802_11Encryption2Enabled))
+		    ) {
+			BAOriSessionSetUp(pAd, pEntry, UserPriority, 0, 10,
+					  FALSE);
 		}
 	}
 
-	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++; // TODO: for debug only. to be removed
+	pAd->RalinkCounters.OneSecOsTxCount[QueIdx]++;	// TODO: for debug only. to be removed
 	return NDIS_STATUS_SUCCESS;
 }
 
-
 /*
 	========================================================================
 
@@ -1193,45 +1189,52 @@ NDIS_STATUS STASendPacket(
 	========================================================================
 */
 #ifdef RTMP_MAC_PCI
-NDIS_STATUS RTMPFreeTXDRequest(
-	IN		PRTMP_ADAPTER	pAd,
-	IN		UCHAR			QueIdx,
-	IN		UCHAR			NumberRequired,
-	IN		PUCHAR			FreeNumberIs)
+NDIS_STATUS RTMPFreeTXDRequest(IN PRTMP_ADAPTER pAd,
+			       IN UCHAR QueIdx,
+			       IN UCHAR NumberRequired, IN PUCHAR FreeNumberIs)
 {
-	ULONG		FreeNumber = 0;
-	NDIS_STATUS 	Status = NDIS_STATUS_FAILURE;
-
-	switch (QueIdx)
-	{
-		case QID_AC_BK:
-		case QID_AC_BE:
-		case QID_AC_VI:
-		case QID_AC_VO:
-			if (pAd->TxRing[QueIdx].TxSwFreeIdx > pAd->TxRing[QueIdx].TxCpuIdx)
-				FreeNumber = pAd->TxRing[QueIdx].TxSwFreeIdx - pAd->TxRing[QueIdx].TxCpuIdx - 1;
-			else
-				FreeNumber = pAd->TxRing[QueIdx].TxSwFreeIdx + TX_RING_SIZE - pAd->TxRing[QueIdx].TxCpuIdx - 1;
-
-			if (FreeNumber >= NumberRequired)
-				Status = NDIS_STATUS_SUCCESS;
-			break;
-
-		case QID_MGMT:
-			if (pAd->MgmtRing.TxSwFreeIdx > pAd->MgmtRing.TxCpuIdx)
-				FreeNumber = pAd->MgmtRing.TxSwFreeIdx - pAd->MgmtRing.TxCpuIdx - 1;
-			else
-				FreeNumber = pAd->MgmtRing.TxSwFreeIdx + MGMT_RING_SIZE - pAd->MgmtRing.TxCpuIdx - 1;
-
-			if (FreeNumber >= NumberRequired)
-				Status = NDIS_STATUS_SUCCESS;
-			break;
-
-		default:
-			DBGPRINT(RT_DEBUG_ERROR,("RTMPFreeTXDRequest::Invalid QueIdx(=%d)\n", QueIdx));
-			break;
+	ULONG FreeNumber = 0;
+	NDIS_STATUS Status = NDIS_STATUS_FAILURE;
+
+	switch (QueIdx) {
+	case QID_AC_BK:
+	case QID_AC_BE:
+	case QID_AC_VI:
+	case QID_AC_VO:
+		if (pAd->TxRing[QueIdx].TxSwFreeIdx >
+		    pAd->TxRing[QueIdx].TxCpuIdx)
+			FreeNumber =
+			    pAd->TxRing[QueIdx].TxSwFreeIdx -
+			    pAd->TxRing[QueIdx].TxCpuIdx - 1;
+		else
+			FreeNumber =
+			    pAd->TxRing[QueIdx].TxSwFreeIdx + TX_RING_SIZE -
+			    pAd->TxRing[QueIdx].TxCpuIdx - 1;
+
+		if (FreeNumber >= NumberRequired)
+			Status = NDIS_STATUS_SUCCESS;
+		break;
+
+	case QID_MGMT:
+		if (pAd->MgmtRing.TxSwFreeIdx > pAd->MgmtRing.TxCpuIdx)
+			FreeNumber =
+			    pAd->MgmtRing.TxSwFreeIdx - pAd->MgmtRing.TxCpuIdx -
+			    1;
+		else
+			FreeNumber =
+			    pAd->MgmtRing.TxSwFreeIdx + MGMT_RING_SIZE -
+			    pAd->MgmtRing.TxCpuIdx - 1;
+
+		if (FreeNumber >= NumberRequired)
+			Status = NDIS_STATUS_SUCCESS;
+		break;
+
+	default:
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTMPFreeTXDRequest::Invalid QueIdx(=%d)\n", QueIdx));
+		break;
 	}
-	*FreeNumberIs = (UCHAR)FreeNumber;
+	*FreeNumberIs = (UCHAR) FreeNumber;
 
 	return (Status);
 }
@@ -1241,76 +1244,69 @@ NDIS_STATUS RTMPFreeTXDRequest(
 	Actually, this function used to check if the TxHardware Queue still has frame need to send.
 	If no frame need to send, go to sleep, else, still wake up.
 */
-NDIS_STATUS RTMPFreeTXDRequest(
-	IN		PRTMP_ADAPTER	pAd,
-	IN		UCHAR			QueIdx,
-	IN		UCHAR			NumberRequired,
-	IN		PUCHAR			FreeNumberIs)
+NDIS_STATUS RTMPFreeTXDRequest(IN PRTMP_ADAPTER pAd,
+			       IN UCHAR QueIdx,
+			       IN UCHAR NumberRequired, IN PUCHAR FreeNumberIs)
 {
-	//ULONG		FreeNumber = 0;
-	NDIS_STATUS	Status = NDIS_STATUS_FAILURE;
-	unsigned long   IrqFlags;
-	HT_TX_CONTEXT	*pHTTXContext;
-
-	switch (QueIdx)
-	{
-		case QID_AC_BK:
-		case QID_AC_BE:
-		case QID_AC_VI:
-		case QID_AC_VO:
-			{
-				pHTTXContext = &pAd->TxContext[QueIdx];
-				RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-				if ((pHTTXContext->CurWritePosition != pHTTXContext->ENextBulkOutPosition) ||
-					(pHTTXContext->IRPPending == TRUE))
-				{
-					Status = NDIS_STATUS_FAILURE;
-				}
-				else
-				{
-					Status = NDIS_STATUS_SUCCESS;
-				}
-				RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx], IrqFlags);
-			}
-			break;
-		case QID_MGMT:
-			if (pAd->MgmtRing.TxSwFreeIdx != MGMT_RING_SIZE)
+	//ULONG         FreeNumber = 0;
+	NDIS_STATUS Status = NDIS_STATUS_FAILURE;
+	unsigned long IrqFlags;
+	HT_TX_CONTEXT *pHTTXContext;
+
+	switch (QueIdx) {
+	case QID_AC_BK:
+	case QID_AC_BE:
+	case QID_AC_VI:
+	case QID_AC_VO:
+		{
+			pHTTXContext = &pAd->TxContext[QueIdx];
+			RTMP_IRQ_LOCK(&pAd->TxContextQueueLock[QueIdx],
+				      IrqFlags);
+			if ((pHTTXContext->CurWritePosition !=
+			     pHTTXContext->ENextBulkOutPosition)
+			    || (pHTTXContext->IRPPending == TRUE)) {
 				Status = NDIS_STATUS_FAILURE;
-			else
+			} else {
 				Status = NDIS_STATUS_SUCCESS;
-			break;
-		default:
-			DBGPRINT(RT_DEBUG_ERROR,("RTMPFreeTXDRequest::Invalid QueIdx(=%d)\n", QueIdx));
-			break;
+			}
+			RTMP_IRQ_UNLOCK(&pAd->TxContextQueueLock[QueIdx],
+					IrqFlags);
+		}
+		break;
+	case QID_MGMT:
+		if (pAd->MgmtRing.TxSwFreeIdx != MGMT_RING_SIZE)
+			Status = NDIS_STATUS_FAILURE;
+		else
+			Status = NDIS_STATUS_SUCCESS;
+		break;
+	default:
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("RTMPFreeTXDRequest::Invalid QueIdx(=%d)\n", QueIdx));
+		break;
 	}
 
 	return (Status);
 }
 #endif // RTMP_MAC_USB //
 
-VOID RTMPSendDisassociationFrame(
-	IN	PRTMP_ADAPTER	pAd)
+VOID RTMPSendDisassociationFrame(IN PRTMP_ADAPTER pAd)
 {
 }
 
-VOID	RTMPSendNullFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	UCHAR			TxRate,
-	IN	BOOLEAN 		bQosNull)
+VOID RTMPSendNullFrame(IN PRTMP_ADAPTER pAd,
+		       IN UCHAR TxRate, IN BOOLEAN bQosNull)
 {
-	UCHAR	NullFrame[48];
-	ULONG	Length;
-	PHEADER_802_11	pHeader_802_11;
-
-    // WPA 802.1x secured port control
-    if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
-         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
-         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
-         (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
-			  || (pAd->StaCfg.IEEE8021X == TRUE)
-        ) &&
-       (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
-	{
+	UCHAR NullFrame[48];
+	ULONG Length;
+	PHEADER_802_11 pHeader_802_11;
+
+	// WPA 802.1x secured port control
+	if (((pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA) ||
+	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPAPSK) ||
+	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2) ||
+	     (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPA2PSK)
+	     || (pAd->StaCfg.IEEE8021X == TRUE)
+	    ) && (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED)) {
 		return;
 	}
 
@@ -1326,28 +1322,26 @@ VOID	RTMPSendNullFrame(
 	COPY_MAC_ADDR(pHeader_802_11->Addr2, pAd->CurrentAddress);
 	COPY_MAC_ADDR(pHeader_802_11->Addr3, pAd->CommonCfg.Bssid);
 
-	if (pAd->CommonCfg.bAPSDForcePowerSave)
-	{
+	if (pAd->CommonCfg.bAPSDForcePowerSave) {
 		pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
+	} else {
+		pHeader_802_11->FC.PwrMgmt =
+		    (pAd->StaCfg.Psm == PWR_SAVE) ? 1 : 0;
 	}
-	else
-	{
-		pHeader_802_11->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE) ? 1: 0;
-	}
-	pHeader_802_11->Duration = pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, TxRate, 14);
+	pHeader_802_11->Duration =
+	    pAd->CommonCfg.Dsifs + RTMPCalcDuration(pAd, TxRate, 14);
 
 	pAd->Sequence++;
 	pHeader_802_11->Sequence = pAd->Sequence;
 
 	// Prepare QosNull function frame
-	if (bQosNull)
-	{
+	if (bQosNull) {
 		pHeader_802_11->FC.SubType = SUBTYPE_QOS_NULL;
 
 		// copy QOS control bytes
-		NullFrame[Length]	=  0;
-		NullFrame[Length+1] =  0;
-		Length += 2;// if pad with 2 bytes for alignment, APSD will fail
+		NullFrame[Length] = 0;
+		NullFrame[Length + 1] = 0;
+		Length += 2;	// if pad with 2 bytes for alignment, APSD will fail
 	}
 
 	HAL_KickOutNullFrameTx(pAd, 0, NullFrame, Length);
@@ -1355,68 +1349,57 @@ VOID	RTMPSendNullFrame(
 }
 
 // IRQL = DISPATCH_LEVEL
-VOID	RTMPSendRTSFrame(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PUCHAR			pDA,
-	IN	unsigned int	NextMpduSize,
-	IN	UCHAR			TxRate,
-	IN	UCHAR			RTSRate,
-	IN	USHORT			AckDuration,
-	IN	UCHAR			QueIdx,
-	IN	UCHAR			FrameGap)
+VOID RTMPSendRTSFrame(IN PRTMP_ADAPTER pAd,
+		      IN PUCHAR pDA,
+		      IN unsigned int NextMpduSize,
+		      IN UCHAR TxRate,
+		      IN UCHAR RTSRate,
+		      IN USHORT AckDuration, IN UCHAR QueIdx, IN UCHAR FrameGap)
 {
 }
 
-
-
 // --------------------------------------------------------
 //  FIND ENCRYPT KEY AND DECIDE CIPHER ALGORITHM
-//		Find the WPA key, either Group or Pairwise Key
-//		LEAP + TKIP also use WPA key.
+//              Find the WPA key, either Group or Pairwise Key
+//              LEAP + TKIP also use WPA key.
 // --------------------------------------------------------
 // Decide WEP bit and cipher suite to be used. Same cipher suite should be used for whole fragment burst
 // In Cisco CCX 2.0 Leap Authentication
-//		   WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey
-//		   Instead of the SharedKey, SharedKey Length may be Zero.
-VOID STAFindCipherAlgorithm(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk)
+//                 WepStatus is Ndis802_11Encryption1Enabled but the key will use PairwiseKey
+//                 Instead of the SharedKey, SharedKey Length may be Zero.
+VOID STAFindCipherAlgorithm(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
-	NDIS_802_11_ENCRYPTION_STATUS	Cipher;				// To indicate cipher used for this packet
-	UCHAR							CipherAlg = CIPHER_NONE;		// cipher alogrithm
-	UCHAR							KeyIdx = 0xff;
-	PUCHAR							pSrcBufVA;
-	PCIPHER_KEY						pKey = NULL;
+	NDIS_802_11_ENCRYPTION_STATUS Cipher;	// To indicate cipher used for this packet
+	UCHAR CipherAlg = CIPHER_NONE;	// cipher alogrithm
+	UCHAR KeyIdx = 0xff;
+	PUCHAR pSrcBufVA;
+	PCIPHER_KEY pKey = NULL;
 
 	pSrcBufVA = GET_OS_PKT_DATAPTR(pTxBlk->pPacket);
 
 	{
-	    // Select Cipher
-	    if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))
-	        Cipher = pAd->StaCfg.GroupCipher; // Cipher for Multicast or Broadcast
-	    else
-	        Cipher = pAd->StaCfg.PairCipher; // Cipher for Unicast
+		// Select Cipher
+		if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))
+			Cipher = pAd->StaCfg.GroupCipher;	// Cipher for Multicast or Broadcast
+		else
+			Cipher = pAd->StaCfg.PairCipher;	// Cipher for Unicast
 
-		if (RTMP_GET_PACKET_EAPOL(pTxBlk->pPacket))
-		{
-			ASSERT(pAd->SharedKey[BSS0][0].CipherAlg <= CIPHER_CKIP128);
+		if (RTMP_GET_PACKET_EAPOL(pTxBlk->pPacket)) {
+			ASSERT(pAd->SharedKey[BSS0][0].CipherAlg <=
+			       CIPHER_CKIP128);
 
 			// 4-way handshaking frame must be clear
-			if (!(TX_BLK_TEST_FLAG(pTxBlk, fTX_bClearEAPFrame)) && (pAd->SharedKey[BSS0][0].CipherAlg) &&
-				(pAd->SharedKey[BSS0][0].KeyLen))
-			{
+			if (!(TX_BLK_TEST_FLAG(pTxBlk, fTX_bClearEAPFrame))
+			    && (pAd->SharedKey[BSS0][0].CipherAlg)
+			    && (pAd->SharedKey[BSS0][0].KeyLen)) {
 				CipherAlg = pAd->SharedKey[BSS0][0].CipherAlg;
 				KeyIdx = 0;
 			}
-		}
-		else if (Cipher == Ndis802_11Encryption1Enabled)
-		{
-				KeyIdx = pAd->StaCfg.DefaultKeyId;
-		}
-		else if ((Cipher == Ndis802_11Encryption2Enabled) ||
-				 (Cipher == Ndis802_11Encryption3Enabled))
-		{
-			if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd))) // multicast
+		} else if (Cipher == Ndis802_11Encryption1Enabled) {
+			KeyIdx = pAd->StaCfg.DefaultKeyId;
+		} else if ((Cipher == Ndis802_11Encryption2Enabled) ||
+			   (Cipher == Ndis802_11Encryption3Enabled)) {
+			if ((*pSrcBufVA & 0x01) && (ADHOC_ON(pAd)))	// multicast
 				KeyIdx = pAd->StaCfg.DefaultKeyId;
 			else if (pAd->SharedKey[BSS0][0].KeyLen)
 				KeyIdx = 0;
@@ -1426,15 +1409,16 @@ VOID STAFindCipherAlgorithm(
 
 		if (KeyIdx == 0xff)
 			CipherAlg = CIPHER_NONE;
-		else if ((Cipher == Ndis802_11EncryptionDisabled) || (pAd->SharedKey[BSS0][KeyIdx].KeyLen == 0))
+		else if ((Cipher == Ndis802_11EncryptionDisabled)
+			 || (pAd->SharedKey[BSS0][KeyIdx].KeyLen == 0))
 			CipherAlg = CIPHER_NONE;
-	    else if ( pAd->StaCfg.WpaSupplicantUP &&
-	             (Cipher == Ndis802_11Encryption1Enabled) &&
-	             (pAd->StaCfg.IEEE8021X == TRUE) &&
-	             (pAd->StaCfg.PortSecured == WPA_802_1X_PORT_NOT_SECURED))
-	        CipherAlg = CIPHER_NONE;
-		else
-		{
+		else if (pAd->StaCfg.WpaSupplicantUP &&
+			 (Cipher == Ndis802_11Encryption1Enabled) &&
+			 (pAd->StaCfg.IEEE8021X == TRUE) &&
+			 (pAd->StaCfg.PortSecured ==
+			  WPA_802_1X_PORT_NOT_SECURED))
+			CipherAlg = CIPHER_NONE;
+		else {
 			//Header_802_11.FC.Wep = 1;
 			CipherAlg = pAd->SharedKey[BSS0][KeyIdx].CipherAlg;
 			pKey = &pAd->SharedKey[BSS0][KeyIdx];
@@ -1445,12 +1429,9 @@ VOID STAFindCipherAlgorithm(
 	pTxBlk->pKey = pKey;
 }
 
-
-VOID STABuildCommon802_11Header(
-	IN  PRTMP_ADAPTER   pAd,
-	IN  TX_BLK          *pTxBlk)
+VOID STABuildCommon802_11Header(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
-	HEADER_802_11	*pHeader_802_11;
+	HEADER_802_11 *pHeader_802_11;
 
 	//
 	// MAKE A COMMON 802.11 HEADER
@@ -1459,33 +1440,36 @@ VOID STABuildCommon802_11Header(
 	// normal wlan header size : 24 octets
 	pTxBlk->MpduHeaderLen = sizeof(HEADER_802_11);
 
-	pHeader_802_11 = (HEADER_802_11 *) &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
+	pHeader_802_11 =
+	    (HEADER_802_11 *) & pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
 
 	NdisZeroMemory(pHeader_802_11, sizeof(HEADER_802_11));
 
 	pHeader_802_11->FC.FrDs = 0;
 	pHeader_802_11->FC.Type = BTYPE_DATA;
-	pHeader_802_11->FC.SubType = ((TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) ? SUBTYPE_QDATA : SUBTYPE_DATA);
-
-    if (pTxBlk->pMacEntry)
-	{
-		if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bForceNonQoS))
-		{
-			pHeader_802_11->Sequence = pTxBlk->pMacEntry->NonQosDataSeq;
-			pTxBlk->pMacEntry->NonQosDataSeq = (pTxBlk->pMacEntry->NonQosDataSeq+1) & MAXSEQ;
-		}
-		else
-		{
+	pHeader_802_11->FC.SubType =
+	    ((TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) ? SUBTYPE_QDATA :
+	     SUBTYPE_DATA);
+
+	if (pTxBlk->pMacEntry) {
+		if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bForceNonQoS)) {
+			pHeader_802_11->Sequence =
+			    pTxBlk->pMacEntry->NonQosDataSeq;
+			pTxBlk->pMacEntry->NonQosDataSeq =
+			    (pTxBlk->pMacEntry->NonQosDataSeq + 1) & MAXSEQ;
+		} else {
 			{
-    	    pHeader_802_11->Sequence = pTxBlk->pMacEntry->TxSeq[pTxBlk->UserPriority];
-    	    pTxBlk->pMacEntry->TxSeq[pTxBlk->UserPriority] = (pTxBlk->pMacEntry->TxSeq[pTxBlk->UserPriority]+1) & MAXSEQ;
-    	}
-	}
-	}
-	else
-	{
+				pHeader_802_11->Sequence =
+				    pTxBlk->pMacEntry->TxSeq[pTxBlk->
+							     UserPriority];
+				pTxBlk->pMacEntry->TxSeq[pTxBlk->UserPriority] =
+				    (pTxBlk->pMacEntry->
+				     TxSeq[pTxBlk->UserPriority] + 1) & MAXSEQ;
+			}
+		}
+	} else {
 		pHeader_802_11->Sequence = pAd->Sequence;
-		pAd->Sequence = (pAd->Sequence+1) & MAXSEQ; // next sequence
+		pAd->Sequence = (pAd->Sequence + 1) & MAXSEQ;	// next sequence
 	}
 
 	pHeader_802_11->Frag = 0;
@@ -1493,20 +1477,23 @@ VOID STABuildCommon802_11Header(
 	pHeader_802_11->FC.MoreData = TX_BLK_TEST_FLAG(pTxBlk, fTX_bMoreData);
 
 	{
-		if (INFRA_ON(pAd))
-		{
+		if (INFRA_ON(pAd)) {
 			{
-			COPY_MAC_ADDR(pHeader_802_11->Addr1, pAd->CommonCfg.Bssid);
-			COPY_MAC_ADDR(pHeader_802_11->Addr2, pAd->CurrentAddress);
-			COPY_MAC_ADDR(pHeader_802_11->Addr3, pTxBlk->pSrcBufHeader);
-			pHeader_802_11->FC.ToDs = 1;
-		}
-		}
-		else if (ADHOC_ON(pAd))
-		{
-			COPY_MAC_ADDR(pHeader_802_11->Addr1, pTxBlk->pSrcBufHeader);
-			COPY_MAC_ADDR(pHeader_802_11->Addr2, pAd->CurrentAddress);
-			COPY_MAC_ADDR(pHeader_802_11->Addr3, pAd->CommonCfg.Bssid);
+				COPY_MAC_ADDR(pHeader_802_11->Addr1,
+					      pAd->CommonCfg.Bssid);
+				COPY_MAC_ADDR(pHeader_802_11->Addr2,
+					      pAd->CurrentAddress);
+				COPY_MAC_ADDR(pHeader_802_11->Addr3,
+					      pTxBlk->pSrcBufHeader);
+				pHeader_802_11->FC.ToDs = 1;
+			}
+		} else if (ADHOC_ON(pAd)) {
+			COPY_MAC_ADDR(pHeader_802_11->Addr1,
+				      pTxBlk->pSrcBufHeader);
+			COPY_MAC_ADDR(pHeader_802_11->Addr2,
+				      pAd->CurrentAddress);
+			COPY_MAC_ADDR(pHeader_802_11->Addr3,
+				      pAd->CommonCfg.Bssid);
 			pHeader_802_11->FC.ToDs = 0;
 		}
 	}
@@ -1518,20 +1505,18 @@ VOID STABuildCommon802_11Header(
 	// STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later.
 	// -----------------------------------------------------------------
 	if (pAd->CommonCfg.bAPSDForcePowerSave)
-    	pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
+		pHeader_802_11->FC.PwrMgmt = PWR_SAVE;
 	else
-    	pHeader_802_11->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
+		pHeader_802_11->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
 }
 
-VOID STABuildCache802_11Header(
-	IN RTMP_ADAPTER		*pAd,
-	IN TX_BLK			*pTxBlk,
-	IN UCHAR			*pHeader)
+VOID STABuildCache802_11Header(IN RTMP_ADAPTER * pAd,
+			       IN TX_BLK * pTxBlk, IN UCHAR * pHeader)
 {
-	MAC_TABLE_ENTRY	*pMacEntry;
-	PHEADER_802_11	pHeader80211;
+	MAC_TABLE_ENTRY *pMacEntry;
+	PHEADER_802_11 pHeader80211;
 
-	pHeader80211 = (PHEADER_802_11)pHeader;
+	pHeader80211 = (PHEADER_802_11) pHeader;
 	pMacEntry = pTxBlk->pMacEntry;
 
 	//
@@ -1546,7 +1531,8 @@ VOID STABuildCache802_11Header(
 
 	// Sequence
 	pHeader80211->Sequence = pMacEntry->TxSeq[pTxBlk->UserPriority];
-    pMacEntry->TxSeq[pTxBlk->UserPriority] = (pMacEntry->TxSeq[pTxBlk->UserPriority]+1) & MAXSEQ;
+	pMacEntry->TxSeq[pTxBlk->UserPriority] =
+	    (pMacEntry->TxSeq[pTxBlk->UserPriority] + 1) & MAXSEQ;
 
 	{
 		// Check if the frame can be sent through DLS direct link interface
@@ -1554,34 +1540,34 @@ VOID STABuildCache802_11Header(
 
 		// The addr3 of normal packet send from DS is Dest Mac address.
 		if (ADHOC_ON(pAd))
-			COPY_MAC_ADDR(pHeader80211->Addr3, pAd->CommonCfg.Bssid);
+			COPY_MAC_ADDR(pHeader80211->Addr3,
+				      pAd->CommonCfg.Bssid);
 		else
-			COPY_MAC_ADDR(pHeader80211->Addr3, pTxBlk->pSrcBufHeader);
+			COPY_MAC_ADDR(pHeader80211->Addr3,
+				      pTxBlk->pSrcBufHeader);
 	}
 
 	// -----------------------------------------------------------------
 	// STEP 2. MAKE A COMMON 802.11 HEADER SHARED BY ENTIRE FRAGMENT BURST. Fill sequence later.
 	// -----------------------------------------------------------------
 	if (pAd->CommonCfg.bAPSDForcePowerSave)
-    	pHeader80211->FC.PwrMgmt = PWR_SAVE;
+		pHeader80211->FC.PwrMgmt = PWR_SAVE;
 	else
-    	pHeader80211->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
+		pHeader80211->FC.PwrMgmt = (pAd->StaCfg.Psm == PWR_SAVE);
 }
 
-static inline PUCHAR STA_Build_ARalink_Frame_Header(
-	IN RTMP_ADAPTER *pAd,
-	IN TX_BLK		*pTxBlk)
+static inline PUCHAR STA_Build_ARalink_Frame_Header(IN RTMP_ADAPTER * pAd,
+						    IN TX_BLK * pTxBlk)
 {
-	PUCHAR			pHeaderBufPtr;
-	HEADER_802_11	*pHeader_802_11;
-	PNDIS_PACKET	pNextPacket;
-	UINT32			nextBufLen;
-	PQUEUE_ENTRY	pQEntry;
+	PUCHAR pHeaderBufPtr;
+	HEADER_802_11 *pHeader_802_11;
+	PNDIS_PACKET pNextPacket;
+	UINT32 nextBufLen;
+	PQUEUE_ENTRY pQEntry;
 
 	STAFindCipherAlgorithm(pAd, pTxBlk);
 	STABuildCommon802_11Header(pAd, pTxBlk);
 
-
 	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
 	pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
@@ -1591,22 +1577,20 @@ static inline PUCHAR STA_Build_ARalink_Frame_Header(
 	// skip common header
 	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
-	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM))
-	{
+	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
 		//
 		// build QOS Control bytes
 		//
 		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
 
-		*(pHeaderBufPtr+1) = 0;
-		pHeaderBufPtr +=2;
+		*(pHeaderBufPtr + 1) = 0;
+		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 	}
-
 	// padding at front of LLC header. LLC header should at 4-bytes aligment.
-	pTxBlk->HdrPadLen = (ULONG)pHeaderBufPtr;
-	pHeaderBufPtr = (PUCHAR)ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (ULONG)(pHeaderBufPtr - pTxBlk->HdrPadLen);
+	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
+	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
+	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
 	// For RA Aggregation,
 	// put the 2nd MSDU length(extra 2-byte field) after QOS_CONTROL in little endian format
@@ -1616,8 +1600,8 @@ static inline PUCHAR STA_Build_ARalink_Frame_Header(
 	if (RTMP_GET_PACKET_VLAN(pNextPacket))
 		nextBufLen -= LENGTH_802_1Q;
 
-	*pHeaderBufPtr = (UCHAR)nextBufLen & 0xff;
-	*(pHeaderBufPtr+1) = (UCHAR)(nextBufLen >> 8);
+	*pHeaderBufPtr = (UCHAR) nextBufLen & 0xff;
+	*(pHeaderBufPtr + 1) = (UCHAR) (nextBufLen >> 8);
 
 	pHeaderBufPtr += 2;
 	pTxBlk->MpduHeaderLen += 2;
@@ -1626,13 +1610,11 @@ static inline PUCHAR STA_Build_ARalink_Frame_Header(
 
 }
 
-static inline PUCHAR STA_Build_AMSDU_Frame_Header(
-	IN RTMP_ADAPTER *pAd,
-	IN TX_BLK		*pTxBlk)
+static inline PUCHAR STA_Build_AMSDU_Frame_Header(IN RTMP_ADAPTER * pAd,
+						  IN TX_BLK * pTxBlk)
 {
-	PUCHAR			pHeaderBufPtr;//, pSaveBufPtr;
-	HEADER_802_11	*pHeader_802_11;
-
+	PUCHAR pHeaderBufPtr;	//, pSaveBufPtr;
+	HEADER_802_11 *pHeader_802_11;
 
 	STAFindCipherAlgorithm(pAd, pTxBlk);
 	STABuildCommon802_11Header(pAd, pTxBlk);
@@ -1653,8 +1635,8 @@ static inline PUCHAR STA_Build_AMSDU_Frame_Header(
 	//
 	*pHeaderBufPtr |= 0x80;
 
-	*(pHeaderBufPtr+1) = 0;
-	pHeaderBufPtr +=2;
+	*(pHeaderBufPtr + 1) = 0;
+	pHeaderBufPtr += 2;
 	pTxBlk->MpduHeaderLen += 2;
 
 	//pSaveBufPtr = pHeaderBufPtr;
@@ -1665,57 +1647,56 @@ static inline PUCHAR STA_Build_AMSDU_Frame_Header(
 	//
 	// @@@ MpduHeaderLen excluding padding @@@
 	//
-	pTxBlk->HdrPadLen = (ULONG)pHeaderBufPtr;
+	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (ULONG)(pHeaderBufPtr - pTxBlk->HdrPadLen);
+	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
 	return pHeaderBufPtr;
 
 }
 
-
-VOID STA_AMPDU_Frame_Tx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk)
+VOID STA_AMPDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
-	HEADER_802_11	*pHeader_802_11;
-	PUCHAR			pHeaderBufPtr;
-	USHORT			FreeNumber;
-	MAC_TABLE_ENTRY	*pMacEntry;
-	BOOLEAN			bVLANPkt;
-	PQUEUE_ENTRY	pQEntry;
+	HEADER_802_11 *pHeader_802_11;
+	PUCHAR pHeaderBufPtr;
+	USHORT FreeNumber;
+	MAC_TABLE_ENTRY *pMacEntry;
+	BOOLEAN bVLANPkt;
+	PQUEUE_ENTRY pQEntry;
 
 	ASSERT(pTxBlk);
 
-	while(pTxBlk->TxPacketList.Head)
-	{
+	while (pTxBlk->TxPacketList.Head) {
 		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
 		pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-		if ( RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE)
-		{
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
+		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
+			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
+					    NDIS_STATUS_FAILURE);
 			continue;
 		}
 
-		bVLANPkt = (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
+		bVLANPkt =
+		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
 
 		pMacEntry = pTxBlk->pMacEntry;
-		if (pMacEntry->isCached)
-		{
+		if (pMacEntry->isCached) {
 			// NOTE: Please make sure the size of pMacEntry->CachedBuf[] is smaller than pTxBlk->HeaderBuf[]!!!!
-			NdisMoveMemory((PUCHAR)&pTxBlk->HeaderBuf[TXINFO_SIZE], (PUCHAR)&pMacEntry->CachedBuf[0], TXWI_SIZE + sizeof(HEADER_802_11));
-			pHeaderBufPtr = (PUCHAR)(&pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE]);
+			NdisMoveMemory((PUCHAR) & pTxBlk->
+				       HeaderBuf[TXINFO_SIZE],
+				       (PUCHAR) & pMacEntry->CachedBuf[0],
+				       TXWI_SIZE + sizeof(HEADER_802_11));
+			pHeaderBufPtr =
+			    (PUCHAR) (&pTxBlk->
+				      HeaderBuf[TXINFO_SIZE + TXWI_SIZE]);
 			STABuildCache802_11Header(pAd, pTxBlk, pHeaderBufPtr);
-		}
-		else
-		{
+		} else {
 			STAFindCipherAlgorithm(pAd, pTxBlk);
 			STABuildCommon802_11Header(pAd, pTxBlk);
 
-			pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
+			pHeaderBufPtr =
+			    &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
 		}
 
-
 		pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
 		// skip common header
@@ -1725,87 +1706,101 @@ VOID STA_AMPDU_Frame_Tx(
 		// build QOS Control bytes
 		//
 		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
-		*(pHeaderBufPtr+1) = 0;
-		pHeaderBufPtr +=2;
+		*(pHeaderBufPtr + 1) = 0;
+		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 
 		//
 		// build HTC+
 		// HTC control filed following QoS field
 		//
-		if ((pAd->CommonCfg.bRdg == TRUE) && CLIENT_STATUS_TEST_FLAG(pTxBlk->pMacEntry, fCLIENT_STATUS_RDG_CAPABLE))
-		{
-			if (pMacEntry->isCached == FALSE)
-			{
+		if ((pAd->CommonCfg.bRdg == TRUE)
+		    && CLIENT_STATUS_TEST_FLAG(pTxBlk->pMacEntry,
+					       fCLIENT_STATUS_RDG_CAPABLE)) {
+			if (pMacEntry->isCached == FALSE) {
 				// mark HTC bit
 				pHeader_802_11->FC.Order = 1;
 
 				NdisZeroMemory(pHeaderBufPtr, 4);
-				*(pHeaderBufPtr+3) |= 0x80;
+				*(pHeaderBufPtr + 3) |= 0x80;
 			}
 			pHeaderBufPtr += 4;
 			pTxBlk->MpduHeaderLen += 4;
 		}
-
 		//pTxBlk->MpduHeaderLen = pHeaderBufPtr - pTxBlk->HeaderBuf - TXWI_SIZE - TXINFO_SIZE;
 		ASSERT(pTxBlk->MpduHeaderLen >= 24);
 
 		// skip 802.3 header
 		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-		pTxBlk->SrcBufLen  -= LENGTH_802_3;
+		pTxBlk->SrcBufLen -= LENGTH_802_3;
 
 		// skip vlan tag
-		if (bVLANPkt)
-		{
-			pTxBlk->pSrcBufData	+= LENGTH_802_1Q;
-			pTxBlk->SrcBufLen	-= LENGTH_802_1Q;
+		if (bVLANPkt) {
+			pTxBlk->pSrcBufData += LENGTH_802_1Q;
+			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
 		}
-
 		//
 		// padding at front of LLC header
 		// LLC header should locate at 4-octets aligment
 		//
 		// @@@ MpduHeaderLen excluding padding @@@
 		//
-		pTxBlk->HdrPadLen = (ULONG)pHeaderBufPtr;
+		pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 		pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
-		pTxBlk->HdrPadLen = (ULONG)(pHeaderBufPtr - pTxBlk->HdrPadLen);
+		pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
 		{
 
 			//
 			// Insert LLC-SNAP encapsulation - 8 octets
 			//
-			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->pSrcBufData-2, pTxBlk->pExtraLlcSnapEncap);
-			if (pTxBlk->pExtraLlcSnapEncap)
-			{
-				NdisMoveMemory(pHeaderBufPtr, pTxBlk->pExtraLlcSnapEncap, 6);
+			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->
+							    pSrcBufData - 2,
+							    pTxBlk->
+							    pExtraLlcSnapEncap);
+			if (pTxBlk->pExtraLlcSnapEncap) {
+				NdisMoveMemory(pHeaderBufPtr,
+					       pTxBlk->pExtraLlcSnapEncap, 6);
 				pHeaderBufPtr += 6;
 				// get 2 octets (TypeofLen)
-				NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData-2, 2);
+				NdisMoveMemory(pHeaderBufPtr,
+					       pTxBlk->pSrcBufData - 2, 2);
 				pHeaderBufPtr += 2;
 				pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 			}
 
 		}
 
-		if (pMacEntry->isCached)
-		{
-            RTMPWriteTxWI_Cache(pAd, (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]), pTxBlk);
-		}
-		else
-		{
-			RTMPWriteTxWI_Data(pAd, (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]), pTxBlk);
-
-			NdisZeroMemory((PUCHAR)(&pMacEntry->CachedBuf[0]), sizeof(pMacEntry->CachedBuf));
-			NdisMoveMemory((PUCHAR)(&pMacEntry->CachedBuf[0]), (PUCHAR)(&pTxBlk->HeaderBuf[TXINFO_SIZE]), (pHeaderBufPtr - (PUCHAR)(&pTxBlk->HeaderBuf[TXINFO_SIZE])));
+		if (pMacEntry->isCached) {
+			RTMPWriteTxWI_Cache(pAd,
+					    (PTXWI_STRUC) (&pTxBlk->
+							   HeaderBuf
+							   [TXINFO_SIZE]),
+					    pTxBlk);
+		} else {
+			RTMPWriteTxWI_Data(pAd,
+					   (PTXWI_STRUC) (&pTxBlk->
+							  HeaderBuf
+							  [TXINFO_SIZE]),
+					   pTxBlk);
+
+			NdisZeroMemory((PUCHAR) (&pMacEntry->CachedBuf[0]),
+				       sizeof(pMacEntry->CachedBuf));
+			NdisMoveMemory((PUCHAR) (&pMacEntry->CachedBuf[0]),
+				       (PUCHAR) (&pTxBlk->
+						 HeaderBuf[TXINFO_SIZE]),
+				       (pHeaderBufPtr -
+					(PUCHAR) (&pTxBlk->
+						  HeaderBuf[TXINFO_SIZE])));
 			pMacEntry->isCached = TRUE;
 		}
 
 		// calculate Transmitted AMPDU count and ByteCount
 		{
-			pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.LowPart ++;
-			pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.QuadPart += pTxBlk->SrcBufLen;
+			pAd->RalinkCounters.TransmittedMPDUsInAMPDUCount.u.
+			    LowPart++;
+			pAd->RalinkCounters.TransmittedOctetsInAMPDUCount.
+			    QuadPart += pTxBlk->SrcBufLen;
 		}
 
 		//FreeNumber = GET_TXRING_FREENO(pAd, QueIdx);
@@ -1824,62 +1819,64 @@ VOID STA_AMPDU_Frame_Tx(
 
 }
 
-
-VOID STA_AMSDU_Frame_Tx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk)
+VOID STA_AMSDU_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
-	PUCHAR			pHeaderBufPtr;
-	USHORT			FreeNumber;
-	USHORT			subFramePayloadLen = 0;	// AMSDU Subframe length without AMSDU-Header / Padding.
-	USHORT			totalMPDUSize=0;
-	UCHAR			*subFrameHeader;
-	UCHAR			padding = 0;
-	USHORT			FirstTx = 0, LastTxIdx = 0;
-	BOOLEAN			bVLANPkt;
-	int 			frameNum = 0;
-	PQUEUE_ENTRY	pQEntry;
-
+	PUCHAR pHeaderBufPtr;
+	USHORT FreeNumber;
+	USHORT subFramePayloadLen = 0;	// AMSDU Subframe length without AMSDU-Header / Padding.
+	USHORT totalMPDUSize = 0;
+	UCHAR *subFrameHeader;
+	UCHAR padding = 0;
+	USHORT FirstTx = 0, LastTxIdx = 0;
+	BOOLEAN bVLANPkt;
+	int frameNum = 0;
+	PQUEUE_ENTRY pQEntry;
 
 	ASSERT(pTxBlk);
 
 	ASSERT((pTxBlk->TxPacketList.Number > 1));
 
-	while(pTxBlk->TxPacketList.Head)
-	{
+	while (pTxBlk->TxPacketList.Head) {
 		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
 		pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE)
-		{
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
+		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
+			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
+					    NDIS_STATUS_FAILURE);
 			continue;
 		}
 
-		bVLANPkt = (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
+		bVLANPkt =
+		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
 
 		// skip 802.3 header
 		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-		pTxBlk->SrcBufLen  -= LENGTH_802_3;
+		pTxBlk->SrcBufLen -= LENGTH_802_3;
 
 		// skip vlan tag
-		if (bVLANPkt)
-		{
-			pTxBlk->pSrcBufData	+= LENGTH_802_1Q;
-			pTxBlk->SrcBufLen	-= LENGTH_802_1Q;
+		if (bVLANPkt) {
+			pTxBlk->pSrcBufData += LENGTH_802_1Q;
+			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
 		}
 
-		if (frameNum == 0)
-		{
-			pHeaderBufPtr = STA_Build_AMSDU_Frame_Header(pAd, pTxBlk);
+		if (frameNum == 0) {
+			pHeaderBufPtr =
+			    STA_Build_AMSDU_Frame_Header(pAd, pTxBlk);
 
 			// NOTE: TxWI->MPDUtotalByteCount will be updated after final frame was handled.
-			RTMPWriteTxWI_Data(pAd, (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]), pTxBlk);
-		}
-		else
-		{
+			RTMPWriteTxWI_Data(pAd,
+					   (PTXWI_STRUC) (&pTxBlk->
+							  HeaderBuf
+							  [TXINFO_SIZE]),
+					   pTxBlk);
+		} else {
 			pHeaderBufPtr = &pTxBlk->HeaderBuf[0];
-			padding = ROUND_UP(LENGTH_AMSDU_SUBFRAMEHEAD + subFramePayloadLen, 4) - (LENGTH_AMSDU_SUBFRAMEHEAD + subFramePayloadLen);
-			NdisZeroMemory(pHeaderBufPtr, padding + LENGTH_AMSDU_SUBFRAMEHEAD);
+			padding =
+			    ROUND_UP(LENGTH_AMSDU_SUBFRAMEHEAD +
+				     subFramePayloadLen,
+				     4) - (LENGTH_AMSDU_SUBFRAMEHEAD +
+					   subFramePayloadLen);
+			NdisZeroMemory(pHeaderBufPtr,
+				       padding + LENGTH_AMSDU_SUBFRAMEHEAD);
 			pHeaderBufPtr += padding;
 			pTxBlk->MpduHeaderLen = padding;
 		}
@@ -1893,39 +1890,42 @@ VOID STA_AMSDU_Frame_Tx(
 
 		NdisMoveMemory(subFrameHeader, pTxBlk->pSrcBufHeader, 12);
 
-
 		pHeaderBufPtr += LENGTH_AMSDU_SUBFRAMEHEAD;
 		pTxBlk->MpduHeaderLen += LENGTH_AMSDU_SUBFRAMEHEAD;
 
-
 		//
 		// Insert LLC-SNAP encapsulation - 8 octets
 		//
-		EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->pSrcBufData-2, pTxBlk->pExtraLlcSnapEncap);
+		EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->pSrcBufData - 2,
+						    pTxBlk->pExtraLlcSnapEncap);
 
 		subFramePayloadLen = pTxBlk->SrcBufLen;
 
-		if (pTxBlk->pExtraLlcSnapEncap)
-		{
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pExtraLlcSnapEncap, 6);
+		if (pTxBlk->pExtraLlcSnapEncap) {
+			NdisMoveMemory(pHeaderBufPtr,
+				       pTxBlk->pExtraLlcSnapEncap, 6);
 			pHeaderBufPtr += 6;
 			// get 2 octets (TypeofLen)
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData-2, 2);
+			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData - 2,
+				       2);
 			pHeaderBufPtr += 2;
 			pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 			subFramePayloadLen += LENGTH_802_1_H;
 		}
-
 		// update subFrame Length field
 		subFrameHeader[12] = (subFramePayloadLen & 0xFF00) >> 8;
 		subFrameHeader[13] = subFramePayloadLen & 0xFF;
 
 		totalMPDUSize += pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
 
-		if (frameNum ==0)
-			FirstTx = HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum, &FreeNumber);
+		if (frameNum == 0)
+			FirstTx =
+			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
+						     &FreeNumber);
 		else
-			LastTxIdx = HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum, &FreeNumber);
+			LastTxIdx =
+			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
+						     &FreeNumber);
 
 		frameNum++;
 
@@ -1934,8 +1934,9 @@ VOID STA_AMSDU_Frame_Tx(
 
 		// calculate Transmitted AMSDU Count and ByteCount
 		{
-			pAd->RalinkCounters.TransmittedAMSDUCount.u.LowPart ++;
-			pAd->RalinkCounters.TransmittedOctetsInAMSDU.QuadPart += totalMPDUSize;
+			pAd->RalinkCounters.TransmittedAMSDUCount.u.LowPart++;
+			pAd->RalinkCounters.TransmittedOctetsInAMSDU.QuadPart +=
+			    totalMPDUSize;
 		}
 
 	}
@@ -1950,29 +1951,24 @@ VOID STA_AMSDU_Frame_Tx(
 		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 }
 
-VOID STA_Legacy_Frame_Tx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk)
+VOID STA_Legacy_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
-	HEADER_802_11	*pHeader_802_11;
-	PUCHAR			pHeaderBufPtr;
-	USHORT			FreeNumber;
-	BOOLEAN			bVLANPkt;
-	PQUEUE_ENTRY	pQEntry;
+	HEADER_802_11 *pHeader_802_11;
+	PUCHAR pHeaderBufPtr;
+	USHORT FreeNumber;
+	BOOLEAN bVLANPkt;
+	PQUEUE_ENTRY pQEntry;
 
 	ASSERT(pTxBlk);
 
-
 	pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
 	pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-	if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE)
-	{
+	if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
 		RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
 		return;
 	}
 
-	if (pTxBlk->TxFrameType == TX_MCAST_FRAME)
-	{
+	if (pTxBlk->TxFrameType == TX_MCAST_FRAME) {
 		INC_COUNTER64(pAd->WlanCounters.MulticastTransmittedFrameCount);
 	}
 
@@ -1989,16 +1985,14 @@ VOID STA_Legacy_Frame_Tx(
 	STAFindCipherAlgorithm(pAd, pTxBlk);
 	STABuildCommon802_11Header(pAd, pTxBlk);
 
-
 	// skip 802.3 header
 	pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-	pTxBlk->SrcBufLen  -= LENGTH_802_3;
+	pTxBlk->SrcBufLen -= LENGTH_802_3;
 
 	// skip vlan tag
-	if (bVLANPkt)
-	{
-		pTxBlk->pSrcBufData	+= LENGTH_802_1Q;
-		pTxBlk->SrcBufLen	-= LENGTH_802_1Q;
+	if (bVLANPkt) {
+		pTxBlk->pSrcBufData += LENGTH_802_1Q;
+		pTxBlk->SrcBufLen -= LENGTH_802_1Q;
 	}
 
 	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
@@ -2007,21 +2001,22 @@ VOID STA_Legacy_Frame_Tx(
 	// skip common header
 	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
-	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM))
-	{
+	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
 		//
 		// build QOS Control bytes
 		//
-		*(pHeaderBufPtr) = ((pTxBlk->UserPriority & 0x0F) | (pAd->CommonCfg.AckPolicy[pTxBlk->QueIdx]<<5));
-		*(pHeaderBufPtr+1) = 0;
-		pHeaderBufPtr +=2;
+		*(pHeaderBufPtr) =
+		    ((pTxBlk->UserPriority & 0x0F) | (pAd->CommonCfg.
+						      AckPolicy[pTxBlk->
+								QueIdx] << 5));
+		*(pHeaderBufPtr + 1) = 0;
+		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 	}
-
 	// The remaining content of MPDU header should locate at 4-octets aligment
-	pTxBlk->HdrPadLen = (ULONG)pHeaderBufPtr;
+	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (ULONG)(pHeaderBufPtr - pTxBlk->HdrPadLen);
+	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
 	{
 
@@ -2029,20 +2024,23 @@ VOID STA_Legacy_Frame_Tx(
 		// Insert LLC-SNAP encapsulation - 8 octets
 		//
 		//
-   		// if original Ethernet frame contains no LLC/SNAP,
+		// if original Ethernet frame contains no LLC/SNAP,
 		// then an extra LLC/SNAP encap is required
 		//
-		EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader, pTxBlk->pExtraLlcSnapEncap);
-		if (pTxBlk->pExtraLlcSnapEncap)
-		{
+		EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader,
+						   pTxBlk->pExtraLlcSnapEncap);
+		if (pTxBlk->pExtraLlcSnapEncap) {
 			UCHAR vlan_size;
 
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pExtraLlcSnapEncap, 6);
+			NdisMoveMemory(pHeaderBufPtr,
+				       pTxBlk->pExtraLlcSnapEncap, 6);
 			pHeaderBufPtr += 6;
 			// skip vlan tag
-			vlan_size =  (bVLANPkt) ? LENGTH_802_1Q : 0;
+			vlan_size = (bVLANPkt) ? LENGTH_802_1Q : 0;
 			// get 2 octets (TypeofLen)
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufHeader+12+vlan_size, 2);
+			NdisMoveMemory(pHeaderBufPtr,
+				       pTxBlk->pSrcBufHeader + 12 + vlan_size,
+				       2);
 			pHeaderBufPtr += 2;
 			pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 		}
@@ -2054,7 +2052,8 @@ VOID STA_Legacy_Frame_Tx(
 	// use Wcid as Key Index
 	//
 
-	RTMPWriteTxWI_Data(pAd, (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]), pTxBlk);
+	RTMPWriteTxWI_Data(pAd, (PTXWI_STRUC) (&pTxBlk->HeaderBuf[TXINFO_SIZE]),
+			   pTxBlk);
 
 	//FreeNumber = GET_TXRING_FREENO(pAd, QueIdx);
 
@@ -2070,87 +2069,88 @@ VOID STA_Legacy_Frame_Tx(
 		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 }
 
-
-VOID STA_ARalink_Frame_Tx(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	TX_BLK			*pTxBlk)
+VOID STA_ARalink_Frame_Tx(IN PRTMP_ADAPTER pAd, IN TX_BLK * pTxBlk)
 {
-	PUCHAR			pHeaderBufPtr;
-	USHORT			FreeNumber;
-	USHORT			totalMPDUSize=0;
-	USHORT			FirstTx, LastTxIdx;
-	int 			frameNum = 0;
-	BOOLEAN			bVLANPkt;
-	PQUEUE_ENTRY	pQEntry;
-
+	PUCHAR pHeaderBufPtr;
+	USHORT FreeNumber;
+	USHORT totalMPDUSize = 0;
+	USHORT FirstTx, LastTxIdx;
+	int frameNum = 0;
+	BOOLEAN bVLANPkt;
+	PQUEUE_ENTRY pQEntry;
 
 	ASSERT(pTxBlk);
 
-	ASSERT((pTxBlk->TxPacketList.Number== 2));
+	ASSERT((pTxBlk->TxPacketList.Number == 2));
 
-
-	FirstTx = LastTxIdx = 0;  // Is it ok init they as 0?
-	while(pTxBlk->TxPacketList.Head)
-	{
+	FirstTx = LastTxIdx = 0;	// Is it ok init they as 0?
+	while (pTxBlk->TxPacketList.Head) {
 		pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
 		pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
 
-		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE)
-		{
-			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
+		if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
+			RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket,
+					    NDIS_STATUS_FAILURE);
 			continue;
 		}
 
-		bVLANPkt = (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
+		bVLANPkt =
+		    (RTMP_GET_PACKET_VLAN(pTxBlk->pPacket) ? TRUE : FALSE);
 
 		// skip 802.3 header
 		pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-		pTxBlk->SrcBufLen  -= LENGTH_802_3;
+		pTxBlk->SrcBufLen -= LENGTH_802_3;
 
 		// skip vlan tag
-		if (bVLANPkt)
-		{
-			pTxBlk->pSrcBufData	+= LENGTH_802_1Q;
-			pTxBlk->SrcBufLen	-= LENGTH_802_1Q;
+		if (bVLANPkt) {
+			pTxBlk->pSrcBufData += LENGTH_802_1Q;
+			pTxBlk->SrcBufLen -= LENGTH_802_1Q;
 		}
 
-		if (frameNum == 0)
-		{	// For first frame, we need to create the 802.11 header + padding(optional) + RA-AGG-LEN + SNAP Header
+		if (frameNum == 0) {	// For first frame, we need to create the 802.11 header + padding(optional) + RA-AGG-LEN + SNAP Header
 
-			pHeaderBufPtr = STA_Build_ARalink_Frame_Header(pAd, pTxBlk);
+			pHeaderBufPtr =
+			    STA_Build_ARalink_Frame_Header(pAd, pTxBlk);
 
 			// It's ok write the TxWI here, because the TxWI->MPDUtotalByteCount
-			//	will be updated after final frame was handled.
-			RTMPWriteTxWI_Data(pAd, (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]), pTxBlk);
-
+			//      will be updated after final frame was handled.
+			RTMPWriteTxWI_Data(pAd,
+					   (PTXWI_STRUC) (&pTxBlk->
+							  HeaderBuf
+							  [TXINFO_SIZE]),
+					   pTxBlk);
 
 			//
 			// Insert LLC-SNAP encapsulation - 8 octets
 			//
-			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->pSrcBufData-2, pTxBlk->pExtraLlcSnapEncap);
-
-			if (pTxBlk->pExtraLlcSnapEncap)
-			{
-				NdisMoveMemory(pHeaderBufPtr, pTxBlk->pExtraLlcSnapEncap, 6);
+			EXTRA_LLCSNAP_ENCAP_FROM_PKT_OFFSET(pTxBlk->
+							    pSrcBufData - 2,
+							    pTxBlk->
+							    pExtraLlcSnapEncap);
+
+			if (pTxBlk->pExtraLlcSnapEncap) {
+				NdisMoveMemory(pHeaderBufPtr,
+					       pTxBlk->pExtraLlcSnapEncap, 6);
 				pHeaderBufPtr += 6;
 				// get 2 octets (TypeofLen)
-				NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData-2, 2);
+				NdisMoveMemory(pHeaderBufPtr,
+					       pTxBlk->pSrcBufData - 2, 2);
 				pHeaderBufPtr += 2;
 				pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 			}
-		}
-		else
-		{	// For second aggregated frame, we need create the 802.3 header to headerBuf, because PCI will copy it to SDPtr0.
+		} else {	// For second aggregated frame, we need create the 802.3 header to headerBuf, because PCI will copy it to SDPtr0.
 
 			pHeaderBufPtr = &pTxBlk->HeaderBuf[0];
 			pTxBlk->MpduHeaderLen = 0;
 
 			// A-Ralink sub-sequent frame header is the same as 802.3 header.
 			//   DA(6)+SA(6)+FrameType(2)
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufHeader, 12);
+			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufHeader,
+				       12);
 			pHeaderBufPtr += 12;
 			// get 2 octets (TypeofLen)
-			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData-2, 2);
+			NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufData - 2,
+				       2);
 			pHeaderBufPtr += 2;
 			pTxBlk->MpduHeaderLen = LENGTH_ARALINK_SUBFRAMEHEAD;
 		}
@@ -2158,10 +2158,14 @@ VOID STA_ARalink_Frame_Tx(
 		totalMPDUSize += pTxBlk->MpduHeaderLen + pTxBlk->SrcBufLen;
 
 		//FreeNumber = GET_TXRING_FREENO(pAd, QueIdx);
-		if (frameNum ==0)
-			FirstTx = HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum, &FreeNumber);
+		if (frameNum == 0)
+			FirstTx =
+			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
+						     &FreeNumber);
 		else
-			LastTxIdx = HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum, &FreeNumber);
+			LastTxIdx =
+			    HAL_WriteMultiTxResource(pAd, pTxBlk, frameNum,
+						     &FreeNumber);
 
 		frameNum++;
 
@@ -2182,31 +2186,26 @@ VOID STA_ARalink_Frame_Tx(
 
 }
 
-
-VOID STA_Fragment_Frame_Tx(
-	IN RTMP_ADAPTER *pAd,
-	IN TX_BLK		*pTxBlk)
+VOID STA_Fragment_Frame_Tx(IN RTMP_ADAPTER * pAd, IN TX_BLK * pTxBlk)
 {
-	HEADER_802_11	*pHeader_802_11;
-	PUCHAR			pHeaderBufPtr;
-	USHORT			FreeNumber;
-	UCHAR 			fragNum = 0;
-	PACKET_INFO		PacketInfo;
-	USHORT			EncryptionOverhead = 0;
-	UINT32			FreeMpduSize, SrcRemainingBytes;
-	USHORT			AckDuration;
-	UINT 			NextMpduSize;
-	BOOLEAN			bVLANPkt;
-	PQUEUE_ENTRY	pQEntry;
-	HTTRANSMIT_SETTING	*pTransmit;
-
+	HEADER_802_11 *pHeader_802_11;
+	PUCHAR pHeaderBufPtr;
+	USHORT FreeNumber;
+	UCHAR fragNum = 0;
+	PACKET_INFO PacketInfo;
+	USHORT EncryptionOverhead = 0;
+	UINT32 FreeMpduSize, SrcRemainingBytes;
+	USHORT AckDuration;
+	UINT NextMpduSize;
+	BOOLEAN bVLANPkt;
+	PQUEUE_ENTRY pQEntry;
+	HTTRANSMIT_SETTING *pTransmit;
 
 	ASSERT(pTxBlk);
 
 	pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
 	pTxBlk->pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-	if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE)
-	{
+	if (RTMP_FillTxBlkInfo(pAd, pTxBlk) != TRUE) {
 		RELEASE_NDIS_PACKET(pAd, pTxBlk->pPacket, NDIS_STATUS_FAILURE);
 		return;
 	}
@@ -2217,104 +2216,100 @@ VOID STA_Fragment_Frame_Tx(
 	STAFindCipherAlgorithm(pAd, pTxBlk);
 	STABuildCommon802_11Header(pAd, pTxBlk);
 
-	if (pTxBlk->CipherAlg == CIPHER_TKIP)
-	{
-		pTxBlk->pPacket = duplicate_pkt_with_TKIP_MIC(pAd, pTxBlk->pPacket);
+	if (pTxBlk->CipherAlg == CIPHER_TKIP) {
+		pTxBlk->pPacket =
+		    duplicate_pkt_with_TKIP_MIC(pAd, pTxBlk->pPacket);
 		if (pTxBlk->pPacket == NULL)
 			return;
-		RTMP_QueryPacketInfo(pTxBlk->pPacket, &PacketInfo, &pTxBlk->pSrcBufHeader, &pTxBlk->SrcBufLen);
+		RTMP_QueryPacketInfo(pTxBlk->pPacket, &PacketInfo,
+				     &pTxBlk->pSrcBufHeader,
+				     &pTxBlk->SrcBufLen);
 	}
-
 	// skip 802.3 header
 	pTxBlk->pSrcBufData = pTxBlk->pSrcBufHeader + LENGTH_802_3;
-	pTxBlk->SrcBufLen  -= LENGTH_802_3;
-
+	pTxBlk->SrcBufLen -= LENGTH_802_3;
 
 	// skip vlan tag
-	if (bVLANPkt)
-	{
-		pTxBlk->pSrcBufData	+= LENGTH_802_1Q;
-		pTxBlk->SrcBufLen	-= LENGTH_802_1Q;
+	if (bVLANPkt) {
+		pTxBlk->pSrcBufData += LENGTH_802_1Q;
+		pTxBlk->SrcBufLen -= LENGTH_802_1Q;
 	}
 
 	pHeaderBufPtr = &pTxBlk->HeaderBuf[TXINFO_SIZE + TXWI_SIZE];
-	pHeader_802_11 = (HEADER_802_11 *)pHeaderBufPtr;
-
+	pHeader_802_11 = (HEADER_802_11 *) pHeaderBufPtr;
 
 	// skip common header
 	pHeaderBufPtr += pTxBlk->MpduHeaderLen;
 
-	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM))
-	{
+	if (TX_BLK_TEST_FLAG(pTxBlk, fTX_bWMM)) {
 		//
 		// build QOS Control bytes
 		//
 		*pHeaderBufPtr = (pTxBlk->UserPriority & 0x0F);
 
-		*(pHeaderBufPtr+1) = 0;
-		pHeaderBufPtr +=2;
+		*(pHeaderBufPtr + 1) = 0;
+		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += 2;
 	}
-
 	//
 	// padding at front of LLC header
 	// LLC header should locate at 4-octets aligment
 	//
-	pTxBlk->HdrPadLen = (ULONG)pHeaderBufPtr;
+	pTxBlk->HdrPadLen = (ULONG) pHeaderBufPtr;
 	pHeaderBufPtr = (PUCHAR) ROUND_UP(pHeaderBufPtr, 4);
-	pTxBlk->HdrPadLen = (ULONG)(pHeaderBufPtr - pTxBlk->HdrPadLen);
-
-
+	pTxBlk->HdrPadLen = (ULONG) (pHeaderBufPtr - pTxBlk->HdrPadLen);
 
 	//
 	// Insert LLC-SNAP encapsulation - 8 octets
 	//
 	//
-   	// if original Ethernet frame contains no LLC/SNAP,
+	// if original Ethernet frame contains no LLC/SNAP,
 	// then an extra LLC/SNAP encap is required
 	//
-	EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader, pTxBlk->pExtraLlcSnapEncap);
-	if (pTxBlk->pExtraLlcSnapEncap)
-	{
+	EXTRA_LLCSNAP_ENCAP_FROM_PKT_START(pTxBlk->pSrcBufHeader,
+					   pTxBlk->pExtraLlcSnapEncap);
+	if (pTxBlk->pExtraLlcSnapEncap) {
 		UCHAR vlan_size;
 
 		NdisMoveMemory(pHeaderBufPtr, pTxBlk->pExtraLlcSnapEncap, 6);
 		pHeaderBufPtr += 6;
 		// skip vlan tag
-		vlan_size =  (bVLANPkt) ? LENGTH_802_1Q : 0;
+		vlan_size = (bVLANPkt) ? LENGTH_802_1Q : 0;
 		// get 2 octets (TypeofLen)
-		NdisMoveMemory(pHeaderBufPtr, pTxBlk->pSrcBufHeader+12+vlan_size, 2);
+		NdisMoveMemory(pHeaderBufPtr,
+			       pTxBlk->pSrcBufHeader + 12 + vlan_size, 2);
 		pHeaderBufPtr += 2;
 		pTxBlk->MpduHeaderLen += LENGTH_802_1_H;
 	}
 
-
 	// If TKIP is used and fragmentation is required. Driver has to
-	//	append TKIP MIC at tail of the scatter buffer
-	//	MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC
-	if (pTxBlk->CipherAlg == CIPHER_TKIP)
-	{
-		RTMPCalculateMICValue(pAd, pTxBlk->pPacket, pTxBlk->pExtraLlcSnapEncap, pTxBlk->pKey, 0);
+	//      append TKIP MIC at tail of the scatter buffer
+	//      MAC ASIC will only perform IV/EIV/ICV insertion but no TKIP MIC
+	if (pTxBlk->CipherAlg == CIPHER_TKIP) {
+		RTMPCalculateMICValue(pAd, pTxBlk->pPacket,
+				      pTxBlk->pExtraLlcSnapEncap, pTxBlk->pKey,
+				      0);
 
 		// NOTE: DON'T refer the skb->len directly after following copy. Becasue the length is not adjust
-		//			to correct lenght, refer to pTxBlk->SrcBufLen for the packet length in following progress.
-		NdisMoveMemory(pTxBlk->pSrcBufData + pTxBlk->SrcBufLen, &pAd->PrivateInfo.Tx.MIC[0], 8);
+		//                      to correct lenght, refer to pTxBlk->SrcBufLen for the packet length in following progress.
+		NdisMoveMemory(pTxBlk->pSrcBufData + pTxBlk->SrcBufLen,
+			       &pAd->PrivateInfo.Tx.MIC[0], 8);
 		//skb_put((RTPKT_TO_OSPKT(pTxBlk->pPacket))->tail, 8);
 		pTxBlk->SrcBufLen += 8;
 		pTxBlk->TotalFrameLen += 8;
 		pTxBlk->CipherAlg = CIPHER_TKIP_NO_MIC;
 	}
-
 	//
 	// calcuate the overhead bytes that encryption algorithm may add. This
 	// affects the calculate of "duration" field
 	//
-	if ((pTxBlk->CipherAlg == CIPHER_WEP64) || (pTxBlk->CipherAlg == CIPHER_WEP128))
-		EncryptionOverhead = 8; //WEP: IV[4] + ICV[4];
+	if ((pTxBlk->CipherAlg == CIPHER_WEP64)
+	    || (pTxBlk->CipherAlg == CIPHER_WEP128))
+		EncryptionOverhead = 8;	//WEP: IV[4] + ICV[4];
 	else if (pTxBlk->CipherAlg == CIPHER_TKIP_NO_MIC)
-		EncryptionOverhead = 12;//TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength
+		EncryptionOverhead = 12;	//TKIP: IV[4] + EIV[4] + ICV[4], MIC will be added to TotalPacketLength
 	else if (pTxBlk->CipherAlg == CIPHER_TKIP)
-		EncryptionOverhead = 20;//TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8]
+		EncryptionOverhead = 20;	//TKIP: IV[4] + EIV[4] + ICV[4] + MIC[8]
 	else if (pTxBlk->CipherAlg == CIPHER_AES)
 		EncryptionOverhead = 16;	// AES: IV[4] + EIV[4] + MIC[8]
 	else
@@ -2331,7 +2326,11 @@ VOID STA_Fragment_Frame_Tx(
 
 	// decide how much time an ACK/CTS frame will consume in the air
 	if (pTxBlk->TxRate <= RATE_LAST_OFDM_RATE)
-	AckDuration = RTMPCalcDuration(pAd, pAd->CommonCfg.ExpectedACKRate[pTxBlk->TxRate], 14);
+		AckDuration =
+		    RTMPCalcDuration(pAd,
+				     pAd->CommonCfg.ExpectedACKRate[pTxBlk->
+								    TxRate],
+				     14);
 	else
 		AckDuration = RTMPCalcDuration(pAd, RATE_6_5, 14);
 
@@ -2346,25 +2345,28 @@ VOID STA_Fragment_Frame_Tx(
 
 		FreeMpduSize -= pTxBlk->MpduHeaderLen;
 
-		if (SrcRemainingBytes <= FreeMpduSize)
-		{	// this is the last or only fragment
+		if (SrcRemainingBytes <= FreeMpduSize) {	// this is the last or only fragment
 
 			pTxBlk->SrcBufLen = SrcRemainingBytes;
 
 			pHeader_802_11->FC.MoreFrag = 0;
-			pHeader_802_11->Duration = pAd->CommonCfg.Dsifs + AckDuration;
+			pHeader_802_11->Duration =
+			    pAd->CommonCfg.Dsifs + AckDuration;
 
 			// Indicate the lower layer that this's the last fragment.
 			pTxBlk->TotalFragNum = fragNum;
-		}
-		else
-		{	// more fragment is required
+		} else {	// more fragment is required
 
 			pTxBlk->SrcBufLen = FreeMpduSize;
 
-			NextMpduSize = min(((UINT)SrcRemainingBytes - pTxBlk->SrcBufLen), ((UINT)pAd->CommonCfg.FragmentThreshold));
+			NextMpduSize =
+			    min(((UINT) SrcRemainingBytes - pTxBlk->SrcBufLen),
+				((UINT) pAd->CommonCfg.FragmentThreshold));
 			pHeader_802_11->FC.MoreFrag = 1;
-			pHeader_802_11->Duration = (3 * pAd->CommonCfg.Dsifs) + (2 * AckDuration) + RTMPCalcDuration(pAd, pTxBlk->TxRate, NextMpduSize + EncryptionOverhead);
+			pHeader_802_11->Duration =
+			    (3 * pAd->CommonCfg.Dsifs) + (2 * AckDuration) +
+			    RTMPCalcDuration(pAd, pTxBlk->TxRate,
+					     NextMpduSize + EncryptionOverhead);
 		}
 
 		if (fragNum == 0)
@@ -2372,7 +2374,10 @@ VOID STA_Fragment_Frame_Tx(
 		else
 			pTxBlk->FrameGap = IFS_SIFS;
 
-		RTMPWriteTxWI_Data(pAd, (PTXWI_STRUC)(&pTxBlk->HeaderBuf[TXINFO_SIZE]), pTxBlk);
+		RTMPWriteTxWI_Data(pAd,
+				   (PTXWI_STRUC) (&pTxBlk->
+						  HeaderBuf[TXINFO_SIZE]),
+				   pTxBlk);
 
 		HAL_WriteFragTxResource(pAd, pTxBlk, fragNum, &FreeNumber);
 
@@ -2389,18 +2394,17 @@ VOID STA_Fragment_Frame_Tx(
 		SrcRemainingBytes -= pTxBlk->SrcBufLen;
 		pTxBlk->pSrcBufData += pTxBlk->SrcBufLen;
 
-		pHeader_802_11->Frag++;	 // increase Frag #
+		pHeader_802_11->Frag++;	// increase Frag #
 
-	}while(SrcRemainingBytes > 0);
+	} while (SrcRemainingBytes > 0);
 
 	//
 	// Kick out Tx
 	//
 	if (!RTMP_TEST_PSFLAG(pAd, fRTMP_PS_DISABLE_TX))
-	HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
+		HAL_KickOutTx(pAd, pTxBlk, pTxBlk->QueIdx);
 }
 
-
 #define RELEASE_FRAMES_OF_TXBLK(_pAd, _pTxBlk, _pQEntry, _Status) 										\
 		while(_pTxBlk->TxPacketList.Head)														\
 		{																						\
@@ -2408,7 +2412,6 @@ VOID STA_Fragment_Frame_Tx(
 			RELEASE_NDIS_PACKET(_pAd, QUEUE_ENTRY_TO_PACKET(_pQEntry), _Status);	\
 		}
 
-
 /*
 	========================================================================
 
@@ -2431,22 +2434,21 @@ VOID STA_Fragment_Frame_Tx(
 
 	========================================================================
 */
-NDIS_STATUS STAHardTransmit(
-	IN PRTMP_ADAPTER	pAd,
-	IN TX_BLK 			*pTxBlk,
-	IN	UCHAR			QueIdx)
+NDIS_STATUS STAHardTransmit(IN PRTMP_ADAPTER pAd,
+			    IN TX_BLK * pTxBlk, IN UCHAR QueIdx)
 {
-	NDIS_PACKET		*pPacket;
-	PQUEUE_ENTRY	pQEntry;
+	NDIS_PACKET *pPacket;
+	PQUEUE_ENTRY pQEntry;
 
 	// ---------------------------------------------
 	// STEP 0. DO SANITY CHECK AND SOME EARLY PREPARATION.
 	// ---------------------------------------------
 	//
 	ASSERT(pTxBlk->TxPacketList.Number);
-	if (pTxBlk->TxPacketList.Head == NULL)
-	{
-		DBGPRINT(RT_DEBUG_ERROR, ("pTxBlk->TotalFrameNum == %ld!\n", pTxBlk->TxPacketList.Number));
+	if (pTxBlk->TxPacketList.Head == NULL) {
+		DBGPRINT(RT_DEBUG_ERROR,
+			 ("pTxBlk->TotalFrameNum == %ld!\n",
+			  pTxBlk->TxPacketList.Number));
 		return NDIS_STATUS_FAILURE;
 	}
 
@@ -2454,13 +2456,13 @@ NDIS_STATUS STAHardTransmit(
 
 	// ------------------------------------------------------------------
 	// STEP 1. WAKE UP PHY
-	//		outgoing frame always wakeup PHY to prevent frame lost and
-	//		turn off PSM bit to improve performance
+	//              outgoing frame always wakeup PHY to prevent frame lost and
+	//              turn off PSM bit to improve performance
 	// ------------------------------------------------------------------
 	// not to change PSM bit, just send this frame out?
-	if ((pAd->StaCfg.Psm == PWR_SAVE) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-	{
-	    DBGPRINT_RAW(RT_DEBUG_INFO, ("AsicForceWakeup At HardTx\n"));
+	if ((pAd->StaCfg.Psm == PWR_SAVE)
+	    && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE)) {
+		DBGPRINT_RAW(RT_DEBUG_INFO, ("AsicForceWakeup At HardTx\n"));
 #ifdef RTMP_MAC_PCI
 		AsicForceWakeup(pAd, TRUE);
 #endif // RTMP_MAC_PCI //
@@ -2468,85 +2470,81 @@ NDIS_STATUS STAHardTransmit(
 		RTUSBEnqueueInternalCmd(pAd, CMDTHREAD_FORCE_WAKE_UP, NULL, 0);
 #endif // RTMP_MAC_USB //
 	}
-
 	// It should not change PSM bit, when APSD turn on.
-	if ((!(pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable) && (pAd->CommonCfg.bAPSDForcePowerSave == FALSE))
-		|| (RTMP_GET_PACKET_EAPOL(pTxBlk->pPacket))
-		|| (RTMP_GET_PACKET_WAI(pTxBlk->pPacket)))
-	{
+	if ((!
+	     (pAd->CommonCfg.bAPSDCapable
+	      && pAd->CommonCfg.APEdcaParm.bAPSDCapable)
+	     && (pAd->CommonCfg.bAPSDForcePowerSave == FALSE))
+	    || (RTMP_GET_PACKET_EAPOL(pTxBlk->pPacket))
+	    || (RTMP_GET_PACKET_WAI(pTxBlk->pPacket))) {
 		if ((pAd->StaCfg.Psm == PWR_SAVE) &&
-            (pAd->StaCfg.WindowsPowerMode == Ndis802_11PowerModeFast_PSP))
+		    (pAd->StaCfg.WindowsPowerMode ==
+		     Ndis802_11PowerModeFast_PSP))
 			RTMP_SET_PSM_BIT(pAd, PWR_ACTIVE);
 	}
 
-	switch (pTxBlk->TxFrameType)
-	{
-		case TX_AMPDU_FRAME:
-				STA_AMPDU_Frame_Tx(pAd, pTxBlk);
-			break;
-		case TX_AMSDU_FRAME:
-				STA_AMSDU_Frame_Tx(pAd, pTxBlk);
-			break;
-		case TX_LEGACY_FRAME:
-				STA_Legacy_Frame_Tx(pAd, pTxBlk);
-			break;
-		case TX_MCAST_FRAME:
-				STA_Legacy_Frame_Tx(pAd, pTxBlk);
-			break;
-		case TX_RALINK_FRAME:
-				STA_ARalink_Frame_Tx(pAd, pTxBlk);
-			break;
-		case TX_FRAG_FRAME:
-				STA_Fragment_Frame_Tx(pAd, pTxBlk);
-			break;
-		default:
-			{
-				// It should not happened!
-				DBGPRINT(RT_DEBUG_ERROR, ("Send a pacekt was not classified!! It should not happen!\n"));
-				while(pTxBlk->TxPacketList.Number)
-				{
-					pQEntry = RemoveHeadQueue(&pTxBlk->TxPacketList);
-					pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
-					if (pPacket)
-						RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
-				}
+	switch (pTxBlk->TxFrameType) {
+	case TX_AMPDU_FRAME:
+		STA_AMPDU_Frame_Tx(pAd, pTxBlk);
+		break;
+	case TX_AMSDU_FRAME:
+		STA_AMSDU_Frame_Tx(pAd, pTxBlk);
+		break;
+	case TX_LEGACY_FRAME:
+		STA_Legacy_Frame_Tx(pAd, pTxBlk);
+		break;
+	case TX_MCAST_FRAME:
+		STA_Legacy_Frame_Tx(pAd, pTxBlk);
+		break;
+	case TX_RALINK_FRAME:
+		STA_ARalink_Frame_Tx(pAd, pTxBlk);
+		break;
+	case TX_FRAG_FRAME:
+		STA_Fragment_Frame_Tx(pAd, pTxBlk);
+		break;
+	default:
+		{
+			// It should not happened!
+			DBGPRINT(RT_DEBUG_ERROR,
+				 ("Send a pacekt was not classified!! It should not happen!\n"));
+			while (pTxBlk->TxPacketList.Number) {
+				pQEntry =
+				    RemoveHeadQueue(&pTxBlk->TxPacketList);
+				pPacket = QUEUE_ENTRY_TO_PACKET(pQEntry);
+				if (pPacket)
+					RELEASE_NDIS_PACKET(pAd, pPacket,
+							    NDIS_STATUS_FAILURE);
 			}
-			break;
+		}
+		break;
 	}
 
 	return (NDIS_STATUS_SUCCESS);
 
 }
 
-ULONG  HashBytesPolynomial(UCHAR *value, unsigned int len)
+ULONG HashBytesPolynomial(UCHAR * value, unsigned int len)
 {
-   unsigned char *word = value;
-   unsigned int ret = 0;
-   unsigned int i;
-
-   for(i=0; i < len; i++)
-   {
-	  int mod = i % 32;
-	  ret ^=(unsigned int) (word[i]) << mod;
-	  ret ^=(unsigned int) (word[i]) >> (32 - mod);
-   }
-   return ret;
+	unsigned char *word = value;
+	unsigned int ret = 0;
+	unsigned int i;
+
+	for (i = 0; i < len; i++) {
+		int mod = i % 32;
+		ret ^= (unsigned int)(word[i]) << mod;
+		ret ^= (unsigned int)(word[i]) >> (32 - mod);
+	}
+	return ret;
 }
 
-VOID Sta_Announce_or_Forward_802_3_Packet(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PNDIS_PACKET	pPacket,
-	IN	UCHAR			FromWhichBSSID)
+VOID Sta_Announce_or_Forward_802_3_Packet(IN PRTMP_ADAPTER pAd,
+					  IN PNDIS_PACKET pPacket,
+					  IN UCHAR FromWhichBSSID)
 {
-	if (TRUE
-		)
-	{
+	if (TRUE) {
 		announce_802_3_packet(pAd, pPacket);
-	}
-	else
-	{
+	} else {
 		// release packet
 		RELEASE_NDIS_PACKET(pAd, pPacket, NDIS_STATUS_FAILURE);
 	}
 }
-
diff --git a/drivers/staging/rt2860/sta/sanity.c b/drivers/staging/rt2860/sta/sanity.c
index 292baa8..3986478 100644
--- a/drivers/staging/rt2860/sta/sanity.c
+++ b/drivers/staging/rt2860/sta/sanity.c
@@ -36,15 +36,15 @@
 */
 #include "../rt_config.h"
 
-extern UCHAR	CISCO_OUI[];
+extern UCHAR CISCO_OUI[];
 
-extern UCHAR	WPA_OUI[];
-extern UCHAR	RSN_OUI[];
-extern UCHAR	WME_INFO_ELEM[];
-extern UCHAR	WME_PARM_ELEM[];
-extern UCHAR	Ccx2QosInfo[];
-extern UCHAR	RALINK_OUI[];
-extern UCHAR	BROADCOM_OUI[];
+extern UCHAR WPA_OUI[];
+extern UCHAR RSN_OUI[];
+extern UCHAR WME_INFO_ELEM[];
+extern UCHAR WME_PARM_ELEM[];
+extern UCHAR Ccx2QosInfo[];
+extern UCHAR RALINK_OUI[];
+extern UCHAR BROADCOM_OUI[];
 
 /*
     ==========================================================================
@@ -54,27 +54,25 @@ extern UCHAR	BROADCOM_OUI[];
         TRUE if all parameters are OK, FALSE otherwise
     ==========================================================================
  */
-BOOLEAN MlmeStartReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT CHAR Ssid[],
-    OUT UCHAR *pSsidLen)
+BOOLEAN MlmeStartReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT CHAR Ssid[], OUT UCHAR * pSsidLen)
 {
-    MLME_START_REQ_STRUCT *Info;
+	MLME_START_REQ_STRUCT *Info;
 
-    Info = (MLME_START_REQ_STRUCT *)(Msg);
+	Info = (MLME_START_REQ_STRUCT *) (Msg);
 
-    if (Info->SsidLen > MAX_LEN_OF_SSID)
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("MlmeStartReqSanity fail - wrong SSID length\n"));
-        return FALSE;
-    }
+	if (Info->SsidLen > MAX_LEN_OF_SSID) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeStartReqSanity fail - wrong SSID length\n"));
+		return FALSE;
+	}
 
-    *pSsidLen = Info->SsidLen;
-    NdisMoveMemory(Ssid, Info->Ssid, *pSsidLen);
+	*pSsidLen = Info->SsidLen;
+	NdisMoveMemory(Ssid, Info->Ssid, *pSsidLen);
 
-    return TRUE;
+	return TRUE;
 }
 
 /*
@@ -88,171 +86,161 @@ BOOLEAN MlmeStartReqSanity(
 
     ==========================================================================
  */
-BOOLEAN PeerAssocRspSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *pMsg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr2,
-    OUT USHORT *pCapabilityInfo,
-    OUT USHORT *pStatus,
-    OUT USHORT *pAid,
-    OUT UCHAR SupRate[],
-    OUT UCHAR *pSupRateLen,
-    OUT UCHAR ExtRate[],
-    OUT UCHAR *pExtRateLen,
-    OUT HT_CAPABILITY_IE		*pHtCapability,
-    OUT ADD_HT_INFO_IE		*pAddHtInfo,	// AP might use this additional ht info IE
-    OUT UCHAR			*pHtCapabilityLen,
-    OUT UCHAR			*pAddHtInfoLen,
-    OUT UCHAR			*pNewExtChannelOffset,
-    OUT PEDCA_PARM pEdcaParm,
-    OUT UCHAR *pCkipFlag)
+BOOLEAN PeerAssocRspSanity(IN PRTMP_ADAPTER pAd, IN VOID * pMsg, IN ULONG MsgLen, OUT PUCHAR pAddr2, OUT USHORT * pCapabilityInfo, OUT USHORT * pStatus, OUT USHORT * pAid, OUT UCHAR SupRate[], OUT UCHAR * pSupRateLen, OUT UCHAR ExtRate[], OUT UCHAR * pExtRateLen, OUT HT_CAPABILITY_IE * pHtCapability, OUT ADD_HT_INFO_IE * pAddHtInfo,	// AP might use this additional ht info IE
+			   OUT UCHAR * pHtCapabilityLen,
+			   OUT UCHAR * pAddHtInfoLen,
+			   OUT UCHAR * pNewExtChannelOffset,
+			   OUT PEDCA_PARM pEdcaParm, OUT UCHAR * pCkipFlag)
 {
-    CHAR          IeType, *Ptr;
-    PFRAME_802_11 pFrame = (PFRAME_802_11)pMsg;
-    PEID_STRUCT   pEid;
-    ULONG         Length = 0;
+	CHAR IeType, *Ptr;
+	PFRAME_802_11 pFrame = (PFRAME_802_11) pMsg;
+	PEID_STRUCT pEid;
+	ULONG Length = 0;
 
 	*pNewExtChannelOffset = 0xff;
 	*pHtCapabilityLen = 0;
 	*pAddHtInfoLen = 0;
-    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-    Ptr = (PCHAR)pFrame->Octet;
-    Length += LENGTH_802_11;
-
-    NdisMoveMemory(pCapabilityInfo, &pFrame->Octet[0], 2);
-    Length += 2;
-    NdisMoveMemory(pStatus,         &pFrame->Octet[2], 2);
-    Length += 2;
-    *pCkipFlag = 0;
-    *pExtRateLen = 0;
-    pEdcaParm->bValid = FALSE;
-
-    if (*pStatus != MLME_SUCCESS)
-        return TRUE;
-
-    NdisMoveMemory(pAid, &pFrame->Octet[4], 2);
-    Length += 2;
-
-    // Aid already swaped byte order in RTMPFrameEndianChange() for big endian platform
-    *pAid = (*pAid) & 0x3fff; // AID is low 14-bit
-
-    // -- get supported rates from payload and advance the pointer
-    IeType = pFrame->Octet[6];
-    *pSupRateLen = pFrame->Octet[7];
-    if ((IeType != IE_SUPP_RATES) || (*pSupRateLen > MAX_LEN_OF_SUPPORTED_RATES))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("PeerAssocRspSanity fail - wrong SupportedRates IE\n"));
-        return FALSE;
-    }
-    else
-        NdisMoveMemory(SupRate, &pFrame->Octet[8], *pSupRateLen);
-
-    Length = Length + 2 + *pSupRateLen;
-
-    // many AP implement proprietary IEs in non-standard order, we'd better
-    // tolerate mis-ordered IEs to get best compatibility
-    pEid = (PEID_STRUCT) &pFrame->Octet[8 + (*pSupRateLen)];
-
-    // get variable fields from payload and advance the pointer
-    while ((Length + 2 + pEid->Len) <= MsgLen)
-    {
-        switch (pEid->Eid)
-        {
-            case IE_EXT_SUPP_RATES:
-                if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES)
-                {
-                    NdisMoveMemory(ExtRate, pEid->Octet, pEid->Len);
-                    *pExtRateLen = pEid->Len;
-                }
-                break;
-
-             case IE_HT_CAP:
-            case IE_HT_CAP2:
-			if (pEid->Len >= SIZE_HT_CAP_IE)  //Note: allow extension.!!
+	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+	Ptr = (PCHAR) pFrame->Octet;
+	Length += LENGTH_802_11;
+
+	NdisMoveMemory(pCapabilityInfo, &pFrame->Octet[0], 2);
+	Length += 2;
+	NdisMoveMemory(pStatus, &pFrame->Octet[2], 2);
+	Length += 2;
+	*pCkipFlag = 0;
+	*pExtRateLen = 0;
+	pEdcaParm->bValid = FALSE;
+
+	if (*pStatus != MLME_SUCCESS)
+		return TRUE;
+
+	NdisMoveMemory(pAid, &pFrame->Octet[4], 2);
+	Length += 2;
+
+	// Aid already swaped byte order in RTMPFrameEndianChange() for big endian platform
+	*pAid = (*pAid) & 0x3fff;	// AID is low 14-bit
+
+	// -- get supported rates from payload and advance the pointer
+	IeType = pFrame->Octet[6];
+	*pSupRateLen = pFrame->Octet[7];
+	if ((IeType != IE_SUPP_RATES)
+	    || (*pSupRateLen > MAX_LEN_OF_SUPPORTED_RATES)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("PeerAssocRspSanity fail - wrong SupportedRates IE\n"));
+		return FALSE;
+	} else
+		NdisMoveMemory(SupRate, &pFrame->Octet[8], *pSupRateLen);
+
+	Length = Length + 2 + *pSupRateLen;
+
+	// many AP implement proprietary IEs in non-standard order, we'd better
+	// tolerate mis-ordered IEs to get best compatibility
+	pEid = (PEID_STRUCT) & pFrame->Octet[8 + (*pSupRateLen)];
+
+	// get variable fields from payload and advance the pointer
+	while ((Length + 2 + pEid->Len) <= MsgLen) {
+		switch (pEid->Eid) {
+		case IE_EXT_SUPP_RATES:
+			if (pEid->Len <= MAX_LEN_OF_SUPPORTED_RATES) {
+				NdisMoveMemory(ExtRate, pEid->Octet, pEid->Len);
+				*pExtRateLen = pEid->Len;
+			}
+			break;
+
+		case IE_HT_CAP:
+		case IE_HT_CAP2:
+			if (pEid->Len >= SIZE_HT_CAP_IE)	//Note: allow extension.!!
 			{
-				NdisMoveMemory(pHtCapability, pEid->Octet, SIZE_HT_CAP_IE);
+				NdisMoveMemory(pHtCapability, pEid->Octet,
+					       SIZE_HT_CAP_IE);
 
-				*(USHORT *)(&pHtCapability->HtCapInfo) = cpu2le16(*(USHORT *)(&pHtCapability->HtCapInfo));
-				*(USHORT *)(&pHtCapability->ExtHtCapInfo) = cpu2le16(*(USHORT *)(&pHtCapability->ExtHtCapInfo));
+				*(USHORT *) (&pHtCapability->HtCapInfo) =
+				    cpu2le16(*(USHORT *)
+					     (&pHtCapability->HtCapInfo));
+				*(USHORT *) (&pHtCapability->ExtHtCapInfo) =
+				    cpu2le16(*(USHORT *)
+					     (&pHtCapability->ExtHtCapInfo));
 
 				*pHtCapabilityLen = SIZE_HT_CAP_IE;
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_WARN, ("PeerAssocRspSanity - wrong IE_HT_CAP. \n"));
+			} else {
+				DBGPRINT(RT_DEBUG_WARN,
+					 ("PeerAssocRspSanity - wrong IE_HT_CAP. \n"));
 			}
 
-		break;
-            case IE_ADD_HT:
-            case IE_ADD_HT2:
-			if (pEid->Len >= sizeof(ADD_HT_INFO_IE))
-			{
+			break;
+		case IE_ADD_HT:
+		case IE_ADD_HT2:
+			if (pEid->Len >= sizeof(ADD_HT_INFO_IE)) {
 				// This IE allows extension, but we can ignore extra bytes beyond our knowledge , so only
 				// copy first sizeof(ADD_HT_INFO_IE)
-				NdisMoveMemory(pAddHtInfo, pEid->Octet, sizeof(ADD_HT_INFO_IE));
+				NdisMoveMemory(pAddHtInfo, pEid->Octet,
+					       sizeof(ADD_HT_INFO_IE));
 
-				*(USHORT *)(&pAddHtInfo->AddHtInfo2) = cpu2le16(*(USHORT *)(&pAddHtInfo->AddHtInfo2));
-				*(USHORT *)(&pAddHtInfo->AddHtInfo3) = cpu2le16(*(USHORT *)(&pAddHtInfo->AddHtInfo3));
+				*(USHORT *) (&pAddHtInfo->AddHtInfo2) =
+				    cpu2le16(*(USHORT *)
+					     (&pAddHtInfo->AddHtInfo2));
+				*(USHORT *) (&pAddHtInfo->AddHtInfo3) =
+				    cpu2le16(*(USHORT *)
+					     (&pAddHtInfo->AddHtInfo3));
 
 				*pAddHtInfoLen = SIZE_ADD_HT_INFO_IE;
-			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_WARN, ("PeerAssocRspSanity - wrong IE_ADD_HT. \n"));
+			} else {
+				DBGPRINT(RT_DEBUG_WARN,
+					 ("PeerAssocRspSanity - wrong IE_ADD_HT. \n"));
 			}
 
-		break;
-            case IE_SECONDARY_CH_OFFSET:
-			if (pEid->Len == 1)
-			{
+			break;
+		case IE_SECONDARY_CH_OFFSET:
+			if (pEid->Len == 1) {
 				*pNewExtChannelOffset = pEid->Octet[0];
+			} else {
+				DBGPRINT(RT_DEBUG_WARN,
+					 ("PeerAssocRspSanity - wrong IE_SECONDARY_CH_OFFSET. \n"));
 			}
-			else
-			{
-				DBGPRINT(RT_DEBUG_WARN, ("PeerAssocRspSanity - wrong IE_SECONDARY_CH_OFFSET. \n"));
+			break;
+
+		case IE_VENDOR_SPECIFIC:
+			// handle WME PARAMTER ELEMENT
+			if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6)
+			    && (pEid->Len == 24)) {
+				PUCHAR ptr;
+				int i;
+
+				// parsing EDCA parameters
+				pEdcaParm->bValid = TRUE;
+				pEdcaParm->bQAck = FALSE;	// pEid->Octet[0] & 0x10;
+				pEdcaParm->bQueueRequest = FALSE;	// pEid->Octet[0] & 0x20;
+				pEdcaParm->bTxopRequest = FALSE;	// pEid->Octet[0] & 0x40;
+				//pEdcaParm->bMoreDataAck    = FALSE; // pEid->Octet[0] & 0x80;
+				pEdcaParm->EdcaUpdateCount =
+				    pEid->Octet[6] & 0x0f;
+				pEdcaParm->bAPSDCapable =
+				    (pEid->Octet[6] & 0x80) ? 1 : 0;
+				ptr = (PUCHAR) & pEid->Octet[8];
+				for (i = 0; i < 4; i++) {
+					UCHAR aci = (*ptr & 0x60) >> 5;	// b5~6 is AC INDEX
+					pEdcaParm->bACM[aci] = (((*ptr) & 0x10) == 0x10);	// b5 is ACM
+					pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;	// b0~3 is AIFSN
+					pEdcaParm->Cwmin[aci] = *(ptr + 1) & 0x0f;	// b0~4 is Cwmin
+					pEdcaParm->Cwmax[aci] = *(ptr + 1) >> 4;	// b5~8 is Cwmax
+					pEdcaParm->Txop[aci] = *(ptr + 2) + 256 * (*(ptr + 3));	// in unit of 32-us
+					ptr += 4;	// point to next AC
+				}
 			}
-		break;
-
-            case IE_VENDOR_SPECIFIC:
-                // handle WME PARAMTER ELEMENT
-                if (NdisEqualMemory(pEid->Octet, WME_PARM_ELEM, 6) && (pEid->Len == 24))
-                {
-                    PUCHAR ptr;
-                    int i;
-
-                    // parsing EDCA parameters
-                    pEdcaParm->bValid          = TRUE;
-                    pEdcaParm->bQAck           = FALSE; // pEid->Octet[0] & 0x10;
-                    pEdcaParm->bQueueRequest   = FALSE; // pEid->Octet[0] & 0x20;
-                    pEdcaParm->bTxopRequest    = FALSE; // pEid->Octet[0] & 0x40;
-                    //pEdcaParm->bMoreDataAck    = FALSE; // pEid->Octet[0] & 0x80;
-                    pEdcaParm->EdcaUpdateCount = pEid->Octet[6] & 0x0f;
-                    pEdcaParm->bAPSDCapable    = (pEid->Octet[6] & 0x80) ? 1 : 0;
-                    ptr = (PUCHAR)&pEid->Octet[8];
-                    for (i=0; i<4; i++)
-                    {
-                        UCHAR aci = (*ptr & 0x60) >> 5; // b5~6 is AC INDEX
-                        pEdcaParm->bACM[aci]  = (((*ptr) & 0x10) == 0x10);   // b5 is ACM
-                        pEdcaParm->Aifsn[aci] = (*ptr) & 0x0f;               // b0~3 is AIFSN
-                        pEdcaParm->Cwmin[aci] = *(ptr+1) & 0x0f;             // b0~4 is Cwmin
-                        pEdcaParm->Cwmax[aci] = *(ptr+1) >> 4;               // b5~8 is Cwmax
-                        pEdcaParm->Txop[aci]  = *(ptr+2) + 256 * (*(ptr+3)); // in unit of 32-us
-                        ptr += 4; // point to next AC
-                    }
-                }
-                break;
-            default:
-                DBGPRINT(RT_DEBUG_TRACE, ("PeerAssocRspSanity - ignore unrecognized EID = %d\n", pEid->Eid));
-                break;
-        }
-
-        Length = Length + 2 + pEid->Len;
-        pEid = (PEID_STRUCT)((UCHAR*)pEid + 2 + pEid->Len);
-    }
-
-
-    return TRUE;
+			break;
+		default:
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PeerAssocRspSanity - ignore unrecognized EID = %d\n",
+				  pEid->Eid));
+			break;
+		}
+
+		Length = Length + 2 + pEid->Len;
+		pEid = (PEID_STRUCT) ((UCHAR *) pEid + 2 + pEid->Len);
+	}
+
+	return TRUE;
 }
 
 /*
@@ -266,47 +254,46 @@ BOOLEAN PeerAssocRspSanity(
 
     ==========================================================================
  */
-BOOLEAN PeerProbeReqSanity(
-    IN PRTMP_ADAPTER pAd,
-    IN VOID *Msg,
-    IN ULONG MsgLen,
-    OUT PUCHAR pAddr2,
-    OUT CHAR Ssid[],
-    OUT UCHAR *pSsidLen)
+BOOLEAN PeerProbeReqSanity(IN PRTMP_ADAPTER pAd,
+			   IN VOID * Msg,
+			   IN ULONG MsgLen,
+			   OUT PUCHAR pAddr2,
+			   OUT CHAR Ssid[], OUT UCHAR * pSsidLen)
 {
-    UCHAR         Idx;
-    UCHAR	      RateLen;
-    CHAR          IeType;
-    PFRAME_802_11 pFrame = (PFRAME_802_11)Msg;
-
-    COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
-
-    if ((pFrame->Octet[0] != IE_SSID) || (pFrame->Octet[1] > MAX_LEN_OF_SSID))
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("PeerProbeReqSanity fail - wrong SSID IE(Type=%d,Len=%d)\n",pFrame->Octet[0],pFrame->Octet[1]));
-        return FALSE;
-    }
-
-    *pSsidLen = pFrame->Octet[1];
-    NdisMoveMemory(Ssid, &pFrame->Octet[2], *pSsidLen);
-
-    Idx = *pSsidLen + 2;
-
-    // -- get supported rates from payload and advance the pointer
-    IeType = pFrame->Octet[Idx];
-    RateLen = pFrame->Octet[Idx + 1];
-    if (IeType != IE_SUPP_RATES)
-    {
-        DBGPRINT(RT_DEBUG_TRACE, ("PeerProbeReqSanity fail - wrong SupportRates IE(Type=%d,Len=%d)\n",pFrame->Octet[Idx],pFrame->Octet[Idx+1]));
-        return FALSE;
-    }
-    else
-    {
-        if ((pAd->CommonCfg.PhyMode == PHY_11G) && (RateLen < 8))
-            return (FALSE);
-    }
-
-    return TRUE;
+	UCHAR Idx;
+	UCHAR RateLen;
+	CHAR IeType;
+	PFRAME_802_11 pFrame = (PFRAME_802_11) Msg;
+
+	COPY_MAC_ADDR(pAddr2, pFrame->Hdr.Addr2);
+
+	if ((pFrame->Octet[0] != IE_SSID)
+	    || (pFrame->Octet[1] > MAX_LEN_OF_SSID)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("PeerProbeReqSanity fail - wrong SSID IE(Type=%d,Len=%d)\n",
+			  pFrame->Octet[0], pFrame->Octet[1]));
+		return FALSE;
+	}
+
+	*pSsidLen = pFrame->Octet[1];
+	NdisMoveMemory(Ssid, &pFrame->Octet[2], *pSsidLen);
+
+	Idx = *pSsidLen + 2;
+
+	// -- get supported rates from payload and advance the pointer
+	IeType = pFrame->Octet[Idx];
+	RateLen = pFrame->Octet[Idx + 1];
+	if (IeType != IE_SUPP_RATES) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("PeerProbeReqSanity fail - wrong SupportRates IE(Type=%d,Len=%d)\n",
+			  pFrame->Octet[Idx], pFrame->Octet[Idx + 1]));
+		return FALSE;
+	} else {
+		if ((pAd->CommonCfg.PhyMode == PHY_11G) && (RateLen < 8))
+			return (FALSE);
+	}
+
+	return TRUE;
 }
 
 /*
@@ -317,62 +304,58 @@ BOOLEAN PeerProbeReqSanity(
 
     ==========================================================================
  */
-BOOLEAN GetTimBit(
-    IN CHAR *Ptr,
-    IN USHORT Aid,
-    OUT UCHAR *TimLen,
-    OUT UCHAR *BcastFlag,
-    OUT UCHAR *DtimCount,
-    OUT UCHAR *DtimPeriod,
-    OUT UCHAR *MessageToMe)
+BOOLEAN GetTimBit(IN CHAR * Ptr,
+		  IN USHORT Aid,
+		  OUT UCHAR * TimLen,
+		  OUT UCHAR * BcastFlag,
+		  OUT UCHAR * DtimCount,
+		  OUT UCHAR * DtimPeriod, OUT UCHAR * MessageToMe)
 {
-    UCHAR          BitCntl, N1, N2, MyByte, MyBit;
-    CHAR          *IdxPtr;
+	UCHAR BitCntl, N1, N2, MyByte, MyBit;
+	CHAR *IdxPtr;
 
-    IdxPtr = Ptr;
+	IdxPtr = Ptr;
 
-    IdxPtr ++;
-    *TimLen = *IdxPtr;
+	IdxPtr++;
+	*TimLen = *IdxPtr;
 
-    // get DTIM Count from TIM element
-    IdxPtr ++;
-    *DtimCount = *IdxPtr;
+	// get DTIM Count from TIM element
+	IdxPtr++;
+	*DtimCount = *IdxPtr;
 
-    // get DTIM Period from TIM element
-    IdxPtr++;
-    *DtimPeriod = *IdxPtr;
+	// get DTIM Period from TIM element
+	IdxPtr++;
+	*DtimPeriod = *IdxPtr;
 
-    // get Bitmap Control from TIM element
-    IdxPtr++;
-    BitCntl = *IdxPtr;
+	// get Bitmap Control from TIM element
+	IdxPtr++;
+	BitCntl = *IdxPtr;
 
-    if ((*DtimCount == 0) && (BitCntl & 0x01))
-        *BcastFlag = TRUE;
-    else
-        *BcastFlag = FALSE;
+	if ((*DtimCount == 0) && (BitCntl & 0x01))
+		*BcastFlag = TRUE;
+	else
+		*BcastFlag = FALSE;
 
-    // Parse Partial Virtual Bitmap from TIM element
-    N1 = BitCntl & 0xfe;    // N1 is the first bitmap byte#
-    N2 = *TimLen - 4 + N1;  // N2 is the last bitmap byte#
+	// Parse Partial Virtual Bitmap from TIM element
+	N1 = BitCntl & 0xfe;	// N1 is the first bitmap byte#
+	N2 = *TimLen - 4 + N1;	// N2 is the last bitmap byte#
 
-    if ((Aid < (N1 << 3)) || (Aid >= ((N2 + 1) << 3)))
-        *MessageToMe = FALSE;
-    else
-    {
-        MyByte = (Aid >> 3) - N1;                       // my byte position in the bitmap byte-stream
-        MyBit = Aid % 16 - ((MyByte & 0x01)? 8:0);
+	if ((Aid < (N1 << 3)) || (Aid >= ((N2 + 1) << 3)))
+		*MessageToMe = FALSE;
+	else {
+		MyByte = (Aid >> 3) - N1;	// my byte position in the bitmap byte-stream
+		MyBit = Aid % 16 - ((MyByte & 0x01) ? 8 : 0);
 
-        IdxPtr += (MyByte + 1);
+		IdxPtr += (MyByte + 1);
 
-        //if (*IdxPtr)
-        //    DBGPRINT(RT_DEBUG_WARN, ("TIM bitmap = 0x%02x\n", *IdxPtr));
+		//if (*IdxPtr)
+		//    DBGPRINT(RT_DEBUG_WARN, ("TIM bitmap = 0x%02x\n", *IdxPtr));
 
-        if (*IdxPtr & (0x01 << MyBit))
-            *MessageToMe = TRUE;
-        else
-            *MessageToMe = FALSE;
-    }
+		if (*IdxPtr & (0x01 << MyBit))
+			*MessageToMe = TRUE;
+		else
+			*MessageToMe = FALSE;
+	}
 
-    return TRUE;
+	return TRUE;
 }
-
diff --git a/drivers/staging/rt2860/sta/sync.c b/drivers/staging/rt2860/sta/sync.c
index dc71c1d..56bb797 100644
--- a/drivers/staging/rt2860/sta/sync.c
+++ b/drivers/staging/rt2860/sta/sync.c
@@ -37,7 +37,6 @@
 */
 #include "../rt_config.h"
 
-
 #define ADHOC_ENTRY_BEACON_LOST_TIME	(2*OS_HZ)	// 2 sec
 
 /*
@@ -51,38 +50,56 @@
 
 	==========================================================================
  */
-VOID SyncStateMachineInit(
-	IN PRTMP_ADAPTER pAd,
-	IN STATE_MACHINE *Sm,
-	OUT STATE_MACHINE_FUNC Trans[])
+VOID SyncStateMachineInit(IN PRTMP_ADAPTER pAd,
+			  IN STATE_MACHINE * Sm, OUT STATE_MACHINE_FUNC Trans[])
 {
-	StateMachineInit(Sm, Trans, MAX_SYNC_STATE, MAX_SYNC_MSG, (STATE_MACHINE_FUNC)Drop, SYNC_IDLE, SYNC_MACHINE_BASE);
+	StateMachineInit(Sm, Trans, MAX_SYNC_STATE, MAX_SYNC_MSG,
+			 (STATE_MACHINE_FUNC) Drop, SYNC_IDLE,
+			 SYNC_MACHINE_BASE);
 
 	// column 1
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)MlmeScanReqAction);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)MlmeJoinReqAction);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)MlmeStartReqAction);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeacon);
-	StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_PROBE_REQ, (STATE_MACHINE_FUNC)PeerProbeReqAction);
+	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_SCAN_REQ,
+			      (STATE_MACHINE_FUNC) MlmeScanReqAction);
+	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_JOIN_REQ,
+			      (STATE_MACHINE_FUNC) MlmeJoinReqAction);
+	StateMachineSetAction(Sm, SYNC_IDLE, MT2_MLME_START_REQ,
+			      (STATE_MACHINE_FUNC) MlmeStartReqAction);
+	StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_BEACON,
+			      (STATE_MACHINE_FUNC) PeerBeacon);
+	StateMachineSetAction(Sm, SYNC_IDLE, MT2_PEER_PROBE_REQ,
+			      (STATE_MACHINE_FUNC) PeerProbeReqAction);
 
 	//column 2
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenScan);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenJoin);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenStart);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeaconAtJoinAction);
-	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_BEACON_TIMEOUT, (STATE_MACHINE_FUNC)BeaconTimeoutAtJoinAction);
+	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_SCAN_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenScan);
+	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_JOIN_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenJoin);
+	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_MLME_START_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenStart);
+	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_PEER_BEACON,
+			      (STATE_MACHINE_FUNC) PeerBeaconAtJoinAction);
+	StateMachineSetAction(Sm, JOIN_WAIT_BEACON, MT2_BEACON_TIMEOUT,
+			      (STATE_MACHINE_FUNC) BeaconTimeoutAtJoinAction);
 
 	// column 3
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_SCAN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenScan);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_JOIN_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenJoin);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_START_REQ, (STATE_MACHINE_FUNC)InvalidStateWhenStart);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_BEACON, (STATE_MACHINE_FUNC)PeerBeaconAtScanAction);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_PROBE_RSP, (STATE_MACHINE_FUNC)PeerBeaconAtScanAction);
-	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_SCAN_TIMEOUT, (STATE_MACHINE_FUNC)ScanTimeoutAction);
+	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_SCAN_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenScan);
+	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_JOIN_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenJoin);
+	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_MLME_START_REQ,
+			      (STATE_MACHINE_FUNC) InvalidStateWhenStart);
+	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_BEACON,
+			      (STATE_MACHINE_FUNC) PeerBeaconAtScanAction);
+	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_PEER_PROBE_RSP,
+			      (STATE_MACHINE_FUNC) PeerBeaconAtScanAction);
+	StateMachineSetAction(Sm, SCAN_LISTEN, MT2_SCAN_TIMEOUT,
+			      (STATE_MACHINE_FUNC) ScanTimeoutAction);
 
 	// timer init
-	RTMPInitTimer(pAd, &pAd->MlmeAux.BeaconTimer, GET_TIMER_FUNCTION(BeaconTimeout), pAd, FALSE);
-	RTMPInitTimer(pAd, &pAd->MlmeAux.ScanTimer, GET_TIMER_FUNCTION(ScanTimeout), pAd, FALSE);
+	RTMPInitTimer(pAd, &pAd->MlmeAux.BeaconTimer,
+		      GET_TIMER_FUNCTION(BeaconTimeout), pAd, FALSE);
+	RTMPInitTimer(pAd, &pAd->MlmeAux.ScanTimer,
+		      GET_TIMER_FUNCTION(ScanTimeout), pAd, FALSE);
 }
 
 /*
@@ -94,15 +111,13 @@ VOID SyncStateMachineInit(
 
 	==========================================================================
  */
-VOID BeaconTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID BeaconTimeout(IN PVOID SystemSpecific1,
+		   IN PVOID FunctionContext,
+		   IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
-	DBGPRINT(RT_DEBUG_TRACE,("SYNC - BeaconTimeout\n"));
+	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BeaconTimeout\n"));
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
@@ -110,16 +125,17 @@ VOID BeaconTimeout(
 		return;
 
 	if ((pAd->CommonCfg.BBPCurrentBW == BW_40)
-		)
-	{
-		UCHAR        BBPValue = 0;
+	    ) {
+		UCHAR BBPValue = 0;
 		AsicSwitchChannel(pAd, pAd->CommonCfg.CentralChannel, FALSE);
 		AsicLockChannel(pAd, pAd->CommonCfg.CentralChannel);
 		RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 		BBPValue &= (~0x18);
 		BBPValue |= 0x10;
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
-		DBGPRINT(RT_DEBUG_TRACE, ("SYNC - End of SCAN, restore to 40MHz channel %d, Total BSS[%02d]\n",pAd->CommonCfg.CentralChannel, pAd->ScanTab.BssNr));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("SYNC - End of SCAN, restore to 40MHz channel %d, Total BSS[%02d]\n",
+			  pAd->CommonCfg.CentralChannel, pAd->ScanTab.BssNr));
 	}
 
 	MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_BEACON_TIMEOUT, 0, NULL);
@@ -135,32 +151,28 @@ VOID BeaconTimeout(
 
 	==========================================================================
  */
-VOID ScanTimeout(
-	IN PVOID SystemSpecific1,
-	IN PVOID FunctionContext,
-	IN PVOID SystemSpecific2,
-	IN PVOID SystemSpecific3)
+VOID ScanTimeout(IN PVOID SystemSpecific1,
+		 IN PVOID FunctionContext,
+		 IN PVOID SystemSpecific2, IN PVOID SystemSpecific3)
 {
-	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *)FunctionContext;
-
+	RTMP_ADAPTER *pAd = (RTMP_ADAPTER *) FunctionContext;
 
 	// Do nothing if the driver is starting halt state.
 	// This might happen when timer already been fired before cancel timer with mlmehalt
 	if (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_HALT_IN_PROGRESS))
 		return;
 
-	if (MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_SCAN_TIMEOUT, 0, NULL))
-	{
-	RTMP_MLME_HANDLER(pAd);
-}
-	else
-	{
+	if (MlmeEnqueue(pAd, SYNC_STATE_MACHINE, MT2_SCAN_TIMEOUT, 0, NULL)) {
+		RTMP_MLME_HANDLER(pAd);
+	} else {
 		// To prevent SyncMachine.CurrState is SCAN_LISTEN forever.
 		pAd->MlmeAux.Channel = 0;
 		ScanNextChannel(pAd);
-		if (pAd->CommonCfg.bWirelessEvent)
-		{
-			RTMPSendWirelessEvent(pAd, IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+		if (pAd->CommonCfg.bWirelessEvent) {
+			RTMPSendWirelessEvent(pAd,
+					      IW_SCAN_ENQUEUE_FAIL_EVENT_FLAG,
+					      pAd->MacTab.Content[BSSID_WCID].
+					      Addr, BSS0, 0);
 		}
 	}
 }
@@ -171,83 +183,78 @@ VOID ScanTimeout(
 		MLME SCAN req state machine procedure
 	==========================================================================
  */
-VOID MlmeScanReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeScanReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR          Ssid[MAX_LEN_OF_SSID], SsidLen, ScanType, BssType, BBPValue = 0;
-	BOOLEAN        TimerCancelled;
-	ULONG		   Now;
-	USHORT         Status;
+	UCHAR Ssid[MAX_LEN_OF_SSID], SsidLen, ScanType, BssType, BBPValue = 0;
+	BOOLEAN TimerCancelled;
+	ULONG Now;
+	USHORT Status;
 	PHEADER_802_11 pHdr80211;
-	PUCHAR         pOutBuffer = NULL;
-	NDIS_STATUS    NStatus;
+	PUCHAR pOutBuffer = NULL;
+	NDIS_STATUS NStatus;
 
 	// Check the total scan tries for one single OID command
 	// If this is the CCX 2.0 Case, skip that!
-	if ( !RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP))
-	{
-		DBGPRINT(RT_DEBUG_TRACE, ("SYNC - MlmeScanReqAction before Startup\n"));
+	if (!RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_START_UP)) {
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("SYNC - MlmeScanReqAction before Startup\n"));
 		return;
 	}
-
 	// Increase the scan retry counters.
 	pAd->StaCfg.ScanCnt++;
 
 #ifdef RTMP_MAC_PCI
-    if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) &&
-        (IDLE_ON(pAd)) &&
-		(pAd->StaCfg.bRadio == TRUE) &&
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)))
-	{
-	        if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE)
-		{
-			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00, 0x02);
+	if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) &&
+	    (IDLE_ON(pAd)) &&
+	    (pAd->StaCfg.bRadio == TRUE) &&
+	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))) {
+		if (pAd->StaCfg.PSControl.field.EnableNewPS == FALSE) {
+			AsicSendCommandToMcu(pAd, 0x31, PowerWakeCID, 0x00,
+					     0x02);
 			AsicCheckCommanOk(pAd, PowerWakeCID);
 			RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF);
-			DBGPRINT(RT_DEBUG_TRACE, ("PSM - Issue Wake up command \n"));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("PSM - Issue Wake up command \n"));
+		} else {
+			RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 		}
-		else
-		{
-		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
-	}
 	}
 #endif // RTMP_MAC_PCI //
 
 	// first check the parameter sanity
 	if (MlmeScanReqSanity(pAd,
-						  Elem->Msg,
-						  Elem->MsgLen,
-						  &BssType,
-						  (PCHAR)Ssid,
-						  &SsidLen,
-						  &ScanType))
-	{
+			      Elem->Msg,
+			      Elem->MsgLen,
+			      &BssType, (PCHAR) Ssid, &SsidLen, &ScanType)) {
 
 		// Check for channel load and noise hist request
 		// Suspend MSDU only at scan request, not the last two mentioned
-			// Suspend MSDU transmission here
-			RTMPSuspendMsduTransmission(pAd);
+		// Suspend MSDU transmission here
+		RTMPSuspendMsduTransmission(pAd);
 
 		//
 		// To prevent data lost.
 		// Send an NULL data with turned PSM bit on to current associated AP before SCAN progress.
 		// And should send an NULL data with turned PSM bit off to AP, when scan progress done
 		//
-		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED) && (INFRA_ON(pAd)))
-		{
-			NStatus = MlmeAllocateMemory(pAd, (PVOID)&pOutBuffer);
-			if (NStatus	== NDIS_STATUS_SUCCESS)
-			{
+		if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)
+		    && (INFRA_ON(pAd))) {
+			NStatus = MlmeAllocateMemory(pAd, (PVOID) & pOutBuffer);
+			if (NStatus == NDIS_STATUS_SUCCESS) {
 				pHdr80211 = (PHEADER_802_11) pOutBuffer;
-				MgtMacHeaderInit(pAd, pHdr80211, SUBTYPE_NULL_FUNC, 1, pAd->CommonCfg.Bssid, pAd->CommonCfg.Bssid);
+				MgtMacHeaderInit(pAd, pHdr80211,
+						 SUBTYPE_NULL_FUNC, 1,
+						 pAd->CommonCfg.Bssid,
+						 pAd->CommonCfg.Bssid);
 				pHdr80211->Duration = 0;
 				pHdr80211->FC.Type = BTYPE_DATA;
 				pHdr80211->FC.PwrMgmt = PWR_SAVE;
 
 				// Send using priority queue
-				MiniportMMRequest(pAd, 0, pOutBuffer, sizeof(HEADER_802_11));
-				DBGPRINT(RT_DEBUG_TRACE, ("MlmeScanReqAction -- Send PSM Data frame for off channel RM\n"));
+				MiniportMMRequest(pAd, 0, pOutBuffer,
+						  sizeof(HEADER_802_11));
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("MlmeScanReqAction -- Send PSM Data frame for off channel RM\n"));
 				MlmeFreeMemory(pAd, pOutBuffer);
 				RTMPusecDelay(5000);
 			}
@@ -263,7 +270,7 @@ VOID MlmeScanReqAction(
 		pAd->MlmeAux.BssType = BssType;
 		pAd->MlmeAux.ScanType = ScanType;
 		pAd->MlmeAux.SsidLen = SsidLen;
-        NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
+		NdisZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
 		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
 
 		// start from the first channel
@@ -275,13 +282,12 @@ VOID MlmeScanReqAction(
 		RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R4, BBPValue);
 		DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BBP R4 to 20MHz.l\n"));
 		ScanNextChannel(pAd);
-	}
-	else
-	{
+	} else {
 		DBGPRINT_ERR(("SYNC - MlmeScanReqAction() sanity check fail\n"));
 		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2,
+			    &Status);
 	}
 }
 
@@ -291,33 +297,31 @@ VOID MlmeScanReqAction(
 		MLME JOIN req state machine procedure
 	==========================================================================
  */
-VOID MlmeJoinReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeJoinReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR        BBPValue = 0;
-	BSS_ENTRY    *pBss;
-	BOOLEAN       TimerCancelled;
+	UCHAR BBPValue = 0;
+	BSS_ENTRY *pBss;
+	BOOLEAN TimerCancelled;
 	HEADER_802_11 Hdr80211;
-	NDIS_STATUS   NStatus;
-	ULONG         FrameLen = 0;
-	PUCHAR        pOutBuffer = NULL;
-	PUCHAR        pSupRate = NULL;
-	UCHAR         SupRateLen;
-	PUCHAR        pExtRate = NULL;
-	UCHAR         ExtRateLen;
-	UCHAR         ASupRate[] = {0x8C, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6C};
-	UCHAR         ASupRateLen = sizeof(ASupRate)/sizeof(UCHAR);
-	MLME_JOIN_REQ_STRUCT *pInfo = (MLME_JOIN_REQ_STRUCT *)(Elem->Msg);
-
-	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - MlmeJoinReqAction(BSS #%ld)\n", pInfo->BssIdx));
+	NDIS_STATUS NStatus;
+	ULONG FrameLen = 0;
+	PUCHAR pOutBuffer = NULL;
+	PUCHAR pSupRate = NULL;
+	UCHAR SupRateLen;
+	PUCHAR pExtRate = NULL;
+	UCHAR ExtRateLen;
+	UCHAR ASupRate[] = { 0x8C, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6C };
+	UCHAR ASupRateLen = sizeof(ASupRate) / sizeof(UCHAR);
+	MLME_JOIN_REQ_STRUCT *pInfo = (MLME_JOIN_REQ_STRUCT *) (Elem->Msg);
+
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("SYNC - MlmeJoinReqAction(BSS #%ld)\n", pInfo->BssIdx));
 
 #ifdef RTMP_MAC_PCI
-    if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) &&
-        (IDLE_ON(pAd)) &&
-		(pAd->StaCfg.bRadio == TRUE) &&
-		(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF)))
-	{
+	if ((OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE)) &&
+	    (IDLE_ON(pAd)) &&
+	    (pAd->StaCfg.bRadio == TRUE) &&
+	    (RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_IDLE_RADIO_OFF))) {
 		RT28xxPciAsicRadioOn(pAd, GUI_IDLE_POWER_SAVE);
 	}
 #endif // RTMP_MAC_PCI //
@@ -332,8 +336,7 @@ VOID MlmeJoinReqAction(
 	COPY_MAC_ADDR(pAd->MlmeAux.Bssid, pBss->Bssid);
 
 	// If AP's SSID is not hidden, it is OK for updating ssid to MlmeAux again.
-	if (pBss->Hidden == 0)
-	{
+	if (pBss->Hidden == 0) {
 		RTMPZeroMemory(pAd->MlmeAux.Ssid, MAX_LEN_OF_SSID);
 		NdisMoveMemory(pAd->MlmeAux.Ssid, pBss->Ssid, pBss->SsidLen);
 		pAd->MlmeAux.SsidLen = pBss->SsidLen;
@@ -343,7 +346,6 @@ VOID MlmeJoinReqAction(
 	pAd->MlmeAux.Channel = pBss->Channel;
 	pAd->MlmeAux.CentralChannel = pBss->CentralChannel;
 
-
 	// Let BBP register at 20MHz to do scan
 	RTMP_BBP_IO_READ8_BY_REG_ID(pAd, BBP_R4, &BBPValue);
 	BBPValue &= (~0x18);
@@ -356,35 +358,28 @@ VOID MlmeJoinReqAction(
 	AsicLockChannel(pAd, pAd->MlmeAux.Channel);
 	RTMPSetTimer(&pAd->MlmeAux.BeaconTimer, JOIN_TIMEOUT);
 
-    do
-	{
+	do {
 		if (((pAd->CommonCfg.bIEEE80211H == 1) &&
-            (pAd->MlmeAux.Channel > 14) &&
-             RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
-            )
-		{
+		     (pAd->MlmeAux.Channel > 14) &&
+		     RadarChannelCheck(pAd, pAd->MlmeAux.Channel))
+		    ) {
 			//
 			// We can't send any Probe request frame to meet 802.11h.
 			//
 			if (pBss->Hidden == 0)
 				break;
 		}
-
 		//
 		// send probe request
 		//
 		NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);
-		if (NStatus == NDIS_STATUS_SUCCESS)
-		{
-			if (pAd->MlmeAux.Channel <= 14)
-			{
+		if (NStatus == NDIS_STATUS_SUCCESS) {
+			if (pAd->MlmeAux.Channel <= 14) {
 				pSupRate = pAd->CommonCfg.SupRate;
 				SupRateLen = pAd->CommonCfg.SupRateLen;
 				pExtRate = pAd->CommonCfg.ExtRate;
 				ExtRateLen = pAd->CommonCfg.ExtRateLen;
-			}
-			else
-			{
+			} else {
 				//
 				// Overwrite Support Rate, CCK rate are not allowed
 				//
@@ -394,39 +389,44 @@ VOID MlmeJoinReqAction(
 			}
 
 			if (pAd->MlmeAux.BssType == BSS_INFRA)
-				MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, pAd->MlmeAux.Bssid, pAd->MlmeAux.Bssid);
+				MgtMacHeaderInit(pAd, &Hdr80211,
+						 SUBTYPE_PROBE_REQ, 0,
+						 pAd->MlmeAux.Bssid,
+						 pAd->MlmeAux.Bssid);
 			else
-				MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, BROADCAST_ADDR, BROADCAST_ADDR);
-
-			MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-							  sizeof(HEADER_802_11),    &Hdr80211,
-							  1,                        &SsidIe,
-							  1,                        &pAd->MlmeAux.SsidLen,
-							  pAd->MlmeAux.SsidLen,	    pAd->MlmeAux.Ssid,
-							  1,                        &SupRateIe,
-							  1,                        &SupRateLen,
-							  SupRateLen,               pSupRate,
-							  END_OF_ARGS);
-
-			if (ExtRateLen)
-			{
+				MgtMacHeaderInit(pAd, &Hdr80211,
+						 SUBTYPE_PROBE_REQ, 0,
+						 BROADCAST_ADDR,
+						 BROADCAST_ADDR);
+
+			MakeOutgoingFrame(pOutBuffer, &FrameLen,
+					  sizeof(HEADER_802_11), &Hdr80211,
+					  1, &SsidIe,
+					  1, &pAd->MlmeAux.SsidLen,
+					  pAd->MlmeAux.SsidLen,
+					  pAd->MlmeAux.Ssid, 1, &SupRateIe, 1,
+					  &SupRateLen, SupRateLen, pSupRate,
+					  END_OF_ARGS);
+
+			if (ExtRateLen) {
 				ULONG Tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &Tmp,
-								  1,                                &ExtRateIe,
-								  1,                                &ExtRateLen,
-								  ExtRateLen,                       pExtRate,
-								  END_OF_ARGS);
+				MakeOutgoingFrame(pOutBuffer + FrameLen, &Tmp,
+						  1, &ExtRateIe,
+						  1, &ExtRateLen,
+						  ExtRateLen, pExtRate,
+						  END_OF_ARGS);
 				FrameLen += Tmp;
 			}
 
-
 			MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 			MlmeFreeMemory(pAd, pOutBuffer);
 		}
-    } while (FALSE);
+	} while (FALSE);
 
-	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - Switch to ch %d, Wait BEACON from %02x:%02x:%02x:%02x:%02x:%02x\n",
-		pBss->Channel, pBss->Bssid[0], pBss->Bssid[1], pBss->Bssid[2], pBss->Bssid[3], pBss->Bssid[4], pBss->Bssid[5]));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("SYNC - Switch to ch %d, Wait BEACON from %02x:%02x:%02x:%02x:%02x:%02x\n",
+		  pBss->Channel, pBss->Bssid[0], pBss->Bssid[1], pBss->Bssid[2],
+		  pBss->Bssid[3], pBss->Bssid[4], pBss->Bssid[5]));
 
 	pAd->Mlme.SyncMachine.CurrState = JOIN_WAIT_BEACON;
 }
@@ -437,28 +437,26 @@ VOID MlmeJoinReqAction(
 		MLME START Request state machine procedure, starting an IBSS
 	==========================================================================
  */
-VOID MlmeStartReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID MlmeStartReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR         Ssid[MAX_LEN_OF_SSID], SsidLen;
-	BOOLEAN       TimerCancelled;
+	UCHAR Ssid[MAX_LEN_OF_SSID], SsidLen;
+	BOOLEAN TimerCancelled;
 
 	// New for WPA security suites
-	UCHAR						VarIE[MAX_VIE_LEN]; 	// Total VIE length = MAX_VIE_LEN - -5
-	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
-	LARGE_INTEGER				TimeStamp;
+	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
+	LARGE_INTEGER TimeStamp;
 	BOOLEAN Privacy;
 	USHORT Status;
 
 	// Init Variable IE structure
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
-	TimeStamp.u.LowPart  = 0;
+	TimeStamp.u.LowPart = 0;
 	TimeStamp.u.HighPart = 0;
 
-	if (MlmeStartReqSanity(pAd, Elem->Msg, Elem->MsgLen, (PCHAR)Ssid, &SsidLen))
-	{
+	if (MlmeStartReqSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, (PCHAR) Ssid, &SsidLen)) {
 		// reset all the timers
 		RTMPCancelTimer(&pAd->MlmeAux.ScanTimer, &TimerCancelled);
 		RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
@@ -466,67 +464,83 @@ VOID MlmeStartReqAction(
 		//
 		// Start a new IBSS. All IBSS parameters are decided now....
 		//
-		DBGPRINT(RT_DEBUG_TRACE, ("MlmeStartReqAction - Start a new IBSS. All IBSS parameters are decided now.... \n"));
-		pAd->MlmeAux.BssType           = BSS_ADHOC;
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeStartReqAction - Start a new IBSS. All IBSS parameters are decided now.... \n"));
+		pAd->MlmeAux.BssType = BSS_ADHOC;
 		NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
-		pAd->MlmeAux.SsidLen           = SsidLen;
+		pAd->MlmeAux.SsidLen = SsidLen;
 
 		// generate a radom number as BSSID
 		MacAddrRandomBssid(pAd, pAd->MlmeAux.Bssid);
-		DBGPRINT(RT_DEBUG_TRACE, ("MlmeStartReqAction - generate a radom number as BSSID \n"));
-
-		Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
-				  (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
-				  (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
-		pAd->MlmeAux.CapabilityInfo    = CAP_GENERATE(0,1,Privacy, (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort), 1, 0);
-		pAd->MlmeAux.BeaconPeriod      = pAd->CommonCfg.BeaconPeriod;
-		pAd->MlmeAux.AtimWin           = pAd->StaCfg.AtimWin;
-		pAd->MlmeAux.Channel           = pAd->CommonCfg.Channel;
-
-		pAd->CommonCfg.CentralChannel  = pAd->CommonCfg.Channel;
-		pAd->MlmeAux.CentralChannel    = pAd->CommonCfg.CentralChannel;
-
-		pAd->MlmeAux.SupRateLen= pAd->CommonCfg.SupRateLen;
-		NdisMoveMemory(pAd->MlmeAux.SupRate, pAd->CommonCfg.SupRate, MAX_LEN_OF_SUPPORTED_RATES);
-		RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("MlmeStartReqAction - generate a radom number as BSSID \n"));
+
+		Privacy =
+		    (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled)
+		    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled)
+		    || (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
+		pAd->MlmeAux.CapabilityInfo =
+		    CAP_GENERATE(0, 1, Privacy,
+				 (pAd->CommonCfg.TxPreamble ==
+				  Rt802_11PreambleShort), 1, 0);
+		pAd->MlmeAux.BeaconPeriod = pAd->CommonCfg.BeaconPeriod;
+		pAd->MlmeAux.AtimWin = pAd->StaCfg.AtimWin;
+		pAd->MlmeAux.Channel = pAd->CommonCfg.Channel;
+
+		pAd->CommonCfg.CentralChannel = pAd->CommonCfg.Channel;
+		pAd->MlmeAux.CentralChannel = pAd->CommonCfg.CentralChannel;
+
+		pAd->MlmeAux.SupRateLen = pAd->CommonCfg.SupRateLen;
+		NdisMoveMemory(pAd->MlmeAux.SupRate, pAd->CommonCfg.SupRate,
+			       MAX_LEN_OF_SUPPORTED_RATES);
+		RTMPCheckRates(pAd, pAd->MlmeAux.SupRate,
+			       &pAd->MlmeAux.SupRateLen);
 		pAd->MlmeAux.ExtRateLen = pAd->CommonCfg.ExtRateLen;
-		NdisMoveMemory(pAd->MlmeAux.ExtRate, pAd->CommonCfg.ExtRate, MAX_LEN_OF_SUPPORTED_RATES);
-		RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
-
-		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-		{
-			RTMPUpdateHTIE(&pAd->CommonCfg.DesiredHtPhy, &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0], &pAd->MlmeAux.HtCapability, &pAd->MlmeAux.AddHtInfo);
+		NdisMoveMemory(pAd->MlmeAux.ExtRate, pAd->CommonCfg.ExtRate,
+			       MAX_LEN_OF_SUPPORTED_RATES);
+		RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate,
+			       &pAd->MlmeAux.ExtRateLen);
+
+		if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
+			RTMPUpdateHTIE(&pAd->CommonCfg.DesiredHtPhy,
+				       &pAd->StaCfg.DesiredHtPhyInfo.MCSSet[0],
+				       &pAd->MlmeAux.HtCapability,
+				       &pAd->MlmeAux.AddHtInfo);
 			pAd->MlmeAux.HtCapabilityLen = sizeof(HT_CAPABILITY_IE);
 			// Not turn pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE here.
-			DBGPRINT(RT_DEBUG_TRACE, ("SYNC -pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE\n"));
-		}
-		else
-		{
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("SYNC -pAd->StaActive.SupportedHtPhy.bHtEnable = TRUE\n"));
+		} else {
 			pAd->MlmeAux.HtCapabilityLen = 0;
 			pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
-			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.MCSSet[0], 16);
+			NdisZeroMemory(&pAd->StaActive.SupportedPhyInfo.
+				       MCSSet[0], 16);
 		}
 		// temporarily not support QOS in IBSS
 		NdisZeroMemory(&pAd->MlmeAux.APEdcaParm, sizeof(EDCA_PARM));
-		NdisZeroMemory(&pAd->MlmeAux.APQbssLoad, sizeof(QBSS_LOAD_PARM));
-		NdisZeroMemory(&pAd->MlmeAux.APQosCapability, sizeof(QOS_CAPABILITY_PARM));
+		NdisZeroMemory(&pAd->MlmeAux.APQbssLoad,
+			       sizeof(QBSS_LOAD_PARM));
+		NdisZeroMemory(&pAd->MlmeAux.APQosCapability,
+			       sizeof(QOS_CAPABILITY_PARM));
 
 		AsicSwitchChannel(pAd, pAd->MlmeAux.Channel, FALSE);
 		AsicLockChannel(pAd, pAd->MlmeAux.Channel);
 
-		DBGPRINT(RT_DEBUG_TRACE, ("SYNC - MlmeStartReqAction(ch= %d,sup rates= %d, ext rates=%d)\n",
-			pAd->MlmeAux.Channel, pAd->MlmeAux.SupRateLen, pAd->MlmeAux.ExtRateLen));
+		DBGPRINT(RT_DEBUG_TRACE,
+			 ("SYNC - MlmeStartReqAction(ch= %d,sup rates= %d, ext rates=%d)\n",
+			  pAd->MlmeAux.Channel, pAd->MlmeAux.SupRateLen,
+			  pAd->MlmeAux.ExtRateLen));
 
 		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 		Status = MLME_SUCCESS;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2, &Status);
-	}
-	else
-	{
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2,
+			    &Status);
+	} else {
 		DBGPRINT_ERR(("SYNC - MlmeStartReqAction() sanity check fail.\n"));
 		pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 		Status = MLME_INVALID_FORMAT;
-		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2, &Status);
+		MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2,
+			    &Status);
 	}
 }
 
@@ -536,35 +550,33 @@ VOID MlmeStartReqAction(
 		peer sends beacon back when scanning
 	==========================================================================
  */
-VOID PeerBeaconAtScanAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerBeaconAtScanAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR           Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
-	UCHAR           Ssid[MAX_LEN_OF_SSID], BssType, Channel, NewChannel,
-					SsidLen, DtimCount, DtimPeriod, BcastFlag, MessageToMe;
-	CF_PARM         CfParm;
-	USHORT          BeaconPeriod, AtimWin, CapabilityInfo;
-	PFRAME_802_11   pFrame;
-	LARGE_INTEGER   TimeStamp;
-	UCHAR           Erp;
-	UCHAR         	SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR		  	SupRateLen, ExtRateLen;
-	USHORT 			LenVIE;
-	UCHAR			CkipFlag;
-	UCHAR			AironetCellPowerLimit;
-	EDCA_PARM       EdcaParm;
-	QBSS_LOAD_PARM  QbssLoad;
+	UCHAR Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
+	UCHAR Ssid[MAX_LEN_OF_SSID], BssType, Channel, NewChannel,
+	    SsidLen, DtimCount, DtimPeriod, BcastFlag, MessageToMe;
+	CF_PARM CfParm;
+	USHORT BeaconPeriod, AtimWin, CapabilityInfo;
+	PFRAME_802_11 pFrame;
+	LARGE_INTEGER TimeStamp;
+	UCHAR Erp;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES],
+	    ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen, ExtRateLen;
+	USHORT LenVIE;
+	UCHAR CkipFlag;
+	UCHAR AironetCellPowerLimit;
+	EDCA_PARM EdcaParm;
+	QBSS_LOAD_PARM QbssLoad;
 	QOS_CAPABILITY_PARM QosCapability;
-	ULONG						RalinkIe;
-	UCHAR						VarIE[MAX_VIE_LEN];		// Total VIE length = MAX_VIE_LEN - -5
-	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
-	HT_CAPABILITY_IE		HtCapability;
-	ADD_HT_INFO_IE		AddHtInfo;	// AP might use this additional ht info IE
-	UCHAR			HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
-	UCHAR			AddHtInfoLen;
-	UCHAR			NewExtChannelOffset = 0xff;
-
+	ULONG RalinkIe;
+	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
+	HT_CAPABILITY_IE HtCapability;
+	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	UCHAR HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
+	UCHAR AddHtInfoLen;
+	UCHAR NewExtChannelOffset = 0xff;
 
 	// NdisFillMemory(Ssid, MAX_LEN_OF_SSID, 0x00);
 	pFrame = (PFRAME_802_11) Elem->Msg;
@@ -572,49 +584,46 @@ VOID PeerBeaconAtScanAction(
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
 
-    RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
+	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
 	RTMPZeroMemory(&AddHtInfo, sizeof(ADD_HT_INFO_IE));
 
 	if (PeerBeaconAndProbeRspSanity(pAd,
-								Elem->Msg,
-								Elem->MsgLen,
-								Elem->Channel,
-								Addr2,
-								Bssid,
-								(PCHAR)Ssid,
-								&SsidLen,
-								&BssType,
-								&BeaconPeriod,
-								&Channel,
-								&NewChannel,
-								&TimeStamp,
-								&CfParm,
-								&AtimWin,
-								&CapabilityInfo,
-								&Erp,
-								&DtimCount,
-								&DtimPeriod,
-								&BcastFlag,
-								&MessageToMe,
-								SupRate,
-								&SupRateLen,
-								ExtRate,
-								&ExtRateLen,
-								&CkipFlag,
-								&AironetCellPowerLimit,
-								&EdcaParm,
-								&QbssLoad,
-								&QosCapability,
-								&RalinkIe,
-								&HtCapabilityLen,
-								&PreNHtCapabilityLen,
-								&HtCapability,
-								&AddHtInfoLen,
-								&AddHtInfo,
-								&NewExtChannelOffset,
-								&LenVIE,
-								pVIE))
-	{
+					Elem->Msg,
+					Elem->MsgLen,
+					Elem->Channel,
+					Addr2,
+					Bssid,
+					(PCHAR) Ssid,
+					&SsidLen,
+					&BssType,
+					&BeaconPeriod,
+					&Channel,
+					&NewChannel,
+					&TimeStamp,
+					&CfParm,
+					&AtimWin,
+					&CapabilityInfo,
+					&Erp,
+					&DtimCount,
+					&DtimPeriod,
+					&BcastFlag,
+					&MessageToMe,
+					SupRate,
+					&SupRateLen,
+					ExtRate,
+					&ExtRateLen,
+					&CkipFlag,
+					&AironetCellPowerLimit,
+					&EdcaParm,
+					&QbssLoad,
+					&QosCapability,
+					&RalinkIe,
+					&HtCapabilityLen,
+					&PreNHtCapabilityLen,
+					&HtCapability,
+					&AddHtInfoLen,
+					&AddHtInfo,
+					&NewExtChannelOffset, &LenVIE, pVIE)) {
 		ULONG Idx;
 		CHAR Rssi = 0;
 
@@ -622,22 +631,32 @@ VOID PeerBeaconAtScanAction(
 		if (Idx != BSS_NOT_FOUND)
 			Rssi = pAd->ScanTab.BssEntry[Idx].Rssi;
 
-		Rssi = RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0), ConvertToRssi(pAd, Elem->Rssi1, RSSI_1), ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
+		Rssi =
+		    RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0),
+				ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
+				ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
 
 		if ((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
 			HtCapabilityLen = SIZE_HT_CAP_IE;
 
-		Idx = BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, (PCHAR)Ssid, SsidLen, BssType, BeaconPeriod,
-						  &CfParm, AtimWin, CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,  &HtCapability,
-						 &AddHtInfo, HtCapabilityLen, AddHtInfoLen, NewExtChannelOffset, Channel, Rssi, TimeStamp, CkipFlag,
-						 &EdcaParm, &QosCapability, &QbssLoad, LenVIE, pVIE);
-
-			if (Idx != BSS_NOT_FOUND)
-			{
-				NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].PTSF, &Elem->Msg[24], 4);
-				NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
-				NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
-			}
+		Idx =
+		    BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, (PCHAR) Ssid,
+				     SsidLen, BssType, BeaconPeriod, &CfParm,
+				     AtimWin, CapabilityInfo, SupRate,
+				     SupRateLen, ExtRate, ExtRateLen,
+				     &HtCapability, &AddHtInfo, HtCapabilityLen,
+				     AddHtInfoLen, NewExtChannelOffset, Channel,
+				     Rssi, TimeStamp, CkipFlag, &EdcaParm,
+				     &QosCapability, &QbssLoad, LenVIE, pVIE);
+
+		if (Idx != BSS_NOT_FOUND) {
+			NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].PTSF,
+				       &Elem->Msg[24], 4);
+			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[0],
+				       &Elem->TimeStamp.u.LowPart, 4);
+			NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[4],
+				       &Elem->TimeStamp.u.LowPart, 4);
+		}
 
 	}
 	// sanity check fail, ignored
@@ -649,88 +668,85 @@ VOID PeerBeaconAtScanAction(
 		When waiting joining the (I)BSS, beacon received from external
 	==========================================================================
  */
-VOID PeerBeaconAtJoinAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerBeaconAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR         Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
-	UCHAR         Ssid[MAX_LEN_OF_SSID], SsidLen, BssType, Channel, MessageToMe,
-				  DtimCount, DtimPeriod, BcastFlag, NewChannel;
+	UCHAR Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
+	UCHAR Ssid[MAX_LEN_OF_SSID], SsidLen, BssType, Channel, MessageToMe,
+	    DtimCount, DtimPeriod, BcastFlag, NewChannel;
 	LARGE_INTEGER TimeStamp;
-	USHORT        BeaconPeriod, AtimWin, CapabilityInfo;
-	CF_PARM       Cf;
-	BOOLEAN       TimerCancelled;
-	UCHAR         Erp;
-	UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR		  SupRateLen, ExtRateLen;
-	UCHAR         CkipFlag;
-	USHORT 		  LenVIE;
-	UCHAR		  AironetCellPowerLimit;
-	EDCA_PARM       EdcaParm;
-	QBSS_LOAD_PARM  QbssLoad;
+	USHORT BeaconPeriod, AtimWin, CapabilityInfo;
+	CF_PARM Cf;
+	BOOLEAN TimerCancelled;
+	UCHAR Erp;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES],
+	    ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen, ExtRateLen;
+	UCHAR CkipFlag;
+	USHORT LenVIE;
+	UCHAR AironetCellPowerLimit;
+	EDCA_PARM EdcaParm;
+	QBSS_LOAD_PARM QbssLoad;
 	QOS_CAPABILITY_PARM QosCapability;
-	USHORT        Status;
-	UCHAR						VarIE[MAX_VIE_LEN];		// Total VIE length = MAX_VIE_LEN - -5
-	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
-	ULONG           RalinkIe;
-	ULONG         Idx;
-	HT_CAPABILITY_IE		HtCapability;
-	ADD_HT_INFO_IE		AddHtInfo;	// AP might use this additional ht info IE
-	UCHAR				HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
-	UCHAR			AddHtInfoLen;
-	UCHAR			NewExtChannelOffset = 0xff;
-	UCHAR			CentralChannel;
-	BOOLEAN			bAllowNrate = FALSE;
+	USHORT Status;
+	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
+	ULONG RalinkIe;
+	ULONG Idx;
+	HT_CAPABILITY_IE HtCapability;
+	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	UCHAR HtCapabilityLen = 0, PreNHtCapabilityLen = 0;
+	UCHAR AddHtInfoLen;
+	UCHAR NewExtChannelOffset = 0xff;
+	UCHAR CentralChannel;
+	BOOLEAN bAllowNrate = FALSE;
 
 	// Init Variable IE structure
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
-    RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
+	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
 	RTMPZeroMemory(&AddHtInfo, sizeof(ADD_HT_INFO_IE));
 
-
 	if (PeerBeaconAndProbeRspSanity(pAd,
-								Elem->Msg,
-								Elem->MsgLen,
-								Elem->Channel,
-								Addr2,
-								Bssid,
-								(PCHAR)Ssid,
-								&SsidLen,
-								&BssType,
-								&BeaconPeriod,
-								&Channel,
-								&NewChannel,
-								&TimeStamp,
-								&Cf,
-								&AtimWin,
-								&CapabilityInfo,
-								&Erp,
-								&DtimCount,
-								&DtimPeriod,
-								&BcastFlag,
-								&MessageToMe,
-								SupRate,
-								&SupRateLen,
-								ExtRate,
-								&ExtRateLen,
-								&CkipFlag,
-								&AironetCellPowerLimit,
-								&EdcaParm,
-								&QbssLoad,
-								&QosCapability,
-								&RalinkIe,
-								&HtCapabilityLen,
-								&PreNHtCapabilityLen,
-								&HtCapability,
-								&AddHtInfoLen,
-								&AddHtInfo,
-								&NewExtChannelOffset,
-								&LenVIE,
-								pVIE))
-	{
+					Elem->Msg,
+					Elem->MsgLen,
+					Elem->Channel,
+					Addr2,
+					Bssid,
+					(PCHAR) Ssid,
+					&SsidLen,
+					&BssType,
+					&BeaconPeriod,
+					&Channel,
+					&NewChannel,
+					&TimeStamp,
+					&Cf,
+					&AtimWin,
+					&CapabilityInfo,
+					&Erp,
+					&DtimCount,
+					&DtimPeriod,
+					&BcastFlag,
+					&MessageToMe,
+					SupRate,
+					&SupRateLen,
+					ExtRate,
+					&ExtRateLen,
+					&CkipFlag,
+					&AironetCellPowerLimit,
+					&EdcaParm,
+					&QbssLoad,
+					&QosCapability,
+					&RalinkIe,
+					&HtCapabilityLen,
+					&PreNHtCapabilityLen,
+					&HtCapability,
+					&AddHtInfoLen,
+					&AddHtInfo,
+					&NewExtChannelOffset, &LenVIE, pVIE)) {
 		// Disqualify 11b only adhoc when we are in 11g only adhoc mode
-		if ((BssType == BSS_ADHOC) && (pAd->CommonCfg.PhyMode == PHY_11G) && ((SupRateLen+ExtRateLen)< 12))
+		if ((BssType == BSS_ADHOC)
+		    && (pAd->CommonCfg.PhyMode == PHY_11G)
+		    && ((SupRateLen + ExtRateLen) < 12))
 			return;
 
 		// BEACON from desired BSS/IBSS found. We should be able to decide most
@@ -739,61 +755,120 @@ VOID PeerBeaconAtJoinAction(
 		//    Do we need to receover back all parameters belonging to previous BSS?
 		// A. Should be not. There's no back-door recover to previous AP. It still need
 		//    a new JOIN-AUTH-ASSOC sequence.
-		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Bssid))
-		{
-			DBGPRINT(RT_DEBUG_TRACE, ("SYNC - receive desired BEACON at JoinWaitBeacon... Channel = %d\n", Channel));
-			RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer, &TimerCancelled);
+		if (MAC_ADDR_EQUAL(pAd->MlmeAux.Bssid, Bssid)) {
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("SYNC - receive desired BEACON at JoinWaitBeacon... Channel = %d\n",
+				  Channel));
+			RTMPCancelTimer(&pAd->MlmeAux.BeaconTimer,
+					&TimerCancelled);
 
 			// Update RSSI to prevent No signal display when cards first initialized
-			pAd->StaCfg.RssiSample.LastRssi0	= ConvertToRssi(pAd, Elem->Rssi0, RSSI_0);
-			pAd->StaCfg.RssiSample.LastRssi1	= ConvertToRssi(pAd, Elem->Rssi1, RSSI_1);
-			pAd->StaCfg.RssiSample.LastRssi2	= ConvertToRssi(pAd, Elem->Rssi2, RSSI_2);
-			pAd->StaCfg.RssiSample.AvgRssi0	= pAd->StaCfg.RssiSample.LastRssi0;
-			pAd->StaCfg.RssiSample.AvgRssi0X8	= pAd->StaCfg.RssiSample.AvgRssi0 << 3;
-			pAd->StaCfg.RssiSample.AvgRssi1	= pAd->StaCfg.RssiSample.LastRssi1;
-			pAd->StaCfg.RssiSample.AvgRssi1X8	= pAd->StaCfg.RssiSample.AvgRssi1 << 3;
-			pAd->StaCfg.RssiSample.AvgRssi2	= pAd->StaCfg.RssiSample.LastRssi2;
-			pAd->StaCfg.RssiSample.AvgRssi2X8	= pAd->StaCfg.RssiSample.AvgRssi2 << 3;
+			pAd->StaCfg.RssiSample.LastRssi0 =
+			    ConvertToRssi(pAd, Elem->Rssi0, RSSI_0);
+			pAd->StaCfg.RssiSample.LastRssi1 =
+			    ConvertToRssi(pAd, Elem->Rssi1, RSSI_1);
+			pAd->StaCfg.RssiSample.LastRssi2 =
+			    ConvertToRssi(pAd, Elem->Rssi2, RSSI_2);
+			pAd->StaCfg.RssiSample.AvgRssi0 =
+			    pAd->StaCfg.RssiSample.LastRssi0;
+			pAd->StaCfg.RssiSample.AvgRssi0X8 =
+			    pAd->StaCfg.RssiSample.AvgRssi0 << 3;
+			pAd->StaCfg.RssiSample.AvgRssi1 =
+			    pAd->StaCfg.RssiSample.LastRssi1;
+			pAd->StaCfg.RssiSample.AvgRssi1X8 =
+			    pAd->StaCfg.RssiSample.AvgRssi1 << 3;
+			pAd->StaCfg.RssiSample.AvgRssi2 =
+			    pAd->StaCfg.RssiSample.LastRssi2;
+			pAd->StaCfg.RssiSample.AvgRssi2X8 =
+			    pAd->StaCfg.RssiSample.AvgRssi2 << 3;
 
 			//
 			// We need to check if SSID only set to any, then we can record the current SSID.
 			// Otherwise will cause hidden SSID association failed.
 			//
-			if (pAd->MlmeAux.SsidLen == 0)
-			{
-				NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid, SsidLen);
+			if (pAd->MlmeAux.SsidLen == 0) {
+				NdisMoveMemory(pAd->MlmeAux.Ssid, Ssid,
+					       SsidLen);
 				pAd->MlmeAux.SsidLen = SsidLen;
-			}
-			else
-			{
-				Idx = BssSsidTableSearch(&pAd->ScanTab, Bssid, pAd->MlmeAux.Ssid, pAd->MlmeAux.SsidLen, Channel);
-
-				if (Idx == BSS_NOT_FOUND)
-				{
+			} else {
+				Idx =
+				    BssSsidTableSearch(&pAd->ScanTab, Bssid,
+						       pAd->MlmeAux.Ssid,
+						       pAd->MlmeAux.SsidLen,
+						       Channel);
+
+				if (Idx == BSS_NOT_FOUND) {
 					CHAR Rssi = 0;
-					Rssi = RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0), ConvertToRssi(pAd, Elem->Rssi1, RSSI_1), ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
-					Idx = BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, (CHAR *) Ssid, SsidLen, BssType, BeaconPeriod,
-										&Cf, AtimWin, CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,  &HtCapability,
-										&AddHtInfo, HtCapabilityLen, AddHtInfoLen, NewExtChannelOffset, Channel, Rssi, TimeStamp, CkipFlag,
-										&EdcaParm, &QosCapability, &QbssLoad, LenVIE, pVIE);
-				if (Idx != BSS_NOT_FOUND)
-				{
-						NdisMoveMemory(pAd->ScanTab.BssEntry[Idx].PTSF, &Elem->Msg[24], 4);
-						NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
-						NdisMoveMemory(&pAd->ScanTab.BssEntry[Idx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
-						CapabilityInfo = pAd->ScanTab.BssEntry[Idx].CapabilityInfo;
+					Rssi =
+					    RTMPMaxRssi(pAd,
+							ConvertToRssi(pAd,
+								      Elem->
+								      Rssi0,
+								      RSSI_0),
+							ConvertToRssi(pAd,
+								      Elem->
+								      Rssi1,
+								      RSSI_1),
+							ConvertToRssi(pAd,
+								      Elem->
+								      Rssi2,
+								      RSSI_2));
+					Idx =
+					    BssTableSetEntry(pAd, &pAd->ScanTab,
+							     Bssid,
+							     (CHAR *) Ssid,
+							     SsidLen, BssType,
+							     BeaconPeriod, &Cf,
+							     AtimWin,
+							     CapabilityInfo,
+							     SupRate,
+							     SupRateLen,
+							     ExtRate,
+							     ExtRateLen,
+							     &HtCapability,
+							     &AddHtInfo,
+							     HtCapabilityLen,
+							     AddHtInfoLen,
+							     NewExtChannelOffset,
+							     Channel, Rssi,
+							     TimeStamp,
+							     CkipFlag,
+							     &EdcaParm,
+							     &QosCapability,
+							     &QbssLoad, LenVIE,
+							     pVIE);
+					if (Idx != BSS_NOT_FOUND) {
+						NdisMoveMemory(pAd->ScanTab.
+							       BssEntry[Idx].
+							       PTSF,
+							       &Elem->Msg[24],
+							       4);
+						NdisMoveMemory(&pAd->ScanTab.
+							       BssEntry[Idx].
+							       TTSF[0],
+							       &Elem->TimeStamp.
+							       u.LowPart, 4);
+						NdisMoveMemory(&pAd->ScanTab.
+							       BssEntry[Idx].
+							       TTSF[4],
+							       &Elem->TimeStamp.
+							       u.LowPart, 4);
+						CapabilityInfo =
+						    pAd->ScanTab.BssEntry[Idx].
+						    CapabilityInfo;
 					}
-				}
-				else
-				{
+				} else {
 					//
 					// Multiple SSID case, used correct CapabilityInfo
 					//
-					CapabilityInfo = pAd->ScanTab.BssEntry[Idx].CapabilityInfo;
+					CapabilityInfo =
+					    pAd->ScanTab.BssEntry[Idx].
+					    CapabilityInfo;
 				}
 			}
 			NdisMoveMemory(pAd->MlmeAux.Bssid, Bssid, MAC_ADDR_LEN);
-			pAd->MlmeAux.CapabilityInfo = CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
+			pAd->MlmeAux.CapabilityInfo =
+			    CapabilityInfo & SUPPORTED_CAPABILITY_INFO;
 			pAd->MlmeAux.BssType = BssType;
 			pAd->MlmeAux.BeaconPeriod = BeaconPeriod;
 			pAd->MlmeAux.Channel = Channel;
@@ -805,110 +880,152 @@ VOID PeerBeaconAtJoinAction(
 			// Copy AP's supported rate to MlmeAux for creating assoication request
 			// Also filter out not supported rate
 			pAd->MlmeAux.SupRateLen = SupRateLen;
-			NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate, SupRateLen);
-			RTMPCheckRates(pAd, pAd->MlmeAux.SupRate, &pAd->MlmeAux.SupRateLen);
+			NdisMoveMemory(pAd->MlmeAux.SupRate, SupRate,
+				       SupRateLen);
+			RTMPCheckRates(pAd, pAd->MlmeAux.SupRate,
+				       &pAd->MlmeAux.SupRateLen);
 			pAd->MlmeAux.ExtRateLen = ExtRateLen;
-			NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate, ExtRateLen);
-			RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate, &pAd->MlmeAux.ExtRateLen);
-
-            NdisZeroMemory(pAd->StaActive.SupportedPhyInfo.MCSSet, 16);
-
-
-			if (((pAd->StaCfg.WepStatus != Ndis802_11WEPEnabled) && (pAd->StaCfg.WepStatus != Ndis802_11Encryption2Enabled))
-				|| (pAd->CommonCfg.HT_DisallowTKIP == FALSE))
-			{
+			NdisMoveMemory(pAd->MlmeAux.ExtRate, ExtRate,
+				       ExtRateLen);
+			RTMPCheckRates(pAd, pAd->MlmeAux.ExtRate,
+				       &pAd->MlmeAux.ExtRateLen);
+
+			NdisZeroMemory(pAd->StaActive.SupportedPhyInfo.MCSSet,
+				       16);
+
+			if (((pAd->StaCfg.WepStatus != Ndis802_11WEPEnabled)
+			     && (pAd->StaCfg.WepStatus !=
+				 Ndis802_11Encryption2Enabled))
+			    || (pAd->CommonCfg.HT_DisallowTKIP == FALSE)) {
 				bAllowNrate = TRUE;
 			}
 
 			pAd->MlmeAux.NewExtChannelOffset = NewExtChannelOffset;
 			pAd->MlmeAux.HtCapabilityLen = HtCapabilityLen;
 
-			RTMPZeroMemory(&pAd->MlmeAux.HtCapability, SIZE_HT_CAP_IE);
+			RTMPZeroMemory(&pAd->MlmeAux.HtCapability,
+				       SIZE_HT_CAP_IE);
 			// filter out un-supported ht rates
-			if (((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0)) &&
-				((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) && (bAllowNrate)))
-			{
-   				RTMPMoveMemory(&pAd->MlmeAux.AddHtInfo, &AddHtInfo, SIZE_ADD_HT_INFO_IE);
+			if (((HtCapabilityLen > 0) || (PreNHtCapabilityLen > 0))
+			    && ((pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+				&& (bAllowNrate))) {
+				RTMPMoveMemory(&pAd->MlmeAux.AddHtInfo,
+					       &AddHtInfo, SIZE_ADD_HT_INFO_IE);
 
 				// StaActive.SupportedHtPhy.MCSSet stores Peer AP's 11n Rx capability
-				NdisMoveMemory(pAd->StaActive.SupportedPhyInfo.MCSSet, HtCapability.MCSSet, 16);
-				pAd->MlmeAux.NewExtChannelOffset = NewExtChannelOffset;
+				NdisMoveMemory(pAd->StaActive.SupportedPhyInfo.
+					       MCSSet, HtCapability.MCSSet, 16);
+				pAd->MlmeAux.NewExtChannelOffset =
+				    NewExtChannelOffset;
 				pAd->MlmeAux.HtCapabilityLen = SIZE_HT_CAP_IE;
-				pAd->StaActive.SupportedPhyInfo.bHtEnable = TRUE;
+				pAd->StaActive.SupportedPhyInfo.bHtEnable =
+				    TRUE;
 				if (PreNHtCapabilityLen > 0)
-					pAd->StaActive.SupportedPhyInfo.bPreNHt = TRUE;
-				RTMPCheckHt(pAd, BSSID_WCID, &HtCapability, &AddHtInfo);
+					pAd->StaActive.SupportedPhyInfo.
+					    bPreNHt = TRUE;
+				RTMPCheckHt(pAd, BSSID_WCID, &HtCapability,
+					    &AddHtInfo);
 				// Copy AP Parameter to StaActive.  This is also in LinkUp.
-				DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAtJoinAction! (MpduDensity=%d, MaxRAmpduFactor=%d, BW=%d)\n",
-					pAd->StaActive.SupportedHtPhy.MpduDensity, pAd->StaActive.SupportedHtPhy.MaxRAmpduFactor, HtCapability.HtCapInfo.ChannelWidth));
-
-				if (AddHtInfoLen > 0)
-				{
+				DBGPRINT(RT_DEBUG_TRACE,
+					 ("PeerBeaconAtJoinAction! (MpduDensity=%d, MaxRAmpduFactor=%d, BW=%d)\n",
+					  pAd->StaActive.SupportedHtPhy.
+					  MpduDensity,
+					  pAd->StaActive.SupportedHtPhy.
+					  MaxRAmpduFactor,
+					  HtCapability.HtCapInfo.ChannelWidth));
+
+				if (AddHtInfoLen > 0) {
 					CentralChannel = AddHtInfo.ControlChan;
-		 			// Check again the Bandwidth capability of this AP.
-		 			if ((AddHtInfo.ControlChan > 2)&& (AddHtInfo.AddHtInfo.ExtChanOffset == EXTCHA_BELOW) && (HtCapability.HtCapInfo.ChannelWidth == BW_40))
-		 			{
-		 				CentralChannel = AddHtInfo.ControlChan - 2;
-		 			}
-		 			else if ((AddHtInfo.AddHtInfo.ExtChanOffset == EXTCHA_ABOVE) && (HtCapability.HtCapInfo.ChannelWidth == BW_40))
-		 			{
-		 				CentralChannel = AddHtInfo.ControlChan + 2;
-		 			}
-
+					// Check again the Bandwidth capability of this AP.
+					if ((AddHtInfo.ControlChan > 2)
+					    && (AddHtInfo.AddHtInfo.
+						ExtChanOffset == EXTCHA_BELOW)
+					    && (HtCapability.HtCapInfo.
+						ChannelWidth == BW_40)) {
+						CentralChannel =
+						    AddHtInfo.ControlChan - 2;
+					} else
+					    if ((AddHtInfo.AddHtInfo.
+						 ExtChanOffset == EXTCHA_ABOVE)
+						&& (HtCapability.HtCapInfo.
+						    ChannelWidth == BW_40)) {
+						CentralChannel =
+						    AddHtInfo.ControlChan + 2;
+					}
 					// Check Error .
-					if (pAd->MlmeAux.CentralChannel != CentralChannel)
-		 				DBGPRINT(RT_DEBUG_ERROR, ("PeerBeaconAtJoinAction HT===>Beacon Central Channel = %d, Control Channel = %d. Mlmeaux CentralChannel = %d\n", CentralChannel, AddHtInfo.ControlChan, pAd->MlmeAux.CentralChannel));
-
-		 			DBGPRINT(RT_DEBUG_TRACE, ("PeerBeaconAtJoinAction HT===>Central Channel = %d, Control Channel = %d,  .\n", CentralChannel, AddHtInfo.ControlChan));
+					if (pAd->MlmeAux.CentralChannel !=
+					    CentralChannel)
+						DBGPRINT(RT_DEBUG_ERROR,
+							 ("PeerBeaconAtJoinAction HT===>Beacon Central Channel = %d, Control Channel = %d. Mlmeaux CentralChannel = %d\n",
+							  CentralChannel,
+							  AddHtInfo.ControlChan,
+							  pAd->MlmeAux.
+							  CentralChannel));
+
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("PeerBeaconAtJoinAction HT===>Central Channel = %d, Control Channel = %d,  .\n",
+						  CentralChannel,
+						  AddHtInfo.ControlChan));
 
 				}
 
-			}
-			else
-			{
-   				// To prevent error, let legacy AP must have same CentralChannel and Channel.
-				if ((HtCapabilityLen == 0) && (PreNHtCapabilityLen == 0))
-					pAd->MlmeAux.CentralChannel = pAd->MlmeAux.Channel;
+			} else {
+				// To prevent error, let legacy AP must have same CentralChannel and Channel.
+				if ((HtCapabilityLen == 0)
+				    && (PreNHtCapabilityLen == 0))
+					pAd->MlmeAux.CentralChannel =
+					    pAd->MlmeAux.Channel;
 
-				pAd->StaActive.SupportedPhyInfo.bHtEnable = FALSE;
+				pAd->StaActive.SupportedPhyInfo.bHtEnable =
+				    FALSE;
 				pAd->MlmeAux.NewExtChannelOffset = 0xff;
-				RTMPZeroMemory(&pAd->MlmeAux.HtCapability, SIZE_HT_CAP_IE);
+				RTMPZeroMemory(&pAd->MlmeAux.HtCapability,
+					       SIZE_HT_CAP_IE);
 				pAd->MlmeAux.HtCapabilityLen = 0;
-				RTMPZeroMemory(&pAd->MlmeAux.AddHtInfo, SIZE_ADD_HT_INFO_IE);
+				RTMPZeroMemory(&pAd->MlmeAux.AddHtInfo,
+					       SIZE_ADD_HT_INFO_IE);
 			}
 
 			RTMPUpdateMlmeRate(pAd);
 
 			// copy QOS related information
 			if ((pAd->CommonCfg.bWmmCapable)
-				 || (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-				)
-			{
-				NdisMoveMemory(&pAd->MlmeAux.APEdcaParm, &EdcaParm, sizeof(EDCA_PARM));
-				NdisMoveMemory(&pAd->MlmeAux.APQbssLoad, &QbssLoad, sizeof(QBSS_LOAD_PARM));
-				NdisMoveMemory(&pAd->MlmeAux.APQosCapability, &QosCapability, sizeof(QOS_CAPABILITY_PARM));
-			}
-			else
-			{
-				NdisZeroMemory(&pAd->MlmeAux.APEdcaParm, sizeof(EDCA_PARM));
-				NdisZeroMemory(&pAd->MlmeAux.APQbssLoad, sizeof(QBSS_LOAD_PARM));
-				NdisZeroMemory(&pAd->MlmeAux.APQosCapability, sizeof(QOS_CAPABILITY_PARM));
+			    || (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
+			    ) {
+				NdisMoveMemory(&pAd->MlmeAux.APEdcaParm,
+					       &EdcaParm, sizeof(EDCA_PARM));
+				NdisMoveMemory(&pAd->MlmeAux.APQbssLoad,
+					       &QbssLoad,
+					       sizeof(QBSS_LOAD_PARM));
+				NdisMoveMemory(&pAd->MlmeAux.APQosCapability,
+					       &QosCapability,
+					       sizeof(QOS_CAPABILITY_PARM));
+			} else {
+				NdisZeroMemory(&pAd->MlmeAux.APEdcaParm,
+					       sizeof(EDCA_PARM));
+				NdisZeroMemory(&pAd->MlmeAux.APQbssLoad,
+					       sizeof(QBSS_LOAD_PARM));
+				NdisZeroMemory(&pAd->MlmeAux.APQosCapability,
+					       sizeof(QOS_CAPABILITY_PARM));
 			}
 
-			DBGPRINT(RT_DEBUG_TRACE, ("SYNC - after JOIN, SupRateLen=%d, ExtRateLen=%d\n",
-										pAd->MlmeAux.SupRateLen, pAd->MlmeAux.ExtRateLen));
+			DBGPRINT(RT_DEBUG_TRACE,
+				 ("SYNC - after JOIN, SupRateLen=%d, ExtRateLen=%d\n",
+				  pAd->MlmeAux.SupRateLen,
+				  pAd->MlmeAux.ExtRateLen));
 
-			if (AironetCellPowerLimit != 0xFF)
-			{
+			if (AironetCellPowerLimit != 0xFF) {
 				//We need to change our TxPower for CCX 2.0 AP Control of Client Transmit Power
-				ChangeToCellPowerLimit(pAd, AironetCellPowerLimit);
-			}
-			else  //Used the default TX Power Percentage.
-				pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;
+				ChangeToCellPowerLimit(pAd,
+						       AironetCellPowerLimit);
+			} else	//Used the default TX Power Percentage.
+				pAd->CommonCfg.TxPowerPercentage =
+				    pAd->CommonCfg.TxPowerDefault;
 
 			pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 			Status = MLME_SUCCESS;
-			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF, 2, &Status);
+			MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF,
+				    2, &Status);
 		}
 		// not to me BEACON, ignored
 	}
@@ -924,98 +1041,99 @@ VOID PeerBeaconAtJoinAction(
 
 	==========================================================================
  */
-VOID PeerBeacon(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerBeacon(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR         Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
-	CHAR          Ssid[MAX_LEN_OF_SSID];
-	CF_PARM       CfParm;
-	UCHAR         SsidLen, MessageToMe=0, BssType, Channel, NewChannel, index=0;
-	UCHAR         DtimCount=0, DtimPeriod=0, BcastFlag=0;
-	USHORT        CapabilityInfo, AtimWin, BeaconPeriod;
+	UCHAR Bssid[MAC_ADDR_LEN], Addr2[MAC_ADDR_LEN];
+	CHAR Ssid[MAX_LEN_OF_SSID];
+	CF_PARM CfParm;
+	UCHAR SsidLen, MessageToMe = 0, BssType, Channel, NewChannel, index = 0;
+	UCHAR DtimCount = 0, DtimPeriod = 0, BcastFlag = 0;
+	USHORT CapabilityInfo, AtimWin, BeaconPeriod;
 	LARGE_INTEGER TimeStamp;
-	USHORT        TbttNumToNextWakeUp;
-	UCHAR         Erp;
-	UCHAR         SupRate[MAX_LEN_OF_SUPPORTED_RATES], ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
-	UCHAR		  SupRateLen, ExtRateLen;
-	UCHAR		  CkipFlag;
-	USHORT        LenVIE;
-	UCHAR		  AironetCellPowerLimit;
-	EDCA_PARM       EdcaParm;
-	QBSS_LOAD_PARM  QbssLoad;
+	USHORT TbttNumToNextWakeUp;
+	UCHAR Erp;
+	UCHAR SupRate[MAX_LEN_OF_SUPPORTED_RATES],
+	    ExtRate[MAX_LEN_OF_SUPPORTED_RATES];
+	UCHAR SupRateLen, ExtRateLen;
+	UCHAR CkipFlag;
+	USHORT LenVIE;
+	UCHAR AironetCellPowerLimit;
+	EDCA_PARM EdcaParm;
+	QBSS_LOAD_PARM QbssLoad;
 	QOS_CAPABILITY_PARM QosCapability;
-	ULONG           RalinkIe;
+	ULONG RalinkIe;
 	// New for WPA security suites
-	UCHAR						VarIE[MAX_VIE_LEN];		// Total VIE length = MAX_VIE_LEN - -5
-	NDIS_802_11_VARIABLE_IEs	*pVIE = NULL;
-	HT_CAPABILITY_IE		HtCapability;
-	ADD_HT_INFO_IE		AddHtInfo;	// AP might use this additional ht info IE
-	UCHAR			HtCapabilityLen, PreNHtCapabilityLen;
-	UCHAR			AddHtInfoLen;
-	UCHAR			NewExtChannelOffset = 0xff;
+	UCHAR VarIE[MAX_VIE_LEN];	// Total VIE length = MAX_VIE_LEN - -5
+	NDIS_802_11_VARIABLE_IEs *pVIE = NULL;
+	HT_CAPABILITY_IE HtCapability;
+	ADD_HT_INFO_IE AddHtInfo;	// AP might use this additional ht info IE
+	UCHAR HtCapabilityLen, PreNHtCapabilityLen;
+	UCHAR AddHtInfoLen;
+	UCHAR NewExtChannelOffset = 0xff;
 
 	if (!(INFRA_ON(pAd) || ADHOC_ON(pAd)
-		))
+	    ))
 		return;
 
 	// Init Variable IE structure
 	pVIE = (PNDIS_802_11_VARIABLE_IEs) VarIE;
 	pVIE->Length = 0;
-    RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
+	RTMPZeroMemory(&HtCapability, sizeof(HtCapability));
 	RTMPZeroMemory(&AddHtInfo, sizeof(ADD_HT_INFO_IE));
 
 	if (PeerBeaconAndProbeRspSanity(pAd,
-								Elem->Msg,
-								Elem->MsgLen,
-								Elem->Channel,
-								Addr2,
-								Bssid,
-								Ssid,
-								&SsidLen,
-								&BssType,
-								&BeaconPeriod,
-								&Channel,
-								&NewChannel,
-								&TimeStamp,
-								&CfParm,
-								&AtimWin,
-								&CapabilityInfo,
-								&Erp,
-								&DtimCount,
-								&DtimPeriod,
-								&BcastFlag,
-								&MessageToMe,
-								SupRate,
-								&SupRateLen,
-								ExtRate,
-								&ExtRateLen,
-								&CkipFlag,
-								&AironetCellPowerLimit,
-								&EdcaParm,
-								&QbssLoad,
-								&QosCapability,
-								&RalinkIe,
-								&HtCapabilityLen,
-								&PreNHtCapabilityLen,
-								&HtCapability,
-								&AddHtInfoLen,
-								&AddHtInfo,
-								&NewExtChannelOffset,
-								&LenVIE,
-								pVIE))
-	{
+					Elem->Msg,
+					Elem->MsgLen,
+					Elem->Channel,
+					Addr2,
+					Bssid,
+					Ssid,
+					&SsidLen,
+					&BssType,
+					&BeaconPeriod,
+					&Channel,
+					&NewChannel,
+					&TimeStamp,
+					&CfParm,
+					&AtimWin,
+					&CapabilityInfo,
+					&Erp,
+					&DtimCount,
+					&DtimPeriod,
+					&BcastFlag,
+					&MessageToMe,
+					SupRate,
+					&SupRateLen,
+					ExtRate,
+					&ExtRateLen,
+					&CkipFlag,
+					&AironetCellPowerLimit,
+					&EdcaParm,
+					&QbssLoad,
+					&QosCapability,
+					&RalinkIe,
+					&HtCapabilityLen,
+					&PreNHtCapabilityLen,
+					&HtCapability,
+					&AddHtInfoLen,
+					&AddHtInfo,
+					&NewExtChannelOffset, &LenVIE, pVIE)) {
 		BOOLEAN is_my_bssid, is_my_ssid;
-		ULONG   Bssidx, Now;
+		ULONG Bssidx, Now;
 		BSS_ENTRY *pBss;
-		CHAR		RealRssi = RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0), ConvertToRssi(pAd, Elem->Rssi1, RSSI_1), ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
-
-		is_my_bssid = MAC_ADDR_EQUAL(Bssid, pAd->CommonCfg.Bssid)? TRUE : FALSE;
-		is_my_ssid = SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen)? TRUE:FALSE;
+		CHAR RealRssi =
+		    RTMPMaxRssi(pAd, ConvertToRssi(pAd, Elem->Rssi0, RSSI_0),
+				ConvertToRssi(pAd, Elem->Rssi1, RSSI_1),
+				ConvertToRssi(pAd, Elem->Rssi2, RSSI_2));
 
+		is_my_bssid =
+		    MAC_ADDR_EQUAL(Bssid, pAd->CommonCfg.Bssid) ? TRUE : FALSE;
+		is_my_ssid =
+		    SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid,
+			       pAd->CommonCfg.SsidLen) ? TRUE : FALSE;
 
 		// ignore BEACON not for my SSID
-		if ((! is_my_ssid) && (! is_my_bssid))
+		if ((!is_my_ssid) && (!is_my_bssid))
 			return;
 
 		// It means STA waits disassoc completely from this AP, ignores this beacon.
@@ -1033,177 +1151,194 @@ VOID PeerBeacon(
 		// Housekeeping "SsidBssTab" table for later-on ROAMing usage.
 		//
 		Bssidx = BssTableSearch(&pAd->ScanTab, Bssid, Channel);
-		if (Bssidx == BSS_NOT_FOUND)
-		{
+		if (Bssidx == BSS_NOT_FOUND) {
 			// discover new AP of this network, create BSS entry
-			Bssidx = BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, Ssid, SsidLen, BssType, BeaconPeriod,
-						 &CfParm, AtimWin, CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen,
-						&HtCapability, &AddHtInfo,HtCapabilityLen,AddHtInfoLen,NewExtChannelOffset, Channel,
-						RealRssi, TimeStamp, CkipFlag, &EdcaParm, &QosCapability,
-						&QbssLoad, LenVIE, pVIE);
-			if (Bssidx == BSS_NOT_FOUND) // return if BSS table full
+			Bssidx =
+			    BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, Ssid,
+					     SsidLen, BssType, BeaconPeriod,
+					     &CfParm, AtimWin, CapabilityInfo,
+					     SupRate, SupRateLen, ExtRate,
+					     ExtRateLen, &HtCapability,
+					     &AddHtInfo, HtCapabilityLen,
+					     AddHtInfoLen, NewExtChannelOffset,
+					     Channel, RealRssi, TimeStamp,
+					     CkipFlag, &EdcaParm,
+					     &QosCapability, &QbssLoad, LenVIE,
+					     pVIE);
+			if (Bssidx == BSS_NOT_FOUND)	// return if BSS table full
 				return;
 
-			NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].PTSF, &Elem->Msg[24], 4);
-			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[0], &Elem->TimeStamp.u.LowPart, 4);
-			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[4], &Elem->TimeStamp.u.LowPart, 4);
-
-
+			NdisMoveMemory(pAd->ScanTab.BssEntry[Bssidx].PTSF,
+				       &Elem->Msg[24], 4);
+			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[0],
+				       &Elem->TimeStamp.u.LowPart, 4);
+			NdisMoveMemory(&pAd->ScanTab.BssEntry[Bssidx].TTSF[4],
+				       &Elem->TimeStamp.u.LowPart, 4);
 
 		}
 
-		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0) && (Channel != NewChannel))
-		{
+		if ((pAd->CommonCfg.bIEEE80211H == 1) && (NewChannel != 0)
+		    && (Channel != NewChannel)) {
 			// Switching to channel 1 can prevent from rescanning the current channel immediately (by auto reconnection).
 			// In addition, clear the MLME queue and the scan table to discard the RX packets and previous scanning results.
 			AsicSwitchChannel(pAd, 1, FALSE);
 			AsicLockChannel(pAd, 1);
-		    LinkDown(pAd, FALSE);
+			LinkDown(pAd, FALSE);
 			MlmeQueueInit(&pAd->Mlme.Queue);
 			BssTableInit(&pAd->ScanTab);
-		    RTMPusecDelay(1000000);		// use delay to prevent STA do reassoc
+			RTMPusecDelay(1000000);	// use delay to prevent STA do reassoc
 
 			// channel sanity check
-			for (index = 0 ; index < pAd->ChannelListNum; index++)
-			{
-				if (pAd->ChannelList[index].Channel == NewChannel)
-				{
-					pAd->ScanTab.BssEntry[Bssidx].Channel = NewChannel;
+			for (index = 0; index < pAd->ChannelListNum; index++) {
+				if (pAd->ChannelList[index].Channel ==
+				    NewChannel) {
+					pAd->ScanTab.BssEntry[Bssidx].Channel =
+					    NewChannel;
 					pAd->CommonCfg.Channel = NewChannel;
-					AsicSwitchChannel(pAd, pAd->CommonCfg.Channel, FALSE);
-					AsicLockChannel(pAd, pAd->CommonCfg.Channel);
-					DBGPRINT(RT_DEBUG_TRACE, ("PeerBeacon - STA receive channel switch announcement IE (New Channel =%d)\n", NewChannel));
+					AsicSwitchChannel(pAd,
+							  pAd->CommonCfg.
+							  Channel, FALSE);
+					AsicLockChannel(pAd,
+							pAd->CommonCfg.Channel);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("PeerBeacon - STA receive channel switch announcement IE (New Channel =%d)\n",
+						  NewChannel));
 					break;
 				}
 			}
 
-			if (index >= pAd->ChannelListNum)
-			{
+			if (index >= pAd->ChannelListNum) {
 				DBGPRINT_ERR(("PeerBeacon(can not find New Channel=%d in ChannelList[%d]\n", pAd->CommonCfg.Channel, pAd->ChannelListNum));
 			}
 		}
-
 		// if the ssid matched & bssid unmatched, we should select the bssid with large value.
 		// This might happened when two STA start at the same time
-		if ((! is_my_bssid) && ADHOC_ON(pAd))
-		{
-			INT	i;
+		if ((!is_my_bssid) && ADHOC_ON(pAd)) {
+			INT i;
 
 			// Add the safeguard against the mismatch of adhoc wep status
-			if (pAd->StaCfg.WepStatus != pAd->ScanTab.BssEntry[Bssidx].WepStatus)
-			{
+			if (pAd->StaCfg.WepStatus !=
+			    pAd->ScanTab.BssEntry[Bssidx].WepStatus) {
 				return;
 			}
-
 			// collapse into the ADHOC network which has bigger BSSID value.
-			for (i = 0; i < 6; i++)
-			{
-				if (Bssid[i] > pAd->CommonCfg.Bssid[i])
-				{
-					DBGPRINT(RT_DEBUG_TRACE, ("SYNC - merge to the IBSS with bigger BSSID=%02x:%02x:%02x:%02x:%02x:%02x\n",
-						Bssid[0], Bssid[1], Bssid[2], Bssid[3], Bssid[4], Bssid[5]));
+			for (i = 0; i < 6; i++) {
+				if (Bssid[i] > pAd->CommonCfg.Bssid[i]) {
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("SYNC - merge to the IBSS with bigger BSSID=%02x:%02x:%02x:%02x:%02x:%02x\n",
+						  Bssid[0], Bssid[1], Bssid[2],
+						  Bssid[3], Bssid[4],
+						  Bssid[5]));
 					AsicDisableSync(pAd);
-					COPY_MAC_ADDR(pAd->CommonCfg.Bssid, Bssid);
+					COPY_MAC_ADDR(pAd->CommonCfg.Bssid,
+						      Bssid);
 					AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
-					MakeIbssBeacon(pAd);        // re-build BEACON frame
-					AsicEnableIbssSync(pAd);    // copy BEACON frame to on-chip memory
+					MakeIbssBeacon(pAd);	// re-build BEACON frame
+					AsicEnableIbssSync(pAd);	// copy BEACON frame to on-chip memory
 					is_my_bssid = TRUE;
 					break;
-				}
-				else if (Bssid[i] < pAd->CommonCfg.Bssid[i])
+				} else if (Bssid[i] < pAd->CommonCfg.Bssid[i])
 					break;
 			}
 		}
 
-
 		NdisGetSystemUpTime(&Now);
 		pBss = &pAd->ScanTab.BssEntry[Bssidx];
-		pBss->Rssi = RealRssi;       // lastest RSSI
-		pBss->LastBeaconRxTime = Now;   // last RX timestamp
+		pBss->Rssi = RealRssi;	// lastest RSSI
+		pBss->LastBeaconRxTime = Now;	// last RX timestamp
 
 		//
 		// BEACON from my BSSID - either IBSS or INFRA network
 		//
-		if (is_my_bssid)
-		{
-			RXWI_STRUC	RxWI;
+		if (is_my_bssid) {
+			RXWI_STRUC RxWI;
 
 			pAd->StaCfg.DtimCount = DtimCount;
 			pAd->StaCfg.DtimPeriod = DtimPeriod;
 			pAd->StaCfg.LastBeaconRxTime = Now;
 
-
 			RxWI.RSSI0 = Elem->Rssi0;
 			RxWI.RSSI1 = Elem->Rssi1;
 			RxWI.RSSI2 = Elem->Rssi2;
 
 			Update_Rssi_Sample(pAd, &pAd->StaCfg.RssiSample, &RxWI);
-			if (AironetCellPowerLimit != 0xFF)
-			{
+			if (AironetCellPowerLimit != 0xFF) {
 				//
 				// We get the Cisco (ccx) "TxPower Limit" required
 				// Changed to appropriate TxPower Limit for Ciso Compatible Extensions
 				//
-				ChangeToCellPowerLimit(pAd, AironetCellPowerLimit);
-			}
-			else
-			{
+				ChangeToCellPowerLimit(pAd,
+						       AironetCellPowerLimit);
+			} else {
 				//
 				// AironetCellPowerLimit equal to 0xFF means the Cisco (ccx) "TxPower Limit" not exist.
 				// Used the default TX Power Percentage, that set from UI.
 				//
-				pAd->CommonCfg.TxPowerPercentage = pAd->CommonCfg.TxPowerDefault;
+				pAd->CommonCfg.TxPowerPercentage =
+				    pAd->CommonCfg.TxPowerDefault;
 			}
 
-			if (ADHOC_ON(pAd) && (CAP_IS_IBSS_ON(CapabilityInfo)))
-			{
-				UCHAR			MaxSupportedRateIn500Kbps = 0;
-				UCHAR			idx;
+			if (ADHOC_ON(pAd) && (CAP_IS_IBSS_ON(CapabilityInfo))) {
+				UCHAR MaxSupportedRateIn500Kbps = 0;
+				UCHAR idx;
 				MAC_TABLE_ENTRY *pEntry;
 
 				// supported rates array may not be sorted. sort it and find the maximum rate
-			    for (idx=0; idx<SupRateLen; idx++)
-			    {
-			        if (MaxSupportedRateIn500Kbps < (SupRate[idx] & 0x7f))
-			            MaxSupportedRateIn500Kbps = SupRate[idx] & 0x7f;
-			    }
-
-				for (idx=0; idx<ExtRateLen; idx++)
-			    {
-			        if (MaxSupportedRateIn500Kbps < (ExtRate[idx] & 0x7f))
-			            MaxSupportedRateIn500Kbps = ExtRate[idx] & 0x7f;
-			    }
+				for (idx = 0; idx < SupRateLen; idx++) {
+					if (MaxSupportedRateIn500Kbps <
+					    (SupRate[idx] & 0x7f))
+						MaxSupportedRateIn500Kbps =
+						    SupRate[idx] & 0x7f;
+				}
+
+				for (idx = 0; idx < ExtRateLen; idx++) {
+					if (MaxSupportedRateIn500Kbps <
+					    (ExtRate[idx] & 0x7f))
+						MaxSupportedRateIn500Kbps =
+						    ExtRate[idx] & 0x7f;
+				}
 
 				// look up the existing table
 				pEntry = MacTableLookup(pAd, Addr2);
 
 				// Ad-hoc mode is using MAC address as BA session. So we need to continuously find newly joined adhoc station by receiving beacon.
 				// To prevent always check this, we use wcid == RESERVED_WCID to recognize it as newly joined adhoc station.
-				if ((ADHOC_ON(pAd) && (Elem->Wcid == RESERVED_WCID)) ||
-					(pEntry && ((pEntry->LastBeaconRxTime + ADHOC_ENTRY_BEACON_LOST_TIME) < Now)))
-				{
+				if ((ADHOC_ON(pAd)
+				     && (Elem->Wcid == RESERVED_WCID))
+				    || (pEntry
+					&&
+					((pEntry->LastBeaconRxTime +
+					  ADHOC_ENTRY_BEACON_LOST_TIME) <
+					 Now))) {
 					if (pEntry == NULL)
 						// Another adhoc joining, add to our MAC table.
-						pEntry = MacTableInsertEntry(pAd, Addr2, BSS0, FALSE);
+						pEntry =
+						    MacTableInsertEntry(pAd,
+									Addr2,
+									BSS0,
+									FALSE);
 
 					if (StaAddMacTableEntry(pAd,
-											pEntry,
-											MaxSupportedRateIn500Kbps,
-											&HtCapability,
-											HtCapabilityLen,
-											&AddHtInfo,
-											AddHtInfoLen,
-											CapabilityInfo) == FALSE)
-					{
-						DBGPRINT(RT_DEBUG_TRACE, ("ADHOC - Add Entry failed.\n"));
+								pEntry,
+								MaxSupportedRateIn500Kbps,
+								&HtCapability,
+								HtCapabilityLen,
+								&AddHtInfo,
+								AddHtInfoLen,
+								CapabilityInfo)
+					    == FALSE) {
+						DBGPRINT(RT_DEBUG_TRACE,
+							 ("ADHOC - Add Entry failed.\n"));
 						return;
 					}
 
 					if (pEntry &&
-						(Elem->Wcid == RESERVED_WCID))
-					{
+					    (Elem->Wcid == RESERVED_WCID)) {
 						idx = pAd->StaCfg.DefaultKeyId;
-						RTMP_STA_SECURITY_INFO_ADD(pAd, BSS0, idx, pEntry);
+						RTMP_STA_SECURITY_INFO_ADD(pAd,
+									   BSS0,
+									   idx,
+									   pEntry);
 					}
 				}
 
@@ -1211,33 +1346,62 @@ VOID PeerBeacon(
 					pEntry->LastBeaconRxTime = Now;
 
 				// At least another peer in this IBSS, declare MediaState as CONNECTED
-				if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED))
-				{
-					OPSTATUS_SET_FLAG(pAd, fOP_STATUS_MEDIA_STATE_CONNECTED);
+				if (!OPSTATUS_TEST_FLAG
+				    (pAd, fOP_STATUS_MEDIA_STATE_CONNECTED)) {
+					OPSTATUS_SET_FLAG(pAd,
+							  fOP_STATUS_MEDIA_STATE_CONNECTED);
 
-					pAd->IndicateMediaState = NdisMediaStateConnected;
+					pAd->IndicateMediaState =
+					    NdisMediaStateConnected;
 					RTMP_IndicateMediaState(pAd);
-	                pAd->ExtraInfo = GENERAL_LINK_UP;
+					pAd->ExtraInfo = GENERAL_LINK_UP;
 					AsicSetBssid(pAd, pAd->CommonCfg.Bssid);
 
 					// 2003/03/12 - john
 					// Make sure this entry in "ScanTab" table, thus complies to Microsoft's policy that
 					// "site survey" result should always include the current connected network.
 					//
-					Bssidx = BssTableSearch(&pAd->ScanTab, Bssid, Channel);
-					if (Bssidx == BSS_NOT_FOUND)
-					{
-						Bssidx = BssTableSetEntry(pAd, &pAd->ScanTab, Bssid, Ssid, SsidLen, BssType, BeaconPeriod,
-									&CfParm, AtimWin, CapabilityInfo, SupRate, SupRateLen, ExtRate, ExtRateLen, &HtCapability,
-									&AddHtInfo, HtCapabilityLen, AddHtInfoLen, NewExtChannelOffset, Channel, RealRssi, TimeStamp, 0,
-									&EdcaParm, &QosCapability, &QbssLoad, LenVIE, pVIE);
+					Bssidx =
+					    BssTableSearch(&pAd->ScanTab, Bssid,
+							   Channel);
+					if (Bssidx == BSS_NOT_FOUND) {
+						Bssidx =
+						    BssTableSetEntry(pAd,
+								     &pAd->
+								     ScanTab,
+								     Bssid,
+								     Ssid,
+								     SsidLen,
+								     BssType,
+								     BeaconPeriod,
+								     &CfParm,
+								     AtimWin,
+								     CapabilityInfo,
+								     SupRate,
+								     SupRateLen,
+								     ExtRate,
+								     ExtRateLen,
+								     &HtCapability,
+								     &AddHtInfo,
+								     HtCapabilityLen,
+								     AddHtInfoLen,
+								     NewExtChannelOffset,
+								     Channel,
+								     RealRssi,
+								     TimeStamp,
+								     0,
+								     &EdcaParm,
+								     &QosCapability,
+								     &QbssLoad,
+								     LenVIE,
+								     pVIE);
 					}
-					DBGPRINT(RT_DEBUG_TRACE, ("ADHOC  fOP_STATUS_MEDIA_STATE_CONNECTED.\n"));
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("ADHOC  fOP_STATUS_MEDIA_STATE_CONNECTED.\n"));
 				}
 			}
 
-			if (INFRA_ON(pAd))
-			{
+			if (INFRA_ON(pAd)) {
 				BOOLEAN bUseShortSlot, bUseBGProtection;
 
 				// decide to use/change to -
@@ -1246,174 +1410,283 @@ VOID PeerBeacon(
 				//      3. short preamble
 
 				//bUseShortSlot = pAd->CommonCfg.bUseShortSlotTime && CAP_IS_SHORT_SLOT(CapabilityInfo);
-				bUseShortSlot = CAP_IS_SHORT_SLOT(CapabilityInfo);
-				if (bUseShortSlot != OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_SLOT_INUSED))
+				bUseShortSlot =
+				    CAP_IS_SHORT_SLOT(CapabilityInfo);
+				if (bUseShortSlot !=
+				    OPSTATUS_TEST_FLAG(pAd,
+						       fOP_STATUS_SHORT_SLOT_INUSED))
 					AsicSetSlotTime(pAd, bUseShortSlot);
 
-				bUseBGProtection = (pAd->CommonCfg.UseBGProtection == 1) ||    // always use
-								   ((pAd->CommonCfg.UseBGProtection == 0) && ERP_IS_USE_PROTECTION(Erp));
+				bUseBGProtection = (pAd->CommonCfg.UseBGProtection == 1) ||	// always use
+				    ((pAd->CommonCfg.UseBGProtection == 0)
+				     && ERP_IS_USE_PROTECTION(Erp));
 
-				if (pAd->CommonCfg.Channel > 14) // always no BG protection in A-band. falsely happened when switching A/G band to a dual-band AP
+				if (pAd->CommonCfg.Channel > 14)	// always no BG protection in A-band. falsely happened when switching A/G band to a dual-band AP
 					bUseBGProtection = FALSE;
 
-				if (bUseBGProtection != OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED))
+				if (bUseBGProtection !=
+				    OPSTATUS_TEST_FLAG(pAd,
+						       fOP_STATUS_BG_PROTECTION_INUSED))
 				{
-					if (bUseBGProtection)
-					{
-						OPSTATUS_SET_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
-						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, (OFDMSETPROTECT|CCKSETPROTECT|ALLN_SETPROTECT),FALSE,(pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1));
-					}
-					else
-					{
-						OPSTATUS_CLEAR_FLAG(pAd, fOP_STATUS_BG_PROTECTION_INUSED);
-						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, (OFDMSETPROTECT|CCKSETPROTECT|ALLN_SETPROTECT),TRUE,(pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1));
+					if (bUseBGProtection) {
+						OPSTATUS_SET_FLAG(pAd,
+								  fOP_STATUS_BG_PROTECTION_INUSED);
+						AsicUpdateProtect(pAd,
+								  pAd->MlmeAux.
+								  AddHtInfo.
+								  AddHtInfo2.
+								  OperaionMode,
+								  (OFDMSETPROTECT
+								   |
+								   CCKSETPROTECT
+								   |
+								   ALLN_SETPROTECT),
+								  FALSE,
+								  (pAd->MlmeAux.
+								   AddHtInfo.
+								   AddHtInfo2.
+								   NonGfPresent
+								   == 1));
+					} else {
+						OPSTATUS_CLEAR_FLAG(pAd,
+								    fOP_STATUS_BG_PROTECTION_INUSED);
+						AsicUpdateProtect(pAd,
+								  pAd->MlmeAux.
+								  AddHtInfo.
+								  AddHtInfo2.
+								  OperaionMode,
+								  (OFDMSETPROTECT
+								   |
+								   CCKSETPROTECT
+								   |
+								   ALLN_SETPROTECT),
+								  TRUE,
+								  (pAd->MlmeAux.
+								   AddHtInfo.
+								   AddHtInfo2.
+								   NonGfPresent
+								   == 1));
 					}
 
-					DBGPRINT(RT_DEBUG_WARN, ("SYNC - AP changed B/G protection to %d\n", bUseBGProtection));
+					DBGPRINT(RT_DEBUG_WARN,
+						 ("SYNC - AP changed B/G protection to %d\n",
+						  bUseBGProtection));
 				}
-
 				// check Ht protection mode. and adhere to the Non-GF device indication by AP.
 				if ((AddHtInfoLen != 0) &&
-					((AddHtInfo.AddHtInfo2.OperaionMode != pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode) ||
-					(AddHtInfo.AddHtInfo2.NonGfPresent != pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent)))
-				{
-					pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent = AddHtInfo.AddHtInfo2.NonGfPresent;
-					pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode = AddHtInfo.AddHtInfo2.OperaionMode;
-					if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.NonGfPresent == 1)
-				{
-						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, TRUE);
-					}
-					else
-						AsicUpdateProtect(pAd, pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode, ALLN_SETPROTECT, FALSE, FALSE);
-
-					DBGPRINT(RT_DEBUG_TRACE, ("SYNC - AP changed N OperaionMode to %d\n", pAd->MlmeAux.AddHtInfo.AddHtInfo2.OperaionMode));
+				    ((AddHtInfo.AddHtInfo2.OperaionMode !=
+				      pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+				      OperaionMode)
+				     || (AddHtInfo.AddHtInfo2.NonGfPresent !=
+					 pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+					 NonGfPresent))) {
+					pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+					    NonGfPresent =
+					    AddHtInfo.AddHtInfo2.NonGfPresent;
+					pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+					    OperaionMode =
+					    AddHtInfo.AddHtInfo2.OperaionMode;
+					if (pAd->MlmeAux.AddHtInfo.AddHtInfo2.
+					    NonGfPresent == 1) {
+						AsicUpdateProtect(pAd,
+								  pAd->MlmeAux.
+								  AddHtInfo.
+								  AddHtInfo2.
+								  OperaionMode,
+								  ALLN_SETPROTECT,
+								  FALSE, TRUE);
+					} else
+						AsicUpdateProtect(pAd,
+								  pAd->MlmeAux.
+								  AddHtInfo.
+								  AddHtInfo2.
+								  OperaionMode,
+								  ALLN_SETPROTECT,
+								  FALSE, FALSE);
+
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("SYNC - AP changed N OperaionMode to %d\n",
+						  pAd->MlmeAux.AddHtInfo.
+						  AddHtInfo2.OperaionMode));
 				}
 
-				if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED) &&
-					ERP_IS_USE_BARKER_PREAMBLE(Erp))
-				{
-					MlmeSetTxPreamble(pAd, Rt802_11PreambleLong);
-					DBGPRINT(RT_DEBUG_TRACE, ("SYNC - AP forced to use LONG preamble\n"));
+				if (OPSTATUS_TEST_FLAG
+				    (pAd, fOP_STATUS_SHORT_PREAMBLE_INUSED)
+				    && ERP_IS_USE_BARKER_PREAMBLE(Erp)) {
+					MlmeSetTxPreamble(pAd,
+							  Rt802_11PreambleLong);
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("SYNC - AP forced to use LONG preamble\n"));
 				}
 
-				if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_WMM_INUSED)    &&
-					(EdcaParm.bValid == TRUE)                          &&
-					(EdcaParm.EdcaUpdateCount != pAd->CommonCfg.APEdcaParm.EdcaUpdateCount))
-				{
-					DBGPRINT(RT_DEBUG_TRACE, ("SYNC - AP change EDCA parameters(from %d to %d)\n",
-						pAd->CommonCfg.APEdcaParm.EdcaUpdateCount,
-						EdcaParm.EdcaUpdateCount));
+				if (OPSTATUS_TEST_FLAG
+				    (pAd, fOP_STATUS_WMM_INUSED)
+				    && (EdcaParm.bValid == TRUE)
+				    && (EdcaParm.EdcaUpdateCount !=
+					pAd->CommonCfg.APEdcaParm.
+					EdcaUpdateCount)) {
+					DBGPRINT(RT_DEBUG_TRACE,
+						 ("SYNC - AP change EDCA parameters(from %d to %d)\n",
+						  pAd->CommonCfg.APEdcaParm.
+						  EdcaUpdateCount,
+						  EdcaParm.EdcaUpdateCount));
 					AsicSetEdcaParm(pAd, &EdcaParm);
 				}
-
 				// copy QOS related information
-				NdisMoveMemory(&pAd->CommonCfg.APQbssLoad, &QbssLoad, sizeof(QBSS_LOAD_PARM));
-				NdisMoveMemory(&pAd->CommonCfg.APQosCapability, &QosCapability, sizeof(QOS_CAPABILITY_PARM));
+				NdisMoveMemory(&pAd->CommonCfg.APQbssLoad,
+					       &QbssLoad,
+					       sizeof(QBSS_LOAD_PARM));
+				NdisMoveMemory(&pAd->CommonCfg.APQosCapability,
+					       &QosCapability,
+					       sizeof(QOS_CAPABILITY_PARM));
 			}
-
 			// only INFRASTRUCTURE mode support power-saving feature
-			if ((INFRA_ON(pAd) && (pAd->StaCfg.Psm == PWR_SAVE)) || (pAd->CommonCfg.bAPSDForcePowerSave))
-			{
+			if ((INFRA_ON(pAd) && (pAd->StaCfg.Psm == PWR_SAVE))
+			    || (pAd->CommonCfg.bAPSDForcePowerSave)) {
 				UCHAR FreeNumber;
 				//  1. AP has backlogged unicast-to-me frame, stay AWAKE, send PSPOLL
 				//  2. AP has backlogged broadcast/multicast frame and we want those frames, stay AWAKE
 				//  3. we have outgoing frames in TxRing or MgmtRing, better stay AWAKE
 				//  4. Psm change to PWR_SAVE, but AP not been informed yet, we better stay AWAKE
 				//  5. otherwise, put PHY back to sleep to save battery.
-				if (MessageToMe)
-				{
+				if (MessageToMe) {
 #ifdef RTMP_MAC_PCI
-					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-					{
+					if (OPSTATUS_TEST_FLAG
+					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
 						// Restore to correct BBP R3 value
-						if (pAd->Antenna.field.RxPath > 1)
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
+						if (pAd->Antenna.field.RxPath >
+						    1)
+							RTMP_BBP_IO_WRITE8_BY_REG_ID
+							    (pAd, BBP_R3,
+							     pAd->StaCfg.BBPR3);
 						// Turn clk to 80Mhz.
 					}
 #endif // RTMP_MAC_PCI //
-					if (pAd->CommonCfg.bAPSDCapable && pAd->CommonCfg.APEdcaParm.bAPSDCapable &&
-						pAd->CommonCfg.bAPSDAC_BE && pAd->CommonCfg.bAPSDAC_BK && pAd->CommonCfg.bAPSDAC_VI && pAd->CommonCfg.bAPSDAC_VO)
-					{
-						pAd->CommonCfg.bNeedSendTriggerFrame = TRUE;
-					}
-					else
+					if (pAd->CommonCfg.bAPSDCapable
+					    && pAd->CommonCfg.APEdcaParm.
+					    bAPSDCapable
+					    && pAd->CommonCfg.bAPSDAC_BE
+					    && pAd->CommonCfg.bAPSDAC_BK
+					    && pAd->CommonCfg.bAPSDAC_VI
+					    && pAd->CommonCfg.bAPSDAC_VO) {
+						pAd->CommonCfg.
+						    bNeedSendTriggerFrame =
+						    TRUE;
+					} else
 						RTMP_PS_POLL_ENQUEUE(pAd);
-				}
-				else if (BcastFlag && (DtimCount == 0) && OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM))
+				} else if (BcastFlag && (DtimCount == 0)
+					   && OPSTATUS_TEST_FLAG(pAd,
+								 fOP_STATUS_RECEIVE_DTIM))
 				{
 #ifdef RTMP_MAC_PCI
-					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-					{
-						if (pAd->Antenna.field.RxPath > 1)
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
+					if (OPSTATUS_TEST_FLAG
+					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
+						if (pAd->Antenna.field.RxPath >
+						    1)
+							RTMP_BBP_IO_WRITE8_BY_REG_ID
+							    (pAd, BBP_R3,
+							     pAd->StaCfg.BBPR3);
 					}
 #endif // RTMP_MAC_PCI //
-				}
-				else if ((pAd->TxSwQueue[QID_AC_BK].Number != 0)													||
-						(pAd->TxSwQueue[QID_AC_BE].Number != 0)														||
-						(pAd->TxSwQueue[QID_AC_VI].Number != 0)														||
-						(pAd->TxSwQueue[QID_AC_VO].Number != 0)														||
-						(RTMPFreeTXDRequest(pAd, QID_AC_BK, TX_RING_SIZE - 1, &FreeNumber) != NDIS_STATUS_SUCCESS)	||
-						(RTMPFreeTXDRequest(pAd, QID_AC_BE, TX_RING_SIZE - 1, &FreeNumber) != NDIS_STATUS_SUCCESS)	||
-						(RTMPFreeTXDRequest(pAd, QID_AC_VI, TX_RING_SIZE - 1, &FreeNumber) != NDIS_STATUS_SUCCESS)	||
-						(RTMPFreeTXDRequest(pAd, QID_AC_VO, TX_RING_SIZE - 1, &FreeNumber) != NDIS_STATUS_SUCCESS)	||
-						(RTMPFreeTXDRequest(pAd, QID_MGMT, MGMT_RING_SIZE - 1, &FreeNumber) != NDIS_STATUS_SUCCESS))
-				{
+				} else
+				    if ((pAd->TxSwQueue[QID_AC_BK].Number != 0)
+					|| (pAd->TxSwQueue[QID_AC_BE].Number !=
+					    0)
+					|| (pAd->TxSwQueue[QID_AC_VI].Number !=
+					    0)
+					|| (pAd->TxSwQueue[QID_AC_VO].Number !=
+					    0)
+					||
+					(RTMPFreeTXDRequest
+					 (pAd, QID_AC_BK, TX_RING_SIZE - 1,
+					  &FreeNumber) != NDIS_STATUS_SUCCESS)
+					||
+					(RTMPFreeTXDRequest
+					 (pAd, QID_AC_BE, TX_RING_SIZE - 1,
+					  &FreeNumber) != NDIS_STATUS_SUCCESS)
+					||
+					(RTMPFreeTXDRequest
+					 (pAd, QID_AC_VI, TX_RING_SIZE - 1,
+					  &FreeNumber) != NDIS_STATUS_SUCCESS)
+					||
+					(RTMPFreeTXDRequest
+					 (pAd, QID_AC_VO, TX_RING_SIZE - 1,
+					  &FreeNumber) != NDIS_STATUS_SUCCESS)
+					||
+					(RTMPFreeTXDRequest
+					 (pAd, QID_MGMT, MGMT_RING_SIZE - 1,
+					  &FreeNumber) !=
+					 NDIS_STATUS_SUCCESS)) {
 					// TODO: consider scheduled HCCA. might not be proper to use traditional DTIM-based power-saving scheme
 					// can we cheat here (i.e. just check MGMT & AC_BE) for better performance?
 #ifdef RTMP_MAC_PCI
-					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_PCIE_DEVICE))
-					{
-						if (pAd->Antenna.field.RxPath > 1)
-						RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R3, pAd->StaCfg.BBPR3);
+					if (OPSTATUS_TEST_FLAG
+					    (pAd, fOP_STATUS_PCIE_DEVICE)) {
+						if (pAd->Antenna.field.RxPath >
+						    1)
+							RTMP_BBP_IO_WRITE8_BY_REG_ID
+							    (pAd, BBP_R3,
+							     pAd->StaCfg.BBPR3);
 					}
 #endif // RTMP_MAC_PCI //
-				}
-				else
-				{
-					if ((pAd->CommonCfg.bACMAPSDTr[QID_AC_VO]) ||
-						(pAd->CommonCfg.bACMAPSDTr[QID_AC_VI]) ||
-						(pAd->CommonCfg.bACMAPSDTr[QID_AC_BK]) ||
-						(pAd->CommonCfg.bACMAPSDTr[QID_AC_BE]))
-					{
+				} else {
+					if ((pAd->CommonCfg.
+					     bACMAPSDTr[QID_AC_VO])
+					    || (pAd->CommonCfg.
+						bACMAPSDTr[QID_AC_VI])
+					    || (pAd->CommonCfg.
+						bACMAPSDTr[QID_AC_BK])
+					    || (pAd->CommonCfg.
+						bACMAPSDTr[QID_AC_BE])) {
 						/*
-							WMM Spec v1.0 3.6.2.4,
-							The WMM STA shall remain awake until it receives a
-							QoS Data or Null frame addressed to it, with the
-							EOSP subfield in QoS Control field set to 1.
-
-							So we can not sleep here or we will suffer a case:
-
-							PS Management Frame -->
-							Trigger frame -->
-							Beacon (TIM=0) (Beacon is closer to Trig frame) -->
-							Station goes to sleep -->
-							AP delivery queued UAPSD packets -->
-							Station can NOT receive the reply
-
-							Maybe we need a timeout timer to avoid that we do
-							NOT receive the EOSP frame.
-
-							We can not use More Data to check if SP is ended
-							due to MaxSPLength.
-						*/
-				}
-				else
-				{
-					USHORT NextDtim = DtimCount;
-
-					if (NextDtim == 0)
-						NextDtim = DtimPeriod;
-
-					TbttNumToNextWakeUp = pAd->StaCfg.DefaultListenCount;
-					if (OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_RECEIVE_DTIM) && (TbttNumToNextWakeUp > NextDtim))
-						TbttNumToNextWakeUp = NextDtim;
-
-					if (!OPSTATUS_TEST_FLAG(pAd, fOP_STATUS_DOZE))
-					{
-						// Set a flag to go to sleep . Then after parse this RxDoneInterrupt, will go to sleep mode.
-						pAd->ThisTbttNumToNextWakeUp = TbttNumToNextWakeUp;
-		                                        AsicSleepThenAutoWakeup(pAd, pAd->ThisTbttNumToNextWakeUp);
+						   WMM Spec v1.0 3.6.2.4,
+						   The WMM STA shall remain awake until it receives a
+						   QoS Data or Null frame addressed to it, with the
+						   EOSP subfield in QoS Control field set to 1.
+
+						   So we can not sleep here or we will suffer a case:
+
+						   PS Management Frame -->
+						   Trigger frame -->
+						   Beacon (TIM=0) (Beacon is closer to Trig frame) -->
+						   Station goes to sleep -->
+						   AP delivery queued UAPSD packets -->
+						   Station can NOT receive the reply
+
+						   Maybe we need a timeout timer to avoid that we do
+						   NOT receive the EOSP frame.
+
+						   We can not use More Data to check if SP is ended
+						   due to MaxSPLength.
+						 */
+					} else {
+						USHORT NextDtim = DtimCount;
+
+						if (NextDtim == 0)
+							NextDtim = DtimPeriod;
+
+						TbttNumToNextWakeUp =
+						    pAd->StaCfg.
+						    DefaultListenCount;
+						if (OPSTATUS_TEST_FLAG
+						    (pAd,
+						     fOP_STATUS_RECEIVE_DTIM)
+						    && (TbttNumToNextWakeUp >
+							NextDtim))
+							TbttNumToNextWakeUp =
+							    NextDtim;
+
+						if (!OPSTATUS_TEST_FLAG
+						    (pAd, fOP_STATUS_DOZE)) {
+							// Set a flag to go to sleep . Then after parse this RxDoneInterrupt, will go to sleep mode.
+							pAd->
+							    ThisTbttNumToNextWakeUp
+							    =
+							    TbttNumToNextWakeUp;
+							AsicSleepThenAutoWakeup
+							    (pAd,
+							     pAd->
+							     ThisTbttNumToNextWakeUp);
 						}
 					}
 				}
@@ -1430,116 +1703,126 @@ VOID PeerBeacon(
 		Receive PROBE REQ from remote peer when operating in IBSS mode
 	==========================================================================
  */
-VOID PeerProbeReqAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID PeerProbeReqAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	UCHAR         Addr2[MAC_ADDR_LEN];
-	CHAR          Ssid[MAX_LEN_OF_SSID];
-	UCHAR         SsidLen;
-	UCHAR		  HtLen, AddHtLen, NewExtLen;
+	UCHAR Addr2[MAC_ADDR_LEN];
+	CHAR Ssid[MAX_LEN_OF_SSID];
+	UCHAR SsidLen;
+	UCHAR HtLen, AddHtLen, NewExtLen;
 	HEADER_802_11 ProbeRspHdr;
-	NDIS_STATUS   NStatus;
-	PUCHAR        pOutBuffer = NULL;
-	ULONG         FrameLen = 0;
+	NDIS_STATUS NStatus;
+	PUCHAR pOutBuffer = NULL;
+	ULONG FrameLen = 0;
 	LARGE_INTEGER FakeTimestamp;
-	UCHAR         DsLen = 1, IbssLen = 2;
-	UCHAR         LocalErpIe[3] = {IE_ERP, 1, 0};
-	BOOLEAN       Privacy;
-	USHORT        CapabilityInfo;
-	UCHAR		  RSNIe = IE_WPA;
+	UCHAR DsLen = 1, IbssLen = 2;
+	UCHAR LocalErpIe[3] = { IE_ERP, 1, 0 };
+	BOOLEAN Privacy;
+	USHORT CapabilityInfo;
+	UCHAR RSNIe = IE_WPA;
 
-	if (! ADHOC_ON(pAd))
+	if (!ADHOC_ON(pAd))
 		return;
 
-	if (PeerProbeReqSanity(pAd, Elem->Msg, Elem->MsgLen, Addr2, Ssid, &SsidLen))
-	{
-		if ((SsidLen == 0) || SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid, pAd->CommonCfg.SsidLen))
-		{
+	if (PeerProbeReqSanity
+	    (pAd, Elem->Msg, Elem->MsgLen, Addr2, Ssid, &SsidLen)) {
+		if ((SsidLen == 0)
+		    || SSID_EQUAL(Ssid, SsidLen, pAd->CommonCfg.Ssid,
+				  pAd->CommonCfg.SsidLen)) {
 			// allocate and send out ProbeRsp frame
-			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
+			NStatus = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
 			if (NStatus != NDIS_STATUS_SUCCESS)
 				return;
 
 			//pAd->StaCfg.AtimWin = 0;  // ??????
 
-			Privacy = (pAd->StaCfg.WepStatus == Ndis802_11Encryption1Enabled) ||
-					  (pAd->StaCfg.WepStatus == Ndis802_11Encryption2Enabled) ||
-					  (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled);
-			CapabilityInfo = CAP_GENERATE(0, 1, Privacy, (pAd->CommonCfg.TxPreamble == Rt802_11PreambleShort), 0, 0);
-
-			MakeOutgoingFrame(pOutBuffer,                   &FrameLen,
-							  sizeof(HEADER_802_11),        &ProbeRspHdr,
-							  TIMESTAMP_LEN,                &FakeTimestamp,
-							  2,                            &pAd->CommonCfg.BeaconPeriod,
-							  2,                            &CapabilityInfo,
-							  1,                            &SsidIe,
-							  1,                            &pAd->CommonCfg.SsidLen,
-							  pAd->CommonCfg.SsidLen,       pAd->CommonCfg.Ssid,
-							  1,                            &SupRateIe,
-							  1,                            &pAd->StaActive.SupRateLen,
-							  pAd->StaActive.SupRateLen,    pAd->StaActive.SupRate,
-							  1,                            &DsIe,
-							  1,                            &DsLen,
-							  1,                            &pAd->CommonCfg.Channel,
-							  1,                            &IbssIe,
-							  1,                            &IbssLen,
-							  2,                            &pAd->StaActive.AtimWin,
-							  END_OF_ARGS);
-
-			if (pAd->StaActive.ExtRateLen)
-			{
+			Privacy =
+			    (pAd->StaCfg.WepStatus ==
+			     Ndis802_11Encryption1Enabled)
+			    || (pAd->StaCfg.WepStatus ==
+				Ndis802_11Encryption2Enabled)
+			    || (pAd->StaCfg.WepStatus ==
+				Ndis802_11Encryption3Enabled);
+			CapabilityInfo =
+			    CAP_GENERATE(0, 1, Privacy,
+					 (pAd->CommonCfg.TxPreamble ==
+					  Rt802_11PreambleShort), 0, 0);
+
+			MakeOutgoingFrame(pOutBuffer, &FrameLen,
+					  sizeof(HEADER_802_11), &ProbeRspHdr,
+					  TIMESTAMP_LEN, &FakeTimestamp,
+					  2, &pAd->CommonCfg.BeaconPeriod,
+					  2, &CapabilityInfo,
+					  1, &SsidIe,
+					  1, &pAd->CommonCfg.SsidLen,
+					  pAd->CommonCfg.SsidLen,
+					  pAd->CommonCfg.Ssid, 1, &SupRateIe, 1,
+					  &pAd->StaActive.SupRateLen,
+					  pAd->StaActive.SupRateLen,
+					  pAd->StaActive.SupRate, 1, &DsIe, 1,
+					  &DsLen, 1, &pAd->CommonCfg.Channel, 1,
+					  &IbssIe, 1, &IbssLen, 2,
+					  &pAd->StaActive.AtimWin, END_OF_ARGS);
+
+			if (pAd->StaActive.ExtRateLen) {
 				ULONG tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,        &tmp,
-								  3,                            LocalErpIe,
-								  1,                            &ExtRateIe,
-								  1,                            &pAd->StaActive.ExtRateLen,
-								  pAd->StaActive.ExtRateLen,    &pAd->StaActive.ExtRate,
-								  END_OF_ARGS);
+				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+						  3, LocalErpIe,
+						  1, &ExtRateIe,
+						  1, &pAd->StaActive.ExtRateLen,
+						  pAd->StaActive.ExtRateLen,
+						  &pAd->StaActive.ExtRate,
+						  END_OF_ARGS);
 				FrameLen += tmp;
 			}
-
 			// If adhoc secruity is set for WPA-None, append the cipher suite IE
-			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone)
-			{
+			if (pAd->StaCfg.AuthMode == Ndis802_11AuthModeWPANone) {
 				ULONG tmp;
-				MakeOutgoingFrame(pOutBuffer + FrameLen,        	&tmp,
-						  			1,                              &RSNIe,
-						  			1,                            	&pAd->StaCfg.RSNIE_Len,
-						  			pAd->StaCfg.RSNIE_Len,      	pAd->StaCfg.RSN_IE,
-						  			END_OF_ARGS);
+				MakeOutgoingFrame(pOutBuffer + FrameLen, &tmp,
+						  1, &RSNIe,
+						  1, &pAd->StaCfg.RSNIE_Len,
+						  pAd->StaCfg.RSNIE_Len,
+						  pAd->StaCfg.RSN_IE,
+						  END_OF_ARGS);
 				FrameLen += tmp;
 			}
 
-			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED)
-			{
+			if (pAd->CommonCfg.PhyMode >= PHY_11ABGN_MIXED) {
 				ULONG TmpLen;
-				UCHAR	BROADCOM[4] = {0x0, 0x90, 0x4c, 0x33};
+				UCHAR BROADCOM[4] = { 0x0, 0x90, 0x4c, 0x33 };
 				HtLen = sizeof(pAd->CommonCfg.HtCapability);
 				AddHtLen = sizeof(pAd->CommonCfg.AddHTInfo);
 				NewExtLen = 1;
 				//New extension channel offset IE is included in Beacon, Probe Rsp or channel Switch Announcement Frame
-				if (pAd->bBroadComHT == TRUE)
-				{
-					MakeOutgoingFrame(pOutBuffer + FrameLen,            &TmpLen,
-								  1,                                &WpaIe,
-								  4,                                &BROADCOM[0],
-								 pAd->MlmeAux.HtCapabilityLen,          &pAd->MlmeAux.HtCapability,
-								  END_OF_ARGS);
-				}
-				else
-				{
-				MakeOutgoingFrame(pOutBuffer + FrameLen,            &TmpLen,
-								  1,                                &HtCapIe,
-								  1,                                &HtLen,
-								 sizeof(HT_CAPABILITY_IE),          &pAd->CommonCfg.HtCapability,
-								  1,                                &AddHtInfoIe,
-								  1,                                &AddHtLen,
-								 sizeof(ADD_HT_INFO_IE),          &pAd->CommonCfg.AddHTInfo,
-								  1,                                &NewExtChanIe,
-								  1,                                &NewExtLen,
-								 sizeof(NEW_EXT_CHAN_IE),          &pAd->CommonCfg.NewExtChanOffset,
-								  END_OF_ARGS);
+				if (pAd->bBroadComHT == TRUE) {
+					MakeOutgoingFrame(pOutBuffer + FrameLen,
+							  &TmpLen, 1, &WpaIe, 4,
+							  &BROADCOM[0],
+							  pAd->MlmeAux.
+							  HtCapabilityLen,
+							  &pAd->MlmeAux.
+							  HtCapability,
+							  END_OF_ARGS);
+				} else {
+					MakeOutgoingFrame(pOutBuffer + FrameLen,
+							  &TmpLen, 1, &HtCapIe,
+							  1, &HtLen,
+							  sizeof
+							  (HT_CAPABILITY_IE),
+							  &pAd->CommonCfg.
+							  HtCapability, 1,
+							  &AddHtInfoIe, 1,
+							  &AddHtLen,
+							  sizeof
+							  (ADD_HT_INFO_IE),
+							  &pAd->CommonCfg.
+							  AddHTInfo, 1,
+							  &NewExtChanIe, 1,
+							  &NewExtLen,
+							  sizeof
+							  (NEW_EXT_CHAN_IE),
+							  &pAd->CommonCfg.
+							  NewExtChanOffset,
+							  END_OF_ARGS);
 				}
 				FrameLen += TmpLen;
 			}
@@ -1550,9 +1833,7 @@ VOID PeerProbeReqAction(
 	}
 }
 
-VOID BeaconTimeoutAtJoinAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID BeaconTimeoutAtJoinAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	USHORT Status;
 	DBGPRINT(RT_DEBUG_TRACE, ("SYNC - BeaconTimeoutAtJoinAction\n"));
@@ -1567,17 +1848,15 @@ VOID BeaconTimeoutAtJoinAction(
 		Scan timeout procedure. basically add channel index by 1 and rescan
 	==========================================================================
  */
-VOID ScanTimeoutAction(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID ScanTimeoutAction(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	pAd->MlmeAux.Channel = NextChannel(pAd, pAd->MlmeAux.Channel);
 
 	// Only one channel scanned for CISCO beacon request
 	if ((pAd->MlmeAux.ScanType == SCAN_CISCO_ACTIVE) ||
-		(pAd->MlmeAux.ScanType == SCAN_CISCO_PASSIVE) ||
-		(pAd->MlmeAux.ScanType == SCAN_CISCO_NOISE) ||
-		(pAd->MlmeAux.ScanType == SCAN_CISCO_CHANNEL_LOAD))
+	    (pAd->MlmeAux.ScanType == SCAN_CISCO_PASSIVE) ||
+	    (pAd->MlmeAux.ScanType == SCAN_CISCO_NOISE) ||
+	    (pAd->MlmeAux.ScanType == SCAN_CISCO_CHANNEL_LOAD))
 		pAd->MlmeAux.Channel = 0;
 
 	// this routine will stop if pAd->MlmeAux.Channel == 0
@@ -1589,12 +1868,12 @@ VOID ScanTimeoutAction(
 	Description:
 	==========================================================================
  */
-VOID InvalidStateWhenScan(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID InvalidStateWhenScan(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	USHORT Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("AYNC - InvalidStateWhenScan(state=%ld). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("AYNC - InvalidStateWhenScan(state=%ld). Reset SYNC machine\n",
+		  pAd->Mlme.SyncMachine.CurrState));
 	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 	Status = MLME_STATE_MACHINE_REJECT;
 	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_SCAN_CONF, 2, &Status);
@@ -1605,12 +1884,12 @@ VOID InvalidStateWhenScan(
 	Description:
 	==========================================================================
  */
-VOID InvalidStateWhenJoin(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID InvalidStateWhenJoin(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	USHORT Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("InvalidStateWhenJoin(state=%ld). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("InvalidStateWhenJoin(state=%ld). Reset SYNC machine\n",
+		  pAd->Mlme.SyncMachine.CurrState));
 	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 	Status = MLME_STATE_MACHINE_REJECT;
 	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_JOIN_CONF, 2, &Status);
@@ -1621,12 +1900,12 @@ VOID InvalidStateWhenJoin(
 	Description:
 	==========================================================================
  */
-VOID InvalidStateWhenStart(
-	IN PRTMP_ADAPTER pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID InvalidStateWhenStart(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
 	USHORT Status;
-	DBGPRINT(RT_DEBUG_TRACE, ("InvalidStateWhenStart(state=%ld). Reset SYNC machine\n", pAd->Mlme.SyncMachine.CurrState));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("InvalidStateWhenStart(state=%ld). Reset SYNC machine\n",
+		  pAd->Mlme.SyncMachine.CurrState));
 	pAd->Mlme.SyncMachine.CurrState = SYNC_IDLE;
 	Status = MLME_STATE_MACHINE_REJECT;
 	MlmeEnqueue(pAd, MLME_CNTL_STATE_MACHINE, MT2_START_CONF, 2, &Status);
@@ -1640,56 +1919,51 @@ VOID InvalidStateWhenStart(
 
 	==========================================================================
  */
-VOID EnqueuePsPoll(
-	IN PRTMP_ADAPTER pAd)
+VOID EnqueuePsPoll(IN PRTMP_ADAPTER pAd)
 {
 
-
 	if (pAd->StaCfg.WindowsPowerMode == Ndis802_11PowerModeLegacy_PSP)
-    	pAd->PsPollFrame.FC.PwrMgmt = PWR_SAVE;
-	MiniportMMRequest(pAd, 0, (PUCHAR)&pAd->PsPollFrame, sizeof(PSPOLL_FRAME));
+		pAd->PsPollFrame.FC.PwrMgmt = PWR_SAVE;
+	MiniportMMRequest(pAd, 0, (PUCHAR) & pAd->PsPollFrame,
+			  sizeof(PSPOLL_FRAME));
 }
 
-
 /*
 	==========================================================================
 	Description:
 	==========================================================================
  */
-VOID EnqueueProbeRequest(
-	IN PRTMP_ADAPTER pAd)
+VOID EnqueueProbeRequest(IN PRTMP_ADAPTER pAd)
 {
-	NDIS_STATUS     NState;
-	PUCHAR          pOutBuffer;
-	ULONG           FrameLen = 0;
-	HEADER_802_11   Hdr80211;
+	NDIS_STATUS NState;
+	PUCHAR pOutBuffer;
+	ULONG FrameLen = 0;
+	HEADER_802_11 Hdr80211;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("force out a ProbeRequest ...\n"));
 
-	NState = MlmeAllocateMemory(pAd, &pOutBuffer);  //Get an unused nonpaged memory
-	if (NState == NDIS_STATUS_SUCCESS)
-	{
-		MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0, BROADCAST_ADDR, BROADCAST_ADDR);
+	NState = MlmeAllocateMemory(pAd, &pOutBuffer);	//Get an unused nonpaged memory
+	if (NState == NDIS_STATUS_SUCCESS) {
+		MgtMacHeaderInit(pAd, &Hdr80211, SUBTYPE_PROBE_REQ, 0,
+				 BROADCAST_ADDR, BROADCAST_ADDR);
 
 		// this ProbeRequest explicitly specify SSID to reduce unwanted ProbeResponse
-		MakeOutgoingFrame(pOutBuffer,                     &FrameLen,
-						  sizeof(HEADER_802_11),          &Hdr80211,
-						  1,                              &SsidIe,
-						  1,                              &pAd->CommonCfg.SsidLen,
-						  pAd->CommonCfg.SsidLen,		  pAd->CommonCfg.Ssid,
-						  1,                              &SupRateIe,
-						  1,                              &pAd->StaActive.SupRateLen,
-						  pAd->StaActive.SupRateLen,      pAd->StaActive.SupRate,
-						  END_OF_ARGS);
+		MakeOutgoingFrame(pOutBuffer, &FrameLen,
+				  sizeof(HEADER_802_11), &Hdr80211,
+				  1, &SsidIe,
+				  1, &pAd->CommonCfg.SsidLen,
+				  pAd->CommonCfg.SsidLen, pAd->CommonCfg.Ssid,
+				  1, &SupRateIe,
+				  1, &pAd->StaActive.SupRateLen,
+				  pAd->StaActive.SupRateLen,
+				  pAd->StaActive.SupRate, END_OF_ARGS);
 		MiniportMMRequest(pAd, 0, pOutBuffer, FrameLen);
 		MlmeFreeMemory(pAd, pOutBuffer);
 	}
 
 }
 
-BOOLEAN ScanRunning(
-		IN PRTMP_ADAPTER pAd)
+BOOLEAN ScanRunning(IN PRTMP_ADAPTER pAd)
 {
 	return (pAd->Mlme.SyncMachine.CurrState == SCAN_LISTEN) ? TRUE : FALSE;
 }
-
diff --git a/drivers/staging/rt2860/sta/wpa.c b/drivers/staging/rt2860/sta/wpa.c
index c6c3f3b..0a45643 100644
--- a/drivers/staging/rt2860/sta/wpa.c
+++ b/drivers/staging/rt2860/sta/wpa.c
@@ -37,7 +37,7 @@
 */
 #include "../rt_config.h"
 
-void inc_byte_array(UCHAR *counter, int len);
+void inc_byte_array(UCHAR * counter, int len);
 
 /*
 	========================================================================
@@ -58,33 +58,29 @@ void inc_byte_array(UCHAR *counter, int len);
 
 	========================================================================
 */
-VOID	RTMPReportMicError(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PCIPHER_KEY 	pWpaKey)
+VOID RTMPReportMicError(IN PRTMP_ADAPTER pAd, IN PCIPHER_KEY pWpaKey)
 {
-	ULONG	Now;
-    UCHAR   unicastKey = (pWpaKey->Type == PAIRWISE_KEY ? 1:0);
+	ULONG Now;
+	UCHAR unicastKey = (pWpaKey->Type == PAIRWISE_KEY ? 1 : 0);
 
 	// Record Last MIC error time and count
 	NdisGetSystemUpTime(&Now);
-	if (pAd->StaCfg.MicErrCnt == 0)
-	{
+	if (pAd->StaCfg.MicErrCnt == 0) {
 		pAd->StaCfg.MicErrCnt++;
 		pAd->StaCfg.LastMicErrorTime = Now;
-        NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
-	}
-	else if (pAd->StaCfg.MicErrCnt == 1)
-	{
-		if ((pAd->StaCfg.LastMicErrorTime + (60 * OS_HZ)) < Now)
-		{
+		NdisZeroMemory(pAd->StaCfg.ReplayCounter, 8);
+	} else if (pAd->StaCfg.MicErrCnt == 1) {
+		if ((pAd->StaCfg.LastMicErrorTime + (60 * OS_HZ)) < Now) {
 			// Update Last MIC error time, this did not violate two MIC errors within 60 seconds
 			pAd->StaCfg.LastMicErrorTime = Now;
-		}
-		else
-		{
+		} else {
 
 			if (pAd->CommonCfg.bWirelessEvent)
-				RTMPSendWirelessEvent(pAd, IW_COUNTER_MEASURES_EVENT_FLAG, pAd->MacTab.Content[BSSID_WCID].Addr, BSS0, 0);
+				RTMPSendWirelessEvent(pAd,
+						      IW_COUNTER_MEASURES_EVENT_FLAG,
+						      pAd->MacTab.
+						      Content[BSSID_WCID].Addr,
+						      BSS0, 0);
 
 			pAd->StaCfg.LastMicErrorTime = Now;
 			// Violate MIC error counts, MIC countermeasures kicks in
@@ -101,154 +97,139 @@ VOID	RTMPReportMicError(
 			// RTMPRingCleanUp(pAd, QID_AC_VO);
 			// RTMPRingCleanUp(pAd, QID_HCCA);
 		}
-	}
-	else
-	{
+	} else {
 		// MIC error count >= 2
 		// This should not happen
 		;
 	}
-    MlmeEnqueue(pAd,
-				MLME_CNTL_STATE_MACHINE,
-				OID_802_11_MIC_FAILURE_REPORT_FRAME,
-				1,
-				&unicastKey);
-
-    if (pAd->StaCfg.MicErrCnt == 2)
-    {
-        RTMPSetTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer, 100);
-    }
+	MlmeEnqueue(pAd,
+		    MLME_CNTL_STATE_MACHINE,
+		    OID_802_11_MIC_FAILURE_REPORT_FRAME, 1, &unicastKey);
+
+	if (pAd->StaCfg.MicErrCnt == 2) {
+		RTMPSetTimer(&pAd->StaCfg.WpaDisassocAndBlockAssocTimer, 100);
+	}
 }
 
 #define	LENGTH_EAP_H    4
 // If the received frame is EAP-Packet ,find out its EAP-Code (Request(0x01), Response(0x02), Success(0x03), Failure(0x04)).
-INT	    WpaCheckEapCode(
-	IN  PRTMP_ADAPTER   		pAd,
-	IN  PUCHAR				pFrame,
-	IN  USHORT				FrameLen,
-	IN  USHORT				OffSet)
+INT WpaCheckEapCode(IN PRTMP_ADAPTER pAd,
+		    IN PUCHAR pFrame, IN USHORT FrameLen, IN USHORT OffSet)
 {
 
-	PUCHAR	pData;
-	INT	result = 0;
+	PUCHAR pData;
+	INT result = 0;
 
-	if( FrameLen < OffSet + LENGTH_EAPOL_H + LENGTH_EAP_H )
+	if (FrameLen < OffSet + LENGTH_EAPOL_H + LENGTH_EAP_H)
 		return result;
 
-	pData = pFrame + OffSet; // skip offset bytes
+	pData = pFrame + OffSet;	// skip offset bytes
 
-	if(*(pData+1) == EAPPacket) 	// 802.1x header - Packet Type
+	if (*(pData + 1) == EAPPacket)	// 802.1x header - Packet Type
 	{
-		 result = *(pData+4);		// EAP header - Code
+		result = *(pData + 4);	// EAP header - Code
 	}
 
 	return result;
 }
 
-VOID    WpaSendMicFailureToWpaSupplicant(
-    IN  PRTMP_ADAPTER    pAd,
-    IN  BOOLEAN          bUnicast)
+VOID WpaSendMicFailureToWpaSupplicant(IN PRTMP_ADAPTER pAd, IN BOOLEAN bUnicast)
 {
-    char custom[IW_CUSTOM_MAX] = {0};
+	char custom[IW_CUSTOM_MAX] = { 0 };
 
-    sprintf(custom, "MLME-MICHAELMICFAILURE.indication");
-	if(bUnicast)
-        sprintf(custom, "%s unicast", custom);
+	sprintf(custom, "MLME-MICHAELMICFAILURE.indication");
+	if (bUnicast)
+		sprintf(custom, "%s unicast", custom);
 
-	RtmpOSWrielessEventSend(pAd, IWEVCUSTOM, -1, NULL, (PUCHAR)custom, strlen(custom));
+	RtmpOSWrielessEventSend(pAd, IWEVCUSTOM, -1, NULL, (PUCHAR) custom,
+				strlen(custom));
 
-    return;
+	return;
 }
 
-VOID	WpaMicFailureReportFrame(
-	IN  PRTMP_ADAPTER   pAd,
-	IN MLME_QUEUE_ELEM *Elem)
+VOID WpaMicFailureReportFrame(IN PRTMP_ADAPTER pAd, IN MLME_QUEUE_ELEM * Elem)
 {
-	PUCHAR              pOutBuffer = NULL;
-	UCHAR               Header802_3[14];
-	ULONG               FrameLen = 0;
-	EAPOL_PACKET        Packet;
-	UCHAR               Mic[16];
-    BOOLEAN             bUnicast;
+	PUCHAR pOutBuffer = NULL;
+	UCHAR Header802_3[14];
+	ULONG FrameLen = 0;
+	EAPOL_PACKET Packet;
+	UCHAR Mic[16];
+	BOOLEAN bUnicast;
 
 	DBGPRINT(RT_DEBUG_TRACE, ("WpaMicFailureReportFrame ----->\n"));
 
-    bUnicast = (Elem->Msg[0] == 1 ? TRUE:FALSE);
+	bUnicast = (Elem->Msg[0] == 1 ? TRUE : FALSE);
 	pAd->Sequence = ((pAd->Sequence) + 1) & (MAX_SEQ_NUMBER);
 
 	// init 802.3 header and Fill Packet
-	MAKE_802_3_HEADER(Header802_3, pAd->CommonCfg.Bssid, pAd->CurrentAddress, EAPOL);
+	MAKE_802_3_HEADER(Header802_3, pAd->CommonCfg.Bssid,
+			  pAd->CurrentAddress, EAPOL);
 
 	NdisZeroMemory(&Packet, sizeof(Packet));
-	Packet.ProVer	= EAPOL_VER;
-	Packet.ProType	= EAPOLKey;
+	Packet.ProVer = EAPOL_VER;
+	Packet.ProType = EAPOLKey;
 
 	Packet.KeyDesc.Type = WPA1_KEY_DESC;
 
-    // Request field presented
-    Packet.KeyDesc.KeyInfo.Request = 1;
+	// Request field presented
+	Packet.KeyDesc.KeyInfo.Request = 1;
 
-	if(pAd->StaCfg.WepStatus  == Ndis802_11Encryption3Enabled)
-	{
+	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {
 		Packet.KeyDesc.KeyInfo.KeyDescVer = 2;
-	}
-	else	  // TKIP
+	} else			// TKIP
 	{
 		Packet.KeyDesc.KeyInfo.KeyDescVer = 1;
 	}
 
-    Packet.KeyDesc.KeyInfo.KeyType = (bUnicast ? PAIRWISEKEY : GROUPKEY);
+	Packet.KeyDesc.KeyInfo.KeyType = (bUnicast ? PAIRWISEKEY : GROUPKEY);
 
 	// KeyMic field presented
-	Packet.KeyDesc.KeyInfo.KeyMic  = 1;
+	Packet.KeyDesc.KeyInfo.KeyMic = 1;
 
-    // Error field presented
-	Packet.KeyDesc.KeyInfo.Error  = 1;
+	// Error field presented
+	Packet.KeyDesc.KeyInfo.Error = 1;
 
 	// Update packet length after decide Key data payload
 	SET_UINT16_TO_ARRARY(Packet.Body_Len, LEN_EAPOL_KEY_MSG)
-
-	// Key Replay Count
-	NdisMoveMemory(Packet.KeyDesc.ReplayCounter, pAd->StaCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
-    inc_byte_array(pAd->StaCfg.ReplayCounter, 8);
+	    // Key Replay Count
+	    NdisMoveMemory(Packet.KeyDesc.ReplayCounter,
+			   pAd->StaCfg.ReplayCounter, LEN_KEY_DESC_REPLAY);
+	inc_byte_array(pAd->StaCfg.ReplayCounter, 8);
 
 	// Convert to little-endian format.
-	*((USHORT *)&Packet.KeyDesc.KeyInfo) = cpu2le16(*((USHORT *)&Packet.KeyDesc.KeyInfo));
-
+	*((USHORT *) & Packet.KeyDesc.KeyInfo) =
+	    cpu2le16(*((USHORT *) & Packet.KeyDesc.KeyInfo));
 
-	MlmeAllocateMemory(pAd, (PUCHAR *)&pOutBuffer);  // allocate memory
-	if(pOutBuffer == NULL)
-	{
+	MlmeAllocateMemory(pAd, (PUCHAR *) & pOutBuffer);	// allocate memory
+	if (pOutBuffer == NULL) {
 		return;
 	}
-
 	// Prepare EAPOL frame for MIC calculation
 	// Be careful, only EAPOL frame is counted for MIC calculation
-	MakeOutgoingFrame(pOutBuffer,               &FrameLen,
-		              CONV_ARRARY_TO_UINT16(Packet.Body_Len) + 4,   &Packet,
-		              END_OF_ARGS);
+	MakeOutgoingFrame(pOutBuffer, &FrameLen,
+			  CONV_ARRARY_TO_UINT16(Packet.Body_Len) + 4, &Packet,
+			  END_OF_ARGS);
 
 	// Prepare and Fill MIC value
 	NdisZeroMemory(Mic, sizeof(Mic));
-	if(pAd->StaCfg.WepStatus  == Ndis802_11Encryption3Enabled)
-	{	// AES
-        UCHAR digest[20] = {0};
-		HMAC_SHA1(pAd->StaCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen, digest, SHA1_DIGEST_SIZE);
+	if (pAd->StaCfg.WepStatus == Ndis802_11Encryption3Enabled) {	// AES
+		UCHAR digest[20] = { 0 };
+		HMAC_SHA1(pAd->StaCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen,
+			  digest, SHA1_DIGEST_SIZE);
 		NdisMoveMemory(Mic, digest, LEN_KEY_DESC_MIC);
-	}
-	else
-	{	// TKIP
-		HMAC_MD5(pAd->StaCfg.PTK,  LEN_EAP_MICK, pOutBuffer, FrameLen, Mic, MD5_DIGEST_SIZE);
+	} else {		// TKIP
+		HMAC_MD5(pAd->StaCfg.PTK, LEN_EAP_MICK, pOutBuffer, FrameLen,
+			 Mic, MD5_DIGEST_SIZE);
 	}
 	NdisMoveMemory(Packet.KeyDesc.KeyMic, Mic, LEN_KEY_DESC_MIC);
 
 	// copy frame to Tx ring and send MIC failure report frame to authenticator
 	RTMPToWirelessSta(pAd, &pAd->MacTab.Content[BSSID_WCID],
-					  Header802_3, LENGTH_802_3,
-					  (PUCHAR)&Packet,
-					  CONV_ARRARY_TO_UINT16(Packet.Body_Len) + 4, FALSE);
+			  Header802_3, LENGTH_802_3,
+			  (PUCHAR) & Packet,
+			  CONV_ARRARY_TO_UINT16(Packet.Body_Len) + 4, FALSE);
 
-	MlmeFreeMemory(pAd, (PUCHAR)pOutBuffer);
+	MlmeFreeMemory(pAd, (PUCHAR) pOutBuffer);
 
 	DBGPRINT(RT_DEBUG_TRACE, ("WpaMicFailureReportFrame <-----\n"));
 }
@@ -262,7 +243,7 @@ VOID	WpaMicFailureReportFrame(
  * rolling over to more significant bytes if the byte was incremented from
  * 0xff to 0x00.
  */
-void inc_byte_array(UCHAR *counter, int len)
+void inc_byte_array(UCHAR * counter, int len)
 {
 	int pos = len - 1;
 	while (pos >= 0) {
@@ -273,26 +254,27 @@ void inc_byte_array(UCHAR *counter, int len)
 	}
 }
 
-VOID WpaDisassocApAndBlockAssoc(
-    IN PVOID SystemSpecific1,
-    IN PVOID FunctionContext,
-    IN PVOID SystemSpecific2,
-    IN PVOID SystemSpecific3)
+VOID WpaDisassocApAndBlockAssoc(IN PVOID SystemSpecific1,
+				IN PVOID FunctionContext,
+				IN PVOID SystemSpecific2,
+				IN PVOID SystemSpecific3)
 {
-    RTMP_ADAPTER                *pAd = (PRTMP_ADAPTER)FunctionContext;
-    MLME_DISASSOC_REQ_STRUCT    DisassocReq;
+	RTMP_ADAPTER *pAd = (PRTMP_ADAPTER) FunctionContext;
+	MLME_DISASSOC_REQ_STRUCT DisassocReq;
 
 	// disassoc from current AP first
-	DBGPRINT(RT_DEBUG_TRACE, ("RTMPReportMicError - disassociate with current AP after sending second continuous EAPOL frame\n"));
-	DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid, REASON_MIC_FAILURE);
-	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ, sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("RTMPReportMicError - disassociate with current AP after sending second continuous EAPOL frame\n"));
+	DisassocParmFill(pAd, &DisassocReq, pAd->CommonCfg.Bssid,
+			 REASON_MIC_FAILURE);
+	MlmeEnqueue(pAd, ASSOC_STATE_MACHINE, MT2_MLME_DISASSOC_REQ,
+		    sizeof(MLME_DISASSOC_REQ_STRUCT), &DisassocReq);
 
 	pAd->Mlme.CntlMachine.CurrState = CNTL_WAIT_DISASSOC;
 	pAd->StaCfg.bBlockAssoc = TRUE;
 }
 
-VOID WpaStaPairwiseKeySetting(
-	IN	PRTMP_ADAPTER	pAd)
+VOID WpaStaPairwiseKeySetting(IN PRTMP_ADAPTER pAd)
 {
 	PCIPHER_KEY pSharedKey;
 	PMAC_TABLE_ENTRY pEntry;
@@ -307,9 +289,11 @@ VOID WpaStaPairwiseKeySetting(
 	// Prepare pair-wise key information into shared key table
 	NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 	pSharedKey->KeyLen = LEN_TKIP_EK;
-    NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32], LEN_TKIP_EK);
-	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.PTK[48], LEN_TKIP_RXMICK);
-	NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.PTK[48+LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
+	NdisMoveMemory(pSharedKey->Key, &pAd->StaCfg.PTK[32], LEN_TKIP_EK);
+	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.PTK[48],
+		       LEN_TKIP_RXMICK);
+	NdisMoveMemory(pSharedKey->TxMic,
+		       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
 
 	// Decide its ChiperAlg
 	if (pAd->StaCfg.PairCipher == Ndis802_11Encryption2Enabled)
@@ -320,37 +304,35 @@ VOID WpaStaPairwiseKeySetting(
 		pSharedKey->CipherAlg = CIPHER_NONE;
 
 	// Update these related information to MAC_TABLE_ENTRY
-	NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32], LEN_TKIP_EK);
-	NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48], LEN_TKIP_RXMICK);
-	NdisMoveMemory(pEntry->PairwiseKey.TxMic, &pAd->StaCfg.PTK[48+LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
+	NdisMoveMemory(pEntry->PairwiseKey.Key, &pAd->StaCfg.PTK[32],
+		       LEN_TKIP_EK);
+	NdisMoveMemory(pEntry->PairwiseKey.RxMic, &pAd->StaCfg.PTK[48],
+		       LEN_TKIP_RXMICK);
+	NdisMoveMemory(pEntry->PairwiseKey.TxMic,
+		       &pAd->StaCfg.PTK[48 + LEN_TKIP_RXMICK], LEN_TKIP_TXMICK);
 	pEntry->PairwiseKey.CipherAlg = pSharedKey->CipherAlg;
 
 	// Update pairwise key information to ASIC Shared Key Table
 	AsicAddSharedKeyEntry(pAd,
-						  BSS0,
-						  0,
-						  pSharedKey->CipherAlg,
-						  pSharedKey->Key,
-						  pSharedKey->TxMic,
-						  pSharedKey->RxMic);
+			      BSS0,
+			      0,
+			      pSharedKey->CipherAlg,
+			      pSharedKey->Key,
+			      pSharedKey->TxMic, pSharedKey->RxMic);
 
 	// Update ASIC WCID attribute table and IVEIV table
-	RTMPAddWcidAttributeEntry(pAd,
-							  BSS0,
-							  0,
-							  pSharedKey->CipherAlg,
-							  pEntry);
+	RTMPAddWcidAttributeEntry(pAd, BSS0, 0, pSharedKey->CipherAlg, pEntry);
 	STA_PORT_SECURED(pAd);
 	pAd->IndicateMediaState = NdisMediaStateConnected;
 
-	DBGPRINT(RT_DEBUG_TRACE, ("%s : AID(%d) port secured\n", __func__, pEntry->Aid));
+	DBGPRINT(RT_DEBUG_TRACE,
+		 ("%s : AID(%d) port secured\n", __func__, pEntry->Aid));
 
 }
 
-VOID WpaStaGroupKeySetting(
-	IN	PRTMP_ADAPTER	pAd)
+VOID WpaStaGroupKeySetting(IN PRTMP_ADAPTER pAd)
 {
-	PCIPHER_KEY		pSharedKey;
+	PCIPHER_KEY pSharedKey;
 
 	pSharedKey = &pAd->SharedKey[BSS0][pAd->StaCfg.DefaultKeyId];
 
@@ -358,8 +340,10 @@ VOID WpaStaGroupKeySetting(
 	NdisZeroMemory(pSharedKey, sizeof(CIPHER_KEY));
 	pSharedKey->KeyLen = LEN_TKIP_EK;
 	NdisMoveMemory(pSharedKey->Key, pAd->StaCfg.GTK, LEN_TKIP_EK);
-	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.GTK[16], LEN_TKIP_RXMICK);
-	NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24], LEN_TKIP_TXMICK);
+	NdisMoveMemory(pSharedKey->RxMic, &pAd->StaCfg.GTK[16],
+		       LEN_TKIP_RXMICK);
+	NdisMoveMemory(pSharedKey->TxMic, &pAd->StaCfg.GTK[24],
+		       LEN_TKIP_TXMICK);
 
 	// Update Shared Key CipherAlg
 	pSharedKey->CipherAlg = CIPHER_NONE;
@@ -374,18 +358,16 @@ VOID WpaStaGroupKeySetting(
 
 	// Update group key information to ASIC Shared Key Table
 	AsicAddSharedKeyEntry(pAd,
-						  BSS0,
-						  pAd->StaCfg.DefaultKeyId,
-						  pSharedKey->CipherAlg,
-						  pSharedKey->Key,
-						  pSharedKey->TxMic,
-						  pSharedKey->RxMic);
+			      BSS0,
+			      pAd->StaCfg.DefaultKeyId,
+			      pSharedKey->CipherAlg,
+			      pSharedKey->Key,
+			      pSharedKey->TxMic, pSharedKey->RxMic);
 
 	// Update ASIC WCID attribute table and IVEIV table
 	RTMPAddWcidAttributeEntry(pAd,
-							  BSS0,
-							  pAd->StaCfg.DefaultKeyId,
-							  pSharedKey->CipherAlg,
-							  NULL);
+				  BSS0,
+				  pAd->StaCfg.DefaultKeyId,
+				  pSharedKey->CipherAlg, NULL);
 
 }
-- 
1.7.1

