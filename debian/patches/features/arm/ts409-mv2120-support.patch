diff -uprN -X dontdiff linux-2.6.26-rc6/arch/arm/mach-orion5x/Kconfig linux-2.6.26-rc6_new/arch/arm/mach-orion5x/Kconfig
--- linux-2.6.26-rc6/arch/arm/mach-orion5x/Kconfig	2008-06-12 23:22:24.000000000 +0200
+++ linux-2.6.26-rc6_new/arch/arm/mach-orion5x/Kconfig	2008-06-15 14:28:43.000000000 +0200
@@ -36,6 +36,18 @@ config MACH_TS209
 	  Say 'Y' here if you want your kernel to support the
 	  QNAP TS-109/TS-209 platform.
 
+config MACH_TS409
+	bool "QNAP TS-409"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  QNAP TS-409 platform.
+
+config MACH_MV2120
+	bool "HP Media Vault mv2120"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  HP Media Vault mv2120 or mv5100.
+
 config MACH_LINKSTATION_PRO
 	bool "Buffalo Linkstation Pro/Live"
 	select I2C_BOARDINFO
diff -uprN -X dontdiff linux-2.6.26-rc6/arch/arm/mach-orion5x/Makefile linux-2.6.26-rc6_new/arch/arm/mach-orion5x/Makefile
--- linux-2.6.26-rc6/arch/arm/mach-orion5x/Makefile	2008-06-12 23:22:24.000000000 +0200
+++ linux-2.6.26-rc6_new/arch/arm/mach-orion5x/Makefile	2008-06-15 14:29:16.000000000 +0200
@@ -4,4 +4,6 @@ obj-$(CONFIG_MACH_RD88F5182)	+= rd88f518
 obj-$(CONFIG_MACH_KUROBOX_PRO)	+= kurobox_pro-setup.o
 obj-$(CONFIG_MACH_LINKSTATION_PRO) += kurobox_pro-setup.o
 obj-$(CONFIG_MACH_DNS323)	+= dns323-setup.o
-obj-$(CONFIG_MACH_TS209)	+= ts209-setup.o
+obj-$(CONFIG_MACH_TS209)	+= ts209-setup.o tsx09-common.o
+obj-$(CONFIG_MACH_TS409)	+= ts409-setup.o tsx09-common.o
+obj-$(CONFIG_MACH_MV2120)	+= mv2120-setup.o
--- /dev/null	2008-06-15 07:07:41.000000000 +0000
+++ b/arch/arm/mach-orion5x/mv2120-setup.c	2008-07-13 14:29:46.000000000 +0000
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2007 Herbert Valerio Riedel <hvr@gnu.org>
+ * Copyright (C) 2008 Martin Michlmayr <tbm@cyrius.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/leds.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/ata_platform.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/orion5x.h>
+#include "common.h"
+
+#define MV2120_NOR_BOOT_BASE	0xf4000000
+#define MV2120_NOR_BOOT_SIZE	SZ_512K
+
+#define MV2120_GPIO_RTC_IRQ	3
+#define MV2120_GPIO_KEY_RESET	17
+#define MV2120_GPIO_KEY_POWER	18
+#define MV2120_GPIO_POWER_OFF	19
+
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+static struct mv643xx_eth_platform_data mv2120_eth_data = {
+	.phy_addr	= 8,
+};
+
+static struct mv_sata_platform_data mv2120_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct mtd_partition mv2120_partitions[] = {
+	{
+		.name	= "firmware",
+		.size	= 0x00080000,
+		.offset	= 0,
+	},
+};
+
+static struct physmap_flash_data mv2120_nor_flash_data = {
+	.width		= 1,
+	.parts		= mv2120_partitions,
+	.nr_parts	= ARRAY_SIZE(mv2120_partitions)
+};
+
+static struct resource mv2120_nor_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= MV2120_NOR_BOOT_BASE,
+	.end		= MV2120_NOR_BOOT_BASE + MV2120_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device mv2120_nor_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &mv2120_nor_flash_data,
+	},
+	.resource	= &mv2120_nor_flash_resource,
+	.num_resources	= 1,
+};
+
+static struct gpio_keys_button mv2120_buttons[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= MV2120_GPIO_KEY_RESET,
+		.desc		= "Reset Button",
+		.active_low	= 1,
+	}, {
+		.code		= KEY_POWER,
+		.gpio		= MV2120_GPIO_KEY_POWER,
+		.desc		= "Power Button",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data mv2120_button_data = {
+	.buttons	= mv2120_buttons,
+	.nbuttons	= ARRAY_SIZE(mv2120_buttons),
+};
+
+static struct platform_device mv2120_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &mv2120_button_data,
+	},
+};
+
+
+/****************************************************************************
+ * General Setup
+ ****************************************************************************/
+static struct i2c_board_info __initdata mv2120_i2c_rtc = {
+	I2C_BOARD_INFO("pcf8563", 0x51),
+	.irq	= 0,
+};
+
+static struct gpio_led mv2120_led_pins[] = {
+	{
+		.name			= "mv2120:blue:health",
+		.gpio			= 0,
+	},
+	{
+		.name			= "mv2120:red:health",
+		.gpio			= 1,
+	},
+	{
+		.name			= "mv2120:led:bright",
+		.gpio			= 4,
+		.default_trigger	= "default-on",
+	},
+	{
+		.name			= "mv2120:led:dimmed",
+		.gpio			= 5,
+	},
+	{
+		.name			= "mv2120:red:sata0",
+		.gpio			= 8,
+		.active_low		= 1,
+	},
+	{
+		.name			= "mv2120:red:sata1",
+		.gpio			= 9,
+		.active_low		= 1,
+	},
+
+};
+
+static struct gpio_led_platform_data mv2120_led_data = {
+	.leds		= mv2120_led_pins,
+	.num_leds	= ARRAY_SIZE(mv2120_led_pins),
+};
+
+static struct platform_device mv2120_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &mv2120_led_data,
+	}
+};
+
+static void mv2120_power_off(void)
+{
+	pr_info("%s: triggering power-off...\n", __func__);
+	gpio_set_value(MV2120_GPIO_POWER_OFF, 0);
+}
+
+static void __init mv2120_init(void)
+{
+	/* Setup basic Orion functions. Need to be called early. */
+	orion5x_init();
+
+	/*
+	 * Setup flash mapping
+	 */
+	orion5x_setup_dev_boot_win(MV2120_NOR_BOOT_BASE,
+			    MV2120_NOR_BOOT_SIZE);
+
+	/*
+	 * Open a special address decode windows for the PCIe WA.
+	 */
+	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
+				ORION5X_PCIE_WA_SIZE);
+
+	/*
+	 * Setup Multiplexing Pins --
+	 * MPP[0] Sys status LED
+	 * MPP[1] Sys error LED
+	 * MPP[2] OverTemp interrupt
+	 * MPP[3] RTC interrupt
+	 * MPP[4] V_LED 5V
+	 * MPP[5] V_LED 3.3V
+	 * MPP[6-7] Reserved
+	 * MPP[8] SATA 0 fail LED
+	 * MPP[9] SATA 1 fail LED
+	 * MPP[10-11] Reserved
+	 * MPP[12] SATA 0 presence
+	 * MPP[13] SATA 1 presence
+	 * MPP[14] SATA 0 active
+	 * MPP[15] SATA 1 active
+	 * MPP[16] Reserved
+	 * MPP[17] Reset button
+	 * MPP[18] Power button
+	 * MPP[19] Power off
+	 */
+	orion5x_write(MPP_0_7_CTRL, 0x3);
+	orion5x_write(MPP_8_15_CTRL, 0x55550000);
+	orion5x_write(MPP_16_19_CTRL, 0x5555);
+	orion5x_gpio_set_valid_pins(0xf0fff);
+
+	/* register mv2120 specific power-off method */
+	if (gpio_request(MV2120_GPIO_POWER_OFF, "POWEROFF") != 0 ||
+	    gpio_direction_output(MV2120_GPIO_POWER_OFF, 1) != 0)
+		pr_err("mv2120: failed to setup power-off GPIO\n");
+	pm_power_off = mv2120_power_off;
+
+	platform_device_register(&mv2120_nor_flash);
+
+	platform_device_register(&mv2120_button_device);
+
+	if (gpio_request(MV2120_GPIO_RTC_IRQ, "rtc") == 0) {
+		if (gpio_direction_input(MV2120_GPIO_RTC_IRQ) == 0)
+			mv2120_i2c_rtc.irq = gpio_to_irq(MV2120_GPIO_RTC_IRQ);
+		else
+			gpio_free(MV2120_GPIO_RTC_IRQ);
+	}
+	i2c_register_board_info(0, &mv2120_i2c_rtc, 1);
+	platform_device_register(&mv2120_leds);
+
+	orion5x_eth_init(&mv2120_eth_data);
+	orion5x_sata_init(&mv2120_sata_data);
+}
+
+/* Warning: HP uses a wrong mach-type (=526) in their bootloader */
+MACHINE_START(MV2120, "HP Media Vault mv2120")
+	/* Maintainer: Martin Michlmayr <tbm@cyrius.com> */
+	.phys_io	= ORION5X_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= mv2120_init,
+	.map_io		= orion5x_map_io,
+	.init_irq	= orion5x_init_irq,
+	.timer		= &orion5x_timer,
+	.fixup		= tag_fixup_mem32
+MACHINE_END
diff -uprN -X dontdiff linux-2.6.26-rc6/arch/arm/mach-orion5x/ts209-setup.c linux-2.6.26-rc6_new/arch/arm/mach-orion5x/ts209-setup.c
--- linux-2.6.26-rc6/arch/arm/mach-orion5x/ts209-setup.c	2008-06-12 23:22:24.000000000 +0200
+++ linux-2.6.26-rc6_new/arch/arm/mach-orion5x/ts209-setup.c	2008-06-15 14:26:08.000000000 +0200
@@ -28,6 +28,7 @@
 #include <asm/mach/pci.h>
 #include <asm/arch/orion5x.h>
 #include "common.h"
+#include "tsx09-common.h"
 
 #define QNAP_TS209_NOR_BOOT_BASE 0xf4000000
 #define QNAP_TS209_NOR_BOOT_SIZE SZ_8M
@@ -183,96 +184,6 @@ static int __init qnap_ts209_pci_init(vo
 subsys_initcall(qnap_ts209_pci_init);
 
 /*****************************************************************************
- * Ethernet
- ****************************************************************************/
-
-static struct mv643xx_eth_platform_data qnap_ts209_eth_data = {
-	.phy_addr       = 8,
-	.force_phy_addr = 1,
-};
-
-static int __init parse_hex_nibble(char n)
-{
-	if (n >= '0' && n <= '9')
-		return n - '0';
-
-	if (n >= 'A' && n <= 'F')
-		return n - 'A' + 10;
-
-	if (n >= 'a' && n <= 'f')
-		return n - 'a' + 10;
-
-	return -1;
-}
-
-static int __init parse_hex_byte(const char *b)
-{
-	int hi;
-	int lo;
-
-	hi = parse_hex_nibble(b[0]);
-	lo = parse_hex_nibble(b[1]);
-
-	if (hi < 0 || lo < 0)
-		return -1;
-
-	return (hi << 4) | lo;
-}
-
-static int __init check_mac_addr(const char *addr_str)
-{
-	u_int8_t addr[6];
-	int i;
-
-	for (i = 0; i < 6; i++) {
-		int byte;
-
-		/*
-		 * Enforce "xx:xx:xx:xx:xx:xx\n" format.
-		 */
-		if (addr_str[(i * 3) + 2] != ((i < 5) ? ':' : '\n'))
-			return -1;
-
-		byte = parse_hex_byte(addr_str + (i * 3));
-		if (byte < 0)
-			return -1;
-		addr[i] = byte;
-	}
-
-	printk(KERN_INFO "ts209: found ethernet mac address ");
-	for (i = 0; i < 6; i++)
-		printk("%.2x%s", addr[i], (i < 5) ? ":" : ".\n");
-
-	memcpy(qnap_ts209_eth_data.mac_addr, addr, 6);
-
-	return 0;
-}
-
-/*
- * The 'NAS Config' flash partition has an ext2 filesystem which
- * contains a file that has the ethernet MAC address in plain text
- * (format "xx:xx:xx:xx:xx:xx\n".)
- */
-static void __init ts209_find_mac_addr(void)
-{
-	unsigned long addr;
-
-	for (addr = 0x00700000; addr < 0x00760000; addr += 1024) {
-		char *nor_page;
-		int ret = 0;
-
-		nor_page = ioremap(QNAP_TS209_NOR_BOOT_BASE + addr, 1024);
-		if (nor_page != NULL) {
-			ret = check_mac_addr(nor_page);
-			iounmap(nor_page);
-		}
-
-		if (ret == 0)
-			break;
-	}
-}
-
-/*****************************************************************************
  * RTC S35390A on I2C bus
  ****************************************************************************/
 
@@ -280,7 +191,6 @@ static void __init ts209_find_mac_addr(v
 
 static struct i2c_board_info __initdata qnap_ts209_i2c_rtc = {
 	I2C_BOARD_INFO("s35390a", 0x30),
-       .irq         = 0,
 };
 
 /****************************************************************************
@@ -335,32 +245,6 @@ static struct platform_device *qnap_ts20
 	&qnap_ts209_button_device,
 };
 
-/*
- * QNAP TS-[12]09 specific power off method via UART1-attached PIC
- */
-
-#define UART1_REG(x)  (UART1_VIRT_BASE + ((UART_##x) << 2))
-
-static void qnap_ts209_power_off(void)
-{
-	/* 19200 baud divisor */
-	const unsigned divisor = ((ORION5X_TCLK + (8 * 19200)) / (16 * 19200));
-
-	pr_info("%s: triggering power-off...\n", __func__);
-
-	/* hijack uart1 and reset into sane state (19200,8n1) */
-	orion5x_write(UART1_REG(LCR), 0x83);
-	orion5x_write(UART1_REG(DLL), divisor & 0xff);
-	orion5x_write(UART1_REG(DLM), (divisor >> 8) & 0xff);
-	orion5x_write(UART1_REG(LCR), 0x03);
-	orion5x_write(UART1_REG(IER), 0x00);
-	orion5x_write(UART1_REG(FCR), 0x00);
-	orion5x_write(UART1_REG(MCR), 0x00);
-
-	/* send the power-off command 'A' to PIC */
-	orion5x_write(UART1_REG(TX), 'A');
-}
-
 static void __init qnap_ts209_init(void)
 {
 	/*
@@ -409,7 +293,7 @@ static void __init qnap_ts209_init(void)
 	orion5x_gpio_set_valid_pins(0x3cc0fff);
 
 	/* register ts209 specific power-off method */
-	pm_power_off = qnap_ts209_power_off;
+	pm_power_off = qnap_tsx09_power_off;
 
 	platform_add_devices(qnap_ts209_devices,
 				ARRAY_SIZE(qnap_ts209_devices));
@@ -425,8 +309,10 @@ static void __init qnap_ts209_init(void)
 		pr_warning("qnap_ts209_init: failed to get RTC IRQ\n");
 	i2c_register_board_info(0, &qnap_ts209_i2c_rtc, 1);
 
-	ts209_find_mac_addr();
-	orion5x_eth_init(&qnap_ts209_eth_data);
+	qnap_tsx09_find_mac_addr(QNAP_TS209_NOR_BOOT_BASE +
+				 qnap_ts209_partitions[5].offset,
+				 qnap_ts209_partitions[5].size);
+	orion5x_eth_init(&qnap_tsx09_eth_data);
 
 	orion5x_sata_init(&qnap_ts209_sata_data);
 }
diff -uprN -X dontdiff linux-2.6.26-rc6/arch/arm/mach-orion5x/ts409-setup.c linux-2.6.26-rc6_new/arch/arm/mach-orion5x/ts409-setup.c
--- linux-2.6.26-rc6/arch/arm/mach-orion5x/ts409-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.26-rc6_new/arch/arm/mach-orion5x/ts409-setup.c	2008-06-15 14:44:51.000000000 +0200
@@ -0,0 +1,274 @@
+/*
+ * QNAP TS-409 Board Setup
+ *
+ * Maintainer: Sylver Bruneau <sylver.bruneau@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/serial_reg.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/orion5x.h>
+#include "common.h"
+#include "tsx09-common.h"
+
+/*****************************************************************************
+ * QNAP TS-409 Info
+ ****************************************************************************/
+
+/*
+ * QNAP TS-409 hardware :
+ * - Marvell 88F5281-D0
+ * - Marvell 88SX7042 SATA controller (PCIe)
+ * - Marvell 88E1118 Gigabit Ethernet PHY
+ * - RTC S35390A (@0x30) on I2C bus
+ * - 8MB NOR flash
+ * - 256MB of DDR-2 RAM
+ */
+
+/*
+ * 8MB NOR flash Device bus boot chip select
+ */
+
+#define QNAP_TS409_NOR_BOOT_BASE 0xff800000
+#define QNAP_TS409_NOR_BOOT_SIZE SZ_8M
+
+/****************************************************************************
+ * 8MiB NOR flash. The struct mtd_partition is not in the same order as the
+ *     partitions on the device because we want to keep compatability with
+ *     existing QNAP firmware.
+ *
+ * Layout as used by QNAP:
+ *  [2] 0x00000000-0x00200000 : "Kernel"
+ *  [3] 0x00200000-0x00600000 : "RootFS1"
+ *  [4] 0x00600000-0x00700000 : "RootFS2"
+ *  [6] 0x00700000-0x00760000 : "NAS Config" (read-only)
+ *  [5] 0x00760000-0x00780000 : "U-Boot Config"
+ *  [1] 0x00780000-0x00800000 : "U-Boot" (read-only)
+ ***************************************************************************/
+static struct mtd_partition qnap_ts409_partitions[] = {
+	{
+		.name		= "U-Boot",
+		.size		= 0x00080000,
+		.offset		= 0x00780000,
+		.mask_flags	= MTD_WRITEABLE,
+	}, {
+		.name		= "Kernel",
+		.size		= 0x00200000,
+		.offset		= 0,
+	}, {
+		.name		= "RootFS1",
+		.size		= 0x00400000,
+		.offset		= 0x00200000,
+	}, {
+		.name		= "RootFS2",
+		.size		= 0x00100000,
+		.offset		= 0x00600000,
+	}, {
+		.name		= "U-Boot Config",
+		.size		= 0x00020000,
+		.offset		= 0x00760000,
+	}, {
+		.name		= "NAS Config",
+		.size		= 0x00060000,
+		.offset		= 0x00700000,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+
+static struct physmap_flash_data qnap_ts409_nor_flash_data = {
+	.width		= 1,
+	.parts		= qnap_ts409_partitions,
+	.nr_parts	= ARRAY_SIZE(qnap_ts409_partitions)
+};
+
+static struct resource qnap_ts409_nor_flash_resource = {
+	.flags	= IORESOURCE_MEM,
+	.start	= QNAP_TS409_NOR_BOOT_BASE,
+	.end	= QNAP_TS409_NOR_BOOT_BASE + QNAP_TS409_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device qnap_ts409_nor_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= { .platform_data = &qnap_ts409_nor_flash_data, },
+	.num_resources	= 1,
+	.resource	= &qnap_ts409_nor_flash_resource,
+};
+
+/*****************************************************************************
+ * PCI
+ ****************************************************************************/
+
+static int __init qnap_ts409_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq;
+
+	/*
+	 * Check for devices with hard-wired IRQs.
+	 */
+	irq = orion5x_pci_map_irq(dev, slot, pin);
+	if (irq != -1)
+		return irq;
+
+	/*
+	 * PCI isn't used on the TS-409
+	 */
+	printk(KERN_ERR "qnap_ts409_pci_map_irq failed, unknown bus\n");
+	return -1;
+}
+
+static struct hw_pci qnap_ts409_pci __initdata = {
+	.nr_controllers	= 2,
+	.swizzle	= pci_std_swizzle,
+	.setup		= orion5x_pci_sys_setup,
+	.scan		= orion5x_pci_sys_scan_bus,
+	.map_irq	= qnap_ts409_pci_map_irq,
+};
+
+static int __init qnap_ts409_pci_init(void)
+{
+	if (machine_is_ts409())
+		pci_common_init(&qnap_ts409_pci);
+
+	return 0;
+}
+
+subsys_initcall(qnap_ts409_pci_init);
+
+/*****************************************************************************
+ * RTC S35390A on I2C bus
+ ****************************************************************************/
+
+#define TS409_RTC_GPIO	10
+
+static struct i2c_board_info __initdata qnap_ts409_i2c_rtc = {
+	I2C_BOARD_INFO("s35390a", 0x30),
+};
+
+/****************************************************************************
+ * GPIO Attached Keys
+ *     Power button is attached to the PIC microcontroller
+ ****************************************************************************/
+
+#define QNAP_TS409_GPIO_KEY_MEDIA	15
+
+static struct gpio_keys_button qnap_ts409_buttons[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= QNAP_TS409_GPIO_KEY_MEDIA,
+		.desc		= "USB Copy Button",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data qnap_ts409_button_data = {
+	.buttons	= qnap_ts409_buttons,
+	.nbuttons	= ARRAY_SIZE(qnap_ts409_buttons),
+};
+
+static struct platform_device qnap_ts409_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &qnap_ts409_button_data,
+	},
+};
+
+/*****************************************************************************
+ * General Setup
+ ****************************************************************************/
+
+static void __init qnap_ts409_init(void)
+{
+	/*
+	 * Setup basic Orion functions. Need to be called early.
+	 */
+	orion5x_init();
+
+	/*
+	 * Setup flash mapping
+	 */
+	orion5x_setup_dev_boot_win(QNAP_TS409_NOR_BOOT_BASE,
+			    QNAP_TS409_NOR_BOOT_SIZE);
+
+	/*
+	 * Open a special address decode windows for the PCIe WA.
+	 */
+	orion5x_setup_pcie_wa_win(ORION5X_PCIE_WA_PHYS_BASE,
+				ORION5X_PCIE_WA_SIZE);
+
+	/*
+	 * Setup Multiplexing Pins --
+	 * MPP[0-4] Reserved
+	 * MPP[4] HDD1 Status
+	 * MPP[5] HDD2 Status
+	 * MPP[6] HDD3 Status
+	 * MPP[7] HDD4 Status
+	 * MPP[8-9] Reserved
+	 * MPP[10] RTC int
+	 * MPP[11-13] Reserved
+	 * MPP[14] SW_RST (0 active)
+	 * MPP[15] USB copy button (0 active)
+	 * MPP[16] UART1 RXD
+	 * MPP[17] UART1 TXD
+	 * MPP[18] UART1 CTSn
+	 * MPP[19] UART1 RTSn
+	 */
+	orion5x_write(MPP_0_7_CTRL, 0x00002203);
+	orion5x_write(MPP_8_15_CTRL, 0x00000033);
+	orion5x_write(MPP_16_19_CTRL, 0x0);
+	orion5x_gpio_set_valid_pins(0x0000fcf3);
+
+	/* register ts409 specific power-off method */
+	pm_power_off = qnap_tsx09_power_off;
+
+	platform_device_register(&qnap_ts409_nor_flash);
+
+	platform_device_register(&qnap_ts409_button_device);
+
+	/* Get RTC IRQ and register the chip */
+	if (gpio_request(TS409_RTC_GPIO, "rtc") == 0) {
+		if (gpio_direction_input(TS409_RTC_GPIO) == 0)
+			qnap_ts409_i2c_rtc.irq = gpio_to_irq(TS409_RTC_GPIO);
+		else
+			gpio_free(TS409_RTC_GPIO);
+	}
+	if (qnap_ts409_i2c_rtc.irq == 0)
+		pr_warning("qnap_ts409_init: failed to get RTC IRQ\n");
+	i2c_register_board_info(0, &qnap_ts409_i2c_rtc, 1);
+
+	qnap_tsx09_find_mac_addr(QNAP_TS409_NOR_BOOT_BASE +
+				 qnap_ts409_partitions[5].offset,
+				 qnap_ts409_partitions[5].size);
+	orion5x_eth_init(&qnap_tsx09_eth_data);
+}
+
+MACHINE_START(TS409, "QNAP TS-409")
+	/* Maintainer:  Sylver Bruneau <sylver.bruneau@gmail.com> */
+	.phys_io	= ORION5X_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION5X_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= qnap_ts409_init,
+	.map_io		= orion5x_map_io,
+	.init_irq	= orion5x_init_irq,
+	.timer		= &orion5x_timer,
+	.fixup		= tag_fixup_mem32,
+MACHINE_END
--- /dev/null	2008-06-15 07:07:41.000000000 +0000
+++ b/arch/arm/mach-orion5x/tsx09-common.c	2008-06-16 08:39:44.000000000 +0000
@@ -0,0 +1,134 @@
+/*
+ * QNAP TS-x09 Boards common functions
+ *
+ * Maintainers: Lennert Buytenhek <buytenh@marvell.com>
+ *              Byron Bradley <byron.bbradley@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/serial_reg.h>
+#include <linux/input.h>
+#include "tsx09-common.h"
+
+/*****************************************************************************
+ * QNAP TS-x09 specific power off method via UART1-attached PIC
+ ****************************************************************************/
+
+#define UART1_REG(x)  (UART1_VIRT_BASE + ((UART_##x) << 2))
+
+void qnap_tsx09_power_off(void)
+{
+	/* 19200 baud divisor */
+	const unsigned divisor = ((ORION5X_TCLK + (8 * 19200)) / (16 * 19200));
+
+	pr_info("%s: triggering power-off...\n", __func__);
+
+	/* hijack uart1 and reset into sane state (19200,8n1) */
+	writel(0x83, UART1_REG(LCR));
+	writel(divisor & 0xff, UART1_REG(DLL));
+	writel((divisor >> 8) & 0xff, UART1_REG(DLM));
+	writel(0x03, UART1_REG(LCR));
+	writel(0x00, UART1_REG(IER));
+	writel(0x00, UART1_REG(FCR));
+	writel(0x00, UART1_REG(MCR));
+
+	/* send the power-off command 'A' to PIC */
+	writel('A', UART1_REG(TX));
+}
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+
+struct mv643xx_eth_platform_data qnap_tsx09_eth_data = {
+	.phy_addr       = 8,
+	.force_phy_addr = 1,
+};
+
+static int __init qnap_tsx09_parse_hex_nibble(char n)
+{
+	if (n >= '0' && n <= '9')
+		return n - '0';
+
+	if (n >= 'A' && n <= 'F')
+		return n - 'A' + 10;
+
+	if (n >= 'a' && n <= 'f')
+		return n - 'a' + 10;
+
+	return -1;
+}
+
+static int __init qnap_tsx09_parse_hex_byte(const char *b)
+{
+	int hi;
+	int lo;
+
+	hi = qnap_tsx09_parse_hex_nibble(b[0]);
+	lo = qnap_tsx09_parse_hex_nibble(b[1]);
+
+	if (hi < 0 || lo < 0)
+		return -1;
+
+	return (hi << 4) | lo;
+}
+
+static int __init qnap_tsx09_check_mac_addr(const char *addr_str)
+{
+	u_int8_t addr[6];
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int byte;
+
+		/*
+		 * Enforce "xx:xx:xx:xx:xx:xx\n" format.
+		 */
+		if (addr_str[(i * 3) + 2] != ((i < 5) ? ':' : '\n'))
+			return -1;
+
+		byte = qnap_tsx09_parse_hex_byte(addr_str + (i * 3));
+		if (byte < 0)
+			return -1;
+		addr[i] = byte;
+	}
+
+	printk(KERN_INFO "tsx09: found ethernet mac address ");
+	for (i = 0; i < 6; i++)
+		printk("%.2x%s", addr[i], (i < 5) ? ":" : ".\n");
+
+	memcpy(qnap_tsx09_eth_data.mac_addr, addr, 6);
+
+	return 0;
+}
+
+/*
+ * The 'NAS Config' flash partition has an ext2 filesystem which
+ * contains a file that has the ethernet MAC address in plain text
+ * (format "xx:xx:xx:xx:xx:xx\n".)
+ */
+void __init qnap_tsx09_find_mac_addr(u32 mem_base, u32 size)
+{
+	unsigned long addr;
+
+	for (addr = mem_base; addr < (mem_base + size); addr += 1024) {
+		char *nor_page;
+		int ret = 0;
+
+		nor_page = ioremap(addr, 1024);
+		if (nor_page != NULL) {
+			ret = qnap_tsx09_check_mac_addr(nor_page);
+			iounmap(nor_page);
+		}
+
+		if (ret == 0)
+			break;
+	}
+}
diff -uprN -X dontdiff linux-2.6.26-rc6/arch/arm/mach-orion5x/tsx09-common.h linux-2.6.26-rc6_new/arch/arm/mach-orion5x/tsx09-common.h
--- linux-2.6.26-rc6/arch/arm/mach-orion5x/tsx09-common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.26-rc6_new/arch/arm/mach-orion5x/tsx09-common.h	2008-06-09 23:07:00.000000000 +0200
@@ -0,0 +1,22 @@
+#ifndef __ARCH_ORION5X_TSX09_COMMON_H
+#define __ARCH_ORION5X_TSX09_COMMON_H
+
+/*
+ * QNAP TS-x09 Boards power-off function
+ */
+
+extern void qnap_tsx09_power_off(void);
+
+/*
+ * QNAP TS-x09 Boards function to find ethernet MAC address in flash memory
+ */
+
+extern void __init qnap_tsx09_find_mac_addr(u32 mem_base, u32 size);
+
+/*
+ * QNAP TS-x09 Boards ethernet declaration
+ */
+
+extern struct mv643xx_eth_platform_data qnap_tsx09_eth_data;
+
+#endif
