# Author: Riku Voipio <riku.voipio@movial.fi>

# Upstream status: the sensor maintainer was busy.  Now there's a new
# maintainer and he asked Riku to update and re-submit the patch.

diff -urpN linux-2.6.17/drivers/hwmon/f75375s.c linux-2.6.18-rc6/drivers/hwmon/f75375s.c
--- linux-2.6.17/drivers/hwmon/f75375s.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-2.6.18-rc6/drivers/hwmon/f75375s.c	2006-10-31 21:54:04.000000000 +0200
@@ -0,0 +1,636 @@
+/*
+ * f75375.c - driver for the Fintek F75375/SP and F75373
+ *             hardware monitoring features
+ *             
+ * Copyright (C) 2005  Riku Voipio <riku.voipio@movial.fi>
+ *
+ * The F75375/SP is a I2C chip made by Fintek. It integrates
+ * complete hardware monitoring features: voltage, fan and temperature
+ * sensors, and manual and automatic fan speed control.
+ *
+ * Datasheets at:
+ * 
+ * http://www.fintek.com.tw/eng/products.asp?BID=4&SID=5
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <asm/io.h>
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = { 0x2d, 0x2e, I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD_1(f75375);
+
+/* Fintek F75375 registers  */
+#define F75375_REG_CONFIG0		0x0	/* |start|x|x|x|x|x|soft_pwdn|init| */
+#define F75375_REG_CONFIG1		0x1	/* |pin2_mode|pin4_mode|t1_mode|t2_mode|fan1_linear_mode|fan2_linear_mode|x|x| */
+#define F75375_REG_CONFIG2		0x2
+#define F75375_REG_CONFIG3		0x3
+#define F75375_REG_ADDR			0x4
+#define F75375_REG_INTR			0x31	/* fault registers upto 38 */
+#define F75375_CHIP_ID			0x5A
+#define F75375_REG_VERSION		0x5C
+#define F75375_REG_VENDOR		0x5D
+#define F75375_REG_FAN_TIMER		0x60	/* 6-7 fan2 speed/temp/man|4-5 fan3 */
+
+#define F75375_REG_VOLT(nr)		(0x10 + (nr))
+#define F75375_REG_VOLT_HIGH(nr)	(0x20 + (nr) * 2 )
+#define F75375_REG_VOLT_LOW(nr)		(0x21 + (nr) * 2 )
+
+#define F75375_REG_TEMP(nr)		(0x14 + (nr))
+#define F75375_REG_TEMP_HIGH(nr)	(0x28 + (nr) * 2 )
+#define F75375_REG_TEMP_HYST(nr)	(0x29 + (nr) * 2 )
+
+#define F75375_REG_FAN(nr)		(0x16 + (nr) * 2 )
+#define F75375_REG_FAN_MIN(nr)		(0x2C + (nr) * 2 )
+#define F75375_REG_FAN_MAX(nr)		(0x70 + (nr) * 0x10 )
+	/*72 - 75 expect count */
+#define F75375_REG_FAN_PWM_DUTY(nr)	(0x76 + (nr) * 0x10 )
+#define F75375_REG_FAN_PWM_CLOCK(nr)	(0x7D + (nr) * 0x10 )
+
+#define F75375_REG_FAN_EXP(nr)		(0x74 + (nr) * 0x10 )
+#define F75375_REG_FAN_B_TEMP(nr,step)	((0xA0 + (nr) * 0x10) + (step))	/* 1..4 */
+#define F75375_REG_FAN_B_SPEED(nr,step)	((0xA5 + (nr) * 0x10) + (step) * 2 )
+
+#define F75375_REG_PWM1_RAISE_DUTY	0x69
+#define F75375_REG_PWM2_RAISE_DUTY	0x6A
+#define F75375_REG_PWM1_DROP_DUTY	0x6B
+#define F75375_REG_PWM2_DROP_DUTY	0x6C
+
+#define  F75375_FAN1_LINEAR_MODE	0x10
+#define  F75375_FAN2_LINEAR_MODE        0x20
+
+#define  F75375_FAN1_MANUAL_MODE	0x30
+#define  F75375_FAN2_MANUAL_MODE	0xc0
+
+#define F75375_PWM_DEFAULT		0xFF
+
+/*
+ * Data structures and manipulation thereof
+ */
+
+struct f75375_data {
+	unsigned short addr;
+	struct i2c_client client;
+	struct class_device *class_dev;
+
+	const char *name;
+	struct mutex update_lock;
+	char valid;
+	unsigned long last_updated;	/* In jiffies */
+	unsigned long last_limits;	/* In jiffies */
+
+	/* Register values */
+	u8 in[4];
+	u8 in_max[4];
+	u8 in_min[4];
+	u16 fan[2];
+	u16 fan_min[2];
+	u16 fan_max[2];
+	u16 fan_exp[2];
+	u8 fan_timer;
+	u8 pwm[2];
+	u8 temp[2];
+	u8 temp_high[2];
+	u8 temp_max_hyst[2];
+	u8 alarms[3];
+	u8 fan_enabled;		/* Read once at init time */
+};
+
+static int f75375_attach_adapter(struct i2c_adapter *adapter);
+static int f75375_detect(struct i2c_adapter *adapter, int address, int kind);
+static void f75375_init_client(struct i2c_client *client);
+static int f75375_detach_client(struct i2c_client *client);
+static inline int f75375_read_value(struct i2c_client *client, u8 reg);
+static inline int f75375_write_value(struct i2c_client *client, u8 reg,
+				     u8 value);
+static struct f75375_data *f75375_update_device(struct device *dev);
+
+static struct i2c_driver f75375_driver = {
+	.driver = {
+		   .name = "f75375",
+		   },
+	.attach_adapter = f75375_attach_adapter,
+	.detach_client = f75375_detach_client,
+};
+
+static inline int f75375_read_value(struct i2c_client *client, u8 reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+static inline u16 f75375_read_value16(struct i2c_client *client, u8 reg)
+{
+	return ((i2c_smbus_read_byte_data(client, reg) << 8)
+		| i2c_smbus_read_byte_data(client, reg + 1));
+}
+
+static inline int f75375_write_value(struct i2c_client *client, u8 reg,
+				     u8 value)
+{
+	return i2c_smbus_write_byte_data(client, reg, value);
+}
+static inline int f75375_write_value16(struct i2c_client *client, u8 reg,
+				       u16 value)
+{
+	int err = i2c_smbus_write_byte_data(client, reg, (value << 8));
+	if (err)
+		return err;
+	return i2c_smbus_write_byte_data(client, reg + 1, (value & 0xFF));
+}
+static struct f75375_data *f75375_update_device(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int nr;
+
+	mutex_lock(&data->update_lock);
+
+	/* Limit registers cache is refreshed after 60 seconds */
+	if (time_after(jiffies, data->last_updated + 60 * HZ)
+	    || !data->valid) {
+		for (nr = 0; nr < 2; nr++) {
+			data->temp_high[nr] = f75375_read_value(client,
+								F75375_REG_TEMP_HIGH
+								(nr));
+			data->temp_max_hyst[nr] =
+			    f75375_read_value(client, F75375_REG_TEMP_HYST(nr));
+			data->fan_max[nr] =
+			    f75375_read_value16(client, F75375_REG_FAN_MAX(nr));
+			data->fan_exp[nr] =
+			    f75375_read_value16(client, F75375_REG_FAN_EXP(nr));
+
+		}
+		for (nr = 0; nr < 4; nr++) {
+			data->in_max[nr] = f75375_read_value(client,
+							     F75375_REG_VOLT_HIGH
+							     (nr));
+			data->in_min[nr] =
+			    f75375_read_value(client, F75375_REG_VOLT_LOW(nr));
+		}
+		data->fan_timer = f75375_read_value(client,
+						    F75375_REG_FAN_TIMER);
+		data->last_limits = jiffies;
+	}
+
+	/* Measurement registers cache is refreshed after 2 second */
+	if (time_after(jiffies, data->last_updated + 2 * HZ)
+	    || !data->valid) {
+		for (nr = 0; nr < 2; nr++) {
+			data->temp[nr] = f75375_read_value(client,
+							   F75375_REG_TEMP(nr));
+			data->fan[nr] = f75375_read_value16(client,
+							    F75375_REG_FAN(nr));
+		}
+		for (nr = 0; nr < 4; nr++) {
+			data->in[nr] = f75375_read_value(client,
+							 F75375_REG_VOLT(nr));
+		}
+		/*for (nr = 0; nr < 3; nr++) {
+		   data->alarms[nr] = f75375_read8(data,
+		   F71805F_REG_STATUS(nr));
+		   } */
+
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+#define show(thing) \
+static ssize_t show_##thing(struct device *dev, struct device_attribute *attr, \
+			char *buf)\
+{\
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\
+	int nr = sensor_attr->index;\
+	struct f75375_data *data = f75375_update_device(dev); \
+	return sprintf(buf, "%d\n", data->thing[nr]); \
+}
+
+static ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->fan_min[nr] = val;
+	f75375_write_value16(client, F75375_REG_FAN_MIN(nr), data->fan_min[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static ssize_t set_fan_exp(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->fan_exp[nr] = val;
+	f75375_write_value16(client, F75375_REG_FAN_MIN(nr),
+			     data->fan_exp[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+show(fan);
+show(fan_min);
+show(fan_max);
+show(fan_exp);
+
+#define show_fan_offset(offset) \
+static SENSOR_DEVICE_ATTR(fan##offset##_input, S_IRUGO,      \
+        show_fan, NULL, offset - 1);\
+static SENSOR_DEVICE_ATTR(fan##offset##_max, S_IRUGO,      \
+        show_fan_max, NULL, offset - 1);\
+static SENSOR_DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR,  \
+        show_fan_min, set_fan_min, offset - 1);       \
+static SENSOR_DEVICE_ATTR(fan##offset##_exp, S_IRUGO | S_IWUSR,  \
+        show_fan_exp, set_fan_exp, offset - 1);       \
+
+show_fan_offset(1);
+show_fan_offset(2);
+
+show(pwm);
+
+static ssize_t set_pwm(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->pwm[nr] = val;
+	f75375_write_value(client, F75375_REG_FAN_PWM_DUTY(nr), data->pwm[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static SENSOR_DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 0);
+static SENSOR_DEVICE_ATTR(pwm2, S_IRUGO | S_IWUSR, show_pwm, set_pwm, 1);
+
+#define VOLT_FROM_REG(val) ((val)*8000)
+#define VOLT_TO_REG(val) ((val)/8000)
+
+static ssize_t show_in(struct device *dev, struct device_attribute *attr,
+		       char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct f75375_data *data = f75375_update_device(dev);
+	return sprintf(buf, "%d\n", VOLT_FROM_REG(data->in[nr]));
+}
+
+static ssize_t show_in_max(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct f75375_data *data = f75375_update_device(dev);
+	return sprintf(buf, "%d\n", VOLT_FROM_REG(data->in_max[nr]));
+}
+
+static ssize_t show_in_min(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct f75375_data *data = f75375_update_device(dev);
+	return sprintf(buf, "%d\n", VOLT_FROM_REG(data->in_max[nr]));
+}
+
+static ssize_t set_in_max(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int val = simple_strtol(buf, NULL, 10);
+	mutex_lock(&data->update_lock);
+	data->in_max[nr] = VOLT_TO_REG(val);
+	f75375_write_value(client, F75375_REG_VOLT_HIGH(nr), data->in_max[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static ssize_t set_in_min(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int val = simple_strtol(buf, NULL, 10);
+	mutex_lock(&data->update_lock);
+	data->in_min[nr] = VOLT_TO_REG(val);
+	f75375_write_value(client, F75375_REG_VOLT_LOW(nr), data->in_min[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+#define show_in_offset(offset) \
+static SENSOR_DEVICE_ATTR(in##offset##_input, S_IRUGO,      \
+        show_in, NULL, offset);\
+static SENSOR_DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR,      \
+        show_in_max, set_in_max, offset);\
+static SENSOR_DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR,  \
+        show_in_min, set_in_min, offset);       \
+
+show_in_offset(0);
+show_in_offset(1);
+show_in_offset(2);
+show_in_offset(3);
+
+#define TEMP_FROM_REG(val) ((val)*1000)
+#define TEMP_TO_REG(val) ((val)/1000)
+
+static ssize_t show_temp(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct f75375_data *data = f75375_update_device(dev);
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp[nr]));
+}
+
+static ssize_t show_temp_max(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct f75375_data *data = f75375_update_device(dev);
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_high[nr]));
+}
+
+static ssize_t show_temp_max_hyst(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	struct f75375_data *data = f75375_update_device(dev);
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_max_hyst[nr]));
+}
+
+static ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->temp_high[nr] = TEMP_TO_REG(val);
+	f75375_write_value(client, F75375_REG_TEMP_HIGH(nr),
+			   data->temp_high[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static ssize_t set_temp_max_hyst(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->temp_max_hyst[nr] = TEMP_TO_REG(val);
+	f75375_write_value(client, F75375_REG_TEMP_HYST(nr),
+			   data->temp_max_hyst[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+#define show_temp_offset(offset) \
+static SENSOR_DEVICE_ATTR(temp##offset##_input, S_IRUGO,      \
+        show_temp, NULL, offset - 1); \
+static SENSOR_DEVICE_ATTR(temp##offset##_max_hyst, S_IRUGO | S_IWUSR,  \
+        show_temp_max_hyst, set_temp_max_hyst, offset - 1);       \
+static SENSOR_DEVICE_ATTR(temp##offset##_max, S_IRUGO | S_IWUSR,  \
+        show_temp_max, set_temp_max, offset - 1);
+
+show_temp_offset(1);
+show_temp_offset(2);
+
+static void f75375_init_client(struct i2c_client *client)
+{
+	/* Start the fans in manual mode */
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int tmp = F75375_FAN1_LINEAR_MODE | F75375_FAN2_LINEAR_MODE;
+	mutex_lock(&data->update_lock);
+	f75375_write_value(client, F75375_REG_CONFIG1, tmp);
+	tmp = F75375_FAN1_MANUAL_MODE | F75375_FAN2_MANUAL_MODE;
+	f75375_write_value(client, F75375_REG_FAN_TIMER, tmp);
+	f75375_write_value(client, F75375_REG_FAN_PWM_DUTY(0),
+			   F75375_PWM_DEFAULT);
+	f75375_write_value(client, F75375_REG_FAN_PWM_DUTY(1),
+			   F75375_PWM_DEFAULT);
+	printk(KERN_INFO "f75375: fan timer after: %X \n", data->fan_timer);
+	mutex_unlock(&data->update_lock);
+}
+
+static int f75375_attach_adapter(struct i2c_adapter *adapter)
+{
+	printk(KERN_INFO "f75375: attaching\n");
+	return i2c_probe(adapter, &addr_data, f75375_detect);
+}
+
+static int f75375_detach_client(struct i2c_client *client)
+{
+	struct f75375_data *data = i2c_get_clientdata(client);
+	int err;
+
+	hwmon_device_unregister(data->class_dev);
+
+	err = i2c_detach_client(client);
+	if (err) {
+		dev_err(&client->dev,
+			"Client deregistration failed, "
+			"client not detached.\n");
+		return err;
+	}
+	kfree(data);
+	return 0;
+}
+
+/* This function is called by i2c_probe */
+static int f75375_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct f75375_data *data;
+	int err = 0;
+	char *name = "";
+
+	if (!(data = kzalloc(sizeof(struct f75375_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	new_client = &data->client;
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &f75375_driver;
+	new_client->flags = 0;
+
+	if (kind < 0) {
+		u16 chipid =
+		    (i2c_smbus_read_byte_data(new_client, F75375_CHIP_ID) << 8)
+		    | i2c_smbus_read_byte_data(new_client, F75375_CHIP_ID + 1);
+		u8 version =
+		    i2c_smbus_read_byte_data(new_client, F75375_REG_VERSION);
+		u16 vendid =
+		    (i2c_smbus_read_byte_data(new_client, F75375_REG_VENDOR) <<
+		     8)
+		    | i2c_smbus_read_byte_data(new_client,
+					       F75375_REG_VENDOR + 1);
+		if (chipid == 0x0306 && vendid == 0x1934) {
+			pr_info("F75375: found F75375 version: %02X\n",
+				version);
+			name = "F75375";
+		} else if (chipid == 0x0204 && vendid == 0x1934) {
+			pr_info("F75375: found F75373 version: %02X\n",
+				version);
+			name = "F75373";
+		} else {
+			printk(KERN_INFO "f75375: failed,%02X,%02X,%02X\n",
+			       chipid, version, vendid);
+			goto exit_free;
+		}
+	}
+	strlcpy(new_client->name, name, I2C_NAME_SIZE);
+	data->valid = 0;
+	mutex_init(&data->update_lock);
+	if ((err = i2c_attach_client(new_client)))
+		goto exit_free;
+
+	/* Initialize the chip */
+	f75375_init_client(new_client);
+
+	/* Register sysfs hooks */
+	data->class_dev = hwmon_device_register(&new_client->dev);
+	if (IS_ERR(data->class_dev)) {
+		err = PTR_ERR(data->class_dev);
+		goto exit_detach;
+	}
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_temp1_input.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_temp1_max.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_temp1_max_hyst.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_temp2_input.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_temp2_max.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_temp2_max_hyst.dev_attr);
+
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan1_input.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan1_max.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan1_min.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan1_exp.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan2_input.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan2_max.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan2_min.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_fan2_exp.dev_attr);
+
+	device_create_file(&new_client->dev, &sensor_dev_attr_pwm1.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_pwm2.dev_attr);
+
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_in0_input.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in0_max.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in0_min.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_in1_input.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in1_max.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in1_min.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_in2_input.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in2_max.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in2_min.dev_attr);
+	device_create_file(&new_client->dev,
+			   &sensor_dev_attr_in3_input.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in3_max.dev_attr);
+	device_create_file(&new_client->dev, &sensor_dev_attr_in3_min.dev_attr);
+
+	return 0;
+
+      exit_detach:
+	i2c_detach_client(new_client);
+      exit_free:
+	kfree(data);
+      exit:
+	return err;
+}
+
+static int __init sensors_f75375_init(void)
+{
+	return i2c_add_driver(&f75375_driver);
+}
+
+static void __exit sensors_f75375_exit(void)
+{
+	i2c_del_driver(&f75375_driver);
+}
+
+MODULE_AUTHOR("Riku Voipio <riku.voipio@movial.fi>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("F75373/F75375 hardware monitoring driver");
+
+module_init(sensors_f75375_init);
+module_exit(sensors_f75375_exit);
diff -urpN linux-2.6.17/drivers/hwmon/Kconfig linux-2.6.18-rc6/drivers/hwmon/Kconfig
--- linux-2.6.17/drivers/hwmon/Kconfig	2006-10-31 20:00:09.000000000 +0200
+++ linux-2.6.18-rc6/drivers/hwmon/Kconfig	2006-10-15 15:05:55.000000000 +0300
@@ -139,6 +139,16 @@ config SENSORS_F71805F
 	  This driver can also be built as a module.  If so, the module
 	  will be called f71805f.
 
+config SENSORS_F75375S
+	tristate "Fintek F75375S/SP and F75373"
+	depends on HWMON && I2C && EXPERIMENTAL
+	help
+	  If you say yes here you get support for hardware monitoring
+	  features of the Fintek F75375S/SP and F75373
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called f75375s.
+
 config SENSORS_FSCHER
 	tristate "FSC Hermes"
 	depends on HWMON && I2C && EXPERIMENTAL
diff -urpN linux-2.6.17/drivers/hwmon/Makefile linux-2.6.18-rc6/drivers/hwmon/Makefile
--- linux-2.6.17/drivers/hwmon/Makefile	2006-10-31 20:00:09.000000000 +0200
+++ linux-2.6.18-rc6/drivers/hwmon/Makefile	2006-10-15 15:02:16.000000000 +0300
@@ -21,6 +21,7 @@ obj-$(CONFIG_SENSORS_ADM9240)	+= adm9240
 obj-$(CONFIG_SENSORS_ATXP1)	+= atxp1.o
 obj-$(CONFIG_SENSORS_DS1621)	+= ds1621.o
 obj-$(CONFIG_SENSORS_F71805F)	+= f71805f.o
+obj-$(CONFIG_SENSORS_F75375S)	+= f75375s.o
 obj-$(CONFIG_SENSORS_FSCHER)	+= fscher.o
 obj-$(CONFIG_SENSORS_FSCPOS)	+= fscpos.o
 obj-$(CONFIG_SENSORS_GL518SM)	+= gl518sm.o
