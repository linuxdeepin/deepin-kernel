diff --git a/Documentation/ja_JP/HOWTO b/Documentation/ja_JP/HOWTO
index 9f08dab..d9d832c 100644
--- a/Documentation/ja_JP/HOWTO
+++ b/Documentation/ja_JP/HOWTO
@@ -1,4 +1,4 @@
-ï»¿NOTE:
+NOTE:
 This is a version of Documentation/HOWTO translated into Japanese.
 This document is maintained by Tsugikazu Shibata <tshibata@ab.jp.nec.com>
 and the JF Project team <www.linux.or.jp/JF>.
@@ -11,14 +11,14 @@ for non English (read: Japanese) speakers and is not intended as a
 fork. So if you have any comments or updates for this file, please try
 to update the original English file first.
 
-Last Updated: 2007/07/18
+Last Updated: 2007/09/23
 ==================================
 ã“ã‚Œã¯ã€
-linux-2.6.22/Documentation/HOWTO
+linux-2.6.23/Documentation/HOWTO
 ã®å’Œè¨³ã§ã™ã€‚
 
 ç¿»è¨³å›£ä½“ï¼š JF ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ < http://www.linux.or.jp/JF/ >
-ç¿»è¨³æ—¥ï¼š 2007/07/16
+ç¿»è¨³æ—¥ï¼š 2007/09/19
 ç¿»è¨³è€…ï¼š Tsugikazu Shibata <tshibata at ab dot jp dot nec dot com>
 æ ¡æ­£è€…ï¼š æ¾å€‰ã•ã‚“ <nbh--mats at nifty dot com>
          å°æ— é›…å…¸ã•ã‚“ (Masanori Kobayasi) <zap03216 at nifty dot ne dot jp>
@@ -27,6 +27,7 @@ linux-2.6.22/Documentation/HOWTO
          é‡å£ã•ã‚“ (Kenji Noguchi) <tokyo246 at gmail dot com>
          æ²³å†…ã•ã‚“ (Takayoshi Kochi) <t-kochi at bq dot jp dot nec dot com>
          å²©æœ¬ã•ã‚“ (iwamoto) <iwamoto.kn at ncos dot nec dot co dot jp>
+         å†…ç”°ã•ã‚“ (Satoshi Uchida) <s-uchida at ap dot jp dot nec dot com>
 ==================================
 
 Linux ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã®ã‚„ã‚Šæ–¹
@@ -40,7 +41,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨å…±ã«æ´»å‹•ã™ã‚‹ã‚„ã‚Šæ–¹ã‚’å­¦ã
 æ‰‹åŠ©ã‘ã«ãªã‚Šã¾ã™ã€‚
 
 ã‚‚ã—ã€ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã©ã“ã‹ãŒå¤ããªã£ã¦ã„ãŸå ´åˆã«ã¯ã€ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³
-ãƒˆã®æœ€å¾Œã«ãƒªã‚¹ãƒˆã—ãŸãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼ã«ãƒ‘ãƒƒãƒã‚’é€ã£ã¦ãã ã•ã„ã€‚
+ãƒˆã®æœ€å¾Œã«ãƒªã‚¹ãƒˆã—ãŸãƒ¡ãƒ³ãƒ†ãƒŠã«ãƒ‘ãƒƒãƒã‚’é€ã£ã¦ãã ã•ã„ã€‚
 
 ã¯ã˜ã‚ã«
 ---------
@@ -59,7 +60,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨å…±ã«æ´»å‹•ã™ã‚‹ã‚„ã‚Šæ–¹ã‚’å­¦ã
 ãƒãƒ«é–‹ç™ºè€…ã«ã¯å¿…è¦ã§ã™ã€‚ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å‘ã‘ã®ä½ãƒ¬ãƒ™ãƒ«éƒ¨åˆ†ã®é–‹ç™ºã‚’ã™ã‚‹ã®
 ã§ãªã‘ã‚Œã°ã€(ã©ã‚“ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ã‚‚)ã‚¢ã‚»ãƒ³ãƒ–ãƒª(è¨³æ³¨: è¨€èª)ã¯å¿…è¦ã‚ã‚Š
 ã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®æœ¬ã¯ã€C è¨€èªã®ååˆ†ãªçŸ¥è­˜ã‚„ä½•å¹´ã‚‚ã®çµŒé¨“ã«å–ã£ã¦ä»£ã‚ã‚‹ã‚‚ã®
-ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€å°‘ãªãã¨ã‚‚ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã¨ã—ã¦ã¯ã„ã„æœ¬ã§ã™ã€‚
+ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€å°‘ãªãã¨ã‚‚ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã¨ã—ã¦ã¯è‰¯ã„æœ¬ã§ã™ã€‚
  - "The C Programming Language" by Kernighan and Ritchie [Prentice Hall]
  -ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªï¼£ç¬¬2ç‰ˆã€(B.W. ã‚«ãƒ¼ãƒ‹ãƒãƒ³/D.M. ãƒªãƒƒãƒãƒ¼è‘— çŸ³ç”°æ™´ä¹…è¨³) [å…±ç«‹å‡ºç‰ˆ]
  - "Practical C Programming" by Steve Oualline [O'Reilly]
@@ -76,7 +77,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨å…±ã«æ´»å‹•ã™ã‚‹ã‚„ã‚Šæ–¹ã‚’å­¦ã
 ã¨ãã©ãã€ã‚«ãƒ¼ãƒãƒ«ãŒãƒ„ãƒ¼ãƒ«ãƒã‚§ã‚¤ãƒ³ã‚„ C è¨€èªæ‹¡å¼µã«ç½®ã„ã¦ã„ã‚‹å‰æãŒã©ã†
 ãªã£ã¦ã„ã‚‹ã®ã‹ã‚ã‹ã‚Šã«ãã„ã“ã¨ãŒã‚ã‚Šã€ã¾ãŸã€æ®‹å¿µãªã“ã¨ã«æ±ºå®šçš„ãªãƒªãƒ•ã‚¡
 ãƒ¬ãƒ³ã‚¹ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚æƒ…å ±ã‚’å¾—ã‚‹ã«ã¯ã€gcc ã® info ãƒšãƒ¼ã‚¸( info gcc )ã‚’
-ã¿ã¦ãã ã•ã„ã€‚
+è¦‹ã¦ãã ã•ã„ã€‚
 
 ã‚ãªãŸã¯æ—¢å­˜ã®é–‹ç™ºã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨ä¸€ç·’ã«ä½œæ¥­ã™ã‚‹æ–¹æ³•ã‚’å­¦ã¼ã†ã¨ã—ã¦ã„ã‚‹ã“
 ã¨ã«ç•™æ„ã—ã¦ãã ã•ã„ã€‚ãã®ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¯ã€ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚¹ã‚¿ã‚¤ãƒ«ã€
@@ -92,7 +93,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨å…±ã«æ´»å‹•ã™ã‚‹ã‚„ã‚Šæ–¹ã‚’å­¦ã
 
 Linux ã‚«ãƒ¼ãƒãƒ«ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ GPL ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§ãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã¦ã„ã¾
 ã™ã€‚ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã®ãƒ¡ã‚¤ãƒ³ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å­˜åœ¨
-ã™ã‚‹ã€COPYING ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã¿ã¦ãã ã•ã„ã€‚ã‚‚ã—ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«ã¤ã„ã¦ã•ã‚‰ã«è³ª
+ã™ã‚‹ã€COPYING ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¦‹ã¦ãã ã•ã„ã€‚ã‚‚ã—ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«ã¤ã„ã¦ã•ã‚‰ã«è³ª
 å•ãŒã‚ã‚Œã°ã€Linux Kernel ãƒ¡ãƒ¼ãƒªãƒ³ã‚°ãƒªã‚¹ãƒˆã«è³ªå•ã™ã‚‹ã®ã§ã¯ãªãã€ã©ã†ã
 æ³•å¾‹å®¶ã«ç›¸è«‡ã—ã¦ãã ã•ã„ã€‚ãƒ¡ãƒ¼ãƒªãƒ³ã‚°ãƒªã‚¹ãƒˆã®äººé”ã¯æ³•å¾‹å®¶ã§ã¯ãªãã€æ³•çš„
 å•é¡Œã«ã¤ã„ã¦ã¯å½¼ã‚‰ã®å£°æ˜ã¯ã‚ã¦ã«ã™ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
@@ -109,7 +110,8 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã¯å¹…åºƒã„ç¯„å›²ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å
 æ–°ã—ã„ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚‚è¿½åŠ ã™ã‚‹ã“ã¨ã‚’å‹§ã‚ã¾ã™ã€‚
 ã‚«ãƒ¼ãƒãƒ«ã®å¤‰æ›´ãŒã€ã‚«ãƒ¼ãƒãƒ«ãŒãƒ¦ãƒ¼ã‚¶ç©ºé–“ã«å…¬é–‹ã—ã¦ã„ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã®
 å¤‰æ›´ã‚’å¼•ãèµ·ã“ã™å ´åˆã€ãã®å¤‰æ›´ã‚’èª¬æ˜ã™ã‚‹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ã®ãƒ‘ãƒƒãƒã‚„æƒ…å ±
-ã‚’ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ã®ãƒ¡ãƒ³ãƒ†ãƒŠ mtk-manpages@gmx.net ã«é€ã‚‹ã“ã¨ã‚’å‹§ã‚ã¾ã™ã€‚
+ã‚’ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒšãƒ¼ã‚¸ã®ãƒ¡ãƒ³ãƒ†ãƒŠ mtk-manpages@gmx.net ã«é€ã‚‹ã“ã¨ã‚’å‹§ã‚ã¾
+ã™ã€‚
 
 ä»¥ä¸‹ã¯ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã«å«ã¾ã‚Œã¦ã„ã‚‹èª­ã‚“ã§ãŠãã¹ããƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€è¦§ã§
 ã™-
@@ -117,7 +119,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã¯å¹…åºƒã„ç¯„å›²ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å
   README
     ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ Linuxã‚«ãƒ¼ãƒãƒ«ã®ç°¡å˜ãªèƒŒæ™¯ã¨ã‚«ãƒ¼ãƒãƒ«ã‚’è¨­å®š(è¨³æ³¨
     configure )ã—ã€ç”Ÿæˆ(è¨³æ³¨ build )ã™ã‚‹ãŸã‚ã«å¿…è¦ãªã“ã¨ã¯ä½•ã‹ãŒæ›¸ã‹ã‚Œ
-    ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒãƒ«ã«é–¢ã—ã¦åˆã‚ã¦ã®äººã¯ã“ã“ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹ã¨ã‚ˆã„ã§
+    ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒãƒ«ã«é–¢ã—ã¦åˆã‚ã¦ã®äººã¯ã“ã“ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹ã¨è‰¯ã„ã§
     ã—ã‚‡ã†ã€‚
 
   Documentation/Changes
@@ -128,7 +130,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã¯å¹…åºƒã„ç¯„å›²ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å
   Documentation/CodingStyle
     ã“ã‚Œã¯ Linux ã‚«ãƒ¼ãƒãƒ«ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚¿ã‚¤ãƒ«ã¨èƒŒæ™¯ã«ã‚ã‚‹ç†ç”±ã‚’è¨˜è¿°
     ã—ã¦ã„ã¾ã™ã€‚å…¨ã¦ã®æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã¯ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã‚ã‚‹ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
-    ã«å¾“ã£ã¦ã„ã‚‹ã“ã¨ã‚’æœŸå¾…ã•ã‚Œã¦ã„ã¾ã™ã€‚å¤§éƒ¨åˆ†ã®ãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼ã¯ã“ã‚Œã‚‰ã®ãƒ«ãƒ¼
+    ã«å¾“ã£ã¦ã„ã‚‹ã“ã¨ã‚’æœŸå¾…ã•ã‚Œã¦ã„ã¾ã™ã€‚å¤§éƒ¨åˆ†ã®ãƒ¡ãƒ³ãƒ†ãƒŠã¯ã“ã‚Œã‚‰ã®ãƒ«ãƒ¼
     ãƒ«ã«å¾“ã£ã¦ã„ã‚‹ã‚‚ã®ã ã‘ã‚’å—ã‘ä»˜ã‘ã€å¤šãã®äººã¯æ­£ã—ã„ã‚¹ã‚¿ã‚¤ãƒ«ã®ã‚³ãƒ¼ãƒ‰
     ã ã‘ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¾ã™ã€‚
 
@@ -168,16 +170,16 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã¯å¹…åºƒã„ç¯„å›²ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å
     æ”¯æ´ã—ã¦ãã ã•ã„ã€‚
 
   Documentation/ManagementStyle
-    ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ Linux ã‚«ãƒ¼ãƒãƒ«ã®ãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼é”ãŒã©ã†è¡Œå‹•ã™ã‚‹ã‹ã€
+    ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ Linux ã‚«ãƒ¼ãƒãƒ«ã®ãƒ¡ãƒ³ãƒ†ãƒŠé”ãŒã©ã†è¡Œå‹•ã™ã‚‹ã‹ã€
     å½¼ã‚‰ã®æ‰‹æ³•ã®èƒŒæ™¯ã«ã‚ã‚‹å…±æœ‰ã•ã‚Œã¦ã„ã‚‹ç²¾ç¥ã«ã¤ã„ã¦è¨˜è¿°ã—ã¦ã„ã¾ã™ã€‚ã“
     ã‚Œã¯ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã®åˆå¿ƒè€…ãªã‚‰ï¼ˆã‚‚ã—ãã¯ã€å˜ã«èˆˆå‘³ãŒã‚ã‚‹ã ã‘ã®äººã§ã‚‚ï¼‰
-    é‡è¦ã§ã™ã€‚ãªãœãªã‚‰ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€ã‚«ãƒ¼ãƒãƒ«ãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼é”ã®ç‹¬ç‰¹ãª
+    é‡è¦ã§ã™ã€‚ãªãœãªã‚‰ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€ã‚«ãƒ¼ãƒãƒ«ãƒ¡ãƒ³ãƒ†ãƒŠé”ã®ç‹¬ç‰¹ãª
     è¡Œå‹•ã«ã¤ã„ã¦ã®å¤šãã®èª¤è§£ã‚„æ··ä¹±ã‚’è§£æ¶ˆã™ã‚‹ã‹ã‚‰ã§ã™ã€‚
 
   Documentation/stable_kernel_rules.txt
     ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã©ã®ã‚ˆã†ã« stable ã‚«ãƒ¼ãƒãƒ«ã®ãƒªãƒªãƒ¼ã‚¹ãŒè¡Œã‚ã‚Œã‚‹ã‹ã®ãƒ«ãƒ¼
     ãƒ«ãŒè¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã—ã¦ã“ã‚Œã‚‰ã®ãƒªãƒªãƒ¼ã‚¹ã®ä¸­ã®ã©ã“ã‹ã§å¤‰æ›´ã‚’å–
-    ã‚Šå…¥ã‚Œã¦ã‚‚ã‚‰ã„ãŸã„å ´åˆã«ä½•ã‚’ã™ã‚Œã°ã„ã„ã‹ãŒç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚
+    ã‚Šå…¥ã‚Œã¦ã‚‚ã‚‰ã„ãŸã„å ´åˆã«ä½•ã‚’ã™ã‚Œã°è‰¯ã„ã‹ãŒç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚
 
   Documentation/kernel-docs.txt
 ã€€ã€€ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã«ä»˜éšã™ã‚‹å¤–éƒ¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ãƒªã‚¹ãƒˆã§ã™ã€‚ã‚‚ã—ã‚ãªãŸãŒ
@@ -218,9 +220,9 @@ web ã‚µã‚¤ãƒˆã«ã¯ã€ã‚³ãƒ¼ãƒ‰ã®æ§‹æˆã€ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã€ç¾åœ¨å­˜åœ¨ã™ã
 ã“ã“ã«ã¯ã€ã¾ãŸã€ã‚«ãƒ¼ãƒãƒ«ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã®ã‚„ã‚Šæ–¹ã‚„ãƒ‘ãƒƒãƒã®å½“ã¦æ–¹ãªã©ã®é–“æ¥
 çš„ãªåŸºæœ¬æƒ…å ±ã‚‚è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚
 
-ã‚ãªãŸãŒã©ã“ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦ã‚ˆã„ã‹ã‚ã‹ã‚‰ãªã„ãŒã€Linux ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã‚³ãƒŸãƒ¥
+ã‚ãªãŸãŒã©ã“ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã—ã¦è‰¯ã„ã‹ã‚ã‹ã‚‰ãªã„ãŒã€Linux ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã‚³ãƒŸãƒ¥
 ãƒ‹ãƒ†ã‚£ã«å‚åŠ ã—ã¦ä½•ã‹ã™ã‚‹ã“ã¨ã‚’ã•ãŒã—ã¦ã„ã‚‹å ´åˆã«ã¯ã€Linux kernel
-Janitor's ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã„ã‘ã°ã‚ˆã„ã§ã—ã‚‡ã† -
+Janitor's ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã„ã‘ã°è‰¯ã„ã§ã—ã‚‡ã† -
 	http://janitor.kernelnewbies.org/
 ã“ã“ã¯ãã®ã‚ˆã†ãªã‚¹ã‚¿ãƒ¼ãƒˆã‚’ã™ã‚‹ã®ã«ã†ã£ã¦ã¤ã‘ã®å ´æ‰€ã§ã™ã€‚ã“ã“ã«ã¯ã€
 Linux ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã®ä¸­ã«å«ã¾ã‚Œã‚‹ã€ãã‚Œã„ã«ã—ã€ä¿®æ­£ã—ãªã‘ã‚Œã°ãª
@@ -243,7 +245,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚½ãƒ¼ã‚¹ãƒ„ãƒªãƒ¼ã®ä¸­ã«å«ã¾ã‚Œã‚‹ã€ãã‚Œã„ã«ã—ã€ä¿
 è‡ªå·±å‚ç…§æ–¹å¼ã§ã€ç´¢å¼•ãŒã¤ã„ãŸ web å½¢å¼ã§ã€ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ã™ã‚‹ã“ã¨ãŒ
 ã§ãã¾ã™ã€‚ã“ã®æœ€æ–°ã®ç´ æ™´ã—ã„ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒ¼ãƒ‰ã®ãƒªãƒã‚¸ãƒˆãƒªã¯ä»¥ä¸‹ã§è¦‹ã¤ã‹ã‚Š
 ã¾ã™-
-	http://sosdg.org/~coywolf/lxr/
+	http://sosdg.org/~qiyong/lxr/
 
 é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹
 -----------------------
@@ -265,9 +267,9 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã®é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã¯ç¾åœ¨å¹¾ã¤ã‹ã®ç•°ãªã‚‹ãƒ¡ã‚¤ãƒ³ã‚
 ä»¥ä¸‹ã®ã¨ãŠã‚Š-
 
   - æ–°ã—ã„ã‚«ãƒ¼ãƒãƒ«ãŒãƒªãƒªãƒ¼ã‚¹ã•ã‚ŒãŸç›´å¾Œã«ã€2é€±é–“ã®ç‰¹åˆ¥æœŸé–“ãŒè¨­ã‘ã‚‰ã‚Œã€
-    ã“ã®æœŸé–“ä¸­ã«ã€ãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼é”ã¯ Linus ã«å¤§ããªå·®åˆ†ã‚’é€ã‚‹ã“ã¨ãŒã§ãã¾
-    ã™ã€‚ã“ã®ã‚ˆã†ãªå·®åˆ†ã¯é€šå¸¸ -mm ã‚«ãƒ¼ãƒãƒ«ã«æ•°é€±é–“å«ã¾ã‚Œã¦ããŸãƒ‘ãƒƒãƒã§
-    ã™ã€‚ å¤§ããªå¤‰æ›´ã¯ git(ã‚«ãƒ¼ãƒãƒ«ã®ã‚½ãƒ¼ã‚¹ç®¡ç†ãƒ„ãƒ¼ãƒ«ã€è©³ç´°ã¯
+    ã“ã®æœŸé–“ä¸­ã«ã€ãƒ¡ãƒ³ãƒ†ãƒŠé”ã¯ Linus ã«å¤§ããªå·®åˆ†ã‚’é€ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
+    ã“ã®ã‚ˆã†ãªå·®åˆ†ã¯é€šå¸¸ -mm ã‚«ãƒ¼ãƒãƒ«ã«æ•°é€±é–“å«ã¾ã‚Œã¦ããŸãƒ‘ãƒƒãƒã§ã™ã€‚
+    å¤§ããªå¤‰æ›´ã¯ git(ã‚«ãƒ¼ãƒãƒ«ã®ã‚½ãƒ¼ã‚¹ç®¡ç†ãƒ„ãƒ¼ãƒ«ã€è©³ç´°ã¯
     http://git.or.cz/  å‚ç…§) ã‚’ä½¿ã£ã¦é€ã‚‹ã®ãŒå¥½ã¾ã—ã„ã‚„ã‚Šæ–¹ã§ã™ãŒã€ãƒ‘ãƒƒ
     ãƒãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ã®ã¾ã¾é€ã‚‹ã®ã§ã‚‚ååˆ†ã§ã™ã€‚
 
@@ -285,6 +287,10 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã®é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã¯ç¾åœ¨å¹¾ã¤ã‹ã®ç•°ãªã‚‹ãƒ¡ã‚¤ãƒ³ã‚
     ã«å®‰å®šã—ãŸçŠ¶æ…‹ã«ã‚ã‚‹ã¨åˆ¤æ–­ã—ãŸã¨ãã«ãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã¾ã™ã€‚ç›®æ¨™ã¯æ¯é€±æ–°
     ã—ã„ -rc ã‚«ãƒ¼ãƒãƒ«ã‚’ãƒªãƒªãƒ¼ã‚¹ã™ã‚‹ã“ã¨ã§ã™ã€‚
 
+   - ä»¥ä¸‹ã® URL ã§å„ -rc ãƒªãƒªãƒ¼ã‚¹ã«å­˜åœ¨ã™ã‚‹æ—¢çŸ¥ã®å¾Œæˆ»ã‚Šå•é¡Œã®ãƒªã‚¹ãƒˆ
+     ãŒè¿½è·¡ã•ã‚Œã¾ã™-
+     http://kernelnewbies.org/known_regressions
+
   - ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚«ãƒ¼ãƒãƒ«ãŒ ã€Œæº–å‚™ãŒã§ããŸã€ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã¾ã§ç¶™ç¶šã—ã¾
     ã™ã€‚ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã ã„ãŸã„ 6é€±é–“ç¶™ç¶šã—ã¾ã™ã€‚
 
@@ -331,8 +337,8 @@ Andrew ã¯å€‹åˆ¥ã®ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã‚«ãƒ¼ãƒãƒ«ãƒ„ãƒªãƒ¼ã¨ãƒ‘ãƒƒãƒã‚’å…¨ã¦é
 linux-kernel ãƒ¡ãƒ¼ãƒªãƒ³ã‚°ãƒªã‚¹ãƒˆã§åé›†ã•ã‚ŒãŸå¤šæ•°ã®ãƒ‘ãƒƒãƒã¨åŒæ™‚ã«ä¸€ã¤ã«ã¾
 ã¨ã‚ã¾ã™ã€‚
 ã“ã®ãƒ„ãƒªãƒ¼ã¯æ–°æ©Ÿèƒ½ã¨ãƒ‘ãƒƒãƒãŒæ¤œè¨¼ã•ã‚Œã‚‹å ´ã¨ãªã‚Šã¾ã™ã€‚ã‚ã‚‹æœŸé–“ã®é–“ãƒ‘ãƒƒãƒ
-ãŒ -mm ã«å…¥ã£ã¦ä¾¡å€¤ã‚’è¨¼æ˜ã•ã‚ŒãŸã‚‰ã€Andrew ã‚„ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ³ãƒ†ãƒŠãŒã€ãƒ¡
-ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã¸å…¥ã‚Œã‚‹ã‚ˆã†ã« Linus ã«ãƒ—ãƒƒã‚·ãƒ¥ã—ã¾ã™ã€‚
+ãŒ -mm ã«å…¥ã£ã¦ä¾¡å€¤ã‚’è¨¼æ˜ã•ã‚ŒãŸã‚‰ã€Andrew ã‚„ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ³ãƒ†ãƒŠãŒã€
+ãƒ¡ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã¸å…¥ã‚Œã‚‹ã‚ˆã†ã« Linus ã«ãƒ—ãƒƒã‚·ãƒ¥ã—ã¾ã™ã€‚
 
 ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¼ãƒãƒ«ãƒ„ãƒªãƒ¼ã«å«ã‚ã‚‹ãŸã‚ã« Linus ã«é€ã‚‹å‰ã«ã€ã™ã¹ã¦ã®æ–°ã—ã„ãƒ‘ãƒƒ
 ãƒãŒ -mm ãƒ„ãƒªãƒ¼ã§ãƒ†ã‚¹ãƒˆã•ã‚Œã‚‹ã“ã¨ãŒå¼·ãæ¨å¥¨ã•ã‚Œã¾ã™ã€‚
@@ -460,7 +466,7 @@ MAINTAINERS ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒªã‚¹ãƒˆãŒã‚ã‚Šã¾ã™ã®ã§å‚ç…§ã—ã¦ãã ã•ã
 ã›ã‚“-
 å½¼ã‚‰ã¯ã‚ãªãŸã®ãƒ‘ãƒƒãƒã®è¡Œæ¯ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥ã‚ŒãŸã„ã®ã§ã€ãã®ãŸã‚ã«ã¯ãã†ã™
 ã‚‹ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ãªãŸã®ãƒ¡ãƒ¼ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒç©ºç™½ã‚„ã‚¿ãƒ–ã‚’åœ§ç¸®ã—ãªã„ã‚ˆã†
-ã«ç¢ºèªã—ãŸæ–¹ãŒã„ã„ã§ã™ã€‚æœ€åˆã®è‰¯ã„ãƒ†ã‚¹ãƒˆã¨ã—ã¦ã¯ã€è‡ªåˆ†ã«ãƒ¡ãƒ¼ãƒ«ã‚’é€ã£ã¦
+ã«ç¢ºèªã—ãŸæ–¹ãŒè‰¯ã„ã§ã™ã€‚æœ€åˆã®è‰¯ã„ãƒ†ã‚¹ãƒˆã¨ã—ã¦ã¯ã€è‡ªåˆ†ã«ãƒ¡ãƒ¼ãƒ«ã‚’é€ã£ã¦
 ã¿ã¦ã€ãã®ãƒ‘ãƒƒãƒã‚’è‡ªåˆ†ã§å½“ã¦ã¦ã¿ã‚‹ã“ã¨ã§ã™ã€‚ã‚‚ã—ãã‚ŒãŒã†ã¾ãè¡Œã‹ãªã„ãª
 ã‚‰ã€ã‚ãªãŸã®ãƒ¡ãƒ¼ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ç›´ã—ã¦ã‚‚ã‚‰ã†ã‹ã€æ­£ã—ãå‹•ãã‚ˆã†ã«å¤‰ãˆã‚‹ã¹
 ãã§ã™ã€‚
@@ -507,14 +513,14 @@ MAINTAINERS ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒªã‚¹ãƒˆãŒã‚ã‚Šã¾ã™ã®ã§å‚ç…§ã—ã¦ãã ã•ã
 ã¨ã‚‚æ™®é€šã®ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯ã‚ãªãŸã®ãƒ‘ãƒƒãƒãŒå—ã‘å…¥ã‚Œã‚‰ã‚Œãªã„ã¨ã„ã†ã“ã¨ã§
 ã¯ *ã‚ã‚Šã¾ã›ã‚“*ã€ãã—ã¦ã‚ãªãŸè‡ªèº«ã«åå¯¾ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ã®ã§ã‚‚ *ã‚ã‚Šã¾
 ã›ã‚“*ã€‚å˜ã«è‡ªåˆ†ã®ãƒ‘ãƒƒãƒã«å¯¾ã—ã¦æŒ‡æ‘˜ã•ã‚ŒãŸå•é¡Œã‚’å…¨ã¦ä¿®æ­£ã—ã¦å†é€ã™ã‚Œã°
-ã„ã„ã®ã§ã™ã€‚
+è‰¯ã„ã®ã§ã™ã€‚
 
 
 ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨ä¼æ¥­çµ„ç¹”ã®ã¡ãŒã„
 -----------------------------------------------------------------
 
 ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¯å¤§éƒ¨åˆ†ã®ä¼çµ±çš„ãªä¼šç¤¾ã®é–‹ç™ºç’°å¢ƒã¨ã¯ç•°ã£ãŸã‚„ã‚Šæ–¹ã§
-å‹•ã„ã¦ã„ã¾ã™ã€‚ä»¥ä¸‹ã¯å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ã§ãã‚‹ã¨ã‚ˆã„ã“ã¨ã®ã®ãƒªã‚¹ãƒˆã§ã™-
+å‹•ã„ã¦ã„ã¾ã™ã€‚ä»¥ä¸‹ã¯å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚ã«ã§ãã‚‹ã¨è‰¯ã„ã“ã¨ã®ãƒªã‚¹ãƒˆã§ã™-
 
   ã‚ãªãŸã®ææ¡ˆã™ã‚‹å¤‰æ›´ã«ã¤ã„ã¦è¨€ã†ã¨ãã®ã†ã¾ã„è¨€ã„æ–¹ï¼š
 
@@ -525,7 +531,7 @@ MAINTAINERS ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒªã‚¹ãƒˆãŒã‚ã‚Šã¾ã™ã®ã§å‚ç…§ã—ã¦ãã ã•ã
     - "ä»¥ä¸‹ã¯ä¸€é€£ã®å°ã•ãªãƒ‘ãƒƒãƒç¾¤ã§ã™ãŒ..."
     - "ã“ã‚Œã¯å…¸å‹çš„ãªãƒã‚·ãƒ³ã§ã®æ€§èƒ½ã‚’å‘ä¸Šã•ã›ã¾ã™.."
 
-  ã‚„ã‚ãŸæ–¹ãŒã„ã„æ‚ªã„è¨€ã„æ–¹ï¼š
+  ã‚„ã‚ãŸæ–¹ãŒè‰¯ã„æ‚ªã„è¨€ã„æ–¹ï¼š
 
     - ã“ã®ã‚„ã‚Šæ–¹ã§ AIX/ptx/Solaris ã§ã¯ã§ããŸã®ã§ã€ã§ãã‚‹ã¯ãšã 
     - ç§ã¯ã“ã‚Œã‚’20å¹´ã‚‚ã®é–“ã‚„ã£ã¦ããŸã€ã ã‹ã‚‰
@@ -575,10 +581,10 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¯ã€ä¸€åº¦ã«å¤§é‡ã®ã‚³ãƒ¼ãƒ‰ã®å¡Šã‚’å–
 
 1) å°ã•ã„ãƒ‘ãƒƒãƒã¯ã‚ãªãŸã®ãƒ‘ãƒƒãƒãŒé©ç”¨ã•ã‚Œã‚‹è¦‹è¾¼ã¿ã‚’å¤§ããã—ã¾ã™ã€ã‚«ãƒ¼
    ãƒãƒ«ã®äººé”ã¯ãƒ‘ãƒƒãƒãŒæ­£ã—ã„ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹æ™‚é–“ã‚„åŠ´åŠ›ã‚’ã‹ã‘ãªã„ã‹
-   ã‚‰ã§ã™ã€‚5è¡Œã®ãƒ‘ãƒƒãƒã¯ãƒ¡ãƒ³ãƒ†ãƒŠãŒãŸã£ãŸ1ç§’è¦‹ã‚‹ã ã‘ã§é©ç”¨ã§ãã¾ã™ã€‚ã—
-   ã‹ã—ã€500è¡Œã®ãƒ‘ãƒƒãƒã¯ã€æ­£ã—ã„ã“ã¨ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã™ã‚‹ã®ã«æ•°æ™‚é–“ã‹ã‹ã‚‹ã‹ã‚‚
-   ã—ã‚Œã¾ã›ã‚“(æ™‚é–“ã¯ãƒ‘ãƒƒãƒã®ã‚µã‚¤ã‚ºãªã©ã«ã‚ˆã‚ŠæŒ‡æ•°é–¢æ•°ã«æ¯”ä¾‹ã—ã¦ã‹ã‹ã‚Šã¾
-   ã™)
+   ã‚‰ã§ã™ã€‚5è¡Œã®ãƒ‘ãƒƒãƒã¯ãƒ¡ãƒ³ãƒ†ãƒŠãŒãŸã£ãŸ1ç§’è¦‹ã‚‹ã ã‘ã§é©ç”¨ã§ãã¾ã™ã€‚
+   ã—ã‹ã—ã€500è¡Œã®ãƒ‘ãƒƒãƒã¯ã€æ­£ã—ã„ã“ã¨ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã™ã‚‹ã®ã«æ•°æ™‚é–“ã‹ã‹ã‚‹ã‹
+   ã‚‚ã—ã‚Œã¾ã›ã‚“(æ™‚é–“ã¯ãƒ‘ãƒƒãƒã®ã‚µã‚¤ã‚ºãªã©ã«ã‚ˆã‚ŠæŒ‡æ•°é–¢æ•°ã«æ¯”ä¾‹ã—ã¦ã‹ã‹ã‚Š
+   ã¾ã™)
 
    å°ã•ã„ãƒ‘ãƒƒãƒã¯ä½•ã‹ã‚ã£ãŸã¨ãã«ãƒ‡ãƒãƒƒã‚°ã‚‚ã¨ã¦ã‚‚ç°¡å˜ã«ãªã‚Šã¾ã™ã€‚ãƒ‘ãƒƒ
    ãƒã‚’1å€‹1å€‹å–ã‚Šé™¤ãã®ã¯ã€ã¨ã¦ã‚‚å¤§ããªãƒ‘ãƒƒãƒã‚’å½“ã¦ãŸå¾Œã«(ã‹ã¤ã€ä½•ã‹ãŠ
@@ -587,23 +593,23 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¯ã€ä¸€åº¦ã«å¤§é‡ã®ã‚³ãƒ¼ãƒ‰ã®å¡Šã‚’å–
 2) å°ã•ã„ãƒ‘ãƒƒãƒã‚’é€ã‚‹ã ã‘ã§ãªãã€é€ã‚‹ã¾ãˆã«ã€æ›¸ãç›´ã—ã¦ã€ã‚·ãƒ³ãƒ—ãƒ«ã«ã™
    ã‚‹(ã‚‚ã—ãã¯ã€å˜ã«é †ç•ªã‚’å¤‰ãˆã‚‹ã ã‘ã§ã‚‚)ã“ã¨ã‚‚ã€ã¨ã¦ã‚‚é‡è¦ã§ã™ã€‚
 
-ä»¥ä¸‹ã¯ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºè€…ã® Al Viro ã®ãŸã¨ãˆè©±ã—ã§ã™ï¼š
+ä»¥ä¸‹ã¯ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºè€…ã® Al Viro ã®ãŸã¨ãˆè©±ã§ã™ï¼š
 
         "ç”Ÿå¾’ã®æ•°å­¦ã®å®¿é¡Œã‚’æ¡ç‚¹ã™ã‚‹å…ˆç”Ÿã®ã“ã¨ã‚’è€ƒãˆã¦ã¿ã¦ãã ã•ã„ã€å…ˆ
-        ç”Ÿã¯ç”Ÿå¾’ãŒè§£ã«åˆ°é”ã™ã‚‹ã¾ã§ã®è©¦è¡ŒéŒ¯èª¤ã‚’ã¿ãŸã„ã¨ã¯æ€ã‚ãªã„ã§ã—ã‚‡
-        ã†ã€‚å…ˆç”Ÿã¯ç°¡æ½”ãªæœ€é«˜ã®è§£ã‚’ã¿ãŸã„ã®ã§ã™ã€‚è‰¯ã„ç”Ÿå¾’ã¯ã“ã‚Œã‚’çŸ¥ã£ã¦
+        ç”Ÿã¯ç”Ÿå¾’ãŒè§£ã«åˆ°é”ã™ã‚‹ã¾ã§ã®è©¦è¡ŒéŒ¯èª¤ã‚’è¦‹ãŸã„ã¨ã¯æ€ã‚ãªã„ã§ã—ã‚‡
+        ã†ã€‚å…ˆç”Ÿã¯ç°¡æ½”ãªæœ€é«˜ã®è§£ã‚’è¦‹ãŸã„ã®ã§ã™ã€‚è‰¯ã„ç”Ÿå¾’ã¯ã“ã‚Œã‚’çŸ¥ã£ã¦
         ãŠã‚Šã€ãã—ã¦æœ€çµ‚è§£ã®å‰ã®ä¸­é–“ä½œæ¥­ã‚’æå‡ºã™ã‚‹ã“ã¨ã¯æ±ºã—ã¦ãªã„ã®ã§
         ã™"
 
-        ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã§ã‚‚ã“ã‚Œã¯åŒã˜ã§ã™ã€‚ãƒ¡ãƒ³ãƒ†ãƒŠãƒ¼é”ã¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¢é”ã¯ã€
-        å•é¡Œã‚’è§£æ±ºã™ã‚‹è§£ã®èƒŒå¾Œã«ãªã‚‹æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚’ã¿ãŸã„ã¨ã¯æ€ã„ã¾ã›ã‚“ã€‚
-        å½¼ã‚‰ã¯å˜ç´”ã§ã‚ã–ã‚„ã‹ãªè§£æ±ºæ–¹æ³•ã‚’ã¿ãŸã„ã®ã§ã™ã€‚
+        ã‚«ãƒ¼ãƒãƒ«é–‹ç™ºã§ã‚‚ã“ã‚Œã¯åŒã˜ã§ã™ã€‚ãƒ¡ãƒ³ãƒ†ãƒŠé”ã¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¢é”ã¯ã€
+        å•é¡Œã‚’è§£æ±ºã™ã‚‹è§£ã®èƒŒå¾Œã«ãªã‚‹æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚’è¦‹ãŸã„ã¨ã¯æ€ã„ã¾ã›ã‚“ã€‚
+        å½¼ã‚‰ã¯å˜ç´”ã§ã‚ã–ã‚„ã‹ãªè§£æ±ºæ–¹æ³•ã‚’è¦‹ãŸã„ã®ã§ã™ã€‚
 
 ã‚ã–ã‚„ã‹ãªè§£ã‚’èª¬æ˜ã™ã‚‹ã®ã¨ã€ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨å…±ã«ä»•äº‹ã‚’ã—ã€æœªè§£æ±ºã®ä»•äº‹ã‚’
 è­°è«–ã™ã‚‹ã“ã¨ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ã‚­ãƒ¼ãƒ—ã™ã‚‹ã®ã¯é›£ã—ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
 ã§ã™ã‹ã‚‰ã€é–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹ã®æ—©æœŸæ®µéšã§æ”¹å–„ã®ãŸã‚ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ã‚‚ã‚‰ã†ã‚ˆ
-ã†ã«ã™ã‚‹ã®ã‚‚ã„ã„ã§ã™ãŒã€å¤‰æ›´ç‚¹ã‚’å°ã•ã„éƒ¨åˆ†ã«åˆ†å‰²ã—ã¦å…¨ä½“ã§ã¯ã¾ã å®Œæˆã—
-ã¦ã„ãªã„ä»•äº‹ã‚’(éƒ¨åˆ†çš„ã«)å–ã‚Šè¾¼ã‚“ã§ã‚‚ã‚‰ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã‚‚ã„ã„ã“ã¨ã§ã™ã€‚
+ã†ã«ã™ã‚‹ã®ã‚‚è‰¯ã„ã§ã™ãŒã€å¤‰æ›´ç‚¹ã‚’å°ã•ã„éƒ¨åˆ†ã«åˆ†å‰²ã—ã¦å…¨ä½“ã§ã¯ã¾ã å®Œæˆã—
+ã¦ã„ãªã„ä»•äº‹ã‚’(éƒ¨åˆ†çš„ã«)å–ã‚Šè¾¼ã‚“ã§ã‚‚ã‚‰ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã‚‚è‰¯ã„ã“ã¨ã§ã™ã€‚
 
 ã¾ãŸã€ã§ãä¸ŠãŒã£ã¦ã„ãªã„ã‚‚ã®ã‚„ã€"å°†æ¥ç›´ã™" ã‚ˆã†ãªãƒ‘ãƒƒãƒã‚’ã€æœ¬æµã«å«ã‚
 ã¦ã‚‚ã‚‰ã†ã‚ˆã†ã«é€ã£ã¦ã‚‚ã€ãã‚Œã¯å—ã‘ä»˜ã‘ã‚‰ã‚Œãªã„ã“ã¨ã‚’ç†è§£ã—ã¦ãã ã•ã„ã€‚
@@ -629,7 +635,7 @@ Linux ã‚«ãƒ¼ãƒãƒ«ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¯ã€ä¸€åº¦ã«å¤§é‡ã®ã‚³ãƒ¼ãƒ‰ã®å¡Šã‚’å–
   - ãƒ†ã‚¹ãƒˆçµæœ
 
 ã“ã‚Œã«ã¤ã„ã¦å…¨ã¦ãŒã©ã®ã‚ˆã†ã«ã‚ã‚‹ã¹ãã‹ã«ã¤ã„ã¦ã®è©³ç´°ã¯ã€ä»¥ä¸‹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡
-ãƒ³ãƒˆã® ChangeLog ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã¿ã¦ãã ã•ã„-
+ãƒ³ãƒˆã® ChangeLog ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦‹ã¦ãã ã•ã„-
   "The Perfect Patch"
       http://www.zip.com.au/~akpm/linux/patches/stuff/tpp.txt
 
diff --git a/Makefile b/Makefile
index c244a02..c6d545c 100644
diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
index ed39313..026cf24 100644
--- a/block/ll_rw_blk.c
+++ b/block/ll_rw_blk.c
@@ -819,7 +819,6 @@ static int __blk_free_tags(struct blk_queue_tag *bqt)
 	retval = atomic_dec_and_test(&bqt->refcnt);
 	if (retval) {
 		BUG_ON(bqt->busy);
-		BUG_ON(!list_empty(&bqt->busy_list));
 
 		kfree(bqt->tag_index);
 		bqt->tag_index = NULL;
@@ -931,7 +930,6 @@ static struct blk_queue_tag *__blk_queue_init_tags(struct request_queue *q,
 	if (init_tag_map(q, tags, depth))
 		goto fail;
 
-	INIT_LIST_HEAD(&tags->busy_list);
 	tags->busy = 0;
 	atomic_set(&tags->refcnt, 1);
 	return tags;
@@ -982,6 +980,7 @@ int blk_queue_init_tags(struct request_queue *q, int depth,
 	 */
 	q->queue_tags = tags;
 	q->queue_flags |= (1 << QUEUE_FLAG_QUEUED);
+	INIT_LIST_HEAD(&q->tag_busy_list);
 	return 0;
 fail:
 	kfree(tags);
@@ -1152,7 +1151,7 @@ int blk_queue_start_tag(struct request_queue *q, struct request *rq)
 	rq->tag = tag;
 	bqt->tag_index[tag] = rq;
 	blkdev_dequeue_request(rq);
-	list_add(&rq->queuelist, &bqt->busy_list);
+	list_add(&rq->queuelist, &q->tag_busy_list);
 	bqt->busy++;
 	return 0;
 }
@@ -1173,11 +1172,10 @@ EXPORT_SYMBOL(blk_queue_start_tag);
  **/
 void blk_queue_invalidate_tags(struct request_queue *q)
 {
-	struct blk_queue_tag *bqt = q->queue_tags;
 	struct list_head *tmp, *n;
 	struct request *rq;
 
-	list_for_each_safe(tmp, n, &bqt->busy_list) {
+	list_for_each_safe(tmp, n, &q->tag_busy_list) {
 		rq = list_entry_rq(tmp);
 
 		if (rq->tag == -1) {
diff --git a/fs/locks.c b/fs/locks.c
index c795eaa..494f250 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -694,11 +694,20 @@ EXPORT_SYMBOL(posix_test_lock);
  * Note: the above assumption may not be true when handling lock requests
  * from a broken NFS client. But broken NFS clients have a lot more to
  * worry about than proper deadlock detection anyway... --okir
+ *
+ * However, the failure of this assumption (also possible in the case of
+ * multiple tasks sharing the same open file table) also means there's no
+ * guarantee that the loop below will terminate.  As a hack, we give up
+ * after a few iterations.
  */
+
+#define MAX_DEADLK_ITERATIONS 10
+
 static int posix_locks_deadlock(struct file_lock *caller_fl,
 				struct file_lock *block_fl)
 {
 	struct list_head *tmp;
+	int i = 0;
 
 next_task:
 	if (posix_same_owner(caller_fl, block_fl))
@@ -706,6 +715,8 @@ next_task:
 	list_for_each(tmp, &blocked_list) {
 		struct file_lock *fl = list_entry(tmp, struct file_lock, fl_link);
 		if (posix_same_owner(fl, block_fl)) {
+			if (i++ > MAX_DEADLK_ITERATIONS)
+				return 0;
 			fl = fl->fl_next;
 			block_fl = fl;
 			goto next_task;
diff --git a/fs/proc/array.c b/fs/proc/array.c
index ee4814d..20d7ae4 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -351,7 +351,8 @@ static cputime_t task_utime(struct task_struct *p)
 	}
 	utime = (clock_t)temp;
 
-	return clock_t_to_cputime(utime);
+	p->prev_utime = max(p->prev_utime, clock_t_to_cputime(utime));
+	return p->prev_utime;
 }
 
 static cputime_t task_stime(struct task_struct *p)
@@ -366,7 +367,8 @@ static cputime_t task_stime(struct task_struct *p)
 	stime = nsec_to_clock_t(p->se.sum_exec_runtime) -
 			cputime_to_clock_t(task_utime(p));
 
-	return clock_t_to_cputime(stime);
+	p->prev_stime = max(p->prev_stime, clock_t_to_cputime(stime));
+	return p->prev_stime;
 }
 #endif
 
diff --git a/fs/splice.c b/fs/splice.c
index e95a362..02c39ae 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -1390,10 +1390,10 @@ static int pipe_to_user(struct pipe_inode_info *pipe, struct pipe_buffer *buf,
 	if (copy_to_user(sd->u.userptr, src + buf->offset, sd->len))
 		ret = -EFAULT;
 
+	buf->ops->unmap(pipe, buf, src);
 out:
 	if (ret > 0)
 		sd->u.userptr += ret;
-	buf->ops->unmap(pipe, buf, src);
 	return ret;
 }
 
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index b126c6f..d26bbb0 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -356,7 +356,6 @@ enum blk_queue_state {
 struct blk_queue_tag {
 	struct request **tag_index;	/* map of busy tags */
 	unsigned long *tag_map;		/* bit map of free/busy tags */
-	struct list_head busy_list;	/* fifo list of busy tags */
 	int busy;			/* current depth */
 	int max_depth;			/* what we will send to device */
 	int real_max_depth;		/* what the array can hold */
@@ -451,6 +450,7 @@ struct request_queue
 	unsigned int		dma_alignment;
 
 	struct blk_queue_tag	*queue_tags;
+	struct list_head	tag_busy_list;
 
 	unsigned int		nr_sorted;
 	unsigned int		in_flight;
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 313c6b6..f509fbd 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1022,6 +1022,7 @@ struct task_struct {
 
 	unsigned int rt_priority;
 	cputime_t utime, stime;
+	cputime_t prev_utime, prev_stime;
 	unsigned long nvcsw, nivcsw; /* context switch counts */
 	struct timespec start_time; 		/* monotonic time */
 	struct timespec real_start_time;	/* boot based time */
diff --git a/kernel/fork.c b/kernel/fork.c
index 33f12f4..f299d45 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1045,6 +1045,8 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 
 	p->utime = cputime_zero;
 	p->stime = cputime_zero;
+	p->prev_utime = cputime_zero;
+	p->prev_stime = cputime_zero;
 
 #ifdef CONFIG_TASK_XACCT
 	p->rchar = 0;		/* I/O counter: bytes read */
diff --git a/kernel/futex_compat.c b/kernel/futex_compat.c
index 2c2e295..f938c23 100644
--- a/kernel/futex_compat.c
+++ b/kernel/futex_compat.c
@@ -29,6 +29,15 @@ fetch_robust_entry(compat_uptr_t *uentry, struct robust_list __user **entry,
 	return 0;
 }
 
+static void __user *futex_uaddr(struct robust_list *entry,
+				compat_long_t futex_offset)
+{
+	compat_uptr_t base = ptr_to_compat(entry);
+	void __user *uaddr = compat_ptr(base + futex_offset);
+
+	return uaddr;
+}
+
 /*
  * Walk curr->robust_list (very carefully, it's a userspace list!)
  * and mark any locks found there dead, and notify any waiters.
@@ -75,11 +84,13 @@ void compat_exit_robust_list(struct task_struct *curr)
 		 * A pending lock might already be on the list, so
 		 * dont process it twice:
 		 */
-		if (entry != pending)
-			if (handle_futex_death((void __user *)entry + futex_offset,
-						curr, pi))
-				return;
+		if (entry != pending) {
+			void __user *uaddr = futex_uaddr(entry,
+							 futex_offset);
 
+			if (handle_futex_death(uaddr, curr, pi))
+				return;
+		}
 		if (rc)
 			return;
 		uentry = next_uentry;
@@ -93,9 +104,11 @@ void compat_exit_robust_list(struct task_struct *curr)
 
 		cond_resched();
 	}
-	if (pending)
-		handle_futex_death((void __user *)pending + futex_offset,
-				   curr, pip);
+	if (pending) {
+		void __user *uaddr = futex_uaddr(pending, futex_offset);
+
+		handle_futex_death(uaddr, curr, pip);
+	}
 }
 
 asmlinkage long
diff --git a/kernel/lockdep.c b/kernel/lockdep.c
index 734da57..42ae4a5 100644
--- a/kernel/lockdep.c
+++ b/kernel/lockdep.c
@@ -1521,7 +1521,7 @@ cache_hit:
 }
 
 static int validate_chain(struct task_struct *curr, struct lockdep_map *lock,
-	       	struct held_lock *hlock, int chain_head)
+	       	struct held_lock *hlock, int chain_head, u64 chain_key)
 {
 	/*
 	 * Trylock needs to maintain the stack of held locks, but it
@@ -1534,7 +1534,7 @@ static int validate_chain(struct task_struct *curr, struct lockdep_map *lock,
 	 * graph_lock for us)
 	 */
 	if (!hlock->trylock && (hlock->check == 2) &&
-			lookup_chain_cache(curr->curr_chain_key, hlock->class)) {
+			lookup_chain_cache(chain_key, hlock->class)) {
 		/*
 		 * Check whether last held lock:
 		 *
@@ -1576,7 +1576,7 @@ static int validate_chain(struct task_struct *curr, struct lockdep_map *lock,
 #else
 static inline int validate_chain(struct task_struct *curr,
 	       	struct lockdep_map *lock, struct held_lock *hlock,
-		int chain_head)
+		int chain_head, u64 chain_key)
 {
 	return 1;
 }
@@ -2450,11 +2450,11 @@ static int __lock_acquire(struct lockdep_map *lock, unsigned int subclass,
 		chain_head = 1;
 	}
 	chain_key = iterate_chain_key(chain_key, id);
-	curr->curr_chain_key = chain_key;
 
-	if (!validate_chain(curr, lock, hlock, chain_head))
+	if (!validate_chain(curr, lock, hlock, chain_head, chain_key))
 		return 0;
 
+	curr->curr_chain_key = chain_key;
 	curr->lockdep_depth++;
 	check_chain_key(curr);
 #ifdef CONFIG_DEBUG_LOCKDEP
diff --git a/kernel/params.c b/kernel/params.c
index 4e57732..5e5651f 100644
--- a/kernel/params.c
+++ b/kernel/params.c
@@ -595,13 +595,16 @@ static void __init param_sysfs_builtin(void)
 
 	for (i=0; i < __stop___param - __start___param; i++) {
 		char *dot;
+		size_t max_name_len;
 
 		kp = &__start___param[i];
+		max_name_len =
+			min_t(size_t, MAX_KBUILD_MODNAME, strlen(kp->name));
 
-		/* We do not handle args without periods. */
-		dot = memchr(kp->name, '.', MAX_KBUILD_MODNAME);
+		dot = memchr(kp->name, '.', max_name_len);
 		if (!dot) {
-			DEBUGP("couldn't find period in %s\n", kp->name);
+			DEBUGP("couldn't find period in first %d characters "
+			       "of %s\n", MAX_KBUILD_MODNAME, kp->name);
 			continue;
 		}
 		name_len = dot - kp->name;
diff --git a/kernel/softlockup.c b/kernel/softlockup.c
index 708d488..e557c44 100644
--- a/kernel/softlockup.c
+++ b/kernel/softlockup.c
@@ -80,10 +80,11 @@ void softlockup_tick(void)
 	print_timestamp = per_cpu(print_timestamp, this_cpu);
 
 	/* report at most once a second */
-	if (print_timestamp < (touch_timestamp + 1) ||
-		did_panic ||
-			!per_cpu(watchdog_task, this_cpu))
+	if ((print_timestamp >= touch_timestamp &&
+			print_timestamp < (touch_timestamp + 1)) ||
+			did_panic || !per_cpu(watchdog_task, this_cpu)) {
 		return;
+	}
 
 	/* do not print during early bootup: */
 	if (unlikely(system_state != SYSTEM_RUNNING)) {
diff --git a/mm/filemap.c b/mm/filemap.c
index 15c8413..14ca63f 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1312,7 +1312,7 @@ int filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 
 	size = (i_size_read(inode) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
 	if (vmf->pgoff >= size)
-		goto outside_data_content;
+		return VM_FAULT_SIGBUS;
 
 	/* If we don't want any read-ahead, don't bother */
 	if (VM_RandomReadHint(vma))
@@ -1389,7 +1389,7 @@ retry_find:
 	if (unlikely(vmf->pgoff >= size)) {
 		unlock_page(page);
 		page_cache_release(page);
-		goto outside_data_content;
+		return VM_FAULT_SIGBUS;
 	}
 
 	/*
@@ -1400,15 +1400,6 @@ retry_find:
 	vmf->page = page;
 	return ret | VM_FAULT_LOCKED;
 
-outside_data_content:
-	/*
-	 * An external ptracer can access pages that normally aren't
-	 * accessible..
-	 */
-	if (vma->vm_mm == current->mm)
-		return VM_FAULT_SIGBUS;
-
-	/* Fall through to the non-read-ahead case */
 no_cached_page:
 	/*
 	 * We're only likely to ever get here if MADV_RANDOM is in
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 4472036..97ddc58 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -672,8 +672,10 @@ retry:
 
 			ret = (*writepage)(page, wbc, data);
 
-			if (unlikely(ret == AOP_WRITEPAGE_ACTIVATE))
+			if (unlikely(ret == AOP_WRITEPAGE_ACTIVATE)) {
 				unlock_page(page);
+				ret = 0;
+			}
 			if (ret || (--(wbc->nr_to_write) <= 0))
 				done = 1;
 			if (wbc->nonblocking && bdi_write_congested(bdi)) {
diff --git a/mm/shmem.c b/mm/shmem.c
index fcd19d3..95558e4 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -916,6 +916,21 @@ static int shmem_writepage(struct page *page, struct writeback_control *wbc)
 	struct inode *inode;
 
 	BUG_ON(!PageLocked(page));
+	/*
+	 * shmem_backing_dev_info's capabilities prevent regular writeback or
+	 * sync from ever calling shmem_writepage; but a stacking filesystem
+	 * may use the ->writepage of its underlying filesystem, in which case
+	 * we want to do nothing when that underlying filesystem is tmpfs
+	 * (writing out to swap is useful as a response to memory pressure, but
+	 * of no use to stabilize the data) - just redirty the page, unlock it
+	 * and claim success in this case.  AOP_WRITEPAGE_ACTIVATE, and the
+	 * page_mapped check below, must be avoided unless we're in reclaim.
+	 */
+	if (!wbc->for_reclaim) {
+		set_page_dirty(page);
+		unlock_page(page);
+		return 0;
+	}
 	BUG_ON(page_mapped(page));
 
 	mapping = page->mapping;
diff --git a/mm/slub.c b/mm/slub.c
index addb20a..c1f2fda 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -1501,28 +1501,8 @@ new_slab:
 	page = new_slab(s, gfpflags, node);
 	if (page) {
 		cpu = smp_processor_id();
-		if (s->cpu_slab[cpu]) {
-			/*
-			 * Someone else populated the cpu_slab while we
-			 * enabled interrupts, or we have gotten scheduled
-			 * on another cpu. The page may not be on the
-			 * requested node even if __GFP_THISNODE was
-			 * specified. So we need to recheck.
-			 */
-			if (node == -1 ||
-				page_to_nid(s->cpu_slab[cpu]) == node) {
-				/*
-				 * Current cpuslab is acceptable and we
-				 * want the current one since its cache hot
-				 */
-				discard_slab(s, page);
-				page = s->cpu_slab[cpu];
-				slab_lock(page);
-				goto load_freelist;
-			}
-			/* New slab does not fit our expectations */
+		if (s->cpu_slab[cpu])
 			flush_slab(s, s->cpu_slab[cpu], cpu);
-		}
 		slab_lock(page);
 		SetSlabFrozen(page);
 		s->cpu_slab[cpu] = page;
