commit 3639f899012bd258edf7f22f0eaad532d2ee6436
Author: Yang Bo <yangbo@linuxdeepin.com>
Date:   Sun Jan 3 20:57:42 2016 +0800

    UBUNTU: SAUCE: scsi_sysfs: protect against double execution of __scsi_remove_device()
    
    (commit be821fd8e62765de43cc4f0e2db363d0e30a7e9b upstream.)
    
    BugLink: http://bugs.launchpad.net/bugs/1509029
    
    On some host errors storvsc module tries to remove sdev by scheduling a job
    which does the following:
    
       sdev = scsi_device_lookup(wrk->host, 0, 0, wrk->lun);
       if (sdev) {
           scsi_remove_device(sdev);
           scsi_device_put(sdev);
       }
    
    While this code seems correct the following crash is observed:
    
     general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC
     RIP: 0010:[<ffffffff81169979>] [<ffffffff81169979>] bdi_destroy+0x39/0x220
     ...
     [<ffffffff814aecdc>] ? _raw_spin_unlock_irq+0x2c/0x40
     [<ffffffff8127b7db>] blk_cleanup_queue+0x17b/0x270
     [<ffffffffa00b54c4>] __scsi_remove_device+0x54/0xd0 [scsi_mod]
     [<ffffffffa00b556b>] scsi_remove_device+0x2b/0x40 [scsi_mod]
     [<ffffffffa00ec47d>] storvsc_remove_lun+0x3d/0x60 [hv_storvsc]
     [<ffffffff81080791>] process_one_work+0x1b1/0x530
     ...
    
    The problem comes with the fact that many such jobs (for the same device)
    are being scheduled simultaneously. While scsi_remove_device() uses
    shost->scan_mutex and scsi_device_lookup() will fail for a device in
    SDEV_DEL state there is no protection against someone who did
    scsi_device_lookup() before we actually entered __scsi_remove_device(). So
    the whole scenario looks like that: two callers do simultaneous (or
    preemption happens) calls to scsi_device_lookup() ant these calls succeed
    for all of them, after that both callers try doing scsi_remove_device().
    shost->scan_mutex only serializes their calls to __scsi_remove_device()
    and we end up doing the cleanup path twice.
    
    OriginalAuthor: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Joseph Salisbury <joseph.salisbury@canonical.com>
    Acked-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: Kamal Mostafa <kamal@canonical.com>
    Signed-off-by: Yang Bo <yangbo@linuxdeepin.com>

diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index dff8faf..3b7e2bb 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -1078,6 +1078,14 @@ void __scsi_remove_device(struct scsi_device *sdev)
 {
 	struct device *dev = &sdev->sdev_gendev;
 
+	/*
+	 * This cleanup path is not reentrant and while it is impossible
+	 * to get a new reference with scsi_device_get() someone can still
+	 * hold a previously acquired one.
+	 */
+	if (sdev->sdev_state == SDEV_DEL)
+		return;
+
 	if (sdev->is_visible) {
 		if (scsi_device_set_state(sdev, SDEV_CANCEL) != 0)
 			return;
